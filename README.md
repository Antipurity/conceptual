The below is pretty much the output of `(docs)`.

<details open="" style="" class=""><summary><b><code>Self</code></b>:  <node><node class="text">A namespace for every <b><code>function</code></b> here. Project's GitHub page: <a href="https://github.com/Antipurity/conceptual" class="">https://github.com/Antipurity/conceptual</a></node></node></summary><details><summary><b><code>Initialize</code></b>:  <node><node class="text">The program's entry point.</node></node></summary><div><b><code>Extension</code></b>:  <node><node class="text">Not implemented.</node></node></div><div><b><code>Browser</code></b>:  <node><node class="text">A <b><code>REPL</code></b> interface.</node>
<node class="text">Supported browsers: modern Chrome and Firefox.</node></node></div><div><b><code>NodeJS</code></b>:  <node><node class="text">This should work. Presents a console <b><code>REPL</code></b> with outputs labeled sequentially.</node></node></div><div><b><code>WebWorker</code></b>:  <node><node class="text">Not implemented.</node></node></div></details><details><summary><b><code>Execution</code></b>:  <node><node class="text"><b><code>Execution</code></b>-related functionality.</node></node></summary><details><summary><b><code>Branching</code></b>:  <node><node class="text"><b><code>Branching</code></b>-related functionality.</node></node></summary><div><b><code>first</code></b>:  <node><node class="text">Finishing </node><code title="first"><code class="hasOperators" title="first"><code class="label" title="label" style="color: rgb(74, 13, 119);">a</code><operator>\</operator><code class="label" title="label" style="color: rgb(101, 141, 143);">b</code><operator>\</operator><code class="label" title="label" style="color: rgb(64, 77, 121);">c</code></code></code><node class="text"> or </node><code title="first"><code title="first"><bracket>(</bracket><b><code><b><code>first</code></b></code></b><space> </space><code class="hasOperators" title="rest"><operator>…</operator><code class="label" title="label" style="color: rgb(141, 180, 63);">Branches</code></code><bracket>)</bracket></code></code><node class="text">: tries to evaluate each expression in order, returning the <b><code>first</code></b> non-<b><code>error</code></b> result or else <b><code>error</code></b>.</node></node></div><div><b><code>last</code></b>:  <node><node class="text">Finishing </node><code title="last"><code class="hasOperators" title="last"><code class="label" title="label" style="color: rgb(74, 13, 119);">a</code><operator>,</operator><code class="label" title="label" style="color: rgb(101, 141, 143);">b</code><operator>,</operator><code class="label" title="label" style="color: rgb(64, 77, 121);">c</code></code></code><node class="text"> or </node><code title="last"><code title="last"><bracket>(</bracket><b><code><b><code>last</code></b></code></b><space> </space><code class="hasOperators" title="rest"><operator>…</operator><code class="label" title="label" style="color: rgb(141, 180, 63);">Branches</code></code><bracket>)</bracket></code></code><node class="text">: tries to evaluate each expression in order, returning the <b><code>first</code></b> <b><code>error</code></b> or else the <b><code>last</code></b> non-<b><code>error</code></b> result.</node></node></div><div><b><code>if</code></b>:  <node><node class="text">Finishing </node><code title="if"><code title="if"><bracket>(</bracket><b><code><b><code>if</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(33, 25, 134);">Condition</code><space> </space><code class="label" title="label" style="color: rgb(27, 217, 140);">Then</code><space> </space><code class="label" title="label" style="color: rgb(196, 152, 37);">Else</code><bracket>)</bracket></code></code><node class="text">: Evaluates </node><code class="label" title="label" style="color: rgb(33, 25, 134);"><code class="label" title="label" style="color: rgb(33, 25, 134);">Condition</code></code><node class="text">, then evaluates </node><code class="label" title="label" style="color: rgb(27, 217, 140);"><code class="label" title="label" style="color: rgb(27, 217, 140);">Then</code></code><node class="text"> <b><code>if</code></b> it was </node><b><code><b><code><b><code>true</code></b></code></b></code></b><node class="text">, or </node><code class="label" title="label" style="color: rgb(196, 152, 37);"><code class="label" title="label" style="color: rgb(196, 152, 37);">Else</code></code><node class="text"> otherwise.</node></node></div></details><div><b><code>repeat</code></b>:  <node><node class="text">Finishing </node><code title="repeat"><code title="repeat"><bracket>(</bracket><b><code><b><code>repeat</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(148, 31, 205);">Expr</code><bracket>)</bracket></code></code><node class="text">: loops forever when finished, interrupting as needed. </node><code title="repeat"><code title="repeat"><b><code><b><code>repeat</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(148, 31, 205);">Expr</code><space> </space><code class="label" title="label" style="color: rgb(129, 118, 137);">Times</code></code></code><node class="text">: repeats the computation many </node><code class="label" title="label" style="color: rgb(129, 118, 137);"><code class="label" title="label" style="color: rgb(129, 118, 137);">Times</code></code><node class="text">.</node>
<node class="text">Label-binding environment is not preserved.</node></node></div><details><summary><b><code>await</code></b>:  <node><node class="text">Finishing </node><code title="await"><code title="await"><bracket>(</bracket><b><code><b><code>await</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(148, 31, 205);">Expr</code><bracket>)</bracket></code></code><node class="text">: waits for the returned promise(s) to <b><code>finish</code></b> before continuing evaluation.</node>
<node class="text">An alternative for the default fitting-for-script-usage partial evaluation. Best used for <b><code>fast</code></b>-returning promises.</node></node></summary><div><b><code>delay</code></b>:  <node><node class="text"></node><code title="delay"><code title="delay"><bracket>(</bracket><b><code><b><code>delay</code></b></code></b><bracket>)</bracket></code></code><node class="text"> or </node><code title="delay"><code title="delay"><bracket>(</bracket><b><code><b><code>delay</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(5, 230, 137);">Value</code><bracket>)</bracket></code></code><node class="text">: Just a <b><code>function</code></b> for testing promises. It should have no effect on evaluation.</node>
<node class="text">Examples: </node><code title="sum"><code class="hasOperators" title="sum"><code title="delay"><bracket>(</bracket><b><code><b><code>delay</code></b></code></b><space> </space><number>1</number><bracket>)</bracket></code><operator>+</operator><code title="delay"><bracket>(</bracket><b><code><b><code>delay</code></b></code></b><space> </space><number>2</number><bracket>)</bracket></code></code></code><node class="text"> eventually returns </node><code title=""><number>3</number></code><node class="text">. </node><code title="sum"><code class="hasOperators" title="sum"><code class="hasOperators" title="mult"><code title="delay"><bracket>(</bracket><b><code><b><code>delay</code></b></code></b><space> </space><number>1</number><bracket>)</bracket></code><operator>*</operator><code title="delay"><bracket>(</bracket><b><code><b><code>delay</code></b></code></b><space> </space><number>3</number><bracket>)</bracket></code></code><operator>+</operator><code class="hasOperators" title="mult"><code title="delay"><bracket>(</bracket><b><code><b><code>delay</code></b></code></b><space> </space><number>4</number><bracket>)</bracket></code><operator>*</operator><code title="delay"><bracket>(</bracket><b><code><b><code>delay</code></b></code></b><space> </space><number>5</number><bracket>)</bracket></code></code></code></code><node class="text"> eventually returns </node><code title=""><number>23</number></code><node class="text">.</node></node></div><div><b><code>race</code></b>:  <node><node class="text">Finishing </node><code title="race"><code title="race"><bracket>(</bracket><b><code><b><code>race</code></b></code></b><space> </space><code class="hasOperators" title="rest"><operator>…</operator><code class="label" title="label" style="color: rgb(167, 172, 45);">Exprs</code></code><bracket>)</bracket></code></code><node class="text">: returns the <b><code>first</code></b> expression that returns instead of being deferred. The opposite of regular multiple-promise handling, which waits for all to join.</node></node></div></details><div><b><code>rest</code></b>:  <node><node class="text"></node><code title="rest"><code title="rest"><bracket>(</bracket><b><code><b><code>rest</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(153, 83, 88);">Array</code><bracket>)</bracket></code></code><node class="text"> or </node><code title="rest"><code class="hasOperators" title="rest"><operator>…</operator><code class="label" title="label" style="color: rgb(153, 83, 88);">Array</code></code></code><node class="text">: when statically used in a <b><code>call</code></b>, spreads the Array into the user.</node>
<node class="text">When in an <b><code>array</code></b> that is assigned to, collects the <b><code>rest</code></b> of arguments into an <b><code>array</code></b> (can only be used once per <b><code>array</code></b>).</node></node></div><details><summary><b><code>finish</code></b>:  <node><node class="text"></node><code title="finish"><code title="finish"><bracket>(</bracket><b><code><b><code>finish</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(148, 31, 205);">Expr</code><bracket>)</bracket></code></code><node class="text">: Fully evaluates the expression — the interpreter loop, focused on re-<b class=""><code>using</code></b> computation results and inlining and inferring everything.</node>
<node class="text">Unless the computed code <b><code>defines</code></b> </node><b><code><b><code><b><code>finish</code></b></code></b></code></b><node class="text">, provides eager override-checking semantics: finishes all dependencies before </node><b><code><b><code><b><code>call</code></b></code></b></code></b><node class="text">ing or constructing Expr.</node>
<node class="text"></node>
<node class="text"></node><b><code><b><code><b><code>finish</code></b></code></b></code></b><node class="text"> proceeds top-down, from what is needed to primitives; </node><b><code><b><code><b><code>call</code></b></code></b></code></b><node class="text"> proceeds bottom-up, making what is needed from primitives.</node>
<node class="text">Each node will be evaluated only once during a <b><code>function</code></b> <b><code>call</code></b>, so graph bindings (</node>… a:(…)<node class="text">) play the role of variables.</node>
<node class="text">Cyclic computations return </node><b><code><b><code><b><code>cycle</code></b></code></b></code></b><node class="text">, though cyclic structures construct a graph.</node></node></summary><div><b><code>inline</code></b>:  <node><node class="text">A marker for making a <b><code>function</code></b> always inlined. Automatically set to <b><code>true</code></b> on user-defined functions.</node></node></div></details><details><summary><b><code>call</code></b>:  <node><node class="text"></node><code title="call"><code title="call"><bracket>(</bracket><b><code><b><code>call</code></b></code></b><space> </space><code title=""><bracket>(</bracket><code class="hasOperators" title="rest"><operator>…</operator><code class="label" title="label" style="color: rgb(94, 158, 90);">Values</code></code><bracket>)</bracket></code><bracket>)</bracket></code></code><node class="text">: Applies the <b><code>first</code></b> value (the <b><code>function</code></b>) to the <b><code>rest</code></b> of values. Evaluates the <b><code>array</code></b> of <b><code>function</code></b> then its arguments, assuming its parts are already evaluated.</node>
<node class="text">Overriding this allows <b><code>function</code></b> application. In fact, </node>F:(function …)<node class="text"> is the same as </node><code title="concept"><code title="concept"><bracket>(</bracket><b><code><b><code>concept</code></b></code></b><space> </space><code title="map"><bracket>(</bracket><b><code><b><code>map</code></b></code></b><space> </space><b><code><b><code>call</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(188, 71, 47);">F</code><bracket>)</bracket></code><bracket>)</bracket></code></code><node class="text">.</node>
<node class="text">Caches results of pure functions.</node></node></summary><div><b><code>cycle</code></b>:  <node><node class="text">Instead of never returning, pure infinite computations return </node><b><code><b><code><b><code>cycle</code></b></code></b></code></b><node class="text"> (and prevent caching until that node is fully returned from).</node></node></div></details><details><summary><b><code>error</code></b>:  <node><node class="text"></node><code title="error"><code title="error"><bracket>(</bracket><b><code><b><code>error</code></b></code></b><space> </space><code class="hasOperators" title="rest"><operator>…</operator><code class="label" title="label" style="color: rgb(55, 188, 105);">Causes</code></code><bracket>)</bracket></code></code><node class="text">: throws an <b><code>error</code></b> when executed, containing useful information as to its likely cause.</node>
<node class="text">Indicates a bug in the code, and is mostly intended to be presented to the user.</node></node></summary><div><b><code>jsRejected</code></b>:  <node><node class="text"></node><code title="jsRejected"><code title="jsRejected"><bracket>(</bracket><b><code><b><code>jsRejected</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(124, 39, 113);">Reason</code><bracket>)</bracket></code></code><node class="text">: represents <b><code>either</code></b> an exception or promise rejection in JS.</node></node></div><div><b><code>errorFast</code></b>:  <node><node class="text">Faster <b><code>error</code></b>-throwing, for things unlikely to be shown to the user.</node></node></div><div><b><code>errorIn</code></b>:  <node><node class="text">Adds slightly more information to an <b><code>error</code></b>.</node></node></div><div><b><code>errorStack</code></b>:  <node><node class="text">Adds the execution stack to the raised <b><code>error</code></b>.</node></node></div></details><details><summary><b><code>function</code></b>:  <node><node class="text"></node><code title="function"><code class="hasOperators" title="function"><code class="label" title="label" style="color: rgb(134, 129, 2);">Input</code><operator>→</operator><code class="label" title="label" style="color: rgb(121, 100, 163);">Output</code></code></code><node class="text"> or </node><code title="function"><code title="function"><bracket>(</bracket><b><code><b><code>function</code></b></code></b><space> </space><code class="hasOperators" title="rest"><operator>…</operator><code class="label" title="label" style="color: rgb(162, 106, 104);">Inputs</code></code><space> </space><code class="label" title="label" style="color: rgb(121, 100, 163);">Output</code><bracket>)</bracket></code></code><node class="text">: an arbitrary transformation of inputs into output. It can be called (like </node><code title=""><code title=""><bracket>(</bracket><code class="label" title="label" style="color: rgb(154, 129, 101);">f</code><space> </space><code class="hasOperators" title="rest"><operator>…</operator><b><code><b><code>Data</code></b></code></b></code><bracket>)</bracket></code></code><node class="text">), which assigns …Inputs to …<b><code>Data</code></b> (setting variables), and evaluates the <b><code>function</code></b> body (Output).</node>
<node class="text">Equal input variables must be ref-equal (so </node><code title="bound"><code title="bound"><code class="label" title="function" style="color: rgb(97, 182, 105);">f</code><space> </space><extracted title="extracted" class="hasOperators"><code class="label" title="function" style="color: rgb(97, 182, 105);">f</code><operator>:</operator><code title="function"><bracket>(</bracket><b><code><b><code>function</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(165, 60, 159);">x</code><space> </space><code class="label" title="label" style="color: rgb(165, 60, 159);">x</code><space> </space><number>0</number><bracket>)</bracket></code></extracted></code></code><node class="text"> accepts </node><code title=""><code title=""><bracket>(</bracket><code class="label" title="label" style="color: rgb(154, 129, 101);">f</code><space> </space><number>0</number><space> </space><number>0</number><bracket>)</bracket></code></code><node class="text"> and </node><code title=""><code title=""><bracket>(</bracket><code class="label" title="label" style="color: rgb(154, 129, 101);">f</code><space> </space><number>1</number><space> </space><number>1</number><bracket>)</bracket></code></code><node class="text">, but not </node><code title=""><code title=""><bracket>(</bracket><code class="label" title="label" style="color: rgb(154, 129, 101);">f</code><space> </space><number>0</number><space> </space><number>1</number><bracket>)</bracket></code></code><node class="text">).</node>
<node class="text">Variables within non-</node><b><code><b><code><b><code>closure</code></b></code></b></code></b><node class="text"> functions will not be changed by application.</node></node></summary><details><summary><b><code>purify</code></b>:  <node><node class="text"></node><code title="purify"><code title="purify"><bracket>(</bracket><b><code><b><code>purify</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(148, 31, 205);">Expr</code><bracket>)</bracket></code></code><node class="text">⇒Expr: partially-evaluates Expr, not executing <b><code>impure</code></b> subexpressions.</node></node></summary><div><b><code>impure</code></b>:  <node><node class="text"></node><code title="impure"><code title="impure"><bracket>(</bracket><b><code><b><code>impure</code></b></code></b><bracket>)</bracket></code></code><node class="text">: signifies that <node>the current operation</node> must be <node>recorded in a pure context</node> and <node>not cached in a non-pure one</node>.</node></node></div></details><div><b><code>argCount</code></b>:  <node><node class="text">A marker for the number of args to a <b><code>function</code></b>.</node></node></div><div><b><code>var</code></b>:  <node><node class="text">Finishing </node><code title="var"><code title="var">?</code></code><node class="text"> or </node><code title="var"><code title="var"><bracket>(</bracket><b><code><b><code>var</code></b></code></b><bracket>)</bracket></code></code><node class="text">: A unique assignable variable.</node>
<node class="text">Unlike a <b><code>label</code></b>, this returns itself when evaluated without having been assigned.</node></node></div><div><b><code>const</code></b>:  <node><node class="text"></node><code title="const"><code title="const"><bracket>(</bracket><b><code><b><code>const</code></b></code></b><bracket>)</bracket></code></code><node class="text">: A new unique object with no inner structure, only good for ref-equality checks.</node></node></div><div><b><code>id</code></b>:  <node><node class="text">id: The identity <b><code>function</code></b> that just returns x from </node><code title="id"><code title="id"><bracket>(</bracket><b><code><b><code>id</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(165, 60, 159);">x</code><bracket>)</bracket></code></code><node class="text">.</node></node></div><div><b><code>try</code></b>:  <node><node class="text"></node><code title="try"><code class="hasOperators" title="try"><code class="label" title="label" style="color: rgb(74, 13, 119);">a</code><operator>|</operator><code class="label" title="label" style="color: rgb(101, 141, 143);">b</code><operator>|</operator><code class="label" title="label" style="color: rgb(64, 77, 121);">c</code></code></code><node class="text"> or </node><code title="try"><code title="try"><bracket>(</bracket><b><code><b><code>try</code></b></code></b><space> </space><code class="hasOperators" title="rest"><operator>…</operator><code class="label" title="label" style="color: rgb(213, 35, 136);">Functions</code></code><bracket>)</bracket></code></code><node class="text">: returns a <b><code>function</code></b> that tries to <b><code>call</code></b> functions in order, returning the <b><code>first</code></b> non-<b><code>error</code></b> result or <b><code>error</code></b>.</node></node></div><div><b><code>compose</code></b>:  <node><node class="text"></node><code title="compose"><code title="compose"><bracket>(</bracket><b><code><b><code>compose</code></b></code></b><space> </space><code class="hasOperators" title="rest"><operator>…</operator><code class="label" title="label" style="color: rgb(213, 35, 136);">Functions</code></code><bracket>)</bracket></code></code><node class="text">: returns a <b><code>function</code></b> that composes functions left-to-right, passing the output of each <b><code>function</code></b> to the next one.</node></node></div><div><b><code>closure</code></b>:  <node><node class="text"></node><code title="closure"><code title="closure"><bracket>(</bracket><b><code><b><code>closure</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(127, 138, 47);">Function</code><bracket>)</bracket></code></code><node class="text">: makes Function into a <b><code>closure</code></b> — names existing in a containing <b><code>function</code></b> will be <b><code>bound</code></b> by the outer <b><code>function</code></b> when a <b><code>closure</code></b> is created.</node>
<node class="text">With binding, the actual definition can be outside of the <b><code>function</code></b> (particularly <b><code>if</code></b> equal-structure closures in different functions are merged) (even though the interface copies <b><code>closure</code></b> definitions into each serialized-to-DOM case), so actually separating closures semantically is required. </node><b><code><b><code><b><code>var</code></b></code></b></code></b><node class="text"> can be used to highlight the same variable on parsing.</node>
<node class="text">Uses </node><b><code><b><code><b><code>bound</code></b></code></b></code></b><node class="text">, and partially-evaluates the result before returning.</node>
<node class="text">Can be written as </node><code title="closure"><code class="hasOperators" title="closure"><operator>!</operator><code class="label" title="label" style="color: rgb(127, 138, 47);">Function</code></code></code><node class="text">.</node></node></div></details></details><details><summary><b><code>Expression</code></b>:  <node><node class="text"><b><code>Expression</code></b>-related functionality.</node></node></summary><div><b><code>graphSize</code></b>:  <node><node class="text"></node><code title="graphSize"><code title="graphSize"><bracket>(</bracket><b><code><b><code>graphSize</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(148, 31, 205);">Expr</code><bracket>)</bracket></code></code><node class="text">⇒Nat: returns the number of distinct objects in Expr, going into arrays.</node></node></div><div><b><code>userTime</code></b>:  <node><node class="text"></node><code title="userTime"><code title="userTime"><bracket>(</bracket><b><code><b><code>userTime</code></b></code></b><bracket>)</bracket></code></code><node class="text">⇒</node><code class="label" title="label" style="color: rgb(77, 147, 160);"><code class="label" title="label" style="color: rgb(77, 147, 160);">TimeMark</code></code><node class="text"> or </node><code title="userTime"><code title="userTime"><bracket>(</bracket><b><code><b><code>userTime</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(77, 147, 160);">TimeMark</code><bracket>)</bracket></code></code><node class="text">: returns the time spent on this job as f<number>64</number> milliseconds, or the non-negative in-job time elapsed since the mark.</node></node></div><div><b><code>realTime</code></b>:  <node><node class="text"></node><code title="realTime"><code title="realTime"><bracket>(</bracket><b><code><b><code>realTime</code></b></code></b><bracket>)</bracket></code></code><node class="text">⇒</node><code class="label" title="label" style="color: rgb(77, 147, 160);"><code class="label" title="label" style="color: rgb(77, 147, 160);">TimeMark</code></code><node class="text"> or </node><code title="realTime"><code title="realTime"><bracket>(</bracket><b><code><b><code>realTime</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(77, 147, 160);">TimeMark</code><bracket>)</bracket></code></code><node class="text">: returns the time since start as f<number>64</number> milliseconds, or the non-negative time elapsed since the mark.</node></node></div><details><summary><b><code>memory</code></b>:  <node><node class="text"></node><code title="memory"><code title="memory"><bracket>(</bracket><b><code><b><code>memory</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(148, 31, 205);">Expr</code><bracket>)</bracket></code></code><node class="text">: Returns </node><code title=""><code title=""><bracket>(</bracket><code class="label" title="label" style="color: rgb(44, 63, 183);">Result</code><space> </space><code class="label" title="label" style="color: rgb(108, 44, 231);">MemoryIncrease</code><bracket>)</bracket></code></code><node class="text">. Doesn't work in the browser.</node>
<node class="text">Does not count <b><code>memory</code></b> allocated in interruptions (between executions of Expr) as part of the reported result.</node></node></summary><div><b><code>memorySince</code></b>:  <node><node class="text"></node><code title=""><code title=""><bracket>(</bracket><code class="hasOperators" title="lookup"><b><code><b><code>memory</code></b></code></b><operator>.</operator><code class="label" title="label" style="color: rgb(12, 191, 174);">since</code></code><bracket>)</bracket></code></code><node class="text">⇒MemMark or </node><code title=""><code title=""><bracket>(</bracket><code class="hasOperators" title="lookup"><b><code><b><code>memory</code></b></code></b><operator>.</operator><code class="label" title="label" style="color: rgb(12, 191, 174);">since</code></code><space> </space><code class="label" title="label" style="color: rgb(120, 177, 75);">MemMark</code><bracket>)</bracket></code></code><node class="text">: Measures required-<b><code>memory</code></b>-size change (allocated <b><code>memory</code></b>) as non-negative f<number>64</number> bytes. Always <number>0</number> in browsers.</node>
<node class="text">Makes no attempt to correct for the <b><code>memory</code></b>-to-measure, </node><code title=""><code title=""><bracket>(</bracket><code class="hasOperators" title="lookup"><b><code><b><code>memory</code></b></code></b><operator>.</operator><code class="label" title="label" style="color: rgb(12, 191, 174);">since</code></code><space> </space><code title=""><bracket>(</bracket><code class="hasOperators" title="lookup"><b><code><b><code>memory</code></b></code></b><operator>.</operator><code class="label" title="label" style="color: rgb(12, 191, 174);">since</code></code><bracket>)</bracket></code><bracket>)</bracket></code></code><node class="text">.</node></node></div></details><div><b><code>quote</code></b>:  <node><node class="text">Finishing </node><code title="quote"><code title="quote"><bracket>(</bracket><b><code><b><code>quote</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(148, 31, 205);">Expr</code><bracket>)</bracket></code></code><node class="text"> or </node><code title="quote"><code class="hasOperators" title="quote"><operator>^</operator><code class="label" title="label" style="color: rgb(148, 31, 205);">Expr</code></code></code><node class="text">: Returns Expr unevaluated, quoting the exact <b><code>array</code></b> structure.</node>
<node class="text">If there are no labels inside, has the same effect as adding </node><b><code><b><code><b><code>array</code></b></code></b></code></b><node class="text"> at the beginning of every <b><code>array</code></b> seen inside, copying.</node></node></div><div><b><code>label</code></b>:  <node><node class="text"></node><code title="label"><code title="label"><bracket>(</bracket><b><code><b><code>label</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(173, 15, 195);">Name</code><bracket>)</bracket></code></code><node class="text">: represents a name that can be <b><code>bound</code></b> or assigned. Equal-name labels are <b><code>bound</code></b> to the same thing within the same binding.</node>
<node class="text">Evaluating an <b><code>unbound</code></b> <b><code>label</code></b> results in </node><code title="error"><code title="error"><bracket>(</bracket><b><code><b><code>error</code></b></code></b><bracket>)</bracket></code></code><node class="text">; evaluating a <b><code>bound</code></b> <b><code>label</code></b> results in its value, in the current <b><code>function</code></b> <b><code>call</code></b>.</node></node></div><div><b><code>bound</code></b>:  <node><node class="text">Finishing </node><code title="bound"><code title="bound"><bracket>(</bracket><b><code><b><code>bound</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(148, 31, 205);">Expr</code><space> </space><code class="label" title="label" style="color: rgb(9, 44, 158);">Ctx</code><bracket>)</bracket></code></code><node class="text">: When called, returns a copy of Expr with all keys <b><code>bound</code></b> to values in Ctx, as <b><code>if</code></b> copying then changing in-place. When evaluated, also evaluates the result.</node>
<node class="text">Inner contexts are always <b><code>bound</code></b> <b><code>first</code></b>.</node>
<node class="text">Can be written as </node>key:value<node class="text"> in an <b><code>array</code></b> to bind its elements: </node><code title=""><code title=""><bracket>(</bracket><code class="label" title="label" style="color: rgb(74, 13, 119);">a</code><space> </space><code class="label" title="label" style="color: rgb(101, 141, 143);">b</code><space> </space><extracted title="extracted" class="hasOperators"><code class="label" title="label" style="color: rgb(74, 13, 119);">a</code><operator>:</operator><number>0</number></extracted><space> </space><extracted title="extracted" class="hasOperators"><code class="label" title="label" style="color: rgb(101, 141, 143);">b</code><operator>:</operator><number>1</number></extracted><bracket>)</bracket></code></code><node class="text"> is </node><code title=""><code title=""><bracket>(</bracket><number>0</number><space> </space><number>1</number><bracket>)</bracket></code></code><node class="text">, </node><code title="bound"><code title="bound"><code class="label" title="" style="color: rgb(38, 241, 105);">a</code><space> </space><extracted title="extracted" class="hasOperators"><code class="label" title="" style="color: rgb(38, 241, 105);">a</code><operator>:</operator><code title=""><bracket>(</bracket><number>0</number><bracket>)</bracket></code></extracted></code></code><node class="text"> is </node><code title=""><code title=""><bracket>(</bracket><number>0</number><bracket>)</bracket></code></code><node class="text">. Can be used to give cycles to data, and encode graphs and multiple-parents in trees.</node>
<node class="text">If Ctx returns non-<b><code>undefined</code></b>, its result won't be recursively <b><code>bound</code></b> unless cyclic.</node>
<node class="text"></node><code title="bound"><code title="bound"><bracket>(</bracket><b><code><b><code>bound</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(74, 13, 119);">a</code><space> </space><code title="map"><bracket>(</bracket><b><code><b><code>map</code></b></code></b><space> </space><code class="hasOperators" title="quote"><operator>^</operator><code class="label" title="label" style="color: rgb(74, 13, 119);">a</code></code><space> </space><number>1</number><bracket>)</bracket></code><bracket>)</bracket></code></code><node class="text"> becomes <number>1</number>, as does </node><code title="bound"><code title="bound"><code class="label" title="" style="color: rgb(125, 154, 106);">a</code><space> </space><extracted title="extracted" class="hasOperators"><code class="label" title="" style="color: rgb(125, 154, 106);">a</code><operator>:</operator><number>1</number></extracted></code></code><node class="text">.</node>
<node class="text">If Ctx is a <b><code>function</code></b>, this acts as a rewrite: </node><code title="bound"><code title="bound"><bracket>(</bracket><b><code><b><code>bound</code></b></code></b><space> </space><code title=""><bracket>(</bracket><code class="label" title="label" style="color: rgb(74, 13, 119);">a</code><space> </space><code class="label" title="label" style="color: rgb(101, 141, 143);">b</code><bracket>)</bracket></code><space> </space><code class="hasOperators" title="function"><code class="label" title="label" style="color: rgb(165, 60, 159);">x</code><operator>→</operator><code title="array"><bracket>(</bracket><b><code><b><code>array</code></b></code></b><space> </space><b><code><b><code>sum</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(165, 60, 159);">x</code><space> </space><number>1</number><bracket>)</bracket></code></code><bracket>)</bracket></code></code><node class="text"> evaluates </node><code title="sum"><code title="sum"><bracket>(</bracket><b><code><b><code>sum</code></b></code></b><space> </space><code title=""><bracket>(</bracket><code class="hasOperators" title="sum"><code class="label" title="label" style="color: rgb(74, 13, 119);">a</code><operator>+</operator><number>1</number></code><space> </space><code class="hasOperators" title="sum"><code class="label" title="label" style="color: rgb(101, 141, 143);">b</code><operator>+</operator><number>1</number></code><bracket>)</bracket></code><space> </space><number>1</number><bracket>)</bracket></code></code><node class="text">.</node>
<node class="text">On <b><code>finish</code></b>, finishes Ctx <b><code>first</code></b>, then binds Expr, then finishes Expr; finishes the <b><code>bound</code></b> Expr to Finishing Ctx.</node></node></div><div><b><code>unbound</code></b>:  <node><node class="text"></node><code title="unbound"><code title="unbound"><bracket>(</bracket><b><code><b><code>unbound</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(148, 31, 205);">Expr</code><bracket>)</bracket></code></code><node class="text">: Eliminates cycles in (a copy of) Expr by inserting </node><code title="bound"><code title="bound"><bracket>(</bracket><b><code><b><code>bound</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(148, 31, 205);">Expr</code><space> </space><code title="map"><bracket>(</bracket><b><code><b><code>map</code></b></code></b><space> </space><code class="hasOperators" title="rest"><operator>…</operator><code class="label" title="label" style="color: rgb(158, 88, 138);">Bindings</code></code><bracket>)</bracket></code><bracket>)</bracket></code></code><node class="text"> with keys in the copy.</node></node></div><details><summary><b><code>journal</code></b>:  <node><node class="text">Finishing </node><code title="journal"><code title="journal"><bracket>(</bracket><b><code><b><code>journal</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(148, 31, 205);">Expr</code><bracket>)</bracket></code></code><node class="text">: virtualizes writes during Expr's evaluation. Returns a <b><code>journal</code></b> that can be passed to <b><code>peekResult</code></b> or <b><code>commit</code></b>.</node></node></summary><div><b><code>peekResult</code></b>:  <node><node class="text"></node><code title="peekResult"><code title="peekResult"><bracket>(</bracket><b><code><b><code>peekResult</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(156, 25, 204);">Journal</code><bracket>)</bracket></code></code><node class="text">: Returns the result contained in a <b><code>journal</code></b>.</node></node></div><div><b><code>commit</code></b>:  <node><node class="text"></node><code title="commit"><code title="commit"><bracket>(</bracket><b><code><b><code>commit</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(156, 25, 204);">Journal</code><bracket>)</bracket></code></code><node class="text">: performs the actual writes stored in a <b><code>journal</code></b>, and returns its result.</node></node></div></details></details><details><summary><b><code>Documentation</code></b>:  <node><node class="text"><b><code>Documentation</code></b>-related functions.</node></node></summary><div><b><code>buzzwords</code></b>:  <node><node class="text"></node><code title="buzzwords"><code title="buzzwords"><bracket>(</bracket><b><code><b><code>buzzwords</code></b></code></b><bracket>)</bracket></code></code><node class="text">: returns all <b><code>buzzwords</code></b> of <b><code>Self</code></b> as a programming language.</node></node></div><div><b><code>docs</code></b>:  <node><node class="text"></node><code title="docs"><code title="docs"><bracket>(</bracket><b><code><b><code>docs</code></b></code></b><bracket>)</bracket></code></code><node class="text">: returns a hierarchical documentation <b><code>elem</code></b>.</node></node></div><div><b><code>txt</code></b>:  <node><node class="text"></node><code title="txt"><code title="txt"><bracket>(</bracket><b><code><b><code>txt</code></b></code></b><bracket>)</bracket></code></code><node class="text">: Returns all available textual descriptions of functions in a <node>(<b><code>map</code></b> … Function Description …)</node> format.</node></node></div><div><b><code>examples</code></b>:  <node><node class="text"></node><code title="examples"><code title="examples"><bracket>(</bracket><b><code><b><code>examples</code></b></code></b><bracket>)</bracket></code></code><node class="text">: Returns all available examples of usage of functions in a <node>(map … Function <node>(… <node>(Code ⇒ Becomes)</node> …)</node> …)</node> format.</node>
<node class="text">All these are automatically tested to be correct at launch.</node></node></div><div><b><code>future</code></b>:  <node><node class="text"></node><code title="future"><code title="future"><bracket>(</bracket><b><code><b><code>future</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(188, 71, 47);">F</code><bracket>)</bracket></code></code><node class="text">: Returns a list of things to be done about F.</node>
<node class="text"></node><code title="future"><code title="future"><bracket>(</bracket><b><code><b><code>future</code></b></code></b><bracket>)</bracket></code></code><node class="text">: Returns all known things to be done. Less than a third is usually done.</node></node></div><div><b><code>refs</code></b>:  <node><node class="text"></node><code title="refs"><code title="refs"><bracket>(</bracket><b><code><b><code>refs</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(248, 1, 56);">Global</code><bracket>)</bracket></code></code><node class="text">: returns <node><node>all other globals that</node> <node><node>this one</node> (likely) refers to</node></node>.</node>
<node class="text"></node><code title="refs"><code title="refs"><bracket>(</bracket><b><code><b><code>refs</code></b></code></b><bracket>)</bracket></code></code><node class="text">: returns the <node>full <node>global reference</node> graph</node>.</node></node></div><div><b><code>refd</code></b>:  <node><node class="text"></node><code title="refd"><code title="refd"><bracket>(</bracket><b><code><b><code>refd</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(248, 1, 56);">Global</code><bracket>)</bracket></code></code><node class="text">: returns <node><node>all other globals that</node> <node><node>this one</node> is (likely) referenced in</node></node>.</node>
<node class="text"></node><code title="refd"><code title="refd"><bracket>(</bracket><b><code><b><code>refd</code></b></code></b><bracket>)</bracket></code></code><node class="text">: returns the <node>full <node>global back-reference</node> graph</node>.</node></node></div></details><details class=""><summary><b class=""><code>Numeric</code></b>:  <node><node class="text">A namespace for some very primitive numeric-computation-related functionality.</node></node></summary><details><summary><b><code>reduce</code></b>:  <node><node class="text"></node><code title="reduce"><code title="reduce"><bracket>(</bracket><b><code><b><code>reduce</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(153, 83, 88);">Array</code><space> </space><code class="label" title="label" style="color: rgb(127, 138, 47);">Function</code><bracket>)</bracket></code></code><node class="text"> or </node><code title="reduce"><code title="reduce"><bracket>(</bracket><b><code><b><code>reduce</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(153, 83, 88);">Array</code><space> </space><code class="label" title="label" style="color: rgb(127, 138, 47);">Function</code><space> </space><code class="label" title="label" style="color: rgb(94, 140, 150);">Initial</code><bracket>)</bracket></code></code><node class="text">: reduces Array with Function, reducing dimensionality (<b><code>array</code></b> nestedness) by <number>1</number>: repeatedly sets Initial to the result of </node><code title=""><code title=""><bracket>(</bracket><code class="label" title="label" style="color: rgb(127, 138, 47);">Function</code><space> </space><code class="label" title="label" style="color: rgb(94, 140, 150);">Initial</code><space> </space><code class="label" title="label" style="color: rgb(137, 117, 131);">Element</code><bracket>)</bracket></code></code><node class="text">. If Initial is <b><code>undefined</code></b>, it is assumed to be the <b><code>first</code></b> <b><code>array</code></b> element.</node></node></summary><div><b><code>stopIteration</code></b>:  <node><node class="text"></node><code title="stopIteration"><code title="stopIteration"><bracket>(</bracket><b><code><b><code>stopIteration</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(44, 63, 183);">Result</code><bracket>)</bracket></code></code><node class="text">: when returned to </node><b><code><b><code><b><code>reduce</code></b></code></b></code></b><node class="text">, iteration gets stopped with this result.</node></node></div></details><div><b><code>transform</code></b>:  <node><node class="text"></node><code title="transform"><code title="transform"><bracket>(</bracket><b><code><b><code>transform</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(127, 138, 47);">Function</code><space> </space><code class="label" title="label" style="color: rgb(153, 83, 88);">Array</code><bracket>)</bracket></code></code><node class="text">: transforms each element of Array by applying Function.</node>
<node class="text"></node><code title="transform"><code title="transform"><bracket>(</bracket><b><code><b><code>transform</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(201, 51, 132);">G</code><space> </space><code title="transform"><bracket>(</bracket><b><code><b><code>transform</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(188, 71, 47);">F</code><space> </space><code class="label" title="label" style="color: rgb(0, 35, 42);">A</code><bracket>)</bracket></code><bracket>)</bracket></code></code><node class="text"> is the same as </node><code title="lookup"><code class="hasOperators" title="lookup"><code title="transform"><bracket>(</bracket><b><code><b><code>transform</code></b></code></b><space> </space><code title="compose"><bracket>(</bracket><b><code><b><code>compose</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(188, 71, 47);">F</code><space> </space><code class="label" title="label" style="color: rgb(201, 51, 132);">G</code><bracket>)</bracket></code><space> </space><code class="label" title="label" style="color: rgb(0, 35, 42);">A</code><bracket>)</bracket></code><operator>.</operator></code></code><node class="text"></node></node></div><div><b><code>broadcasted</code></b>:  <node><node class="text"></node><code title="broadcasted"><code title="broadcasted"><bracket>(</bracket><b><code><b><code>broadcasted</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(127, 138, 47);">Function</code><bracket>)</bracket></code></code><node class="text">: creates a <b><code>function</code></b> that is <b><code>broadcasted</code></b> over <b><code>array</code></b> arguments (</node><code title=""><code title=""><bracket>(</bracket><code title="broadcasted"><bracket>(</bracket><b><code><b><code>broadcasted</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(105, 110, 169);">Func</code><bracket>)</bracket></code><space> </space><code class="hasOperators" title="rest"><operator>…</operator><code class="label" title="label" style="color: rgb(147, 119, 29);">Args</code></code><bracket>)</bracket></code></code><node class="text">). No <b><code>array</code></b> inputs means just applying Function; having <b><code>array</code></b> inputs means returning an <b><code>array</code></b> of applying </node><code title="broadcasted"><code title="broadcasted"><bracket>(</bracket><b><code><b><code>broadcasted</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(127, 138, 47);">Function</code><bracket>)</bracket></code></code><node class="text"> to each element, with the same index for all arguments, <b class=""><code>using</code></b> the <b><code>last</code></b> element <b><code>if</code></b> out-of-bounds for an argument, and non-<b><code>array</code></b> inputs treated as arrays of length <number>1</number>.</node></node></div><details><summary><b><code>sum</code></b></summary><details><summary><code title="defines"><b><code>defines</code></b><space> </space><code title="defines"><bracket>(</bracket><b><code>defines</code></b><space> </space><b><code>undefined</code></b><space> </space><b><code>deconstruct</code></b><bracket>)</bracket></code><space> </space><b><code>deconstruct</code></b></code></summary><div><b><code>overridable</code></b>:  <node><node class="text"></node><code title="overridable"><code title="overridable"><bracket>(</bracket><b><code><b><code>overridable</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(127, 138, 47);">Function</code><bracket>)</bracket></code></code><node class="text">: creates a <b><code>function</code></b> that checks whether any input <b><code>defines</code></b> it, otherwise calls the base Function.</node></node></div></details></details><div><b><code>mult</code></b></div><div><b><code>sub</code></b></div><div><b><code>div</code></b></div><details><summary><b><code>Random</code></b>:  <node><node class="text">Some functions for random number generation.</node></node></summary><div><b><code>randomNat</code></b>:  <node><node class="text"></node><code title="randomNat"><code title="randomNat"><bracket>(</bracket><b><code><b><code>randomNat</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(148, 23, 214);">Nat</code><bracket>)</bracket></code></code><node class="text">: Picks a random non-negative integer less than n, from a uniform distribution.</node>
<node class="text">An interface to JS's crypto.getRandomValues for generating random numbers on-demand as opposed to in-batches, optimizing to request the least amount of random bits required.</node>
<node class="text"></node><code title="randomNat"><code title="randomNat"><bracket>(</bracket><b><code><b><code>randomNat</code></b></code></b><space> </space><number>1</number><bracket>)</bracket></code></code><node class="text"> is <number>0</number>.</node>
<node class="text"></node><code title="randomNat"><code title="randomNat"><bracket>(</bracket><b><code><b><code>randomNat</code></b></code></b><space> </space><number>2</number><bracket>)</bracket></code></code><node class="text"> is <b><code>either</code></b> <number>0</number> or <number>1</number>.</node></node></div><div><b><code>randomProb</code></b>:  <node><node class="text"></node><code title="randomProb"><code title="randomProb"><bracket>(</bracket><b><code><b><code>randomProb</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(140, 129, 115);">Probability</code><bracket>)</bracket></code></code><node class="text">: Returns <b><code>true</code></b> with probability p, else <b><code>false</code></b>.</node>
<node class="text">Equivalent to JS <string>'Math.random() &lt; p'</string> with checks on p (it should be <number>0</number>…<number>1</number>), but (probably) faster.</node></node></div></details></details><details><summary><b><code>Data</code></b>:  <node><node class="text">A namespace for some data-representation-related functions.</node></node></summary><details><summary><b><code>lookup</code></b>:  <node><node class="text"></node><code title="lookup"><code class="hasOperators" title="lookup"><code class="label" title="label" style="color: rgb(161, 1, 126);">Map</code><operator>.</operator></code></code><node class="text"> or </node><code title="lookup"><code title="lookup"><bracket>(</bracket><b><code><b><code>lookup</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(161, 1, 126);">Map</code><bracket>)</bracket></code></code><node class="text">: returns an <b><code>array</code></b> of Map's keys.</node>
<node class="text"></node><code title="lookup"><code title="lookup"><bracket>(</bracket><b><code><b><code>lookup</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(161, 1, 126);">Map</code><space> </space><code class="label" title="label" style="color: rgb(127, 149, 108);">Key</code><bracket>)</bracket></code></code><node class="text">: returns the value in Map at Key (neither Key nor Value can be </node><b><code><b><code><b><code>undefined</code></b></code></b></code></b><node class="text">), or </node><b><code><b><code><b><code>undefined</code></b></code></b></code></b><node class="text"> <b><code>if</code></b> not found.</node>
<node class="text">(For <b><code>string</code></b> keys, can be written as </node><code title="lookup"><code class="hasOperators" title="lookup"><code class="label" title="label" style="color: rgb(121, 160, 104);">obj</code><operator>.</operator><code class="label" title="label" style="color: rgb(100, 114, 170);">key</code></code></code><node class="text">.)</node></node></summary><div><b><code>scope</code></b>:  <node><node class="text">hello</node></node></div></details><div><b><code>string</code></b>:  <node><node class="text"></node><code title="string"><code title="string"><bracket>(</bracket><b><code><b><code>string</code></b></code></b><space> </space><code class="hasOperators" title="rest"><operator>…</operator><code class="label" title="label" style="color: rgb(113, 137, 134);">Strings</code></code><bracket>)</bracket></code></code><node class="text">: represents a <b><code>string</code></b> of characters, with the <b><code>label</code></b> not <b><code>bound</code></b>. Also written as </node><code title=""><string>'xyz'</string></code><node class="text"> and </node><code title=""><string>"prequote""postquote"</string></code><node class="text">.</node>
<node class="text"></node><code title="string"><code title="string"><bracket>(</bracket><b><code><b><code>string</code></b></code></b><space> </space><string>"a"</string><space> </space><string>"b"</string><bracket>)</bracket></code></code><node class="text">: strings inside will be joined (into </node><code title=""><string>"ab"</string></code><node class="text"> here).</node></node></div><div><b><code>merge</code></b>:  <node><node class="text"></node><code title="merge"><code title="merge"><bracket>(</bracket><b><code><b><code>merge</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(153, 83, 88);">Array</code><bracket>)</bracket></code></code><node class="text">: Returns <b><code>either</code></b> a previously-created <b><code>array</code></b> content-equal to Array, or Array.</node>
<node class="text">(Does not <b><code>merge</code></b> cycles.)</node></node></div><div><b><code>array</code></b>:  <node><node class="text"></node><code title="array"><code title="array"><bracket>(</bracket><b><code><b><code>array</code></b></code></b><space> </space><code class="hasOperators" title="rest"><operator>…</operator><code class="label" title="label" style="color: rgb(30, 60, 167);">Items</code></code><bracket>)</bracket></code></code><node class="text">: an <b><code>array</code></b> of items with semantically constant content.</node>
<node class="text">If a <b><code>function</code></b> (</node><code class="label" title="label" style="color: rgb(153, 83, 88);"><code class="label" title="label" style="color: rgb(153, 83, 88);">Array</code></code><node class="text">'s head) <b><code>defines</code></b> </node><b><code><b><code><b><code>merge</code></b></code></b></code></b><node class="text"> to be </node><b><code><b><code><b><code>true</code></b></code></b></code></b><node class="text">, then calls to this guaranteed-pure <b><code>function</code></b> (arrays of <b><code>function</code></b>-then-args) are merged.</node></node></div><details><summary><b><code>concept</code></b>:  <node><node class="text"></node><code title="concept"><code title="concept"><bracket>(</bracket><b><code><b><code>concept</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(84, 98, 202);">View</code><bracket>)</bracket></code></code><node class="text">: Creates an object that <b><code>defines</code></b> some things (via a <b><code>map</code></b>).</node>
<node class="text">Concepts are used to give each <b><code>function</code></b> a free extensibility point.</node>
<node class="text">Rather than co-opting strings and <b><code>files</code></b> (duck typing, docstrings, documentation, READMEs) to convey parts of a <b><code>concept</code></b>, refer to defined functionality directly.</node>
<node class="text">Try to use this only as explicitly suggested by functions.</node>
<node class="text">Views and non-<b><code>_unknown</code></b> arrays are considered immutable.</node></node></summary><div><b><code>defines</code></b>:  <node><node class="text"></node><code title="defines"><code title="defines"><bracket>(</bracket><b><code><b><code>defines</code></b></code></b><space> </space><b><code><b><code>Data</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(37, 104, 36);">Code</code><bracket>)</bracket></code></code><node class="text">: Gets the definition by <b><code>Data</code></b> of Code.</node>
<node class="text">It's <b><code>either</code></b> a <b><code>function</code></b> or <b><code>undefined</code></b>, and has to be applied or ignored respectively (_getOverrideResult) to get the actual overriden value.</node>
<node class="text"></node>
<node class="text">Array data gets its head consulted (once, not recursively). A <b><code>function</code></b> acts like a <b><code>concept</code></b> that defined </node><b><code><b><code><b><code>call</code></b></code></b></code></b><node class="text"> as that <b><code>function</code></b>. A JS object with a Map </node><code title="lookup"><code class="hasOperators" title="lookup"><b><code><b><code>defines</code></b></code></b><operator>.</operator><code class="label" title="label" style="color: rgb(100, 114, 170);">key</code></code></code><node class="text"> consults that <b><code>map</code></b> with Code as the key.</node></node></div></details><div><b><code>map</code></b>:  <node><node class="text"></node><code title="map"><code title="map"><bracket>(</bracket><b><code><b><code>map</code></b></code></b><table><tr><td><space> </space><code class="label" title="label" style="color: rgb(127, 149, 108);">Key</code></td><td><space> </space><code class="label" title="label" style="color: rgb(5, 230, 137);">Value</code></td></tr><tr><td><space> </space><code class="label" title="label" style="color: rgb(127, 149, 108);">Key</code></td><td><space> </space><code class="label" title="label" style="color: rgb(5, 230, 137);">Value</code></td></tr></table><space> </space><code class="hasOperators" title="rest"><operator>…</operator><code class="label" title="label" style="color: rgb(143, 59, 183);">Rest</code></code><bracket>)</bracket></code><table></table></code><node class="text">: a key-value store.</node>
<node class="text">The <b><code>array</code></b>-representation of a JS Map.</node>
<node class="text">Read keys with </node><b><code><b><code><b><code>lookup</code></b></code></b></code></b><node class="text">.</node></node></div><div><b><code>typed</code></b>:  <node><node class="text"></node><code title="typed"><code class="hasOperators" title="typed"><code class="label" title="label" style="color: rgb(5, 230, 137);">Value</code><operator>::</operator><code class="label" title="label" style="color: rgb(117, 110, 96);">Type</code></code></code><node class="text"> or </node><code title="typed"><code title="typed"><bracket>(</bracket><b><code><b><code>typed</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(5, 230, 137);">Value</code><space> </space><code class="label" title="label" style="color: rgb(117, 110, 96);">Type</code><bracket>)</bracket></code></code><node class="text">: specifies that the value definitely fits the type.</node>
<node class="text">Since we currently <b><code>inline</code></b> everything, specifying types of <b><code>function</code></b> args allows to see <b><code>either</code></b> the final type of body or the <b><code>error</code></b>.</node></node></div></details><details><summary><b><code>UI</code></b>:  <node><node class="text">A namespace for user interface functionality.</node></node></summary><div><b><code>button</code></b>:  <node><node class="text"></node><code title="button"><code title="button"><bracket>(</bracket><b><code><b><code>button</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(175, 69, 140);">OnClick</code><bracket>)</bracket></code></code><node class="text">: Returns a <b><code>button</code></b> that calls a <b><code>function</code></b>(s) on click (with no arguments). Overridable.</node></node></div><details><summary><b><code>contextMenu</code></b>:  <node><node class="text">Creates and displays a &lt;context-menu&gt; element near the specified element.</node></node></summary><div><b><code>replaceRangeWithLinkTo</code></b>:  <node><node class="text">Replaces a Range (obtained from the current selection) with a link to the <b><code>elem</code></b>.</node>
<node class="text">A language can define this with a function that <node>takes the element and value to <node>link to</node></node> and <node>returns an element to insert</node>.</node>
<node class="text">Remember to <b><code>quote</code></b> the link unless you want to evaluate the insides.</node></node></div><div><b><code>permissionsElem</code></b>:  <node><node class="text">Build a namespace hierarchy of globals that </node><code class="label" title="label" style="color: rgb(15, 100, 131);"><code class="label" title="label" style="color: rgb(15, 100, 131);">expr</code></code><node class="text"> is <b><code>bound</code></b> to.</node></node></div><div><b><code>stringToDoc</code></b>:  <node><node class="text">Parse text in </node>...<node class="text"> to <b><code>style</code></b> it as <b><code>fancy</code></b>, and treat other strings as </node><b><code><b><code><b><code>structuredSentence</code></b></code></b></code></b><node class="text">s.</node></node></div><div><b><code>elemToWindow</code></b>:  <node><node class="text">Wraps an element in &lt;<b><code>div</code></b>.window&gt;.</node></node></div><div><b><code>elemExpandAll</code></b>:  <node><node class="text">Clicks all &lt;collapsed&gt; elements in the element.</node></node></div><div><b><code>allowDragging</code></b>:  <node><node class="text">Allows dragging the element around with a pointer. Only <b><code>call</code></b> on absolutely-positioned elements with .style.left and .style.top.</node></node></div><div><b><code>describe</code></b>:  <node><node class="text">Creates an element that describes a value.</node></node></div></details><div><b><code>url</code></b>:  <node><node class="text">Creates a URL element.</node></node></div><div><b><code>evaluator</code></b>:  <node><node class="text"></node><code title="elem"><code title="elem"><bracket>(</bracket><b><code><b><code>elem</code></b></code></b><space> </space><b><code><b><code>evaluator</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(148, 31, 205);">Expr</code><space> </space><code class="label" title="label" style="color: rgb(82, 196, 107);">Language</code><bracket>)</bracket></code></code><node class="text">: When logged to DOM, this displays the expression, its </node><b><code><b><code><b><code>log</code></b></code></b></code></b><node class="text">s along the way, and its one evaluation result in one removable (by clicking on the prompt) DOM element.</node></node></div><div><b><code>REPL</code></b>:  <node><node class="text"></node><code title="elem"><code title="elem"><bracket>(</bracket><b><code><b><code>elem</code></b></code></b><space> </space><b><code><b><code>REPL</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(82, 196, 107);">Language</code><bracket>)</bracket></code></code><node class="text">: Creates a visual <b><code>REPL</code></b> instance (read-evaluate-print loop).</node></node></div><div><b><code>log</code></b>:  <node><node class="text"></node><code title="log"><code title="log"><bracket>(</bracket><b><code><b><code>log</code></b></code></b><space> </space><code class="hasOperators" title="rest"><operator>…</operator><code class="label" title="label" style="color: rgb(94, 158, 90);">Values</code></code><bracket>)</bracket></code></code><node class="text">: For debugging; logs to the current DOM node or console.</node></node></div><details><summary><b><code>elem</code></b>:  <node><node class="text"></node><code title="elem"><code title="elem"><bracket>(</bracket><b><code><b><code>elem</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(49, 150, 185);">TagName</code><space> </space><code class="label" title="label" style="color: rgb(93, 65, 48);">Content</code><space> </space><code class="label" title="label" style="color: rgb(151, 38, 195);">Style</code><bracket>)</bracket></code></code><node class="text">: creates an HTML DOM element.</node></node></summary><div><b><code>elemCollapse</code></b>:  <node><node class="text">Collapses an element (or a range of elements) in-place. Click to expand again. Pass in a <b><code>function</code></b> to create the element only <b><code>if</code></b> needed. Pass in <b><code>null</code></b> as </node><code class="label" title="label" style="color: rgb(153, 46, 146);"><code class="label" title="label" style="color: rgb(153, 46, 146);">end</code></code><node class="text"> to collapse all consequent siblings.</node></node></div><div><b><code>elemInsert</code></b>:  <node><node class="text">Inserts a DOM element into the displayed DOM tree smoothly (<b><code>if</code></b> CSS transitions are enabled for it, and are specified in seconds, with all-props being the <b><code>first</code></b> specified one), by transitioning height and opacity from <number>0</number>.</node>
<node class="text">Very bad performance <b><code>if</code></b> a lot of inserts happen at the same time, but as good as it can be for intermittent smooth single-element-tree insertions.</node></node></div><div><b><code>elemRemove</code></b>:  <node><node class="text">Removes a DOM element from the displayed document smoothly (<b><code>if</code></b> CSS transitions are enabled for it, and are specified in seconds, with all-props being the <b><code>first</code></b>), by transitioning height and opacity to <number>0</number>.</node></node></div><div><b><code>elemClone</code></b></div><div><b><code>elemValue</code></b>:  <node><node class="text">If el, remember that it is a viewer of v. If !el, return an <b><code>array</code></b> of all in-document viewers of v.</node></node></div></details><div><b><code>structured</code></b>:  <node><node class="text"></node><code title="structured"><code title="structured"><bracket>(</bracket><b><code><b><code>structured</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(111, 90, 123);">Arrays</code><bracket>)</bracket></code></code><node class="text">: shows deep structure of Arrays (consisting of acyclic arrays and strings and DOM elements): wraps each <b><code>sub</code></b>-<b><code>array</code></b> in </node>&lt;node&gt;<node class="text"> <b><code>if</code></b> we have DOM or pretty-prints it into a <b><code>string</code></b> <b><code>if</code></b> not.</node></node></div><div><b><code>structuredSentence</code></b></div></details><details class=""><summary><b class=""><code>Languages</code></b>:  <node><node class="text">A namespace for languages and their handling.</node></node></summary><details><summary><b><code>js</code></b>:  <node><node class="text">A namespace of everything pertaining to the host language, JavaScript.</node>
<node class="text">Somewhat usable in a <b><code>REPL</code></b>.</node></node></summary><div><b><code>instanceof</code></b>:  <node><node class="text">This exists only to highlight a thing in <b><code>js</code></b>.</node></node></div><div><b><code>continue</code></b>:  <node><node class="text">This exists only to highlight a thing in <b><code>js</code></b>.</node></node></div><div><b><code>break</code></b>:  <node><node class="text">This exists only to highlight a thing in <b><code>js</code></b>.</node></node></div><div><b><code>finally</code></b>:  <node><node class="text">This exists only to highlight a thing in <b><code>js</code></b>.</node></node></div><div><b><code>typeof</code></b>:  <node><node class="text">This exists only to highlight a thing in <b><code>js</code></b>.</node></node></div><div><b><code>return</code></b>:  <node><node class="text">This exists only to highlight a thing in <b><code>js</code></b>.</node></node></div><div><b><code>throw</code></b>:  <node><node class="text">This exists only to highlight a thing in <b><code>js</code></b>.</node></node></div><div><b><code>catch</code></b>:  <node><node class="text">This exists only to highlight a thing in <b><code>js</code></b>.</node></node></div><div><b><code>while</code></b>:  <node><node class="text">This exists only to highlight a thing in <b><code>js</code></b>.</node></node></div><div><b><code>void</code></b>:  <node><node class="text">This exists only to highlight a thing in <b><code>js</code></b>.</node></node></div><div><b><code>else</code></b>:  <node><node class="text">This exists only to highlight a thing in <b><code>js</code></b>.</node></node></div><div><b><code>for</code></b>:  <node><node class="text">This exists only to highlight a thing in <b><code>js</code></b>.</node></node></div><div><b><code>let</code></b>:  <node><node class="text">This exists only to highlight a thing in <b><code>js</code></b>.</node></node></div><div><b><code>new</code></b>:  <node><node class="text">This exists only to highlight a thing in <b><code>js</code></b>.</node></node></div><div><b><code>switch</code></b>:  <node><node class="text">This exists only to highlight a thing in <b><code>js</code></b>.</node></node></div><div><b><code>case</code></b>:  <node><node class="text">This exists only to highlight a thing in <b><code>js</code></b>.</node></node></div></details><div><b><code>style</code></b>:  <node><node class="text">An overridable function that turns <node><node>a <b><code>serialize</code></b>/<b><code>parse</code></b> node</node>, <node>its value</node>, and <node><b><code>unbound</code></b> representation</node></node> into a displayed node.</node></node></div><details><summary><b><code>serialize</code></b>:  <node><node class="text"></node><code title="serialize"><code title="serialize"><bracket>(</bracket><b><code><b><code>serialize</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(148, 31, 205);">Expr</code><bracket>)</bracket></code></code><node class="text"> or … or </node><code title="serialize"><code title="serialize"><bracket>(</bracket><b><code><b><code>serialize</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(148, 31, 205);">Expr</code><space> </space><code class="label" title="label" style="color: rgb(82, 196, 107);">Language</code><space> </space><code class="label" title="label" style="color: rgb(214, 52, 118);">Backctx</code><space> </space><code class="label" title="label" style="color: rgb(30, 115, 228);">Options</code><bracket>)</bracket></code></code><node class="text">: serializes Expr into a <b><code>string</code></b> or a DOM tree (that can be parsed to retrieve the original structure).</node></node></summary><div><b><code>nameResult</code></b>:  <node><node class="text"></node><code title="nameResult"><code title="nameResult"><bracket>(</bracket><b><code><b><code>nameResult</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(148, 31, 205);">Expr</code><bracket>)</bracket></code></code><node class="text">: provides a list of suggestions for naming Expr. Used in </node><b><code><b><code><b><code>serialize</code></b></code></b></code></b><node class="text"> for more human-readable graph serializations.</node></node></div></details><div><b><code>parse</code></b>:  <node><node class="text"></node><code title="parse"><code title="parse"><bracket>(</bracket><b><code><b><code>parse</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(19, 191, 5);">String</code><bracket>)</bracket></code></code><node class="text"> or … or </node><code title="parse"><code title="parse"><bracket>(</bracket><b><code><b><code>parse</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(19, 191, 5);">String</code><space> </space><code class="label" title="label" style="color: rgb(82, 196, 107);">Language</code><space> </space><code class="label" title="label" style="color: rgb(113, 2, 157);">Context</code><space> </space><code class="label" title="label" style="color: rgb(30, 115, 228);">Options</code><bracket>)</bracket></code></code><node class="text">: parses String into the graph represented by it, returning </node><code title=""><code title=""><bracket>(</bracket><code class="label" title="label" style="color: rgb(148, 31, 205);">Expr</code><space> </space><code class="label" title="label" style="color: rgb(179, 81, 75);">StyledDOM</code><bracket>)</bracket></code></code><node class="text">.</node></node></div><div><b><code>basic</code></b>:  <node><node class="text">A language for ordered-edge-list graphs.</node>
<node class="text"><b><code>label</code></b>, </node><b><code><b><code><b><code>label</code></b></code></b></code></b><node class="text">, <node><string>'string'</string></node>, <node><string>"string"</string></node>, <node>(<number>0</number> <number>1</number>)</node>, <node>(a:<number>2</number> a)</node>.</node>
<node class="text">This is a <node>more space-efficient than binary</node> representation for graphs of arrays.</node></node></div><div><b><code>fancy</code></b>:  <node><node class="text">A language for ordered-edge-list graphs (like </node><b><code><b><code><b><code>basic</code></b></code></b></code></b><node class="text">) with some syntactic conveniences.</node>
<node class="text"><b><code>label</code></b>, </node><b><code><b><code><b><code>label</code></b></code></b></code></b><node class="text">, <node><string>'string'</string></node>, <node><string>"string"</string></node>, <node>(<number>0</number> <number>1</number>)</node>, <node>(a:<number>2</number> a)</node>; <node><number>1</number>+<number>2</number></node>, <node>a→a*<number>2</number></node>.</node></node></div><div><b><code>fast</code></b>:  <node><node class="text">A </node><b><code><b><code><b><code>basic</code></b></code></b></code></b><node class="text">-like language that can be parsed and serialized <b><code>fast</code></b>.</node>
<node class="text">Intended to only be used for internal inter-<b><code>memory</code></b> communication (of generic <b><code>bound</code></b> graphs).</node>
<node class="text">Does not <b><code>merge</code></b> the parsed arrays.</node></node></div></details><details><summary><b><code>Garbage</code></b>:  <node><node class="text">It's a nice thought, but it doesn't play well with others.</node></node></summary><div><b><code>philosophy</code></b>:  <node><node class="text">Does that matter to you?</node></node></div><div><b><code>enumerableTypes</code></b>:  <node><node class="text">A namespace for when/forany/forall/only/any/all, none of which we have found a use for, so far.</node></node></div></details><details><summary><b><code>System</code></b>:  <node class=""><node class="text">A namespace for low-level functions that must not be called in user code, for safety.</node></node></summary><div><b><code>deconstruct</code></b>:  <node><node class="text"></node><code title="deconstruct"><code title="deconstruct"><bracket>(</bracket><b><code><b><code>deconstruct</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(120, 34, 230);">Object</code><bracket>)</bracket></code></code><node class="text">: turn an object into its <b><code>array</code></b>-representation (that could be evaluated to re-create that native value).</node></node></div><div><b><code>jsEval</code></b>:  <node><node class="text">Finishing </node><code title="jsEval"><code title="jsEval"><bracket>(</bracket><b><code><b><code>jsEval</code></b></code></b><space> </space><code class="label" title="label" style="color: rgb(15, 206, 112);">Source</code><space> </space><code class="label" title="label" style="color: rgb(9, 44, 158);">Ctx</code><bracket>)</bracket></code></code><node class="text">: evaluates (strict-mode) JS source code that can statically reference values of Ctx (a <b><code>map</code></b>) with JS-identifier keys.</node></node></div><details><summary><b><code>interrupt</code></b>:  <node><node class="text">Used to make functions re-entrant in a non-interruptible language, for better UX.</node>
<node class="text"></node>
<node class="text">Technical details:</node>
<node class="text"></node><code title="throw"><code title="throw"><b><code><b><code>throw</code></b></code></b><space> </space><b><code><b><code>interrupt</code></b></code></b></code></code><node class="text"> to <b><code>interrupt</code></b> execution.</node>
<node class="text">Create <b><code>function</code></b> state in </node><code class="label" title="label" style="color: rgb(154, 129, 101);"><code class="label" title="label" style="color: rgb(154, 129, 101);">f</code></code><node class="text"> like </node>let [i = 0, j = 0] = interrupt(f)<node class="text">, in particular for loops.</node>
<node class="text">Wrap <b><code>function</code></b> body in </node>try{…}catch(err){ if (err === interrupt) interrupt(f,2)(i,j);  throw err }<node class="text">: store <number>4</number> values in tmp at a time, up to the requested length (</node><code title="rest"><code class="hasOperators" title="rest"><operator>...</operator><code class="label" title="label" style="color: rgb(30, 178, 176);">args</code></code></code><node class="text"> in JS allocates, so this way tries to avoid that).</node></node></summary><div><b><code>noInterrupt</code></b>:  <node><node class="text">A marker that a <b><code>function</code></b> cannot <b><code>interrupt</code></b>, directly or indirectly.</node></node></div></details><details><summary><b><code>Rewrite</code></b>:  <node><node class="text">A namespace for rewriting Self's code to a different form.</node></node></summary><div><b><code>SelfToReadableJS</code></b>:  <node><node class="text">Converts <b><code>Self</code></b> to a human-readable form that pollutes the global <b><code>scope</code></b> on execution.</node></node></div><div><b><code>SelfToScopedJS</code></b>:  <node><node class="text">Converts <b><code>Self</code></b> to a form that has itself hidden in a <b><code>scope</code></b>.</node></node></div></details></details></details>
