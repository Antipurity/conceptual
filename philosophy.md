This document describes the design philosophy behind the Conceptual programming language, and why it exists the way it does.

# Concepts; purity

What is a thought, an idea, a concept? When is one remembered and re-discovered, and when is a new one created? If a mind is made only from thoughts, then they define the world and everything else, dynamically during life; is a mind then fundamentally about dynamic definition, about extensible thoughts put together?

*A thought is something that can be developed further.*

The concepts vaguely mentioned above may be nice to think about, but to attain the very essence of humanity and create an artificial intelligence (why *not* have that as an ultimate  goal?), one has to be much more precise, to the point of making formalization (artificial) and intuition (intelligence) the same; using concepts from programming, and creation of a new programming base (language), is a must. (Implementation is more important than a bunch of words though, even if it is the hardest.)

- **Purity**

Even the most basic concepts are constructed from others, like a circular puzzle.

Consider this: a thing (that has some structure â€” an object) that depends only on its own structure, pure of (without) any hidden information attached to its identity. This means that equal pure objects can and should be merged into one.

It is often seen in programming, though not in its pure form. Languages with pure functions, pure data structures, common subexpression merging in compilers. Traditionally it is always either all or nothing though; separating purity from everything (making it optional) allows for more power and expressivity.

Concepts are pure definitions. What has been thought of is remembered, including any runtime-collected (non-structural) information. Why remember what has never been thought of, and why not remember what *has*?

- **By definition**

To cut it short, concepts allow the new to re-define the old, data to re-define code. It is at once a new programming paradigm (requiring a language to try it out in), and a model of a mind (a proper base for AI).

Is this a PL project, or an AI project, or what? Things only get weirder from here.

# Design principles

What is a big and clunky thought, and what is a small and nimble thought? One can identify thoughts with extensibility points; then, the more extensible the better. Usually entrances into black boxes are made manually, but perfecting extensibility, making it automatic like the concept of concepts allows, makes thoughts most small and nimble, to better combine all in one super-dense place.

Without very specifically directed effort, such a conceptual singularity will not happen. And AI is almost incidental to that, such a small thing.

Truly, "*separate cleanly to combine easily*" is the only real design principle here; others are adopted more to develop particular concepts. In other words, "maximally expressible features" or "perfectionism".

There are some other valued principles here, like "of many variants of saying a thing or writing code, pick the *shortest*" and "*suffering makes for* a dozen times *faster* change and *development*" and "*understanding is formalization*", but they are not as essential as "separate cleanly to combine easily" (and arise from different concepts).

# Particular concepts

While they are language features here, quite a few of them do have rich philosophical implications, which were significant during developing their understandings.

[TODO, preferably when code reaches them.]
