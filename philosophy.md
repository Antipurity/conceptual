# Guiding principles

- Improve until perfection. Thoughts developed enough converge to the concepts behind them (by convergence, thoughts can be used to reach concepts, and concepts are the best way to reason about thoughts). In the conceptual realm, there are no quirks that prevent easy usage of a concept, and programs equal thoughts and concepts. A suitable place for the humanity's reproduction ritual.

  - It can always be better. Improve, do not simply strive towards an ideal (simply converge to a good). What we want is not fully known and implemented anyway.

  - Shortness. The more expressive the design, the simpler it is to use; the less conceptually artificial special cases, the shorter the using code is.

  - Expressivity before speed. Premature optimization is the root of all non-good; it is a collection of concepts, ought to be expressed in a proper framework properly — that framework comes first, and makes building optimization easy. "Speed"/"optimization" can be replaced with any concept.

  - Separate cleanly to combine easily. Stage-2 concepts may seem overly unusual, ambitious, and detached from the current way of doing things; but all that is necessary to fully allow not even knowing about any unused concept. Bugs and undefined behavior are to be eliminated entirely. Evolution (clear limits and arbitrary generation) can then be completely automatic.

  - Extensibility. Every sub-project is a base for a future, based on a past. This is the difference between some characters in a story having godlike powers because the world was artificially designed to allow them that, and everything being a natural part of the world, even gods. Many small things on a common base can be created (or learned) gradually, one-by-one; one huge thing is incomprehensible until learned. For understanding, this includes intuitive bases already present in a mind.

  - Formalization should exactly equal intuition; artificial *is* intelligence. Code, words, or the mind itself — all made to express the same truth; all targets for implementation.

- Noise before silence. Improvement does not regress, so *anything* is better than nothing. Moreover, the project can easily be cut short at any time, so better to annoy people with the incomplete than risk it never existing.

- Purity: the same is worthless. Be unique, or do not be.

  - One concept, one way of expressing it. Having several ways to define a function is no good; achieve shortness of interface with proper separation.

- Be self-aware. A base implementation is good, a meta-circular one is impressive, but both is immortal. Explain every part of yourself perfectly, and that *is* AI — you in a different medium.

PL base, leading to PL, leading to program editor; if programs are so good they can be called thoughts and concepts, is this not enough to learn then edit... mind and reality themselves? Not without a proper physical interface, like magical telekinesis or (nano-)machine construction.

Once split by a metallic barrier, concepts will act as one again.

The rest is uninteresting.

# The rest

This document describes the design philosophy behind the Conceptual programming language, and why it exists the way it does.

# Concepts; purity

What is a thought, an idea, a concept? When is one remembered and re-discovered, and when is a new one created? If a mind is made only from thoughts, then they define the world and everything else, dynamically during life; is a mind then fundamentally about dynamic definition, about extensible thoughts put together?

*A thought is something that can be developed further.*

The concepts vaguely mentioned above may be nice to think about, but to attain the very essence of humanity and create an artificial intelligence (why *not* have that as an ultimate  goal?), one has to be much more precise, to the point of making formalization (artificial) and intuition (intelligence) the same; using concepts from programming, and creation of a new programming base (language), is a must. (Implementation is more important than a bunch of words though, even if it is the hardest.)

- **Purity**

Even the most basic concepts are constructed from others, like a circular puzzle.

Consider this: a thing (that has some structure — an object) that depends only on its own structure, pure of (without) any hidden information attached to its identity. This means that equal pure objects can and should be merged into one.

It is often seen in programming, though not in its pure form. Languages with pure functions, pure data structures, common subexpression merging in compilers. Traditionally it is always either all or nothing though; separating purity from everything (making it optional) allows for more power and expressivity.

Concepts are pure definitions. What has been thought of is remembered, including any runtime-collected (non-structural) information. Why remember what has never been thought of, and why not remember what *has*?

- **By definition**

To cut it short, concepts allow the new to re-define the old, data to re-define code. It is at once a new programming paradigm (requiring a language to try it out in), and a model of a mind (a proper base for AI).
