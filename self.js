/* Code begins at the first `})({`, as methods that are bound to each other. _XXX methods are private and somewhat invisible. */
'use strict';
(function() {
const __version = '0'
const _ = (function is(name) {
  const obj = Object.create(is)
  return obj.is = name, obj
});
function __base(net) {
  const globals = typeof self !== ''+void 0 ? self : typeof global !== ''+void 0 ? global : window
  const env = new Map
  const object = new Map
  const constructed = new Map

  const defKey = Symbol('defines')

  // preload is for easier readAts. load is basically a copy of `bound` with a little notational convenience stuff thrown in.
  preload(net, globals)
  load(net, globals, true)
  Object.keys(net).forEach(k => k && +k === +k && delete net[k])
  Object.keys(net).forEach(k => net[k] = globals[k])
  if (net.interrupt) net.interrupt.noInterrupt = false

  postload()
  Initialize.call(globals, net, typeof __line != ''+void 0 ? __line.lines : undefined)
  env.clear(), object.clear(), constructed.clear()

  function objectFor(x) {
    // Load {call(){}} into a trivially-callable function, as a notational convenience.
    return x && typeof x.call == 'function' && x.call !== Function.prototype.call ? x.call : Object.create(null)
  }
  function preload(from, into) {
    // Pre-create objects/functions to be filled by `load`, so that arbitrary order of definitions is permitted.
    Object.keys(from).forEach(k => {
      if (k in into) try { delete into[k] } catch (err) {}
      if (from[k] instanceof Map) {
        if (into[k] === undefined) into[k] = new Map
        return
      } else if (from[k] && Object.getPrototypeOf(from[k]) === Object.prototype) {
        if (into[k] === undefined) into[k] = objectFor(from[k])
        if (typeof into[k] == 'function') into[k].displayName = k
        return
      } else if (Array.isArray(from[k])) {
        if (into[k] === undefined && +k !== +k) into[k] = new Array(from[k].length)
        return
      }
      if (into[k] !== from[k] && +k !== +k) into[k] = from[k]
    })
    if (from.defines) into.defines.key = defKey
    if (from.call && from._newExecutionEnv) into.call.env = from._newExecutionEnv()
    if (from.interrupt) into.interrupt.noInterrupt = true
  }
  function load(from, into, inLookup) {
    // Handle is(…) (as ref-to-global) and arrays and objects (as definitions) specially.

    // Cache to prevent cycles from referring to old not-loaded versions of objects.
    if (env.has(from)) return env.get(from)
    if (from && Object.getPrototypeOf(from) === _) {
      // Look up symbols in the network.
      if (!object.has(from.is)) {
        if (Array.isArray(from.is)) into = postload(from)
        else if (!(from.is in net)) throw new Error("Not a link to an existing thing: "+from.is)
        else into = load(net[from.is], globals[from.is])
        env.set(from, into), object.set(from.is, into)
      }
      return object.get(from.is)
    }
    if (from instanceof Map) {
      // Load keys and values.
      if (into === undefined) into = new Map
      env.set(from, into)
      from.forEach((v,k) => into.set(load(k), load(v)))
      return into
    } else if (from && Object.getPrototypeOf(from) === Object.prototype) {
      // Load object values: turn {…} into {[defines.key]:{…}}, as a notational convenience.
      if (into === undefined) into = objectFor(from)
      env.set(from, into)

      if (!inLookup) {
        let d
        for (let key of Object.keys(from)) {
          if (from[key] === defKey) { into[key] = from[key];  continue }
            // Since objectFor(…) is different for functions, we have to copy.
          const k = load(_(key))
          if (k !== call || typeof from[key] != 'function')
            (d || (d = Object.create(null)))[_id(k)] = load(from[key], undefined, k === readAt)
        }
        return d && (into[defKey] = into !== Self ? Object.freeze(d) : d), into
      } else {
        for (let k of Object.keys(from)) if (+k !== +k) {
          const loaded = load(from[k], into[k])
          if (loaded !== into[k]) into[k] = loaded
        }
        return into
      }
    }
    if (Array.isArray(from)) {
      // Look into arrays and load their elements.
      if (into === undefined) into = new Array(from.length)
      env.set(from, into)
      for (let i = 0; i < into.length; ++i) into[i] = load(from[i])
      return into
    }
    return from
  }
  function postload(from) {
    if (from !== undefined) {
      const x = from.is.map(x => load(x))
      const to = load(_('defines'))(load(from.is[0]), load(_('construct')))(x)
      constructed.set(to, from)
      env.set(from, to)
      return to
    } else
      constructed.forEach((from, obj) => construct(from.is.map(x => load(x)), obj)), constructed.clear()
  }
}
__base({

  Initialize:{
    docs:`The program's entry point.`,
    readAt:{
      Browser:_(`Browser`),
      NodeJS:_(`NodeJS`),
      WebWorker:_(`WebWorker`),
    },
    nameResult:[
      `The nightmare reborn`,
    ],
    call(net, lines, into) {
      if (!net || 'ctx' in Self) throw "Do not call Initialize manually."
      if ('→'.charCodeAt() !== 8594) throw "Unicode data got garbled."
      if (defines(call, docs).indexOf('\n ') >= 0) throw "Depth got added to strings."

      net[undefined] = undefined, Initialize.lines = lines

      // Turn `net` into maps.
      let ctx = new Map
      Object.keys(net).forEach(k => ctx.set(k, net[k]))
      ctx.set('_globalScope', net)
      Self.ctx = ctx
      Self[defines.key][_id(readAt)] = net, Object.freeze(Self[defines.key])

      // Initialize every global that defines `Initialize`.
      for (let k in net)
        if (!isArray(net[k]) && typeof defines(net[k], Initialize) == 'function')
          defines(net[k], Initialize)(net)

      // Set the TensorFlowJS backend if we can.
      function setBackend() { if (typeof tf != ''+void 0) return tf.setBackend(_numericCPU[1] ? 'cpu' : 'webgl'), true }
      observe(_numericCPU, setBackend)
      let tfjsid = setInterval(() => setBackend() && (clearInterval(tfjsid), tfjsid = null), 300)

      // Run unit-tests if requested.
      if (_setting(_runUnitTests)) {
        function tryTesting() {
          if (typeof tf != ''+void 0)
            return tf.ready().then(() => {
              const prevCallEnv = call.env
              try { _test(call.env = _newExecutionEnv(null, Self.into && Self.into.firstChild || null, fancier, Self.ctx)) }
              finally { call.env = prevCallEnv }
            }), true
        }
        let tfjsid = setInterval(() => tryTesting() && (clearInterval(tfjsid), tfjsid = null), 300)
      }

      // Select the appropriate JS-environment-specific entry point.
      let ok = false
      if (this.self && !this.window)
        WebWorker(), ok = true
      else {
        if (this.process)
          NodeJS(), ok = true
        if (this.document)
          Browser(into), ok = true
      }
      if (!ok)
        throw "What is this JS environment? Submit a bug report so that we know of it."
    },
  },

  Execution:{
    docs:`Execution-related functionality.`,
    readAt:{
      Time:_(`Time`),
      Numeric:_(`Numeric`),
      Data:_(`Data`),
      limit:_(`limit`),
      interpreter:_(`interpreter`),
    },
  },

  Documentation:{
    docs:`Documentation-related functions.`,
    readAt:{
      tutorial:_(`tutorial`),
      docs:_(`docs`),
      referencedBy:_(`referencedBy`),
      referencesTo:_(`referencesTo`),
      definersOf:_(`definersOf`),
      sizeof:_(`sizeof`),
      examples:_(`examples`),
      todo:_(`todo`),
      philosophy:_(`philosophy`),
    },
  },

  Numeric:{
    docs:`A namespace for some very primitive numeric-computation-related functionality.`,
    readAt:{
      _numericCPU:_(`_numericCPU`),
      ArrayOps:_(`ArrayOps`),
      ReshapingOps:_(`ReshapingOps`),
      NumInit:_(`NumInit`),
      Arithmetic:_(`Arithmetic`),
      Random:_(`Random`),
      NumTypes:_(`NumTypes`),
      Neural:_(`Neural`),
    },
  },

  _numericCPU:[
    _(`settings`),
    false,
    `Whether the TensorFlowJS backend uses the 'cpu' (checked) or 'webgl' (unchecked) backend.
If CPU is faster at massively-parallel big numeric computations, then times are grim indeed.`,
  ],

  NumInit:{
    docs:`A namespace for numeric initialization.`,
    readAt:{
      zeros:_(`zeros`),
      identity:_(`identity`),
      ones:_(`ones`),
      randomVar:_(`randomVar`),
      randomVarData:_(`randomVarData`),
      varData:_(`varData`),
    },
  },

  Arithmetic:{
    examples:[
      `Loss goes down.`,
      [
        `repeat ^randomVar(ones)+randomVar(ones)=5 100`,
      ],
      [
        `repeat ^randomVar(ones)*randomVar(ones)=5 100`,
      ],
      [
        `repeat ^randomVar(ones)-randomVar(ones)=5 100`,
      ],
      [
        `repeat ^randomVar(ones)/randomVar(ones)=5 100`,
      ],
      [
        `repeat ^randomVar(ones)**randomVar(ones)=5 1000`,
      ],
      [
        `repeat ^sqrt(randomVar(ones))=5 1000`,
      ],
      [
        `repeat ^exp(randomVar(ones))=5 100`,
      ],
      [
        `repeat ^expm1(randomVar(ones))=5 100`,
      ],
      [
        `repeat ^log(randomVar(ones))=5 1000`,
      ],
      [
        `repeat ^sin(randomVar(ones))=.5 1000`,
      ],
      [
        `repeat ^softsign(randomVar(ones))=.5 1000`,
      ],
    ],
    docs:`This is where we shamelessly copy over the functions of TensorFlowJS that we need.`,
    readAt:{
      assertFinite:_(`assertFinite`),
      less:_(`less`),
      equals:_(`equals`),
      where:_(`where`),
      add:_(`add`),
      sub:_(`sub`),
      mul:_(`mul`),
      div:_(`div`),
      pow:_(`pow`),
      sqrt:_(`sqrt`),
      exp:_(`exp`),
      expm1:_(`expm1`),
      log:_(`log`),
      sin:_(`sin`),
      cos:_(`cos`),
      sum:_(`sum`),
      mean:_(`mean`),
      max:_(`max`),
      abs:_(`abs`),
      floor:_(`floor`),
      sign:_(`sign`),
      softsign:_(`softsign`),
      clip:_(`clip`),
      isNaN:_(`isNaN`),
      argmax:_(`argmax`),
      oneHot:_(`oneHot`),
      matMul:_(`matMul`),
    },
  },

  assertFinite:{
    docs:`For debugging.`,
    argCount:1,
    keep:1,
    dispose:1,
    interrupt:false,
    call(x) {
      if (_isDisposable(x)) {
        const data = x.dataSync()
        for (let i = 0; i < data.length; ++i)
          if (data[i] !== data[i] || !isFinite(data[i]))
            errorStack("Got", data[i], "from", x)
      }
      return x
    },
    mergeAdjustment:_(`_mergeTensors`),
    adjust:[
      _(`array`),
      _(`_dout`),
    ],
  },

  _isNum(x) { return typeof x == 'number' },

  _num(x) {
    if (!isArray(x) && isArray(defines(x, deconstruct)) && defines(x, deconstruct)[0] === stateCell)
      x = defines(x, deconstruct)[1] // Look into state-cells, without needing to `accessState`.
    if (_isDisposable(x) && x.isDisposedInternal) error("Tensor already disposed:", x, "made at", _tensorOrigins(x))
    if (typeof x != 'number' && !_isDisposable(x) && (!_isNumericArray(x) || !x.every(_isNum))) error("Neither number nor tensor:", x)
    return x
  },

  less:{
    use:true,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
      [
        _(`boolsType`),
        [
          _(`rest`),
          `Sizes`,
        ],
      ],
    ],
    docs:`a<b for each value.`,
    argCount:2,
    dispose:true,
    interrupt:false,
    call(a,b) { return a=_num(a), b=_num(b), _isNum(a) && _isNum(b) ? a<b : _tf(tf.less(a,b)) },
  },

  equals:{
    use:true,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
      [
        _(`boolsType`),
        [
          _(`rest`),
          `Sizes`,
        ],
      ],
    ],
    docs:`a==b for each value. Like \`equal\` but broadcasted on \`tensor\`s.`,
    argCount:2,
    dispose:true,
    interrupt:false,
    call(a,b) { return a=_num(a), b=_num(b), typeof a == 'number' && typeof b == 'number' ? a===b : _tf(tf.equal(a,b)) },
  },

  where:{
    use:true,
    type:[
      _(`funcType`),
      [
        _(`boolsType`),
        [
          _(`rest`),
          `Sizes`,
        ],
      ],
      _(5696),
      _(5696),
      _(5696),
    ],
    readAt:{
      values:_(`_whereValues`),
    },
    docs:`a?b:c for each value.`,
    argCount:3,
    dispose:true,
    interrupt:false,
    call(a,b,c) {
      if (typeof a == 'boolean') return a?b:c // `_whereValues`
      a=_num(a), b=_num(b), c=_num(c)
      // Since `tf.where` doesn't broadcast numbers, we must do it ourselves. (A one-liner otherwise.)
      //   (Wouldn't have been a problem with manual compilation for GPU…)
      const shape = a && a.size > 1 ? a.shape : b && b.size > 1 ? b.shape : c && c.size > 1 ? c.shape : a.shape
      let db=false, dc=false
      try {
        if (typeof b == 'number' || b.size === 1) b = _tf(tf.broadcastTo(b, shape)), db=true
        if (typeof c == 'number' || c.size === 1) c = _tf(tf.broadcastTo(c, shape)), dc=true
        return _tf(tf.where(a,b,c))
      } finally { db && dispose(b), dc && dispose(c) }
    },
    adjust:[
      _(`array`),
      0,
      [
        _(`where`),
        _(`_inA`),
        _(`_dout`),
        0,
      ],
      [
        _(`where`),
        _(`_inA`),
        0,
        _(`_dout`),
      ],
    ],
    mergeAdjustment:[
      undefined,
      _(`_mergeTensors`),
      _(`_mergeTensors`),
    ],
  },

  _whereValues:_([
    _(`concept`),
    _(`call`),
    _(`where`),
    _(`type`),
    [
      _(`funcType`),
      [
        _(`boolsType`),
        1,
      ],
      `Type`,
      `Type`,
      `Type`,
    ],
    _(`docs`),
    `A differently-\`type\`d \`where\`.`,
  ]),

  NumTypes:{
    docs:`A namespace for common numeric types.`,
    readAt:{
      i8:_(`i8`),
      i16:_(`i16`),
      i32:_(`i32`),
      u8:_(`u8`),
      u16:_(`u16`),
      u32:_(`u32`),
      f32:_(`f32`),
      f64:_(`f64`),
    },
  },

  i8:{
    docs:`\`(i8 array(…Numbers))\`: \`make\`s a flat array of signed 8-bit integers.`,
    argCount:1,
    construct(x, obj) { if (obj === undefined) return typeof x[1] != 'string' ? new Int8Array(x[1]) : _fromBase64(x[1], 'int8') },
  },

  i16:{
    docs:`\`(i16 array(…Numbers))\`: \`make\`s a flat array of signed 16-bit integers.`,
    argCount:1,
    construct(x, obj) { if (obj === undefined) return typeof x[1] != 'string' ? new Int16Array(x[1]) : _fromBase64(x[1], 'int16') },
  },

  i32:{
    docs:`\`(i32 array(…Numbers))\`: \`make\`s a flat array of signed 32-bit integers.`,
    argCount:1,
    construct(x, obj) { if (obj === undefined) return typeof x[1] != 'string' ? new Int32Array(x[1]) : _fromBase64(x[1], 'int32') },
  },

  u8:{
    docs:`\`(u8 array(…Numbers))\`: \`make\`s a flat array of unsigned 8-bit integers.`,
    argCount:1,
    construct(x, obj) { if (obj === undefined) return typeof x[1] != 'string' ? new Uint8Array(x[1]) : _fromBase64(x[1], 'uint8') },
  },

  u16:{
    docs:`\`(u16 array(…Numbers))\`: \`make\`s a flat array of unsigned 16-bit integers.`,
    argCount:1,
    construct(x, obj) { if (obj === undefined) return typeof x[1] != 'string' ? new Uint16Array(x[1]) : _fromBase64(x[1], 'uint16') },
  },

  u32:{
    docs:`\`(u32 array(…Numbers))\`: \`make\`s a flat array of unsigned 32-bit integers.`,
    argCount:1,
    construct(x, obj) { if (obj === undefined) return typeof x[1] != 'string' ? new Uint32Array(x[1]) : _fromBase64(x[1], 'uint32') },
  },

  f32:{
    docs:`\`(f32 array(…Numbers))\`: \`make\`s a flat array of 32-bit floats.`,
    argCount:1,
    construct(x, obj) { if (obj === undefined) return typeof x[1] != 'string' ? new Float32Array(x[1]) : _fromBase64(x[1], 'float32') },
  },

  f64:{
    docs:`\`(f64 array(…Numbers))\`: \`make\`s a flat array of 64-bit floats.`,
    argCount:1,
    construct(x, obj) { if (obj === undefined) return typeof x[1] != 'string' ? new Float64Array(x[1]) : _fromBase64(x[1], 'float64') },
  },

  Data:{
    docs:`A namespace for some data-representation-related functions.`,
    readAt:{
      _mergeIfDefined:_(`_mergeIfDefined`),
      Constructions:_(`Constructions`),
      array:_(`array`),
      stateCell:_(`stateCell`),
    },
  },

  _mergeIfDefined:[
    _(`settings`),
    false,
    `Whether \`bound\` will create \`merged\` DAGs if array heads define \`merged\` to be \`true\`.
(This can conflict with cycles, creating afterimages, so \`a a:1+a\` would be parsed as \`1+a a:1+a\`.)`,
  ],

  Time:{
    docs:`A namespace for some time-related functionality.`,
    readAt:{
      userTime:_(`userTime`),
      realTime:_(`realTime`),
      await:_(`await`),
    },
  },

  UI:{
    docs:`A namespace for user interface functionality.`,
    philosophy:`Even when switching languages and/or bindings makes some things look the same, being able to {highlight ref-equal objects}, and {view the basic default-bindings serialization}, and {link to actual values without going through text}, makes meaning a first-class citizen. This is impossible to achieve without first-class UI support, but with it, incomprehensible code can be easy to understand (replicate in a mind).
Keep names short and rely on the IDE. Route gradient not through the closest text representation, but through actual dependencies.`,
    readAt:{
      Languages:_(`Languages`),
      hierarchy:_(`hierarchy`),
      _useDarkTheme:_(`_useDarkTheme`),
      _disableSmoothTransitions:_(`_disableSmoothTransitions`),
      _noBoxStylingForPrograms:_(`_noBoxStylingForPrograms`),
      _crispHighlight:_(`_crispHighlight`),
      _hoverHighlightsDOMValues:_(`_hoverHighlightsDOMValues`),
      _maxHighlightedValues:_(`_maxHighlightedValues`),
      print:_(`print`),
      contextMenu:_(`contextMenu`),
      REPL:_(`REPL`),
      _highlightInterrupts:_(`_highlightInterrupts`),
      elem:_(`elem`),
    },
  },

  Languages:{
    docs:`A namespace for languages and their handling.
One of programming's most annoying debates is tabs vs spaces. With UI support, you can choose neither.`,
    philosophy:`Languages just define how the bound-graph structure gets parsed/serialized, not execution.
Decoupling form from meaning allows composition and trivial changing of forms.`,
    readAt:{
      serialize:_(`serialize`),
      fast:_(`fast`),
      basic:_(`basic`),
      fancy:_(`fancy`),
      fancier:_(`fancier`),
      stringLanguage:_(`stringLanguage`),
      js:_(`js`),
      _colorVariables:_(`_colorVariables`),
      _maxSerializedTensorSize:_(`_maxSerializedTensorSize`),
    },
  },

  repeat:{
    docs:`\`(repeat ^Expr)\`: loops forever when finished, interrupting as needed.
\`repeat Expr Times\`: repeats the computation many \`Times\`.
Results of evaluating DAG nodes are not preserved.`,
    dispose:true,
    call(expr, iterations) {
      // Example usage: `repeat ^(randomNat 10) 1000`
      if (iterations !== undefined && typeof iterations != 'number' && typeof iterations != 'function')
        error("iterations must be undefined or a number or a function, got", iterations)
      let [i = 0, v, disposed = false, prevV, into, timeTotal = 0, timePrint = 0] = interrupt(7)
      if (into === undefined)
        into = elemValue(elem('code'), [repeat, expr, iterations]), into.classList.add('code'), print(into)
      let done = 0
      const start = _timeSince()
      try {
        // Loop.
        while (true) {
          if (!disposed) dispose(v), disposed = true
          v = interpreter(callAdjust, expr)
          if (_isUnknown(v)) return elemRemove(into), _unknown([repeat, v[1], iterations], v)
          done = 2
          ++i, disposed = false
          if (iterations && (typeof iterations === 'number' ? i >= iterations : iterations(v,i))) return elemRemove(into), v
          _checkInterrupt(expr)
          done = 1
        }
      } catch (err) {
        // Print our last computed value.
        if (v !== prevV && timePrint < .05 * (timeTotal + _timeSince(start)))
          if (done === 2 || !_isDisposable(v) && done === 1 || err !== interrupt) {
            const end = _timeSince()
            const pre = _smoothHeightPre(into)
            _removeChildren(into)
            err === interrupt && into.append(serialize(v, _langAt(), _bindingsAt(), {...serialize.displayed, observe:false}))
            _smoothHeightPost(into, pre)
            prevV = v
            timePrint += _timeSince(end), call.env && (call.env[_id(userTime)] -= _timeSince(end))
          }
        if (err === interrupt) interrupt.stack.push(i, v, disposed, prevV, into, timeTotal + _timeSince(start), timePrint)
        else if (!disposed) dispose(v)
        throw err
      }
    },
  },

  Self:{
    docs:`Open programming environment with machine learning, to treat humans and programs equally.
A namespace for every function here. Project's GitHub page: {https://github.com/Antipurity/conceptual}`,
    philosophy:`What happens when you force a person to change.
Can't get away from it, love it so much.

I sacrificed myself to bring this to you.
So that no one has to sacrifice anything for transcendence.
In particular, so that AGI doesn't have to sacrifice humanity in order to transcend it, which, let's be real, definitely will happen if humanity is not transcendent enough.`,
    readAt:_(`undefined`),
  },

  argCount:{
    docs:`A marker for the number of args to a function.`,
  },

  userTime:{
    type:[
      _(`funcType`),
      _(`userTime`),
      _(`_numberType`),
    ],
    docs:`\`userTime()\`⇒\`TimeMark\` or \`userTime(TimeMark)\`⇒\`UserDuration\`: returns the time spent on this job as \`f64\` milliseconds, or the non-negative in-job time elapsed since the mark.

This does not include time spent on other jobs, but does include the time to interrupt/restore execution.`,
    readAt:{
      start:_(`_userTimeStart`),
    },
    interrupt:false,
    impure:true,
    call(mark) { return _userTimeSince(mark) },
  },

  _userTimeStart:_([
    _(`concept`),
    _(`call`),
    _(`userTime`),
    _(`type`),
    [
      _(`funcType`),
      _(`userTime`),
    ],
    _(`docs`),
    `A differently-\`type\`d version of \`userTime\`.`,
  ]),

  realTime:{
    type:[
      _(`funcType`),
      _(`realTime`),
      _(`_numberType`),
    ],
    docs:`\`realTime()\`⇒\`TimeMark\` or \`realTime(TimeMark)\`⇒\`RealDuration\`: returns the time since start as \`f64\` milliseconds, or the non-negative time elapsed since the mark.

This includes time spent on other jobs.`,
    readAt:{
      start:_(`_realTimeStart`),
    },
    interrupt:false,
    impure:true,
    call(mark) { return _timeSince(mark) },
  },

  _realTimeStart:_([
    _(`concept`),
    _(`call`),
    _(`realTime`),
    _(`type`),
    [
      _(`funcType`),
      _(`realTime`),
    ],
    _(`docs`),
    `A differently-\`type\`d version of \`realTime\`.`,
  ]),

  limit:{
    docs:`The namespace for limiting resources available to code.
Also: \`limit {'time' Milliseconds 'arrays' Count 'tensorMemory' Bytes} Func …Args\` to limit the resources available to \`Func\`.`,
    readAt:{
      time:_(`limitTime`),
      arrays:_(`limitArrays`),
      tensorMemory:_(`limitTensorMemory`),
    },
    dispose:true,
    adjustLater:true,
    mergeAdjustment:null,
    adjust:{
      call(ins, _, dout) {
        if (call.pure) throw impure
        let [failed] = interrupt(1)
        try {
          if (failed === undefined) {
            failed = adjustLoad(null)
            if (failed !== 'returned' && failed !== 'error') _inexactReversal(true, failed)
          }
          if (failed === 'error') return _allocArray(0)
          const [__, fn, ...args] = ins
          return adjust(fn, args, _, dout)
        } catch (err) { if (err === interrupt) interrupt.stack.push(failed);  throw err }
      },
      dispose:_(`_disposeEachAndDealloc`),
    },
    call(opts, fn, ...args) {
      if (typeof fn != 'function') error('Not a func:', fn)
      const [time, arrays, tensorMemory] = _destructure(opts, limit.opts || (limit.opts = ['time', 'arrays', 'tensorMemory']))
      let [endTime, endArrays, endTensorMemory, adjLen = adjustUndo()] = interrupt(4)
      if (time != null && endTime === undefined) endTime = _userTimeSince() + sync(_num(_setting(time)))
      if (arrays != null && endArrays === undefined) endArrays = array.count + sync(_num(_setting(arrays)))
      if (tensorMemory != null && endTensorMemory === undefined) endTensorMemory = tensorMemorySince() + sync(_num(_setting(tensorMemory)))
      const prevEndTime = limitTime.limit, prevEndArrays = limitArrays.limit, prevEndTensorMemory = limitTensorMemory.limit
      if (endTime !== undefined) limitTime.limit = limitTime.limit !== undefined ? Math.min(limitTime.limit, endTime) : endTime
      if (endArrays !== undefined) limitArrays.limit = limitArrays.limit !== undefined ? Math.min(limitArrays.limit, endArrays) : endArrays
      if (endTensorMemory !== undefined) limitTensorMemory.limit = limitTensorMemory.limit !== undefined ? Math.min(limitTensorMemory.limit, endTensorMemory) : endTensorMemory
      try { const ret = fn(...args);  adjustSave('returned');  return ret }
      catch (err) {
        if (err === interrupt) interrupt.stack.push(endTime, endArrays, endTensorMemory, adjLen)
        else // Cancel any possible adjustment, because it's too late for regrets.
          adjLen !== undefined && adjustUndo(adjLen), adjustSave('error')
        throw err
      } finally { limitTime.limit = prevEndTime, limitArrays.limit = prevEndArrays, limitTensorMemory.limit = prevEndTensorMemory }
    },
  },

  limitTime:{
    use:true,
    docs:`\`limitTime Duration Func …Args\`: returns \`Func(…Args)\` if its \`userTime\` never stretches past \`Duration\`, or throws \`limit\` otherwise (on the first \`_checkInterrupt\` that sees the violation).
\`Duration\` is in milliseconds.

What is an infinite loop?
    To you, it's an annoyance.
    To a simple program, it's lethal.
    With \`limitTime\`, it's just a failure.`,
    examples:[
      `Interrupts are not free, so experiment with this: \`\`settings ^_msBeforeInterrupt\`\``,
      [
        `limitTime 1000 repeat ^(1+2)`,
      ],
      [
        `limit {'time' 1000} repeat ^(1+2)`,
      ],
      [
        `limitTime 10*1000 repeat 5`,
      ],
      [
        `limitTime 100e3 repeat 2.718281828459045 10000`,
      ],
    ],
    type:[
      _(`funcType`),
      _(`_numberType`),
      [
        _(`funcType`),
        [
          _(`rest`),
          `Inputs`,
        ],
        `Output`,
      ],
      [
        _(`rest`),
        `Inputs`,
      ],
      `Output`,
    ],
    dispose:true,
    adjustLater:true,
    mergeAdjustment:null,
    adjust:{
      call(ins, _, dout) { return defines(limit, adjust)(ins, _, dout) },
      dispose:_(`_disposeEachAndDealloc`),
    },
    call(duration, fn, ...args) {
      if (!limitTime.o) limitTime.o = {time:null}
      limitTime.o.time = duration
      return limit(limitTime.o, fn, ...args)
      // .limit, .o
    },
  },

  limitArrays:{
    use:true,
    docs:`\`limitArrays Count Func …Args\`
An imperfect way to limit memory: returns \`Func(…Args)\`, or throws \`limit\` otherwise (in \`_allocArray\`).`,
    dispose:true,
    adjustLater:true,
    mergeAdjustment:null,
    adjust:{
      call(ins, _, dout) { return defines(limit, adjust)(ins, _, dout) },
      dispose:_(`_disposeEachAndDealloc`),
    },
    call(count, fn, ...args) {
      if (!limitArrays.o) limitArrays.o = {arrays:null}
      limitArrays.o.arrays = count
      return limit(limitArrays.o, fn, ...args)
      // .limit, .o
    },
  },

  limitTensorMemory:{
    use:true,
    docs:`\`limitTensorMemory Count Func …Args\`
An imperfect way to limit memory: returns \`Func(…Args)\`, or throws \`limit\` otherwise (in \`_allocArray\`).`,
    dispose:true,
    adjustLater:true,
    mergeAdjustment:null,
    adjust:{
      call(ins, _, dout) { return defines(limit, adjust)(ins, _, dout) },
      dispose:_(`_disposeEachAndDealloc`),
    },
    call(count, fn, ...args) {
      if (!limitTensorMemory.o) limitTensorMemory.o = {tensorMemory:null}
      limitTensorMemory.o.tensorMemory = count
      return limit(limitTensorMemory.o, fn, ...args)
      // .limit, .o
    },
  },

  _userTimeSince:{
    use:1,
    docs:`Like \`_timeSince\` but for \`userTime\`.`,
    interrupt:false,
    call(mark = 0) { return typeof mark == 'number' ? call.env[_id(userTime)] + _timeSince(call.env[_id(realTime)]) - mark : error('Bad mark:', mark) },
  },

  _timeSince:{
    use:1,
    docs:`\`_timeSince()\`⇒\`TimeMark\` or \`(_timeSince TimeMark)\`⇒\`RealDuration\`: returns the current time as f64 milliseconds, or the non-negative time elapsed since the mark.
Makes no attempt to correct for the time to measure, \`(_timeSince _timeSince())\`.
Browsers reduce the precision of this to prevent timing attacks. Putting that precision back could be beneficial, somewhere in their hidden options.`,
    interrupt:false,
    call(mark = 0) {
      if (typeof performance != ''+void 0 && performance.now) { // Browser
        if (typeof mark != 'number') error('Bad mark:', mark)
        return performance.now() - mark
     } else if (typeof process != ''+void 0 && process.hrtime && process.hrtime.bigint) { // NodeJS
        if (!mark) return process.hrtime.bigint()
        return Math.max(0, Number(process.hrtime.bigint() - mark)/1e6)
      } else if (typeof require != ''+void 0) { // NodeJS
        if (!_timeSince.now) _timeSince.now = require('perf_hooks'), _timeSince.now = _timeSince.performance.now.bind(_timeSince.now)
        return _timeSince.now() - mark
      } else {
        // Ensure monotonicity with Date.now().
        if (typeof mark != 'number') error('Bad mark:', mark)
        if (_timeSince.prev == null) _timeSince.prev = Date.now(), _timeSince.add = 0
        const n = Date.now()
        if (_timeSince.prev > n) _timeSince.add += _timeSince.prev - n
        return (_timeSince.prev = n) + _timeSince.add - mark
      }
      // .prev, .add
    },
  },

  tensorMemorySince:{
    use:1,
    type:[
      _(`funcType`),
      _(`_numberType`),
    ],
    docs:`\`tensorMemorySince()\`⇒\`Mark\` or \`(tensorMemorySince Mark)\`: Measures required-memory-size change (allocated memory) as non-negative \`f64\` byte count.
In browsers, returns \`tensor\` memory.
Makes no attempt to correct for the memory-to-measure, \`(tensorMemorySince tensorMemorySince())\` (which is 0 in browsers).`,
    interrupt:false,
    impure:true,
    call(mark = 0) {
      if (typeof mark != 'number') error('Bad mark:', mark)
      if (typeof process != ''+void 0 && process.memoryUsage) {
        const m = process.memoryUsage()
        return Math.max(0, m.rss + m.heapUsed - m.heapTotal - mark)
      }
      return tf.engine().state.numBytes - mark
    },
  },

  arraysSince:{
    docs:`\`arraysSince()\`→\`Mark\` or \`arraysSince(Mark)\``,
    interrupt:false,
    impure:true,
    call(mark) { return typeof mark == 'number' ? array.count - mark : error('Bad mark:', mark) },
  },

  countReachableObjects:{
    impure:true,
    interrupt:true,
    call(from = Self, makeHierarchy = false) {
      const seen = new Set
      const backctx = _invertBindingContext(Self.ctx)
      let enterGlobal = backctx.has(from)
      if (from !== Self) walk(from)
      else if (!makeHierarchy) Self.ctx.forEach(g => (enterGlobal = true, walk(g)))
      else {
        let m = new Map, n = 0
        Self.ctx.forEach(g => (enterGlobal = true, walk(g), m.set(g, seen.size - n), n = seen.size))
        seen.clear()
        return hierarchy(m)
      }
      const sz = seen.size
      seen.clear()
      return sz

      function walk(x) {
        if (!x || typeof x != 'object' && typeof x != 'function') return
        if (backctx.has(x) && !enterGlobal) return
        else if (backctx.has(x)) enterGlobal = false
        if (seen.has(x)) return;  else seen.add(x)
        if (isArray(x)) return x.forEach(walk)
        if (x instanceof Set) return x.forEach(walk)
        if (x instanceof Map) return x.forEach((v,k) => { walk(k), walk(v) })
        if (x[defines.key]) for (let k in x[defines.key]) walk(x[defines.key][k])
        if (typeof document != ''+void 0 && x instanceof Node && (walk(x.to), true)) for (let ch = x.firstChild; ch; ch = ch.nextSibling) walk(ch)
        else try { for (let k in x) walk(x[k]) } catch (err) {}
      }
    },
  },

  isArray:{
    use:true,
    argCount:1,
    type:[
      _(`funcType`),
      `LiterallyAnything`,
      [
        _(`boolsType`),
        1,
      ],
    ],
    docs:`\`isArray X\`: whether \`X\` is an \`array\`.`,
    interrupt:false,
    call(a) { return Array.isArray(a) },
  },

  arrayLength:{
    use:true,
    argCount:1,
    type:[
      _(`funcType`),
      `IDontCare`,
      _(`_numberType`),
    ],
    interrupt:false,
    call(a) { return isArray(a) || _isNumericArray(a) ? a.length : error("Not an array:", a) },
  },

  arrayPush:{
    use:true,
    argCount:2,
    type:[
      _(`funcType`),
      `SomeArrayPlease`,
      `Some value, I don't care`,
      `ThenWeWillGiveYouNothing`,
    ],
    interrupt:false,
    call(a, value) { isArray(a) ? _changeArrayItem(a, a.length, value) : error("Not an array:", a) },
  },

  arrayLimit:{
    use:true,
    argCount:2,
    type:[
      _(`funcType`),
      `SomeArrayPlease`,
      `And please some maximum array size, like a 100`,
      `ThenWeWillGiveYouNothing`,
    ],
    interrupt:false,
    call(a, maxSize) {
      if (!isArray(a)) error("Not an array:", a)
      if (typeof maxSize != 'number' || maxSize !== maxSize>>>0) error("Not an index:", maxSize)
      if (a.length*2 <= maxSize) return
      const preserveFrom = a.length - (maxSize>>>1)
      let n = 0
      for (let i=0; i < a.length; ++i) a[n++] = a[i]
      a.length = n
      _rememberArrayItems(a)
      _observeChange(a)
    },
  },

  arraySlice:{
    use:true,
    argCount:3,
    type:[
      _(`funcType`),
      `SomeArrayPlease`,
      `And some index`,
      `And another index`,
      `Gives you a slice`,
    ],
    interrupt:false,
    call(a, begin, end) {
      if (!isArray(a) && typeof a != 'string') error("Not an array/string:", a)
      if (typeof begin != 'number' || begin !== begin>>>0) error("Not an index:", begin)
      if (typeof end != 'number' || end !== end>>>0) error("Not an index:", end)
      return a.slice(begin, end)
    },
  },

  arrayConcat:{
    interrupt:false,
    impure:true,
    call(a, b, ...rest) {
      if (!isArray(a) && typeof a != 'string') error('Not an array/string:', a)
      if (rest.length) return arrayConcat(a, arrayConcat(b, ...rest))
      if (!isArray(b) && typeof b != 'string') error('Not an array/string:', b)
      if (typeof a != typeof b) error('Type mismatch:', a, b)
      return isArray(a) ? [...a, ...b] : a+b
    },
  },

  arraySorted:{
    docs:`\`arraySorted(Array)\`: sorts an array of numbers into ascending order, and returns the sorted copy.
(Or, given a \`tensor\`, returns the array of its sorted values.)`,
    examples:[
      [
        `display 'hi' arraySorted(biasedGlorotNormal(50,50)@biasedGlorotNormal(50,50))`,
      ],
      `Ah. A good opportunity to inspect distributions of activations of neural network layers.

What should we expect those distributions to look like?

Is there a way to distinguish bad distributions (cannot learn) from good distributions (learns anything)?

And hey, did you hear of this paper: {https://www.youtube.com/watch?v=a6v92P0EbJc}/{https://arxiv.org/pdf/2006.04647.pdf}?
Since it finds a strong correlation between uncorrelated-ness of initial input gradients and final NN performance, it kind of suggests that NNs are best at enveloping problems, being initially as close to random and unbiased as possible.
(I mean, \`matMul\` already works hard to not assume anything and connect every output to every input (per-row), and you are just going to introduce bias with an ill-considered initialization? At least try to keep an open mind.)
(Or maybe that means that the best way to train NNs is to progressively train a hierarchy of progressively-bigger NNs which are all \`add\`ed up, twice as big each time. Open mind. Which does not mean not trying to make sense of that information.)

But what about inner-output distributions? Do we want a smooth line?

Say that we have a big neural network made from \`matMul\`s and \`softsign\`s (so, at every layer, output is in \`-1\`…\`1\`).
And it makes itself as big as it pleases, by being recurrent or recursive.

What is going to happen if we put no care into initialization and just put something like \`biasedGlorotNormal\` everywhere? No training.`,
      [
        `display 'ursmarts' arraySorted(f(f(f(f(f(f(biasedGlorotNormal(n)))))))) n:256 f:x->softsign(x@biasedGlorotNormal(n,n))`,
      ],
      `Biased to become \`0\`.

So if any layer receives gradient to become anything in particular (such as \`Layer@MoreWeights=15\`), gradient will be highly correlated, since all numbers have to shift in the same direction.

I mean, look at the gradient (see \`defines matMul adjust\`) of small vs bigger randomness when predicting \`3\`:`,
      [
        `display .05 arraySorted(_matMul truncatedNormal(^16(),0,.05) (truncatedNormal(^16(),0,.05)-3) true false)`,
      ],
      [
        `display .5 arraySorted(_matMul truncatedNormal(^16(),0,.5) (truncatedNormal(^16(),0,.5)-3) true false)`,
      ],
      `The small-variance one looks more correlated to me, even though the predicted \`3\` is still not in the output range.

If this was a paper, we would have needed to formulate and prove theorems about the exact formula for correlated-ness of these operations on random Gaussian variables, and how this correlated-ness back-propagates throughout the net. Luckily, these are just \`examples\`, so all we need is to not be obviously wrong.

Back to \`-1\`…\`1\`. On initialization, we would like all distributions to be in, say, \`-.9\`…\`.9\` (since gradients for \`softsign\` are probably too small elsewhere).

Just pick the correct variance. \`8/sqrt(n)\` for big \`n\`×\`n\` matrices works, experimentally (by isolating a layer and looking at its outputs and picking a good variance, then re-doing this for varying \`n\` and picking a formula that fits all).`,
      [
        `display '90%' arraySorted(f(f(f(f(f(f(truncatedNormal(^n(),0,.45)))))))) n:256 f:x->softsign(x@truncatedNormal(^(n n),0,8/sqrt(n)))`,
      ],
      [
        `display '80%' arraySorted(f(f(f(f(f(f(truncatedNormal(^n(),0,.4)))))))) n:256 f:x->softsign(x@truncatedNormal(^(n n),0,3.5/sqrt(n)))`,
      ],
      `Now, every layer is as open-minded as any other. Initially, I mean.

(Maybe it is possible to keep them open-minded, via some de-regularization loss that keeps activations near 0-mean and a good variance. Or via batch normalization, where each batch is explicitly normalized to 0-mean and a good variance. Or via sticky dropout: a random mask that sets some values to 0, and is updated relatively-rarely.)
    (This is similar to maintaining diversity for open-ended algorithms such as creature evolution on Irth, but numerically, for neural networks. Same purpose too: maintains adaptability.)

Now, the big question: do we want to actually demonstrate that these things learn better?
No.`,
    ],
    interrupt:false,
    argCount:1,
    call(a) {
      if (_isDisposable(a)) {
        const t = sync(a)
        if (typeof t == 'number') return [t]
        return Array.from(t).sort((x,y) => x-y)
      }
      if (!isArray(a)) error("Not an array:", a)
      return a.map(sync).sort((x,y) => x-y)
    },
  },

  arrayAscends:{
    use:true,
    argCount:1,
    type:[
      _(`funcType`),
      [
        _(`arrayType`),
        `T`,
        `L`,
      ],
      [
        _(`boolsType`),
        1,
      ],
    ],
    interrupt:false,
    call(a) {
      if (!isArray(a)) error("Not an array:", a)
      if (typeof a[0] != 'number') return false
      for (let i = 1; i < a.length; ++i)
        if (typeof a[i] != 'number' || a[i-1] > a[i]) return false
      return true
    },
  },

  arrayCons:{
    use:2,
    argCount:2,
    type:[
      _(`funcType`),
      `array head`,
      `plus the rest of the array (or hey, a string, I do not judge)`,
      `equals a concatenation (not at all efficient, but it works)`,
    ],
    interrupt:false,
    dispose:_(`_disposeEachAndDealloc`),
    call(a,b) { // [a, ...b]
      if (typeof b == 'string') {
        if (typeof a == 'number') {
          if (a > 0 && a === a>>>0) a = String.fromCodePoint(a)
          else error("Bad number:", a)
        }
        if (typeof a != 'string') error("Not a string:", a)
        return a+b
      }
      if (isArray(b)) return array(a, ...b)
      return array(a)
    },
  },

  arrayCar:{
    use:1,
    docs:`Returns array head, \`deconstruct\`ing if an object.`,
    interrupt:false,
    dispose:true,
    call(a) {
      if (isArray(a)) return keep(a[0]) // Return array heads.
      if (a instanceof WeakMap) return weakMap // Also deconstruct objects.
      if (_isDisposable(a)) return tensor
      if (a instanceof Map) return map
      const d = deconstruct(a)
      if (!isArray(d)) return a
      return keep(d[0])
    },
  },

  arrayCdr:{
    use:1,
    docs:`Returns array tail (everything but its head), \`deconstruct\`ing if an object.`,
    interrupt:false,
    dispose:_(`_killArray`),
    call(a) {
      if (!isArray(a)) a = deconstruct(a)
      if (!isArray(a)) return
      return a.length > 1 ? arraySlice(a, 1, a.length) : undefined
    },
  },

  _listen:{
    docs:`Registers a global event listener, or sets an interval if \`Type\` is a number (ms).`,
    readAt:{
      Deinitialize:_(`Deinitialize`),
      _cwt:[
        _(`_cwtOk`),
        _(`_cwtTutOk`),
        _(`_cwtStage1`),
        _(`_cwtStage2`),
        _(`_cwtStage3`),
        _(`_cwtStage4`),
        _(`_cwtStage5`),
      ],
    },
    call(Type, listener, opt) {
      if (!Deinitialize.events) Deinitialize.events = [], Deinitialize.intervals = []
      if (typeof Type == 'number') {
        const int = setInterval(listener, Type)
        if (int.unref) int.unref()
        return void Deinitialize.intervals.push(int)
      }
      (Self.into !== document.body ? Self.into : self).addEventListener(Type, listener, opt)
      Deinitialize.events.push(Type, listener, opt)
    },
  },

  Deinitialize:{
    docs:`The self-destruct switch. For pretending that we never existed.`,
    call() {
      if ('ctx' in Self) throw "Delete Self.ctx to confirm"
      // Else execute order 66.
      Deinitialize.intervals.forEach(clearInterval)
      const e = Deinitialize.events
      for (let i = 0; i < e.length; i += 3)
        (Self.into !== document.body ? Self.into : self).removeEventListener(e[i], e[i+1], e[i+2])
      _jobs.expr.length = 0
      Self.into.remove()
    },
  },

  _useDarkTheme:[
    _(`settings`),
    false,
    `Whether to use dark theme (or light).

Gaze upon the ever-shifting radiance of creation.
Or let go of all you know, to embrace vacuous might.
Just don't short-sightedly lock yourself into one consequence.
Yes.`,
  ],

  _disableSmoothTransitions:[
    _(`settings`),
    false,
    `Whether to disable smooth transitions.`,
  ],

  _noBoxStylingForPrograms:[
    _(`settings`),
    false,
    `Whether to disable box styling, and make all program text use inline styling.
Try creating an array of multi-line strings to see the difference.`,
  ],

  _crispHighlight:[
    _(`settings`),
    false,
    `Check to make hovering change background for equal values, or else use box shadows.
Probably necessary if \`_noBoxStylingForPrograms\` is checked.`,
  ],

  Browser:{
    docs:`A REPL interface.
Supported browsers: modern Chrome/Chromium and Firefox.`,
    readAt:{
      icon:_(`BrowserIconURL`),
    },
    js:[
      `https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.0/dist/tf.min.js`,
      `https://d3js.org/d3.v6.min.js`,
    ],
    style:`.into * {transition: all .2s ease-in, margin 0s, padding 0s; box-sizing: border-box; vertical-align:top; animation: fadein .2s; font-family: monospace, monospace; font-size:1rem}

@keyframes fadein { from {opacity:0} }

text { font-family:sans-serif !important }
summary>text, details>div>text { display:inline-block }

.into {
  background-color:var(--background);
  color:var(--main);
  caret-color:var(--main);
  --background:white;
  --highlight:royalblue;
  --main:black;
}
.into:not(body) { box-shadow:var(--highlight) 0 0 .1em .1em }
.into.dark {
  --background:rgb(15,15,15);
  --highlight:rgb(225, 110, 65);
  --main:white;
}
.into.noTransitions * { transition: none !important; animation: none !important }
.into>*:not(script) {display:table; white-space:pre-wrap}
.into.crispHighlight :not(collapsed).hover { box-shadow:none; background-color:rgba(128,128,128,.4) }
.into.crispHighlight :focus:not(summary):not(.window) { box-shadow:none; outline:.1em solid rgba(128,128,128,.5) }
.into.crispHighlight scroll-highlight { box-shadow:none; border-left:.3em solid rgba(128,128,128,.7) }
.into.noComplexity string, .into.noComplexity node, into.noComplexity.extracted { display:inline }

:focus:not(summary) {outline:none; box-shadow:var(--highlight) 0 0 .1em .1em}
input[type=range]::-moz-focus-outer { border:0 }
.hover {box-shadow:var(--highlight) 0 0 .1em .1em}
.working {box-shadow:var(--highlight) 0 0 .1em .1em inset}
bracket {color:var(--highlight)}
string {color:darkgreen; display:inline-block}
string>string { filter:brightness(150%) }
.into.dark string {color: limegreen}
number {color:var(--highlight)}
prompt {font-weight:bold; cursor:pointer}
known {font-weight:bold}
node {display:inline-block; font-family:monospace, monospace}
node.text { display:inline }
error {color:red; background-color:var(--background)}
extracted {display:inline-block}
extracted.hover { background-color:var(--background); position:sticky; top:.3em; bottom:.3em; z-index:10 }
.into:not(.noValueHighlight):not(.selecting) extracted:hover { background-color:var(--background); position:sticky; top:.3em; bottom:.3em }
.warning { color:darkred }

scroll-highlight { position:fixed; right:0; z-index:13; box-shadow:var(--highlight) 0 0 .2em .2em; will-change:transform }

waiting {
  display: inline-block;
  width: 1.5em;
  height: 1.5em;
  margin: 1.2em;
  border-radius: 50%;
  border: .2em solid var(--main);
  border-color: transparent var(--main) transparent var(--main);
  animation: rotate 2s cubic-bezier(.5,0,0,2.5) infinite !important;
}

.into:not(.noComplexity) .broken { padding-left:1em }
.into:not(.noComplexity) .broken>:not(extracted):not(operator) { display:table; max-width:100% }
.into:not(.noComplexity) .broken>operator:not(:first-child)::before { content:"\\A" }
.into:not(.noComplexity) .broken>bracket.funcCall::after { content:"\\A" }
.into:not(.noComplexity) .broken>bracket:first-child+operator::before { content:"" }
.into:not(.noComplexity) .broken.hasOperators>*:not(operator) { display:inline-block }
.into:not(.noComplexity) .broken>.funcCall { display:inline-block !important; margin-left:0 }
.into:not(.noComplexity) .broken>bracket.funcCall { display:inline !important }
.into:not(.noComplexity) .broken>bracket:not(.funcCall) {margin-left:-1em; display:block !important}
.into:not(.noComplexity) .broken>.funcCall:first-child {margin-left:-1em}
.code>:not(:first-child):not(table) {display:block}

node.code {display:table; font-family:monospace, monospace}
.editorContainer { display:table }
.editorContainer>:last-child[contenteditable] { min-height:1.2em; min-width: 1.2em; width:100%; display:table-cell }
.editorContainer.editable * { animation:none }
.editorContainer.editable { display:block }
.editorContainer.editable>:last-child[contenteditable] { min-height:1.2em; min-width: 1.2em; width:calc(100% - 2ch); display:inline-block }
.editorContainer.editable.hover>:last-child[contenteditable] { box-shadow:none }
prompt { width:2ch; color:red; float:left }
prompt::before { content:'▶' /* > ⊱ ▶ */ }
.editable>prompt::before { content:'⊱' }

edit-object>.editorContainer.editable { display:inline-block }

JobIndicator { width:14px; height:14px; margin:.2em; transition:none; background-color:var(--main); border-radius:50%; display:inline-block }
JobIndicator.yes { background-color:var(--highlight); animation: rotate 4s infinite linear, fadein .2s !important }
JobIndicator>div { width:4px; height:4px; margin:5px; position:absolute; background-color:var(--main); border-radius:50%; transform: rotate(var(--turns)) translate(10px); animation:none }
@keyframes rotate {
  0% { transform: rotate(-0.25turn) }
  100% { transform: rotate(0.75turn) }
}
JobIndicator.yes>.yes { background-color:var(--highlight) }

button { margin:.5em; padding:.5em; border-radius:.3em; border:1px solid var(--highlight); color:var(--highlight); font-size:inherit; min-width:2.4em; min-height:2.4em; background-color:rgba(128,128,128,.15) }
button:hover, a:hover, collapsed[content]:hover, prompt:hover { filter:brightness(130%) }
button:active, a:active, collapsed[content]:active, prompt:active { filter:brightness(60%) }
button::-moz-focus-inner { border:0 }

table {border-spacing:0}
table>* {border-spacing:0}
td {padding:0 0 0 1ch}
td>space { display:none }

particle {
  border-radius:50%;
  width:.1em; height:.1em;
  box-shadow:0 0 .3em .3em var(--highlight);
  position:absolute;
  animation: particle-disappears .5s forwards !important;
}
.into.crispHighlight particle { box-shadow:none; border:.3em solid rgba(128,128,128,.5) }
@keyframes particle-disappears {
  0% { opacity: 0; transform: translate(0px, 0px) }
  20% { opacity: 1 }
  100% { opacity: 0; transform: translate(var(--x), var(--y)) }
}

collapsed>hidden { display:none !important }
collapsed { color:var(--highlight); background-color:rgba(128,128,128,.15); margin:-1px; border:1px solid var(--highlight); border-radius:.2em; text-align:center; display:inline-block }
collapsed[content] { cursor:pointer }
collapsed::before { content:attr(content) }

.window { z-index:12; position:absolute; background-color:var(--background) !important; box-shadow:var(--highlight) 0 0 .1em .1em !important; transition:all .2s, left 0s, top 0s; padding:.5em; will-change:transform; font-family:monospace, monospace; border-radius:1em }
context-menu>node>input { border:none }
.window extracted.hover { position:static }

context-menu-buttons { display:block; margin:.5em }
context-menu-buttons>button { margin:0 }
context-menu-buttons>button:first-child { border-radius:.3em 0 0 .3em }
context-menu-buttons>button:not(:first-child):not(:last-child) { border-radius:0; border-left:none }
context-menu-buttons>button:last-child { border-radius:0 .3em .3em 0; border-left:none }

unimportant {opacity:.6}
textarea, div.resizable { transition:all .2s, width 0s, height 0s !important }
div.resizable { resize:both; overflow:hidden; display:block }
iframe { width:100%; height:100% }

.hasOperators>operator, .hasOperators { margin:0 .2em }
.hasOperators>.hasOperators>operator, .hasOperators>.hasOperators { margin:0 .1em }
.hasOperators>.hasOperators>.hasOperators>operator, .hasOperators>.hasOperators>.hasOperators { margin:0 }

hr { border-bottom:1px;  margin:0 }
details { padding: .1em; padding-left: 1em; display: table; overflow: hidden }
summary { margin-left: -1em }
details>:not(summary):not(hr) { display:block }
details>div>:not(:first-child) { max-width:75vw }
details>div { display:table-row }
details, details>div { border-left: 1px solid currentcolor; border-bottom: 1px solid rgba(128,128,128,.5) }
details>div>:first-child { padding-left:2ch }

time-report { display:table; font-size:.8em; color:gray; opacity:0; visibility:hidden }
.hover>div.code>time-report, div.code:hover>time-report { opacity:1; visibility:visible }
serialization>div.code { display:inline-table }

.removed { margin:0 }

separated-text { margin:1em; display:block }
separated-text>div>tutorial { margin:-1em; display:block }

separated-text serialization, text serialization { background-color:rgba(50%, 50%, 50%, 20%); border-radius:.2em; display:inline-block }
separated-text serialization serialization, text serialization serialization { background-color:none }
.nonArray>bracket { font-weight:bold }

svg text { font-family:monospace !important; font-size:medium !important }
svg, svg * { transition: none !important }

settings>label { visibility:hidden; opacity:0; z-index:20; padding:1ch; border-radius:.3em; position:absolute; pointer-events:none; width:100%; margin-top:1.2em; left:-100vw }
settings:hover>label { visibility:visible; opacity:1; background-color:rgba(90,150,210, .85); pointer-events:auto; left:0 }

separated-text>serialization, text>serialization, separated-text>serialization *, text>serialization * { animation:none !important }

inline-block { display:inline-block }
`,

    call(into = document.body) {
      Self.into = into
      serialize.displayed = serialize.dom
      const passive = {passive:true}, passiveCapture = {passive:true, capture:true}

      // Insert scripts.
      //   TensorFlowJS: though not all of it fits our needs, this is the best numeric-operations library I know of.
      //     Much easier than manually going through WebGL and/or WebGPU (which isn't supported on my machine), at least.
      //     (To replace it, we'd need a "consolidate refcount=1 subtrees and non-interdependent DAG slices into GPU programs" function.)
      //   D3.js: data-driven documents, for plots (`display`).
      //     Also causes the 'Some cookies are misusing the recommended "SameSite" attribute' warning.
      defines(Browser, js).forEach(src => {
        if (!document.querySelector(`script[src=${CSS.escape(src)}]`)) {
          const s = elem('script')
          s.onerror = evt => {
            // Fetch from local filesystem if the remote one isn't available.
            const s = elem('script')
            s.src = evt.target.src.match(/\/[^\/]*$/)[0].slice(1)
            evt.target.replaceWith(s)
          }
          s.src = src
          document.head.append(s)
        }
      })

      // If not inserting into a particular element, create a new close-able window for us.
      if (into === null) {
        Self.into = into = elem('div')
        const close = elem('button', '❌', 'Close')
        close.title = `Close`
        close.onclick = () => (delete Self.ctx, Deinitialize(), close.onclick = null)
        into.append(close)
        into.style.position = 'absolute'
        into.style.left = scrollX + innerWidth/2 + 'px'
        into.style.top = scrollY + innerHeight/2 + 'px'
        allowDragging(into)
        const doc = document.body
        const parent = doc.attachShadow ? doc.appendChild(document.createElement('div')).attachShadow({mode:'closed'}) : doc
        parent.appendChild(into)
      }
      into.classList.add('into')

      // React to changes in some settings.
      observe(_useDarkTheme, st => Self.into.classList.toggle('dark', st[1], true))(_useDarkTheme)
      observe(_disableSmoothTransitions, st => Self.into.classList.toggle('noTransitions', st[1], true))(_disableSmoothTransitions)
      observe(_noBoxStylingForPrograms, st => Self.into.classList.toggle('noComplexity', st[1], true))(_noBoxStylingForPrograms)
      observe(_crispHighlight, st => Self.into.classList.toggle('crispHighlight', st[1], true))(_crispHighlight)
      observe(_highlightInterrupts, st => !st[1] && Self.into.querySelectorAll('.working').forEach(el => el.classList.toggle('working', false, true)))(_highlightInterrupts)
      observe(_runInBackground, st => _jobsLater.ww = undefined)

      // Insert the style defined by code.
      const StyleElem = document.createElement('style')
      StyleElem.style.display = 'none'
      StyleElem.innerHTML = defines(Browser, style)
      into.append(StyleElem)

      // Create a REPL.
      if (!location.hash) {
        const lang = fancier, binds = new Map(Self.ctx)
        const env = call.env = _newExecutionEnv(null, null, lang, binds)
        const repl = call.env[_id(print)] = REPL(lang, binds)
        into.appendChild(repl)
        Self.into.querySelector('[contenteditable]').focus()
      }

      // If our URL has `#…` at the end, parse and evaluate that command.
      function evalHash(hash) {
        if (hash) elemInsert(into, evaluator(parse(decodeURI(location.hash.slice(1)))), into.firstChild)
      }
      evalHash(location.hash)
      _listen('hashchange', () => evalHash(location.hash))

      // Execute the relevant thing in `Commands` when a button is pressed when not editing.
      let commandElem = null
      function updateKeypressElem(evt) { commandElem = _closestNodeParent(evt.target || evt.explicitOriginalTarget) || commandElem }
      _listen('pointermove', updateKeypressElem, passiveCapture)
      _listen('pointerover', updateKeypressElem, passiveCapture)
      _listen('keydown', evt => {
        let key = evt.key
        if (['Control', 'Meta', 'Shift', 'Alt'].includes(key)) return
        if (evt.ctrlKey) key = 'Ctrl'+key
        if (evt.metaKey) key = 'Meta'+key
        if (evt.altKey) key = 'Alt'+key
        if (typeof Commands.get(key) == 'function' && !_isEditable(document.activeElement)) {
          const target = commandElem || document.activeElement !== document.body && document.activeElement || Self.into
          const range = getSelection().rangeCount && getSelection().getRangeAt(0)
          _doJob([Commands.get(key), target, range, evt], _newExecutionEnv(), el => commandElem = el || commandElem)
          evt.preventDefault()
        }
      })

      // Select the <node> under cursor on double-click.
      // Also make <details> open smoothly, and allow them to be closed by clicking.
      function getSummaryParent(el) { return el && (el.tagName === 'SUMMARY' ? el : getSummaryParent(el.parentNode)) }
      _listen('click', evt => {
        if (evt.ctrlKey || evt.shiftKey || evt.altKey || evt.metaKey) return (!evt.target || evt.target.tagName !== 'A') && evt.preventDefault()
        let t = evt.target || evt.explicitOriginalTarget
        const par = getSummaryParent(t)
        if (par) t = par
        if (t.tagName === 'DETAILS')
          return t.firstChild.click()
        if (t.tagName === 'SUMMARY' && evt.detail !== 3 && !_disableSmoothTransitions[1]) {
          const el = t.parentNode
          const pre = _smoothHeightPre(el)
          if (parseFloat(el.style.height) !== pre)
            el.style.height = pre + 'px'
          const smooth = () => (el.removeEventListener('toggle', smooth), _updateBroken(el), _smoothHeightPost(el, pre))
          el.addEventListener('toggle', smooth)
        }
        if (evt.detail !== 2) return
        const p = _closestNodeParent(t)
        p && getSelection().selectAllChildren(p)
        evt.preventDefault()
      })

      // Open a custom <context-menu> when a context menu is requested, or when a pointer is clicked-then-held down in place for 1 second.
      //   (If `contextmenu` is still dispatched on mobile, there might not be a use for this.)
      function openMenu(evt, range) {
        clearTimeout(contextMenuId), contextMenuId = startX = startY = undefined
        if (typeof Commands.get('AuxClick') == 'function')
          _runFunc(Commands.get('AuxClick'), _closestNodeParent(evt.target || evt.explicitOriginalTarget) || Self.into, range, evt), evt.preventDefault()
      }
      _listen('contextmenu', evt => {
        const range = getSelection().rangeCount && getSelection().getRangeAt(0)
        openMenu(evt, range)
      })
      let contextMenuId, startX, startY
      _listen('pointerdown', evt => {
        atCursor.lastEvt = evt
        const dx = evt.clientX - startX, dy = evt.clientY - startY
        if ((dx*dx + dy*dy) <= 25) {
          const range = getSelection().rangeCount && getSelection().getRangeAt(0)
          clearTimeout(contextMenuId), contextMenuId = setTimeout(openMenu, 1000, evt, range)
        } else
          startX = evt.clientX, startY = evt.clientY
      }, passiveCapture)
      function cancelContextMenu(evt) {
        if (evt.type === 'pointermove') atCursor.lastEvt = evt
        if (contextMenuId == null || startX === undefined) return
        const dx = evt.clientX - startX, dy = evt.clientY - startY
        if (evt.type === 'pointercancel' || evt.type === 'pointerup' || (dx*dx + dy*dy) > 25)
          clearTimeout(contextMenuId), contextMenuId = null, startX = startY = undefined
      }
      _listen('pointermove', cancelContextMenu, passiveCapture)
      _listen('pointerup', cancelContextMenu, passiveCapture)
      _listen('pointercancel', cancelContextMenu, passiveCapture)

      // Close not-containing-target <context-menu>s on a click elsewhere.
      const closeMenus = evt => {
        if (evt.ctrlKey || evt.shiftKey || evt.altKey || evt.metaKey) return
        const t = evt.target || evt.explicitOriginalTarget
        if (evt.type === 'focusin' && _isEditable(t) || !atCursor.opened) return
        const bad = atCursor.opened.filter(el => !el.contains(t))
        atCursor.opened = atCursor.opened.filter(el => el.contains(t))
        bad.forEach(elemRemove)
      }
      _listen('pointerdown', closeMenus, passive)
      _listen('focusin', closeMenus, passive)

      // Ensure that we still re-enter the interpreter loop after manually interrupting a script.
      _listen(2000, () => _jobs.running && _jobs())

      // On resize, update the "all-or-nothing" line-break-ingness of <node>s.
      let width = innerWidth
      _listen('resize', _throttled(() => width !== innerWidth ? _updateBroken(into) : (width = innerWidth), .1), passive)

      // If scrolled to near end, make sure that transitions preserve that scroll.
      // On transition end, remove .style.height (for _smoothHeightPost/elemInsert).
      let atEnd = false
      _listen('transitionstart', evt => {
        if (_disableSmoothTransitions[1]) return
        if (evt.propertyName !== 'height' || (evt.target || evt.explicitOriginalTarget).tagName === 'SCROLL-HIGHLIGHT') return
        if (evt.propertyName !== 'height' || Self.into !== document.body) return
        atEnd = atEnd || _updateMaxScrollBegin()
      }, passive)
      _listen('transitionend', evt => {
        if (_disableSmoothTransitions[1]) return
        const t = evt.target || evt.explicitOriginalTarget
        if (t.tagName === 'SCROLL-HIGHLIGHT') return
        if (evt.propertyName !== 'height' || Self.into !== document.body) return
        t.style.removeProperty('height'), _clearStyle(t)
        _updateMaxScrollEnd(atEnd), atEnd = false
      }, passive)

      // On .ctrlKey pointerdown on a value, insert a <collapsed> reference to it into selection if editable.
      _listen('pointerdown', evt => {
        if (!(evt.ctrlKey || evt.metaKey) || evt.shiftKey || evt.altKey) return
        const range = getSelection().rangeCount && getSelection().getRangeAt(0)
        if (typeof Commands.get('CtrlClick') == 'function') {
          const target = _closestNodeParent(evt.target || evt.explicitOriginalTarget) || Self.into
          if (!target || target.tagName !== 'A')
            _runFunc(Commands.get('CtrlClick'), target, range, evt), evt.preventDefault()
        }
      })

      // Ensure that selection cannot end up inside <collapsed>/<serialization> elements.
      _listen('selectionchange', () => {
        Self.into.classList.toggle('selecting', !getSelection().isCollapsed, true)
        if (!getSelection().rangeCount) return
        const r = getSelection().getRangeAt(0)
        let el = r.commonAncestorContainer
        if (!el) return
        try {
          if (el === _isEditable(el) && r.startContainer === r.endContainer) {
            if (r.startOffset === 0 && r.endOffset === el.childNodes.length && el.lastChild) {
              while (el.lastChild) el = el.lastChild
              r.setEndAfter(el)
            }
          }
          if (el.tagName === 'COLLAPSED')
            el.nextSibling ? r.setStartBefore(el.nextSibling) : r.setStartAfter(el),
            el.nextSibling ? r.setEndBefore(el.nextSibling) : r.setEndAfter(el)
          el = el.parentNode
          if (!el) return
          if (el.tagName === 'COLLAPSED')
            el.nextSibling ? r.setStartBefore(el.nextSibling) : r.setStartAfter(el),
            el.nextSibling ? r.setEndBefore(el.nextSibling) : r.setEndAfter(el)
        } catch (err) { console.error(err) }
      }, passiveCapture)

      // Highlight equal-id <node>s over selection or under cursor.
      function changeHoverTo(el) {
        const prev = changeHoverTo.prev
        const def = el && !isArray(el.to) && defines(el.to, _closestNodeParent)
        const New = el == null ? null : el instanceof Set ? el : el && def ? def(el) : new Set(elemValue(undefined, el.to))
        New instanceof Set && el instanceof Element && !el.classList.contains('groupedValue') && !New.has(el) && (elemValue(el, el.to), New.add(el))
        const needed = new Set
        let parentCandidate
        const parents = new Map;  for (let n = 0, p = el; p; ++n, p = p.parentNode) parents.set(p, n)
        function distanceInParents(el) { for (let n = 0, p = el; p; ++n, p = p.parentNode) if (parents.has(p)) return n + parents.get(p);  return Infinity }
        const prob = New && New.size > _maxHighlightedValues[1] && (1 - _maxHighlightedValues[1] / New.size) || 0
        const ignored = new Set
        New && New.forEach(el => {
          if (el.tagName === 'SERIALIZATION' || !el.classList) return
          if (prob && Math.random() < prob) return ignored.add(el)
          needed.add(el)
          el = el.parentNode
          if (el && el.tagName === 'EXTRACTED' && !ignored.has(el))
            if (parentCandidate === undefined || distanceInParents(el) < distanceInParents(parentCandidate))
              needed.delete(parentCandidate), needed.add(parentCandidate = el)
        })
        New && New.forEach(el => {
          if (el.tagName === 'SERIALIZATION' || !el.classList) return
          if (ignored.has(el)) return
          el.classList.add('hover')
          needed.has(el.parentNode) && el.parentNode.classList.add('hover')
        })
        if (prev) prev.forEach(el => !needed.has(el) && (el.classList.remove('hover'), _clearStyle(el)))
        scrollHighlight(New)
        changeHoverTo.prev = needed
      }
      function highlightParent(evt) {
        if (!_hoverHighlightsDOMValues[1]) return
        if (evt.type === 'pointerout' && evt.pointerType === 'touch') return
        if (evt.type === 'selectionchange' && getSelection().isCollapsed) return
        changeHoverTo(getParent(evt))
      }
      function getParent(evt) {
        const s = getSelection()
        let el
        if (s.isCollapsed && evt) el = evt.type.slice(-3) !== 'out' ? evt.target || evt.explicitOriginalTarget : evt.relatedTarget
        else el = s
        return _closestNodeParent(el)
      }
      const highlight = _throttled(highlightParent, .1)
      observe(_hoverHighlightsDOMValues, () => changeHoverTo(null), true)
      _listen('pointerover', highlight, passiveCapture)
      _listen('pointerout', highlight, passiveCapture)
      _listen('selectionchange', highlight, passiveCapture)

      // Create the toolbar.
      const bottombar = elem('div')
      bottombar.setAttribute('style', "position:sticky; left:0; bottom:0; z-index:11; width:100%")
      const JobIndicator = _jobs.indicator = elem('JobIndicator')
      JobIndicator.title = "Currently running 0 jobs. Click this to pause all."
      const toolbarElem = elem('span')
      observe(settingsToolbar, function onChange(toolbar) {
        while (toolbarElem.firstChild)
          toolbarElem.removeChild(toolbarElem.firstChild)
        for (let i=0; i < toolbar.length; ++i) if (isArray(toolbar[i]) && toolbar[i][0] === quote) toolbar[i] = toolbar[i][1]
        toolbarElem.append(' ', ...toolbar.map(x => isArray(x) && x[0] === settings ? settings(x) : elemValue(elem('collapsed', '···'), x)))
        elemValue(toolbarElem, toolbar)
      }, true)(settingsToolbar)
      bottombar.append(JobIndicator, toolbarElem)
      into.append(bottombar)

      // Highlight all current jobs' logging areas when hovering over the job indicator.
      elemValue(JobIndicator, {
        [defines.key]:{
          [_id(_closestNodeParent)]() {
            const r = []
            if (_jobs.expr)
              for (let i = 0; i < _jobs.expr.length; i += 3) {
                const L = _jobs.expr[i+1][_id(print)]
                if (L) r.push(L instanceof Map ? L.get(print) : L)
              }
            if (_jobs.limbo)
              for (let i = 0; i < _jobs.limbo.length; i += 3) {
                const L = _jobs.limbo[i+1][_id(print)]
                if (L) r.push(L instanceof Map ? L.get(print) : L)
              }
            return r.map(el => el.parentNode || el)
          }
        }
      })
      JobIndicator.onclick = () => {
        if (_jobs.expr) { // On click, pause all jobs.
          for (let i = _jobs.expr.length; i > 0; i -= 3)
            _pausedToStepper(_jobs.expr[i-3], _jobs.expr[i-2], _jobs.expr[i-1])
        }
      }

      // On any element tree mutations inside `into`, re-highlight.
      const mo = new MutationObserver(_throttled(record => {
        changeHoverTo(changeHoverTo.prev)
      }, .05));
      [...into.childNodes].forEach(ch => mo.observe(ch, { childList:true, subtree:true }))

      // Show the current highlight on the global scrollbar.
      const scrollHighlights = new Map
      const scrollHighlight = _throttled(function scrollHighlight(els) {
        const free = _allocArray(0)
        scrollHighlights.forEach(v => free.push(v)), scrollHighlights.clear()
        const prob = els && els.size > _maxHighlightedValues[1] && (1 - _maxHighlightedValues[1] / els.size) || 0
        els && els.forEach(el => {
          if (!_isStylableDOM(el)) return
          if (prob && Math.random() < prob) return
          const h = free.length ? free.shift() : document.createElement('scroll-highlight')
          scrollHighlights.set(el, h)
        })
        free.forEach(el => elemRemove(el, false, false, false)), _allocArray(free)
        if (scrollHighlights.size) {
          updateScrollHighlights()
          scrollHighlights.forEach(v => {!v.parentNode && (v.style.opacity = 0, into.append(v))})
          _reflow().then(() => scrollHighlights.forEach(v => v.style.opacity !== '' && (v.style.removeProperty('opacity'))))
        } else if (into.querySelector('scroll-highlight'))
          [...into.querySelectorAll('scroll-highlight')].forEach(el => !el.removed && (console.error('Dangling scroll highlight:', el), el.remove()))
      }, .2)
      function updateScrollHighlights() {
        if (!scrollHighlights.size) return
        const Min = -document.documentElement.scrollTop, Max = document.documentElement.scrollHeight + Min
        if (Max+1 <= Min) return
        scrollHighlights.forEach((v,k) => {
          if (!k.isConnected || getComputedStyle(k).display === 'none')
            return elemRemove(scrollHighlights.get(k)), scrollHighlights.delete(k)
          let rect = k.getBoundingClientRect(), rng = document.createRange()
          while (rect && !rect.x && !rect.y && !rect.width && !rect.height)
            rng.selectNode(k), rect = rng.getBoundingClientRect(), k = k.parentNode
          rng.detach()
          v._top = (rect.top - Min) / (Max - Min), v._height = rect.height / (Max - Min)
        })
        scrollHighlights.forEach(v => { if (v._top <= 1 && v._height <= 1) v.style.top = v._top*100+'%', v.style.height = v._height*100+'%' })
      }
      _listen('resize', _throttled(updateScrollHighlights, .125), passiveCapture)

      // Make copying behave better (but not cutting, because preventing its default would make us need to remove selection ourselves, and that's just too much for a one-liner).
      _listen('copy', evt => { if (!getSelection().isCollapsed) evt.clipboardData.setData('text/plain', String(getSelection())), evt.preventDefault() })

      // Forget values of removed trees as soon as possible (also, on adding, un-forget, just in case).
      const gcObs = new MutationObserver(records => {
        for (let i=0; i < records.length; ++i)
          if (records[i].type === 'childList' && records[i].addedNodes)
            for (let j=0; j < records[i].addedNodes.length; ++j) {
              const el = records[i].addedNodes[j]
              reinstateTree(el)
            }
          else if (records[i].type === 'childList' && records[i].removedNodes)
            for (let j=0; j < records[i].removedNodes.length; ++j) {
              const el = records[i].removedNodes[j]
              elemValue(el, null, true, true)
            }
      })
      function reinstateTree(el) {
        if (!(el instanceof Element)) return
        if ('to' in el) elemValue(el, el.to)
        for (let ch = el.firstChild; ch; ch = ch.nextSibling) reinstateTree(ch)
      }
      gcObs.observe(Self.into, { childList:true, subtree:true, characterData:true })
      // To make sure we didn't miss anything, garbage-collect DOM elements every 5 mins.
      let domgc = false, domenv = _newExecutionEnv()
      _listen(300000, () => {
        atCursor.lastEvt = null
        if (domgc) return; else domgc = true
        _doJob([GarbageCollectUI], domenv)
      })
      function GarbageCollectUI() {
        // Garbage-collects unneeded DOM elements.
        let [nextV = _onlyUndefined] = interrupt(1)
        try {
          let reachedV = false
          elemValue.elems.forEach((elems, v) => {
            if (!reachedV && v !== nextV && nextV !== _onlyUndefined) return
            nextV = v
            _checkInterrupt(GarbageCollectUI)
            reachedV = true
            elemValue(null, v)
          })
        } catch (err) { if (err === interrupt) interrupt.stack.push(nextV);  throw err }
      }
    },
  },

  _runUnitTests:[
    _(`settings`),
    false,
    `Whether we should run unit-tests (\`_test()\`) on startup.`,
  ],

  NodeJS:{
    docs:`Casualty of bit-rot.

Presents a console REPL with outputs labeled sequentially, or just reads and executes the whole file if redirected from it.
Example: \`nodejs self.js basic <input.txt >output.txt\` will write the result of executing everything in \`input.txt\` (parsed with language \`basic\`) to \`output.txt\`.`,
    call() {
      if (process.argv.length > 3) return console.log(`Usage:
nodejs self.js
nodejs self.js basic`)
      const lang = process.argv[2] && Self.ctx.get(process.argv[2]) || fancier

      const out = process.stdout
      if (!out.isTTY || !out.hasColors()) _colored.disabled = true
      serialize.displayed = !_colored.disabled ? serialize.consoleColored : {maxDepth:3}

      if (process.stdin.isTTY) // REPL for terminals.
        REPL(lang)
      else { // Read+execute for files.
        interrupt.noInterrupt = true
        require('fs').readFile(process.stdin.fd, 'utf-8', (err, data) => {
          if (err) throw err
          const env = _newExecutionEnv(null, null, lang, Self.ctx)
          _schedule(parse(data, lang), env, print)
        })
      }
    },
  },

  WebWorker:{
    docs:`Casualty of bit-rot.
Used for \`_purifyInWorker\`.
For \`file://\` URIs in Firefox, \`privacy.file_unique_origin\` in \`about:config\` needs to be false.`,
    call() {
      WebWorker.envs = Object.create(null)
      onmessage = evt => {
        const msg = evt.data
        if (isArray(msg) && typeof msg[0] == 'number' && typeof msg[1] == 'string' && msg.length == 2) {
          // Schedule parsing-and-serialization.
          const [ID, str] = msg
          let env = _newExecutionEnv()
          WebWorker.envs[ID] = env
          _doJob(_fastParse(str), _newExecutionEnv(), result => {
            // When done, postMessage the serialized result back.
            postMessage([ID, _fastSerialize(result)])
            delete WebWorker.envs[ID]
          }, ID)
        } else if (typeof msg == 'number') {
          _cancel(WebWorker.envs[msg])
          delete WebWorker.envs[msg]
        }
        else throw "Bad message"
      }
    },
  },

  settingsToolbar:[
    _(`_useDarkTheme`),
  ],

  _runFunc:{
    docs:`Calls a native function or schedules a non-native function. Exists to minimize memory allocation for functions that we want to quickly run outside a job (such as from event handlers).`,
    call(f, ...args) {
      if (typeof f != 'function') error("Expected a function, got", f)
      if (defines(f, deconstruct) === undefined)
        f(...args)
      else
        _doJob([f, ...args.map(quote)], _newExecutionEnv())
    },
  },

  _hoverHighlightsDOMValues:[
    _(`settings`),
    true,
    `Whether to highlight the same values associated with DOM nodes on hover.
The \`_closestNodeParent\` is shown by this.`,
  ],

  _maxHighlightedValues:[
    _(`settings`),
    128,
    `Maximum count of highlighted same-values. If over this, the highlighted nodes are chosen randomly.`,
  ],

  _purifyInWorker:{
    docs:`\`(_purifyInWorker Expr)\`: calls \`purify\` on (a copy of) \`Expr\` in parallel; returns a promise.`,
    examples:[
      [
        `_purifyInWorker ^(1*2+3*4)`,
      ]
    ],
    await:true,
    call(expr) {
      if (!_purifyInWorker.workers) {
        const ws = []
        for (let i = navigator.hardwareConcurrency-1; i; --i)
          ws[i-1] = {
            worker:new Worker('self.js'), // Assuming our script's name here.
            tasks:{},
          },
          ws[i-1].worker.onmessage = ({data:[ID, str]}) => ws[i-1].tasks[ID][1](_fastParse(str)),
          ws[i-1].worker.onerror = () => {
            ws.forEach(w => Object.keys(w.tasks).forEach(ID => {
              let env = _newExecutionEnv()
              env[_id(_schedule)] = +ID
              _doJob([purify, [quote, w.tasks[ID][0]]], env, w.tasks[ID][1])
            }))
            ws.length = 0
          }
        _purifyInWorker.workers = ws
      }

      return new Promise(then => {
        const ID = _newJobId()
        if (!_purifyInWorker.workers.length) {
          let env = _newExecutionEnv()
          env[_id(_schedule)] = ID
          return _doJob([purify, [quote, expr]], env, then)
        }
        const str = _fastSerialize([purify, [quote, expr]])
        const w = _purifyInWorker.workers[Math.floor(Math.random() * _purifyInWorker.workers.length)]
        w.worker.postMessage([ID, str])
        w.tasks[ID] = [expr, then]
      })
    },
  },

  _colored(str, pre=39, post = 39) {
    // Style a string for ANSI terminals. See `man 4 console_codes`.
    if (_colored.disabled) return str
    return typeof str != 'string' ? str : ('\x1b['+pre+'m') + str + ('\x1b['+post+'m')
  },

  _collapsedSerialization(v, lang = basic) {
    const el = serialize(v, lang, undefined, {...serialize.displayed, collapseDepth:1, collapseBreadth:16, deconstructElems:true, dontBind:v})
    let e = el.tagName === 'SERIALIZATION' ? el.firstChild : el
    if (isArray(v) && !_isLabel(v) || !isArray(v) && isArray(defines(v, deconstruct)) || v[defines.key] || typeof v == 'function' || _isDisposable(v))
      if (e.title !== 'bound' && (e.firstChild.tagName != 'BRACKET' || e.lastChild.tagName != 'BRACKET')) {
        e.insertBefore(elem('bracket', '('), e.firstChild)
        e.appendChild(elem('bracket', ')'))
      }
    return el
  },

  _getOuterLinker(el) { return el && (el.contentEditable === 'true' || el.parentNode && !isArray(el.parentNode.to) && defines(el.parentNode.to, insertLinkTo) ? el : _getOuterLinker(el.parentNode)) },

  insertLinkTo:{
    docs:`\`insertLinkTo DOMElement Range\`
(\`mapRead Commands 'CtrlClick'\`)
Replaces a \`Range\` (obtained from the current selection) with a link to the target elem's value.
A language can define this with a function that {takes the element and value to {link to}} and {returns an element to insert}.
Linking to outside of the \`editor\` \`quote\`s the value, linking to inside should extract the node into a shared variable.`,
    call(el, r) {
      if (!el) return
      const p = r.commonAncestorContainer, ed = _getOuterLinker(el)
      const pre = _smoothTransformPre(el)
      if (!_getOuterLinker(p)) return false
      const edInfo = ed && ed.parentNode.to
      let col
      if (ed && ed === _getOuterLinker(p) && isArray(edInfo) && edInfo[0] === editor && defines(edInfo[2], insertLinkTo))
        col = defines(edInfo[2], insertLinkTo)(r, el)
      else {
        // Don't use `elemCollapse`, because un-collapsing in an editable area is just trouble, and the value can be viewed anyway.
        col = elemValue(elem('collapsed', '···'), quote(el.to))
        col.special = true
        r.deleteContents()
        r.insertNode(col)
        r.setEndAfter(col)
      }
      p.dispatchEvent(new Event('input', {bubbles:true}))
      _smoothTransformPost(col, pre, 100)
    },
  },

  _closestNodeParent(el) {
    if (el instanceof Selection) el = el.rangeCount ? el.getRangeAt(0).commonAncestorContainer : null
    while (el && !('to' in el || el.tagName === 'SERIALIZATION'))
      el = el.parentNode
    return el
  },

  _bracketize(range, brackets = '()') {
    // Appends brackets at range's start and end.
    if (range.commonAncestorContainer.classList && range.commonAncestorContainer.classList.contains('editable')) return
    const b0 = elem('span', brackets[0]), b1 = elem('span', brackets[1])
    range.insertNode(b0)
    range.collapse(false)
    range.insertNode(b1)
    range.setStartAfter(b0)
    range.setEndBefore(b1)
  },

  hierarchy:{
    docs:`Turns a map from globals into a namespace-based hierarchy.`,
    readAt:{
      disableBindings:_(`disableBindingsElem`),
      settings:_(`settings`),
    },
    call(m, topLevel, parents = readAt.parents, lang = basic, binds, sourceCodeOrder = true) {
      if (typeof document == ''+void 0) return m
      if (!(m instanceof Map)) error("Expected a map, got", m)
      const globals = new Map // From globals to their elems.
      m.forEach((v,x) => globals.set(x, null))
      let p // Add unmentioned namespace-parent globals too.
      globals.forEach((our, x) => (p = parents.get(x)) && !globals.has(p) && globals.set(p, null))
      const result = !topLevel ? elem('details', elem('summary', 'Binds to:')) : elemFor(topLevel)
      ;(sourceCodeOrder ? Self.ctx : globals).forEach((x,x2) => { // Make globals appear in source-code order.
        if (!sourceCodeOrder) x = x2
        if (topLevel && x === topLevel || !globals.has(x)) return
        let our = globals.get(x)
        if (!our) globals.set(x, our = elemFor(x))
        const p = parents.get(x)
        if (!p) return result.append(our)
        let their = globals.get(p)
        if (!their) globals.set(p, their = elemFor(p))
        their.append(our)
      })
      m.forEach((_,x) => { // Add anything we missed from going through globals to the top-level.
        if (topLevel && x === topLevel || globals.has(x)) return
        let our = globals.get(x)
        if (!our) globals.set(x, our = elemFor(x))
        result.append(our)
      })
      for (let ch = result.firstChild.nextSibling; ch; ch = ch.nextSibling)
        ch.replaceWith(ch = purgeChildless(ch))
      if (result.childNodes.length == 1) result.append(elem('div', 'nothing'))
      result.open = true
      return result

      function elemFor(x) {
        const el = elem('details')
        const xEl = _isDOM(x) ? x : serialize(x, lang, binds, serialize.displayed)
        const v = m.get(x)
        el.append(elem('summary', v === undefined ? xEl : [xEl, ':  ', _isDOM(v) ? v : serialize(v, lang, binds, serialize.displayed)]))
        elemValue(el, x)
        return isArray(x) || defines(x, permissionsElem) === undefined || topLevel ? el : defines(x, permissionsElem)(el)
      }
      function purgeChildless(el) {
        if (el.tagName != 'DETAILS') return el
        if (el.childNodes.length == 1) {
          const chs = [...el.firstChild.childNodes]
          while (el.firstChild.firstChild) el.firstChild.removeChild(el.firstChild.firstChild)
          const ch = elem('div', chs)
          elemValue(ch, el.to)
          return el.replaceWith(ch), ch
        }
        for (let ch = el.firstChild.nextSibling; ch; ch = ch.nextSibling)
          ch = purgeChildless(ch)
        return el
      }
    },
  },

  permissionsElem:{
    docs:`Build a namespace hierarchy of globals that \`expr\` is bound to.`,
    call(expr, topLevel) {
      const uses = new Set, seen = new Set
      mark(expr), seen.clear()
      uses.forEach(x => readAt.parents.has(x) && uses.add(readAt.parents.get(x)))
      if (topLevel) uses.delete(topLevel)
      const m = new Map
      uses.forEach(x => m.set(x, undefined))
      return hierarchy(m, topLevel)

      function mark(x) {
        if (seen.has(x)) return; else seen.add(x)
        if (_invertBindingContext(Self.ctx).has(x) && typeof x != 'boolean' && typeof x != 'string' && x != null) return uses.add(x)
        if (!isArray(x) && defines(x, deconstruct)) return mark(deconstruct(x))
        else if (x instanceof Map) x.forEach((v,k) => (mark(k), mark(v)))
        else if (isArray(x)) x.forEach(mark)
        else if (x && !x[defines.key] && typeof x == 'object')
          Object.keys(x).forEach(k => mark(x[k]))
        else if (x && x[defines.key]) mark(x[defines.key])
      }
    },
  },

  stringToDoc:{
    docs:`Parse text in \`...?\` to style it as \`fancier\`, and treat other strings as \`structuredSentence\`s. Return an array of children.
Text in double-backticks will be replaced with the result of executing it: \`1+2\`=\`\`1+2\`\`.`,
    interrupt:false,
    call(s) {
      if (typeof s != 'string') return s
      let arr = s.split('``')
      for (let i = 0; i < arr.length; ++i)
        if (i & 1) { // Program. Execute.
          const prevPure = call.pure;  call.pure = undefined
          try {
            arr[i] = daintyEvaluator([print, _rememberToDispose(parse(arr[i]))], _newExecutionEnv())
            typeof document != ''+void 0 && arr[i] instanceof Node && (arr[i].style.display = 'inline')
          } catch (err) { console.log(err), arr[i] = elem('serialization', err !== interrupt ? arr[i] : '<interrupted while parsing '+arr[i]+'>') }
          finally { call.pure = prevPure }
        } else if (arr[i]) { // String.
          let sub = arr[i].split('`')
          for (let j = 0; j < sub.length; ++j)
            if (j & 1)
              try { // Program. Prettify.
                sub[j] = elem('serialization', _rememberToDispose(parse(sub[j], undefined, undefined, parse.dom))[1])
              } catch (err) { console.log(err), sub[j] = elem('serialization', err !== interrupt ? sub[j] : '<interrupted while parsing '+sub[j]+'>') }
            else { // String. Put.
              sub[j] = sub[j].split('\n').map(structuredSentence)
              typeof document != ''+void 0 && sub[j].forEach(el => el.classList.add('text'))
              interleave(sub[j], '\n')
              sub[j] = sub[j].filter(x => x)
            }
          arr[i] = sub
        }
      return arr.filter(x => x)
      function interleave(arr, separator) {
        arr.length = arr.length*2 - 1
        for (let i=arr.length-1; i>0; --i)
          arr[i] = !(i&1) ? arr[i>>>1] : separator
      }
    },
  },

  elemToWindow:{
    docs:`Wraps an element in \`<div.window>\`.`,
    call(el) {
      const pre = _smoothHeightPre(el)
      el.style.position = 'relative' // So that .offsetLeft/Top refer to the same thing as position:absolute.
      const x = el.offsetLeft, y = el.offsetTop
      el.style.removeProperty('position'), _clearStyle(el)
      const menu = elem('div')
      menu.classList.add('window')
      if (el.to) elemValue(menu, el.to), menu.special = true
      const col = elemCollapse(() => {
        const pre = _smoothTransformPre(menu)
        menu.replaceWith(el)
        _smoothTransformPost(el, pre)
        return el
      })
      elemValue(col, el.to)
      el.isConnected ? el.before(col) : setTimeout(() => menu.before(col), 100)
      menu.isWindow = col
      el.replaceWith(menu)
      menu.style.left = x + 'px', menu.style.top = y + 'px'
      allowDragging(menu)
      menu.append(el)
      _smoothHeightPost(col, pre)
      return menu
    },
  },

  elemExpandAll:{
    docs:`Clicks all <collapsed> elements in the element.`,
    call(el, readonly = false) {
      if (!el) return
      if (el.tagName === 'COLLAPSED' && el.onclick && readonly) return true
      if (!(el instanceof Element)) return
      let chs
      if (el.tagName === 'COLLAPSED' && el.onclick) chs = [...el.firstChild.childNodes], el.onclick({target:el}, true)
      else chs = [...el.childNodes]
      for (let i = 0; i < chs.length; ++i) if (elemExpandAll(chs[i], readonly)) return true
    },
  },

  _restoreWindow(w) {
    if (!w) return
    const inside = w.firstChild, preT = _smoothTransformPre(inside), preH = _smoothHeightPre(w.isWindow)
    w.isWindow.remove()
    w.replaceWith(inside)
    _reflow().then(() => _smoothTransformPost(inside, preT), _smoothHeightPost(inside, preH))
  },

  _getOuterWindow(el) { return !el ? null : el.isWindow ? el : _getOuterWindow(el.parentNode) },

  disableBindingsElem:{
    docs:`\`disableBindingsElem()\`: creates an elem for disabling current bindings hierarchically.`,
    call() {
      const binds = _bindingsAt()
      const m = new Map
      binds.forEach(addCheckbox)
      return elemValue(hierarchy(m, elem('span', 'Bindings:')), binds)

      function addCheckbox(v, L) {
        if (typeof L != 'string') return
        const el = elem('input')
        el.type = 'checkbox'
        el.checked = true
        el.onchange = function() {
          this.checked ? binds.set(L, v) : binds.delete(L);
          if (this.parentNode.tagName === 'SUMMARY') {
            [...this.parentNode.parentNode.querySelectorAll('input[type=checkbox]')].forEach(
              el => el !== this && (el.checked = this.checked, el.onchange())
            )
          }
        }
        m.set(v, el)
      }
    },
  },

  elemCollapse:{
    docs:`Collapses an element (or a range of elements) in-place. Click to expand again. Pass in a function to create the element only if needed. Pass in null as \`end\` to collapse all consequent non-bracket siblings.`,
    call(start, end = undefined) {
      const col = elem('collapsed')
      if (typeof start == 'function') {
        col.setAttribute('content', '···')
        col.append(elem('hidden'))
        col.onclick = (evt, instant = false) => {
          evt.preventDefault && evt.preventDefault()
          const col = evt.target || evt.explicitOriginalTarget, p = col.parentNode, pre = !instant && _smoothHeightPre(p)
          const el = start()
          if (p) isArray(el) ? el.forEach(el => p.insertBefore(el, col)) : el.parentNode !== p && p.insertBefore(el, col), p.removeChild(col)
          if (!instant) {
            if (_getOuterWindow(p) || _getOuterContextMenu(p)) _updateBroken(_getOuterWindow(p) || _getOuterContextMenu(p))
            else p && _updateBroken(p)
            p.dispatchEvent(new Event('input', {bubbles:true}))
            _smoothHeightPost(p, pre)
          }
        }
      } else {
        if (isArray(start)) start = elem('text', start) // Assume `stringToDoc` made `start`.
        const parent = start.parentNode, pre = parent && _smoothHeightPre(parent)
        let nextCol = end !== undefined ? end : start.nextSibling
        const d = elem('hidden')
        if (end === undefined)
          d.append(start), 'to' in start && elemValue(col, start.to)
        else {
          const a = []
          for (let el = start, next = start.nextSibling; end !== undefined && el && el !== end; [el, next] = [next, next && next.nextSibling]) {
            d.append(el)
            'to' in el && a.push(el.to)
            if (next && next.tagName === 'BRACKET' && !next.nextSibling) end = next, nextCol = next
          }
          elemValue(col, a.length !== 1 ? [rest, a] : a[0])
        }
        col.setAttribute('content', end === undefined ? '···' : '···$')
        col.append(d)
        col.onclick = (evt, instant = false) => {
          evt.preventDefault && evt.preventDefault()
          const col = evt.target || evt.explicitOriginalTarget, d = col.firstChild, p = col.parentNode, pre = !instant && _smoothHeightPre(p)
          if (d.firstChild === d.lastChild)
            col.replaceWith(d.firstChild)
          else {
            const before = col.nextSibling
            while (d.firstChild) p.insertBefore(d.firstChild, before)
            p.removeChild(col)
          }
          if (!instant) {
            if (_getOuterWindow(p) || _getOuterContextMenu(p)) _updateBroken(_getOuterWindow(p) || _getOuterContextMenu(p)); else if (p) _updateBroken(p)
            _smoothHeightPost(p, pre)
          }
        }
        if (start.title) col.title = start.title
        if (parent) parent.insertBefore(col, nextCol), _smoothHeightPost(parent, pre)
      }
      col.special = (original, copy) => copy.onclick = original.onclick
      return col
    },
  },
  
  print:{
    docs:`\`(print …Values)\`: For debugging; prints to the current DOM node or console.`,
    readAt:{
      prompt:_(`prompt`),
      display:_(`display`),
      structured:_(`structured`),
      structuredSentence:_(`structuredSentence`),
    },
    call(...x) {
      const prevPure = call.pure;  call.pure = false
      print.did = true
      try {
        let before = call.env && call.env[_id(print)]
        if (before instanceof Map) before = before.get(print)
        if (before && before.parentNode) {
          let str
          if (x.length != 1 || !_isStylableDOM(x[0]))
            str = serialize(x.length > 1 ? x : x[0], _langAt(), _bindingsAt(), {...serialize.displayed, observe:false})
          else str = x[0]
          if (str.parentNode) str = elemClone(str)
          if (typeof str == 'string') str = document.createTextNode(str)
          const wasMax = _updateMaxScrollBegin()
          before.parentNode.insertBefore(str, before)
          _updateBroken(str)
          _updateMaxScrollEnd(wasMax)
        } else
          console.log(...x)
        if (x.length == 1) return x[0]
      } catch (err) { if (err !== impure) console.log(err, err && err.stack), console.log('When trying to print', ...x) }
      finally { call.pure = prevPure }
      // print.did (for not erasing parts of a print in a terminal in NodeJS)
    },
  },

  _updateMaxScrollBegin() { return !_disableSmoothTransitions[1] && scrollY >= document.documentElement.scrollHeight - innerHeight - 5 },

  _updateMaxScrollEnd(begin) { if (begin) scrollBy(0, 10000) },

  allowDragging:{
    docs:`Allows dragging the element around with a pointer (but not with touch). Only call on absolutely-positioned elements with .style.left and .style.top.`,
    call(el) {
      let pointerId = null, startX, startY, scrX, scrY
      const passive = {passive:true}
      el.addEventListener('pointerdown', evt => {
        if (evt.pointerType === 'touch') return
        const t = evt.target || evt.explicitOriginalTarget
        if (_isEditable(t) || t.tagName === 'KNOWN' || t.tagName === 'TEXTAREA' || t.tagName === 'BUTTON' || t.tagName === 'INPUT' || t.tagName === 'DETAILS' || t.tagName === 'SUMMARY' || t.tagName === 'COLLAPSED' || t.classList && t.classList.contains('resizable')) return
        if (_closestNodeParent(t) && _closestNodeParent(t) !== el) return
        pointerId = evt.pointerId, startX = evt.clientX, startY = evt.clientY, el.setPointerCapture(pointerId)
        scrX = scrollX, scrY = scrollY
        getSelection().rangeCount && getSelection().collapseToEnd()
        evt.stopPropagation(), _getOuterContextMenu(document.activeElement) === _getOuterContextMenu(el) && evt.preventDefault()
        addEventListener('scroll', move, passive)
      })
      function move(evt) {
        if (!el.isConnected) return removeEventListener('scroll', move, passive)
        if (pointerId == null || evt.pointerId !== pointerId && evt.pointerId !== undefined) return
        const x = parseFloat(el.style.left), y = parseFloat(el.style.top)
        let dx = evt.clientX != null ? evt.clientX - startX : 0, dy = evt.clientY != null ? evt.clientY - startY : 0
        dx += scrollX - scrX, dy += scrollY - scrY
        scrX = scrollX, scrY = scrollY
        if (dx) el.style.left = x + dx + 'px'
        if (dy) el.style.top = y + dy + 'px'
        if (dx) el.style.maxWidth = innerWidth - (x + dx) - 16 + 'px'
        if (evt.clientX || evt.clientY) startX = evt.clientX, startY = evt.clientY
      }
      el.addEventListener('pointermove', move, passive)
      el.addEventListener('pointerup', () => (pointerId = null, removeEventListener('scroll', move, passive)), passive)
      el.addEventListener('pointercancel', () => (pointerId = null, removeEventListener('scroll', move, passive)), passive)
    },
  },

  _isEditable(el) { return el && (el.contentEditable === 'true' || el.tagName === 'TEXTAREA' || el.tagName === 'INPUT' ? el : _isEditable(el.parentNode)) },

  _getOuterContextMenu(el) { return !el ? Self.into : (el.tagName === 'CONTEXT-MENU' ? el : _getOuterContextMenu(el.parentNode)) },

  _escapeLabel(name, lang = _langAt(call.env) || fancier) {
    return typeof defines(lang, _escapeLabel) == 'function' ? defines(lang, _escapeLabel)(name) : name
  },

  _unescapeLabel(repr, lang = _langAt(call.env) || fancier) {
    return typeof defines(lang, _unescapeLabel) == 'function' ? defines(lang, _unescapeLabel)(repr) : repr
  },

  describe:{
    docs:`Creates an element that describes a value.`,
    _printAll:[
      {
        docs:`Allow renaming labels.`,
        call([el, v]) {
          if (el && el.classList.contains('label')) {
            // Allow renaming labels.
            const inp = elem('input')
            inp.type = 'text'
            let prev = _unescapeLabel(el.textContent, el), updating = false
            inp.value = prev
            const updateGlobal = _throttled(() => (_updateBroken(Self.into), updating = false), .05)
            const editor = _isEditable(el)
            inp.oninput = _throttled(() => {
              if (inp.value && +inp.value === +inp.value) return
              let arr = elemValue(undefined, el.to)
              if (!arr && editor) // Restore ourselves when we've lost it because it's cyclic.
                arr = [...editor.querySelectorAll('.label')].filter(x => _unescapeLabel(x.textContent, x) === prev)
              if (isArray(arr))
                for (let i = 0; i < arr.length; ++i)
                  if (arr[i].classList.contains('label') && _unescapeLabel(arr[i].textContent, arr[i]) === prev)
                    arr[i].textContent = _escapeLabel(inp.value, arr[i])
              prev = inp.value
              if (!updating) setTimeout(updateGlobal, 0), updating = true
            }, .2)
            return inp
          }
        },
      },
      function([el, v]) {
        // For globals, display the owner namespace (if any) (even if the property name does not match) and the global binding.
        //   For non-exposed globals, display the owner namespace (if any).
        if (v != null && _invertBindingContext(Self.ctx).has(v)) {
          const global = serialize(v, undefined, undefined, serialize.displayed), p = readAt.parents.get(v) || Self
          return p ? elem('div', [elem('unimportant', [serialize(p, undefined, undefined, serialize.displayed), '.']), global]) : global
        } else if (readAt.parents.has(v)) {
          const p = readAt.parents.get(v)
          return elem('div', elem('unimportant', ['In ', serialize(p, undefined, undefined, serialize.displayed)]))
        }
      },
      {
        docs:`For numbers, display a slider from 0 to 2*number for easy adjusting.
For strings, display them in a <textarea> for easy editing and copying.
For anything else, display the globals the expression binds to, and an expandable basic definition.`,
        call([el, v]) {
          // For globals, a short definition of what we were called on.
          if (typeof v == 'number' && isFinite(v) && el && v === +el.textContent && _isEditable(el)) {
            // Display a slider from 0 to 2*number for easy adjusting.
            const range = elem('input', ''+v)
            range.type = 'range'
            range.min = v > 0 ? 0 : 2*v
            range.max = v > 0 ? 2*v : 0
            range.step = .01
            range.value = v
            let i = elemValue(undefined, el.to).indexOf(el)
            range.oninput = () => {
              if (el && !el.isConnected) el = elemValue(undefined, el.to).filter(_isEditable)[i]
              if (!el) return
              el.replaceWith(el = elemValue(elem('number', ''+range.value), el.to = +range.value))
              i = elemValue(undefined, el.to).filter(_isEditable).indexOf(el)
            }
            return range
          } else if (typeof v == 'string' && v.length < 100000) {
            // Display strings in a <textarea> for easy editing and copying.
            const area = elem('textarea', v)
            if (!_isEditable(el))
              area.readOnly = true
            else if (el) {
              let i = elemValue(undefined, el.to).filter(_isEditable).indexOf(el)
              area.oninput = _throttled(() => {
                if (el && !el.isConnected) el = elemValue(undefined, el.to).filter(_isEditable)[i]
                if (!el) return
                el.replaceWith(el = serialize(area.value, undefined, undefined, serialize.displayed))
                elemValue(area, el.to = area.value)
                i = elemValue(undefined, el.to).filter(_isEditable).indexOf(el)
              }, .1)
            }
            return elemValue(area, v)
          } else if (!_invertBindingContext(Self.ctx).has(v))
            if (!isArray(v) || v[0] !== REPL || !(v[2] instanceof Map))
              return permissionsElem(v) // Display the globals that this one's deconstruction binds to (unless a REPL).
        },
      },
      {
        docs:`Docstring.`,
        call([el, v]) {
          if (!isArray(v) && typeof defines(v, docs) == 'string')
            return elem('text', stringToDoc(defines(v, docs)))
        },
      },
      function([el, v]) {
        // The docstring of settings.
        if (isArray(v) && v[0] === settings && typeof v[2] == 'string')
          return elem('text', v[2])
      },
      function([el, v]) {
        // The official `settings` form of settings.
        if (isArray(v) && v[0] === settings && typeof v[2] == 'string')
          return settings(v)
      },
      function([el, v]) {
        // The AutoWorld and type, if available.
        if (!el || v === undefined) return
        const [AWs, TPs] = _getAutoInfoNear(el)
        if (isArray(v) && v[0] === bound && v[1] instanceof Map) v = v[2]
        try {
          let aw = AWs.get(v), tp = TPs.get(v)
          if (autoWorld.objectWorld && autoWorld.objectWorld.has(v)) {
            aw = autoWorld.objectWorld.get(v)
            tp = defines(aw, deconstruct)[2].Type[aw.objectIndex.get(v)]
          }
          if (!isArray(v) && defines(v, type))
            tp = defines(v, type)
          tp = _typeFinalize(tp)
          if (tp !== undefined) // "In […], typed T"
            return aw ? elem('text', [
              elemValue(elem('unimportant', 'In '), autoWorld),
              elemValue(elemCollapse(() => serialize(aw, undefined, undefined, serialize.displayed)), aw),
              elemValue(elem('unimportant', ' typed '), Types),
              serialize(tp, undefined, undefined, serialize.displayed)
            ]) : elem('text', [ // "Typed T"
              elemValue(elem('unimportant', 'Typed '), Types),
              serialize(tp, undefined, undefined, serialize.displayed)
            ])
        } finally { _allocMap(AWs), _allocMap(TPs) }
      },
      {
        docs:`Examples.`,
        call([el, v]) {
          if (!isArray(v) && isArray(defines(v, examples)))
            return elem('div', [
              elemValue(elem('unimportant', 'Examples: '), examples),
              elemCollapse(() => serialize(examples(v), undefined, undefined, serialize.displayed))
            ])
        },
      },
      {
        docs:`A plot for numeric arrays and non-disposed tensors.`,
        call([el, v]) {
          if (_isNumericArray(v) && v.length > 1 && v.every(_isNum) || _isDisposable(v) && !v.isDisposedInternal)
            return elem('div', [
              elemValue(elem('unimportant', _isDisposable(v) ? 'Distribution: ' : 'Plot: '), display),
              elemCollapse(() => daintyEvaluator([display, elemValue(elem('collapsed', '···'), v), [quote, v]]))
            ])
        },
      },


      {
        docs:`A table for \`readAt\`s.`,
        call([el, v]) {
          if (!isArray(v) && defines(v, readAt)) {
            const backctx = _invertBindingContext(Self.ctx)
            const row = ([k,v]) => {
              if (typeof k != 'string') return
              let ve
              if (!backctx.has(v))
                ve = elemValue(elemCollapse(() => serialize(v, undefined, undefined, serialize.displayed)), v)
              else
                ve = serialize(v, undefined, undefined, serialize.displayed)
              return elem('tr', [elem('td', elem('span', k)), elem('td', ve)])
            }
            // For `Self`, only display public functionality without readAt.parents (displaying all bindings is too much).
            let a
            if (v !== Self) {
              const lkp = defines(v, readAt)
              a = Object.keys(defines(v, readAt)).map(k => [k, lkp[k]])
            } else a = [...backctx].filter(([v,k]) => v && v !== true && k[0] !== '_' && !readAt.parents.has(v)).map(([v,k])=>[k,v])
  
            return elem('div', [
              elemValue(elem('unimportant', 'Namespace for:'), readAt),
              elem('table', a.length <= 16 ? a.map(row) : [a.slice(0,16).map(row), elemCollapse(() => a.slice(16).map(row))]),
            ])
          }
        },
      },
      function([el, v]) {
        // For globals, the list of back-refs.
        if (_invertBindingContext(Self.ctx).has(v)) {
          const refd = referencesTo(v)
          if (refd && refd.length)
            return elem('div', [
              elemValue(elem('unimportant', [
                'Used in ',
                elemValue(elem('number', ''+refd.length), refd.length),
                refd.length != 1 ? ' other globals: ' : ' other global: ',
              ]), referencesTo),
              elemValue(elemCollapse(() => serialize(refd.length !== 1 ? refd : refd[0], basic, undefined, serialize.displayed)), refd)
            ])
        }
      },
      function([el, v]) {
        // For globals, the list of back-defs.
        if (_invertBindingContext(Self.ctx).has(v)) {
          const defd = definersOf(v)
          if (defd && defd.length)
            return elem('div', [
              elemValue(elem('unimportant', [
                'Defined by ',
                elemValue(elem('number', ''+defd.length), defd.length),
                defd.length != 1 ? ' globals: ' : ' global: ',
              ]), definersOf),
              elemValue(elemCollapse(() => serialize(defd.length !== 1 ? defd : defd[0], basic, undefined, serialize.displayed)), defd)
            ])
        }
      },
      function([el, v]) {
        // Array/string length (auto-updated), or the number/boolean/null/undefined.
        if (isArray(v) || typeof v == 'string') {
          const num = elemValue(elem('number', ''+v.length), v.length)
          if (isArray(v)) {
            const f = v => { num.textContent = ''+v.length, elemValue(num, v.length), !num.isConnected && (clearInterval(to), observe(v, f, false)) }
            const to = setInterval(() => !num.isConnected && (observe(v, f, false), clearTimeout(to)), 60000)
            observe(v, f, true)
          }
          return elem('div', [
            elemValue(elem('unimportant', (isArray(v) ? 'Array' : 'String') + ' length: '), [readAt, v, 'length']),
            num,
          ])
        }
        if (v instanceof Map || v instanceof Set)
          return elem('div', [
            elem('unimportant', (v instanceof Map ? 'Map' : 'Set') + ' size: '),
            elemValue(elem('number', ''+v.size), v.size),
          ])
        if (typeof v == 'number')
          return elemValue(elem('number', ''+v), v)
        if (typeof v == 'boolean' || v == null)
          return elemValue(elem('known', ''+v), v)
      },
      function([el, v]) {
        // The full deconstruction if not a primitive value (like a number).
        if (v && (typeof v == 'object' || typeof v == 'function'))
          return elem('div', [
            elemValue(elem('unimportant', 'Basically: '), basic),
            elemValue(elemCollapse(() => _collapsedSerialization(v)), v),
          ])
      },
    ],
    call(el) {
      if (typeof document == ''+void 0) return
      let v
      if (!(el instanceof Node)) v = el, el = undefined
      else v = el.to

      // Append a daintyEvaluator, executing `(_printAll describe ^(el v))`.
      return daintyEvaluator([_printAll, describe, [quote, [el, v]]], _newExecutionEnv())
    },
  },

  _getAutoInfoNear:{
    docs:`\`_getAutoInfoNear DOMElement\`→\`(vToAutoWorld vToType)\`
Collates \`map\`s from \`DOMElement.'to'\` to auto-world/type/embedding in the surrounding \`serialize\`ation.`,
    call(el) {
      const AWs = _allocMap(), TPs = _allocMap()
      autoWorld.objectWorld && fillObjectsInfo(findSerialization(el))
      return [AWs, TPs]

      function findSerialization(e) { return !e ? null : e.tagName === 'SERIALIZATION' ? e : findSerialization(e.parentNode) }
      function fillObjectsInfo(e) {
        if (!e || e.tagName === 'COLLAPSED') return
        if (autoWorld.objectWorld.has(e.to)) {
          const aw = autoWorld.objectWorld.get(e.to), At = aw.objectIndex.get(e.to)
          aw.NodeTypes[At].forEach((Type, Node) => (AWs.set(Node, aw), TPs.set(Node, Type)))
        }
        for (let ch = e.firstChild; ch; ch = ch.nextSibling) fillObjectsInfo(ch)
      }
    },
  },

  contextMenu:{
    docs:`Creates and displays a \`<context-menu>\` element near the specified element.`,
    philosophy:`Do not expect important information to get up in your face to yell about itself. Drill down to what you need or want. (In fact, those that want to improve will naturally be inclined to prioritize their shortcomings, so using the first impression can be counter-productive.)`,
    readAt:{
      describe:_(`describe`),
      toWindow:_(`elemToWindow`),
      allowDragging:_(`allowDragging`),
      permissions:_(`permissionsElem`),
      stringToDoc:_(`stringToDoc`),
      expandAll:_(`elemExpandAll`),
      insertLinkTo:_(`insertLinkTo`),
      atCursor:_(`atCursor`),
      addSearchElem:_(`addSearchElem`),
      editObject:_(`editObject`),
    },
    _printAll:[
      {
        docs:`Propose to execute functions that define \`button\`.`,
        call([el, range, v]) {
          if (typeof v == 'function' && defines(v, button) !== undefined) {
            const names = nameResult(v)
            return button(v, names && names[0])
          }
        },
      },
      {
        docs:`Describe context menu's items.`,
        call([el, range, v]) { return describe(el) },
      },
      {
        docs:`Fetch URLs and try to display their contents.`,
        call([el, range, v]) {
          if (isArray(v) && v[0] === elem && v[1] === url && typeof v[2] == 'string') {
            return elem('div', [
              elemValue(elem('unimportant', 'URL to: '), url),
              elemValue(elemCollapse(() => {
                const result = elem('div')
                result.classList.add('resizable')
      
                fetch(v[2], {mode:'cors'})
                .catch(r => elemInsert(result, serialize(_errorRepr(r), undefined, undefined, serialize.displayed)))
                .then(r => r.arrayBuffer())
                .then(r => new TextDecoder().decode(new Uint8Array(r)))
                .then(r => {
                  try {
                    elemInsert(result, serialize(JSON.parse(r), undefined, undefined, serialize.displayed))
                  } catch (err) { elemInsert(result, _fastParse(r)) }
                })
                .catch(() => {
                  const frame = elem('iframe')
                  frame.src = v[2]
                  elemInsert(result, frame)
                })
                return result
              }), v[2]),
            ])
          }
        },
      },
      {
        docs:`Buttons.
If we're at the top-level element, present an option to make a REPL.
If we're at a top-level element, present an option to delete it (unless it's all we have).
If we can expand all in the context element, then present that option.
Present an option to hide the element.
Present an option to hide the element and all elements after it on the same hierarchy level.
Present "To window" (for non-windows) or "Restore" (for windows — draggable absolutely-positioned elements).
If the cursor is in editor, present an option to replace the currently-selected contents with a link to the value.
Allow editing run-time and rewrite-time values.`,
        call([el, range, v]) {
          const elems = []
          if (el.parentNode === Self.into || el.tagName === 'HTML' || el === Self.into) {
            elems.push(button(() => {
              let before = el.parentNode === Self.into ? el : Self.into.firstChild
              while (before && (!(before instanceof Element) || getComputedStyle(before).display === 'none')) before = before.nextSibling
              elemInsert(Self.into, REPL(), before)
            }, '💻', 'Append a new REPL.'))
            if (el.previousSibling && 'to' in el.previousSibling || el.nextSibling && 'to' in el.nextSibling)
              elems.push(button(() => elemRemove(el), '🏹', 'Delete this.'))
          }
          if (elemExpandAll(el, true))
            elems.push(button(() => elemExpandAll(el), '🔮', 'Expand all collapsed element trees here.'))
          if (_getOuterWindow(el) !== el && !_isEditable(el))
            elems.push(button(() => elemCollapse(el), '…', 'Collapse element tree.'))
          if (el.nextSibling && el.nextSibling.tagName !== 'BRACKET')
            elems.push(button(() => elemCollapse(el, null), '…$', 'Collapse to end.'))
          if (!_isEditable(el) && el !== document.documentElement) {
            if (!_getOuterWindow(el))
              elems.push( button(() => elemToWindow(el), ' ', 'Extract this element into a draggable window.') )
            else
              elems.push( button(() => _restoreWindow(_getOuterWindow(el)), '×', 'Put the extracted element back into its previous position.') )
          }
          if (range && v !== undefined && _isEditable(range.commonAncestorContainer))
            elems.push( button(() => insertLinkTo(el, range), '🔗', 'Insert a collapsed link to this at cursor.') )

          const extraArea = elem('div')
          {
            // Allow editing & rewriting.
            let a,b,c
            if (editObject(v, null))
              elems.push( a = button(() => {
                _removeChildren(extraArea)
                elemInsert(extraArea, editObject(v))
              }, '🔧', 'Change the run-time object.') )
            if (editRewrite(v, null))
              elems.push( b = button(() => {
                _removeChildren(extraArea)
                elemInsert(extraArea, editRewrite(v))
              }, '📝', 'Rewrite the global object. Changes will apply to the next rewrite 💾, `Rewrite()`.') )
            elems.push( c = button(() => {
              _removeChildren(extraArea)
              elemInsert(extraArea, REPL())
            }, '📋', 'Open a REPL here.') )
            ;[a,b,c].forEach(ch => ch && (ch.doNotCloseTheContextMenuOnClick = true))
            extraArea.title = 'Try out the next rewrite.'
          }

          return elem('div', [
            elem('context-menu-buttons', elems),
            extraArea,
          ])
        },
      },
    ],
    call(el, range, evt) {
      if (!el && (evt.target || evt.explicitOriginalTarget) === document.documentElement)
        el = evt.target || evt.explicitOriginalTarget
      if (!el) return
      const v = el.to
      const menu = elem('context-menu')
      menu.classList.add('window')
      allowDragging(menu)

      // Close (when unfocused or) on a click on a <button> inside.
      menu.addEventListener('click', evt => {
        if (evt.ctrlKey || evt.shiftKey || evt.altKey || evt.metaKey) return (!evt.target || evt.target.tagName !== 'A') && evt.preventDefault()
        const t = evt.target || evt.explicitOriginalTarget
        if (!t.doNotCloseTheContextMenuOnClick)
          t.tagName === 'BUTTON' && _getOuterContextMenu(t) === menu && elemRemove(menu)
      })
      menu.tabIndex = 0

      // Append a daintyEvaluator, executing `(_printAll contextMenu ^(el range v))`.
      menu.append(daintyEvaluator([_printAll, contextMenu, [quote, [el, range, v]]], _newExecutionEnv()))

      let inside = _getOuterContextMenu(el)
      if (_getOuterContextMenu(inside.parentNode) !== Self.into) inside = Self.into // Only one nesting layer.
      atCursor(menu, evt, inside)

      menu.focus({preventScroll:true})
    },
  },

  daintyEvaluator:{
    docs:`\`(daintyEvaluator Expr Env)\`: returns an element that will evaluate the expression and display its \`print\`s if any, but not the result.`,
    call(expr, env = _newExecutionEnv()) {
      if (typeof document == ''+void 0) return

      // Evaluate the requested expression.
      if (call.pure) throw impure
      const result = _evaluationElem(env)
      const el = elem('div', result)
      el.classList.add('code')
      env[_id(print)] = el.lastChild
      let empty = false
      const prev = call.env
      _doJob(expr, env, () => (!result.previousSibling ? (empty = true, el.remove()) : result.remove()))
      call.env = prev
      return !empty ? el : undefined
    },
  },

  atCursor:{
    docs:`Positions an element at cursor (as pointed out by an event).`,
    call(el, pointerEvt = atCursor.lastEvt, inside = Self.into) {
      let x = pointerEvt ? pointerEvt.clientX : 0, y = pointerEvt ? pointerEvt.clientY : 0
      if (el.parentNode) error('Only position new elements at cursor')
      if (!inside.isConnected) error('Only position elements inside the visible document')
      const r = (inside !== document.body ? inside : document.documentElement).getBoundingClientRect()

      if (!atCursor.opened) atCursor.opened = []

      // Position at an appropriate corner of itself.
      el.style.position = 'absolute'
      const xOk = x < innerWidth * .8, yOk = y < innerHeight * .8
      x -= r.left, y -= r.top
      el.style.left = x + 'px'
      el.style.top = y + 'px'
      if (xOk && yOk) { // Open to bottom-right
        el.style.borderTopLeftRadius = 0
      } else if (xOk) { // Open to top-right
        el.style.transform = 'translate(0, -100%)'
        el.style.borderBottomLeftRadius = 0
      } else if (yOk) { // Open to bottom-left
        el.style.transform = 'translate(-100%, 0)'
        el.style.borderTopRightRadius = 0
      } else { // Open to top-left
        el.style.transform = 'translate(-100%, -100%)'
        el.style.borderBottomRightRadius = 0
      }
      el.style.maxWidth = innerWidth - parseFloat(el.style.left) - 16 + 'px'
      inside.append(el)

      // Remove on clicking/focusing elsewhere.
      atCursor.opened.push(el)

      // .lastEvt, .opened
    },
  },

  _evaluationElem:{
    docs:`Creates and returns a pause-button and a waiting indicator.`,
    call(env) {
      if (!env) error("Where's the execution env:", env)
      const el = elem('div')
      const pause = elem('button', '⏸')
      pause.onclick = () => _pausedToStepper(..._cancel(env, true))
      pause.title = `Pause execution`
      el.append(pause)
      el.append(elem('waiting'))
      return elemValue(el, [_evaluationElem, env])
    },
  },

  _recognizeBinding(binds, v) {
    if (isArray(v) && v[0] === _extracted && v.length == 3 && (_isLabel(v[1]) || _invertBindingContext(binds).has(v[1])))
      return [_isLabel(v[1]) ? v[1] : label(_invertBindingContext(binds).get(v[1])), v[2]]
    return [null, v]
  },

  _addBinding(binds, L, v) {
    if (binds !== Self.ctx && !binds.has(evaluator.history))
      binds.set(evaluator.history, _allocMap())
    if (binds && binds.has(evaluator.history) && _isLabel(L)) { // Add result to bindings.
      if (binds.get(evaluator.history).has(_unlabel(L)))
        return [error, "Label", L, "is already bound to", binds.get(_unlabel(L))]
      else {
        binds.get(evaluator.history).set(_unlabel(L), binds.has(_unlabel(L)) ? binds.get(_unlabel(L)) : evaluator.none)
        binds.set(_unlabel(L), quote(v))
        _invertBindingContext(binds, true)
        return [_extracted, L, v]
      }
    }
    return v
  },

  _removeBinding(binds, L) {
    if (binds && binds.has(evaluator.history) && _isLabel(L)) { // Delete result from bindings.
      const prevBinding = binds.get(evaluator.history).get(_unlabel(L))
      binds.get(evaluator.history).delete(_unlabel(L))
      prevBinding !== evaluator.none ? binds.set(_unlabel(L), prevBinding) : binds.delete(_unlabel(L))
      _invertBindingContext(binds, true)
    }
  },

  evaluator:{
    docs:`\`(evaluator Expr Env)\`: When logged to DOM, this displays the expression, its \`print\`s along the way, and its one evaluation result in one removable (by clicking on the prompt) DOM element.
When evaluating \`a:b\`, binds \`a\` to \`^b\` in consequent parses/serializations in the parent REPL; when evaluating anything else, tries to add the result to the \`CurrentUsage\` binding. Both are reverted when the evaluator is removed.`,
    _printAll:[
      {
        docs:`Display evaluation's result.`,
        call([result]) { return result !== undefined ? result : _onlyUndefined },
      },
      {
        docs:`Display the report on times taken.`,
        call([result, user, real, end]) {
          if (user != null) return elem('time-report', [
            elemValue(elem('span', 'user'), userTime),
            elem('space', ' '),
            _formatDuration(user),
            ', ',
            elemValue(elem('span', 'real'), realTime),
            elem('space', ' '),
            _formatDuration(real),
            ', ',
            elemValue(elem('span', 'report'), serialize),
            elem('space', ' '),
            _formatDuration(_timeSince(end)),
          ])
        },
      },
    ],
    Initialize() {
      evaluator.none = Symbol('none')
      evaluator.history = Symbol('history')
    },
    call(expr, env = _newExecutionEnv(), thenElem) {
      if (call.pure) throw impure

      if (typeof document == ''+void 0) return

      const lang = _langAt(env), binds = _bindingsAt(env)
      let bindAs = null, prevBinding = evaluator.none

      const el = elem('div')

      el.classList.add('code')
      const prompt = elem('prompt')
      const query = elem('span')
      query.classList.add('editorContainer')
      query.append(prompt)
      query.append(serialize(expr, lang, binds, _evaluatorObservesInput[1] ? serialize.displayed : {...serialize.displayed, observe:false}))
      const waiting = _evaluationElem(env)
      env[_id(print)] = waiting
      el.append(query)
      el.append(waiting)

      prompt.title = 'Click to remove this.'
      prompt.onclick = () => { // Remove the evaluator.
        _getOuterWindow(el) && _getOuterWindow(el).firstChild === el && _restoreWindow(_getOuterWindow(el))
        env != null && _cancel(env), env = null
        thenElem ? el.replaceWith(thenElem) : elemRemove(el)
        elemValue(el, null, true, true), prompt.onclick = null

        _removeBinding(binds, bindAs)
      }
      elemValue(el, [evaluator, quote(expr), env])

      // Evaluate the requested expression.
      const start = _timeSince()
      ;[bindAs, expr] = _recognizeBinding(binds, expr)
      _doJob(expr, env, r => { // Got the result.
        const end = _timeSince(), real = _timeSince(start)

        r = _addBinding(binds, bindAs, r)
        if (!isArray(r) || r[0] !== _extracted) bindAs = null

        const pre = _smoothHeightPre(el)
        elemRemove(waiting)
        // Merge `_updateBroken` of both logged children into one.
        _updateBroken(el)

        // Display `_printAll evaluator ^(Result UserDuration RealDuration EndTime)`.
        el.append(daintyEvaluator([_printAll, evaluator, [quote, [r, env[_id(userTime)], real, end]]], _newExecutionEnv(env)))
        env = null
      })
      return el
    },
  },

  _formatDuration(x) {
    // Turns the number of milliseconds to a mostly-human-readable representation.
    return [
      elem('number', x < 1 ? x.toPrecision(6).replace(/\.?0+$/, '') : x < 10 ? x.toPrecision(3).replace(/\.?0+$/, '') : x < 1000 ? ''+(x|0) : (x/1000).toFixed(1)),
      x < 1000 ? 'ms' : 's',
    ]
  },

  _getOuterREPL(el) { return !el ? null : el.isREPL ? el : _getOuterREPL(el.parentNode) },

  _langAt(env = call.env) {
    if (!env) return fancier
    if (_id(_langAt) in env) return env[_id(_langAt)]
    const el = env[_id(print)]
    el = _getOuterREPL(el)
    if (el && isArray(el.to)) return el.to[1]
  },

  _bindingsAt(env = call.env) {
    if (!env) return Self.ctx
    if (_id(_bindingsAt) in env) return env[_id(_bindingsAt)]
    const el = env[_id(print)]
    el = _getOuterREPL(el)
    if (el && isArray(el.to)) return el.to[2]
  },

  _invertBindingContext(ctx, clear = false) {
    if (!(ctx instanceof Map)) throw console.error(ctx), "Invalid binding context"
    if (!_invertBindingContext.cache)
      _invertBindingContext.cache = new WeakMap, Object.freeze(_invertBindingContext)
    if (clear) return _invertBindingContext.cache.delete(ctx)
    if (_invertBindingContext.cache.has(ctx)) return _invertBindingContext.cache.get(ctx)
    const backctx = new Map
    ctx.forEach((to, name) => {
      if (typeof name == 'string') (name[0] !== '_' || !backctx.has(to)) && backctx.set(to, name)
    })
    _invertBindingContext.cache.set(ctx, backctx)
    return backctx
    // .cache
  },

  _removeChildren(el) {
    // Smoothly removes all children of a node.
    if (el.firstChild)
      for (let ch = el.lastChild; ch; ch = ch.previousSibling)
        if (!ch.removed)
          elemValue(ch, undefined, true, true), elemRemove(ch, true, true, false)
  },

  _autocompleteBrackets:[
    _(`settings`),
    `()[]{}`,
    `Whether to autocomplete brackets/quotes in \`editor\`s.
Pressing an opening bracket surrounds the cursor/selection.
Pressing a closing bracket surrounds the closest highlightable parent.`,
  ],

  _fullParseConstruction:[
    _(`settings`),
    false,
    `Whether \`editor\`s should \`construct\` parsed things fully when syntax-highlighting.
Leaving this off leaves objects like \`static\` or \`dataset\` unfilled, but makes parsing potentially much faster.`,
  ],

  _parseEditor(query, env = _newExecutionEnv(), syntaxOnly = false) {
    // Re-parses the contents of an element created with `editor`, highlighting the syntax and returning a promise.
    //   Returns a promise of its current value (or on .catch, the parsing error).
    const ed = query.lastChild, lang = query.to[2], binds = query.to[3]
    const s = getSelection(), i = _saveCaret(ed, s, false), j = _saveCaret(ed, s, true)
    return new Promise((then, err) => {
      _doJob([parse, ed, lang, binds, !syntaxOnly ? parse.dom : {...parse.dom, syntaxOnly}], env, r => {
        if (!_isError(r)) {
          const [expr, styled] = r
          while (ed.firstChild) ed.removeChild(ed.firstChild)
          ed.append(elem('div', styled))
          _updateBroken(ed.lastChild)
          if (i !== undefined && (document.activeElement === Self.into.parentNode.host || ed.contains(document.activeElement))) {
            const focus = _loadCaret(ed, i), anchor = _loadCaret(ed, j)
            s.setBaseAndExtent(...focus, ...anchor)
          }
          then(expr)
        } else
          err(r)
      })
    })
  },

  _editorError(query, expr) {
    // Displays the error message of editing, absolutely-positioned and quickly vanishing.
    let err = isArray(expr) && expr[0] === jsRejected && expr.length == 2 ? expr[1] : expr
    if (isArray(err) && err[0] === 'give more') err = err[1]
    try {
      const el = elem('error', err instanceof Element ? err : serialize(err, undefined, undefined, serialize.displayed))
      el.style.left = '1em'
      el.style.position = 'absolute'
      return elemInsert(query, el), void setTimeout(elemRemove, 1000, el)
    } catch (e) { return console.error(err) }
  },

  editor:{
    docs:`\`(editor InitialString Lang Binds OnInput OnEnter)\`: creates a user-editable expression input.
\`OnInput\` is passed the parsed expression and whether the currently entered text fails to parse. \`OnEnter\` is passed the expression and whether that's the parsing's error message, and it returns \`true\` to clear editor contents.
Don't do expensive synchronous tasks in \`OnInput\`.`,
    readAt:{
      _autocompleteBrackets:_(`_autocompleteBrackets`),
      _fullParseConstruction:_(`_fullParseConstruction`),
      _typingChill:_(`_typingChill`),
    },
    call(initialString = '', lang = fancier, binds = Self.ctx, onInput, onEnter, alwaysConstruct = false) {
      if (typeof initialString != 'string' && !(initialString instanceof Node))
        error('String expected, got', initialString)
      if (!(binds instanceof Map)) error('Map expected, got', binds)
      if (onInput && typeof onInput != 'function') error('Function or nothing expected, got', onInput)
      if (onEnter && typeof onEnter != 'function') error('Function or nothing expected, got', onEnter)

      // On any mutations inside, re-parse its contents, and call `onInput` if given.
      let chillId = null
      let parseEnv = null, important = false, prevText = ''
      const obs = new MutationObserver(_throttled(record => {
        if (!important && prevText === ed.textContent) return
        prevText = ed.textContent

        parseEnv && _cancel(parseEnv), parseEnv = _newExecutionEnv()
        important = false
        return _parseEditor(query, parseEnv, !(alwaysConstruct && _evaluateWhileTyping[1]) && !_fullParseConstruction[1]).
          then(v => { parseEnv = null, OnInput(v, false), obs.takeRecords(); return new Promise(then => setTimeout(then, 0)) }).
          catch(err => { parseEnv = null, OnInput(err, true), obs.takeRecords(), setTimeout(() => obs.takeRecords(), 50) })
      }, ms => Math.max(50, ms * (1/.2 - 1)), record => {
        for (let i=0; i < record.length; ++i) if (record[i].type === 'characterData') important = true
      }))

      // Create the element with the initial string.
      const ed = elem('node')
      ed.contentEditable = true
      ed.spellcheck = false
      obs.observe(ed, { childList:true, subtree:true, characterData:true })
      if (initialString && typeof initialString == 'string')
        ed.append(initialString)
      else if (initialString instanceof Node)
        ed.append(initialString)

      const query = elem('span')
      elemValue(query, [editor, initialString, lang, binds, onInput, onEnter])
      query.classList.add('editorContainer')
      query.classList.add('editable')
      const prompt = elem('prompt')
      query.append(prompt)
      prompt.title = 'Click to clear this.'
      prompt.onclick = () => _smoothHeight(ed, () => ed.textContent = '')
      query.append(ed)

      const undo = [[initialString]], redo = []

      ed.oninput = _throttled(() => {
        // Grow the undo buffer (and clear the redo buffer) on change.
        if (!undo.length || undo[undo.length-1].join('') !== _innerText(ed).join(''))
          redo.length = 0, undo.push(children(ed)), undo.length > 4096 && (undo.splice(0, undo.length - 4096))
      }, .05)
      let height
      ed.addEventListener('input', evt => {
        if (_disableSmoothTransitions[1]) return
        if (height) height = _smoothHeightPost(ed, height)
        else height = _smoothHeightPre(ed)
      })
      ed.onkeydown = evt => {
        if (evt.altKey) return

        // Arrows in contenteditable move the caret like a buffoon, so we help them.
        if (!evt.ctrlKey && (evt.key === 'ArrowLeft' || evt.key === 'ArrowRight')) {
          const s = getSelection()
          let focusNode = s.focusNode, focusOffset = s.focusOffset
          if (!s.isCollapsed && !evt.shiftKey && s.rangeCount) {
            const r = s.getRangeAt(0)
            if (evt.key === 'ArrowLeft')
              focusNode = r.startContainer, focusOffset = r.startOffset
            else
              focusNode = r.endContainer, focusOffset = r.endOffset
          }
          const delta = !s.isCollapsed && !evt.shiftKey ? 0 : evt.key === 'ArrowLeft' ? -1 : 1
          if (focusNode)
            if (!focusNode.nodeValue || focusOffset+delta < 0 || focusOffset+delta > focusNode.nodeValue.length) {
              _loadCaret(ed, _saveCaret(ed, s.anchorNode, s.anchorOffset))
              const i = _saveCaret(ed, focusNode, focusOffset) + delta
              const arr = _loadCaret(ed, i)
              if (evt.shiftKey)
                s.extend(...arr)
              else
                s.collapse(...arr)
              evt.preventDefault()
            }
        }

        // On Escape, blur editor (originally, so hover-highlighting becomes available, but now, just why not).
        if (evt.key === 'Escape' && document.activeElement === ed) ed.blur()

        // Brackets do not enter their character, instead they surround something with that bracket.
        // '(' surrounds the selection in brackets. ')' surrounds the closest highlightable parent in brackets.
        if (_autocompleteBrackets[1] && !evt.ctrlKey && getSelection().rangeCount) {
          const brackets = _autocompleteBrackets[1]
          const i = brackets.indexOf(evt.key)
          if (i >= 0 && i%2) { // Surround closest parent.
            const r = document.createRange(), el = _closestNodeParent(getSelection())
            if (!el) return
            r.selectNodeContents(el)
            return _bracketize(r, brackets.slice(i-1,i+1)), evt.preventDefault()
          } else if (i >= 0) // Surround selection.
            return _bracketize(getSelection().getRangeAt(0), brackets.slice(i,i+2)), evt.preventDefault()
        }
        // On Enter (unless with Shift or Ctrl), evaluate the expression.
        if (evt.key === 'Enter' && !evt.shiftKey && !evt.ctrlKey) evaluate(evt)

        // On Ctrl+Z, pop one from undo (and push to redo).
        if (evt.key === 'z' && !evt.shiftKey && evt.ctrlKey && undo.length) {
          if (undo[undo.length-1].join('') === _innerText(ed).join('')) undo.pop()
          if (undo.length)
            redo.push(children(ed)), children(ed, undo.pop()), evt.preventDefault()
        }
        // On Ctrl+Shift+Z, pop one from redo.
        if (evt.key === 'Z' && evt.shiftKey && evt.ctrlKey && redo.length)
          undo.push(children(ed)), children(ed, redo.pop()), evt.preventDefault()
      }
      return query

      function OnInput(expr, fail) {
        if (!onInput) return
        if (chillId != null) clearTimeout(chillId)
        chillId = setTimeout((expr, fail) => (chillId = null, onInput(expr, fail)), _typingChill[1], expr, fail)
      }
      function evaluate(evt) {
        let clear = false
        evt.preventDefault() // Since this doesn't work in promises.
        if (onEnter)
          _parseEditor(query)
          .then(expr => { if (onEnter && onEnter(expr, false)) ed.textContent = '', OnInput(undefined, true) })
          .catch(err => { if (onEnter && onEnter(err, true)) ed.textContent = '', OnInput(undefined, true) })
      }
      function children(el, to) { // Set children of `el` to `to`, or return an array of inner text of `el`.
        const pre = _smoothHeightPre(el)
        if (!to) return _innerText(el).map(e => typeof e == 'string' ? e : elemClone(e))
        while (el.firstChild) el.removeChild(el.firstChild)
        el.append(...to, elem('div'))
        _smoothHeightPost(el, pre)
      }
    },
  },

  _evaluateWhileTyping:[
    _(`settings`),
    true,
    `Whether to evaluate expressions as they are typed in a REPL.`,
  ],

  _typingChill:[
    _(`settings`),
    150,
    `Purification of expressions while typing is throttled by this many ms.`,
  ],

  _evaluatorObservesInput:[
    _(`settings`),
    false,
    `Whether \`evaluator\` will update the input representation when any object in it changes.
Too much updating when you're training a NN, so, off.`,
  ],

  REPL:{
    docs:`\`(REPL Language Bindings)\`: Creates a visual REPL element (read-evaluate-print loop).`,
    readAt:{
      editor:_(`editor`),
      evaluator:_(`evaluator`),
      daintyEvaluator:_(`daintyEvaluator`),
      _evaluateWhileTyping:_(`_evaluateWhileTyping`),
      _evaluatorObservesInput:_(`_evaluatorObservesInput`),
    },
    call(lang = fancier, binds = new Map(Self.ctx)) {
      if (!defines(lang, parse) || !defines(lang, serialize)) throw "Invalid language"
      if (!(binds instanceof Map)) throw "Invalid binding context"

      let env = _newExecutionEnv(null, null, lang, binds)

      if (typeof document == ''+void 0) { // NodeJS
        // Use the `repl` module to display colored prompts and command inputs/outputs.
        const msg = defines(lang, REPL)
        const repl = require('repl')
        const out = process.stdout
        if (!out.isTTY || !out.hasColors()) _colored.disabled = true
        const prompt = '> ', coloredPrompt = _colored(prompt, 31) // red
        const opt = serialize.displayed
        console.log('ctrl-D or .exit to exit.')
        console.log('A ' + serialize(REPL, basic, undefined, opt) + ' of language ' + serialize(lang, basic, undefined, opt) + (typeof msg == 'string' ? stringToDoc(': ' + msg).join('') : ''))
        const originalBinds = binds
        let n = 0
        opt.breakLength = out.columns
        repl.start({
          eval(cmd, _jsContext, _filename, then) {
            cmd = cmd.trim()
            try {
              print.did = false
              const expr = parse(cmd, undefined, binds)
              opt.breakLength = out.columns
              if (out.isTTY && !print.did) {
                const lines = Math.ceil((cmd.length + prompt.length) / out.columns)
                out.moveCursor(0, -lines)
                out.clearScreenDown()
                out.write(coloredPrompt + serialize(expr, undefined, undefined, {...opt, offset:(prompt.length+1)>>>1}) + '\n')
              }
              _schedule(expr, _newExecutionEnv(env, null, lang, binds), result => {
                // If binds contain result in values, set name to that; if not, create a new one.
                let name
                binds.forEach((v,k) => v === result && (name = k[1]))
                if (!name) do { name = '$' + n++ } while (binds.has(name))
                if (!binds.has(name))
                  (binds = new Map(binds)).set(name, quote(result))
                _bindingsAt.binds = binds
  
                then(null, _colored(name, 33) + ': ' + serialize(result, undefined, undefined, {...opt, offset:1+Math.ceil(name.length/2+.5)})) // brown
              })
            } catch (err) {
              if (isArray(err) && err[0] === 'give more') then(new repl.Recoverable(err))
              else console.log(typeof err == 'string' ? _colored(err, 31) : err), then() // red
            }
          },
          writer: x => x,
          completer: cmd => {
            const arr = /[^`=\s\[\]]+$/.exec(cmd)
            const begins = arr ? arr[0] : ''
            const matches = []
            binds.forEach((_v,k) => k.slice(0, begins.length) === begins && matches.push(k))
            return [matches, begins]
          },
          coloredPrompt,
        }).on('reset', () => { binds = originalBinds, n = 0 }) // .clear
        // Cannot seem to react to SIGINT (and stop execution).
        return
      }
      // Else Browser

      if (call.pure) throw impure

      const repl = elem('node')
      repl.isREPL = true, repl.classList.add('REPL')
      const us = [REPL, lang, binds]
      observe(us, function onChange(us) {
        if (!repl.isConnected) return observe(us, onChange, false)
        lang = us[1], binds = us[2]
        env = _newExecutionEnv(null, null, lang, binds)
        const contents = lastExpr === undefined ? '' : serialize(lastExpr, lang, binds, {...serialize.displayed, observe:false}).firstChild
        query.replaceWith(query = editor(contents, lang, binds, purifyAndDisplay, evaluate, true))
        langDisplay.replaceWith(langDisplay = serialize(lang, basic, undefined, serialize.displayed))
        const a = [...repl.querySelectorAll('serialization')]
        if (a.length < 64) a.forEach(el => {
          if (el !== langDisplay && !_isEditable(el)) el.replaceWith(serialize(el.firstChild.to, lang, binds, serialize.displayed))
        })
      }, true)
      elemValue(repl, us)

      // Display purified output.
      const pureOutput = elem('div')
      pureOutput.classList.add('code')
      pureOutput.style.display = 'inline-block'
      pureOutput.style.position = 'relative'
      let penv, waiting, lastExpr
      const purifyAndDisplay = _throttled((expr, fail) => {
        if (msg === false && isArray(expr) && expr[0] === jsEval && typeof expr[1] == 'string' && expr[2]) expr = [randomNat, 2]
        const pre = _smoothHeightPre(pureOutput)
        if (penv !== undefined) _cancel(penv), waiting.remove(), penv = undefined, waiting = undefined
        let promise
        if (_evaluateWhileTyping[1]) {
          _removeChildren(pureOutput)
          if (!fail) promise = new Promise(then => {
            const e = penv = _newExecutionEnv(env, null, lang, binds)
            e[_id(print)] = waiting = _evaluationElem(penv), call.env = penv
            const bindAs = isArray(expr) && expr[0] === _extracted && expr.length == 3 && _isLabel(expr[1]) ? expr[1] : null
            if (bindAs) expr = expr[2]
            pureOutput.append(waiting)
            _doJob(_isError(expr) ? quote(expr) : [purify, quote(expr)], penv, result => {
              const pre = _smoothHeightPre(pureOutput)
              try {
                waiting && waiting.remove(), waiting = undefined
                if (_isUnknown(result) && _isError(result[1]))
                  result = result[1] // Display errors too.
                if (bindAs) result = [_extracted, bindAs, result]

                if (!_isUnknown(result)) {
                  // Display `_printAll evaluator (Result)`.
                  pureOutput.append(daintyEvaluator([_printAll, evaluator, [quote, [result]]], _newExecutionEnv(penv)))
                } else {
                  const btn = button(evaluateCurrent, 'evaluate')
                  btn.doNotCloseTheContextMenuOnClick = true
                  elemInsert(pureOutput, elemValue(btn, result))
                }
              } finally { _smoothHeightPost(pureOutput, pre), penv = undefined, then(e[_id(userTime)]) }
            })
            _smoothHeightPost(pureOutput, pre)
          }); else if (expr !== undefined) {
            let el = expr
            if (isArray(el) && el[0] === jsRejected && isArray(el[1]) && el[1][0] === 'give more')
              el = el[1][1] === 'No value at top level' ? undefined : elem('error', el[1][1])
            el && elemInsert(pureOutput, serialize(el, lang, binds, serialize.displayed))
            _smoothHeightPost(pureOutput, pre)
          }
        } else {
          if (pureOutput.lastChild && pureOutput.firstChild === pureOutput.lastChild && pureOutput.lastChild.tagName === 'BUTTON') return
          _removeChildren(pureOutput)
          const btn = button(evaluateCurrent, 'evaluate')
          btn.doNotCloseTheContextMenuOnClick = true
          pureOutput.append(elemValue(btn, evaluator))
          _reflow().then(() => _smoothHeightPost(pureOutput, pre))
        }
        return promise
      }, .1, expr => lastExpr = expr)

      const evaluateCurrent = () => _parseEditor(query).then(evaluate).catch(err => evaluate(err, true))
      const evaluate = (expr, fail) => {
        if (fail) return
        const prev = call.env, e = _newExecutionEnv(env), ev = evaluator(expr, e)
        call.env = env
        try { return print(ev), true }
        finally { call.env = prev }
      }
      repl.classList.add('code')

      const msg = defines(lang, REPL)
      let langDisplay
      repl.append(elem('text', [
        'A ',
        serialize(REPL, basic, undefined, serialize.displayed),
        ' of language ',
        langDisplay = serialize(lang, basic, undefined, serialize.displayed),
        typeof msg == 'string' ? stringToDoc(': ' + msg) : elem('span')]))

      let query = editor('', lang, binds, purifyAndDisplay, evaluate, true)
      repl.append(query)
      repl.append(pureOutput)
      env[_id(print)] = query
      return repl
    },
  },

  button:{
    docs:`\`(button OnClick)\`: Returns a button that calls a function on click (with no arguments). Overridable.`,
    call(f, name, title) {
      const backctx = _invertBindingContext(Self.ctx)
      if (typeof name != 'string' && !_isDOM(name)) name = backctx.has(f) ? backctx.get(f) : f && f.displayName || f && f.name
      if (!name) name = 'Execute'
      if (typeof defines(f, button) == 'function') return defines(f, button)()
      else if (typeof defines(f, button) == 'string') name = defines(f, button)
      if (f instanceof Node) return f
      if (typeof f != 'function') error("Cannot call not-a-function:", f)

      if (typeof name == 'string')
        name = name.replace(/[A-Z]/g, s => ' '+s.toLowerCase()),
        name = name[0].toUpperCase() + name.slice(1)

      const el = elem('button')
      if (title) el.title = title
      el.onclick = f
      el.append(name)
      return el
    },
  },

  files:{
    docs:`\`(elem files StringMap)\`: an element for downloading files.`,
    elem(tag, content, name = 'Files:') {
      if (tag != files) error('...')
      const el = elem('details', elem('summary', name))
      if (content instanceof Map)
        content.forEach((value, name) => _appendFile(el, name, value) )
      else if (typeof content == 'object' && !content[defines.key])
        Object.keys(content).forEach(k => _appendFile(el, k, content[k]))
      else error('...')
      el.open = true
      return el
    },
  },

  url:{
    docs:`Creates a URL element.`,
    elem(tag, href, contents = href) {
      if (typeof href != 'string') errorStack("Must be a string:", href)
      if (tag !== url || typeof document == ''+void 0) return href
      const el = elem('a', contents)
      elemValue(el, [elem, url, href])
      el.href = href
      el.title = decodeURI(href)
      if (el.title.slice(0,8) === 'https://') el.title = el.title.slice(8)
      if (el.title.slice(0,7) === 'file://') el.title = el.title.slice(7)
      return el
    },
  },

  _expandTutorialBindings:[
    _(`settings`),
    true,
    `If checked, \`a:b\` bindings will serialize as \`a:b\` when evaluated, else as \`a:a\`.`,
  ],

  tutorial:{
    docs:`\`tutorial Func\`: views the unlockable code tutorial of \`Func\`, if available.
\`tutorial()\`: views all globally-available tutorials.

All tutorials are finite. Savor them while they last.`,
    readAt:{
      _expandTutorialBindings:_(`_expandTutorialBindings`),
    },
    tutorial:[
      `A nice, sunny day out, with not a single cloud in sight.
Let's make our understanding of tutorials as clear as the weather.
Yes, before accessing any tutorials, we have to know: what exactly is a tutorial?

Tutorials are a way of explaining ourselves to other humans as a way to leave a mark in their hearts. You better make your thing understandable, and you better be nice, or no immortality for you.

But first, we need to make sure that you can type characters. Yes, just type out \`'Let me in'\` in the field below and press Enter, very, very gently. Remember that your keyboard can be your friend for decades to come if you don't neglect it. And so can we.`,
      [
        _(`fancy`),
        ``,
        `Let me in`,
      ],
      `Good work getting this far. I cannot even imagine the trouble you went through, but for what you did, we are grateful.

Tutorials in \`tutorial\` are arrays of either text (like what you are reading) or an array of the language (see \`Languages\`) then the initial string (then optionally either the intended result or a function that judges whether the result is OK and we can continue; this is why you had to type in the thing above to see this).

Try making a tutorial from this description. Have to hand it to you: remember that \`(Func …Args)\` is how you call functions, \`(array …Items)\` is how you make arrays, and that \`fancy\` is the most basic language.`,
      [
        _(`fancy`),
        ``,
        function(result) { return result instanceof Node && result.tagName === 'TUTORIAL' },
      ],
      `Ah. The hero is here, long awaited, to save us from our troubles of not knowing how to make tutorials.

Rest would be mistimed now. You are a hacker, and you must drill deeper into the representations. Right-click on \`tutorial\` to summon a \`contextMenu\` on it, find its tutorial, and see what value will allow you to progress.`,
      [
        _(`fancy`),
        `'So, on a scale from one to ten, how much did the last person you killed deserve it?'`,
        `0`,
      ],
      `Or did you expect to have the answer handed to you? No one will give you anything if you don't take it.

Now, type \`tutorial call\` (to know the basics) or \`tutorial callAdjust\` (to know the future) and claim what's yours.`,
      [
        _(`fancy`),
      ],
      `(If you get tired of how linear the narration is, use \`docs()\` (or \`(docs)\`, depending on the sub-language) to see everything this place has to offer.)`,
    ],
    call(f = undefined) {
      // Did you ever hear the tragedy of Darth Plagueis the Wise?
      // […]
      // Unfortunately, he taught his apprentice everything he knew, then his apprentice killed him in his sleep.
      // Ironic. He could save others from death, but not himself.
      if (f === undefined) {
        const m = _allocMap()
        Self.ctx.forEach(global => {
          if (!isArray(global) && isArray(defines(global, tutorial)))
            m.set(global, tutorial(global))
        })
        return hierarchy(m, elem('div', 'All available code tutorials:'))
      }
      let t = isArray(f) ? f : defines(f, tutorial), i = 0, result = elem('tutorial')
      if (!isArray(t)) return
      const binds = new Map(Self.ctx)
      emit()
      return result

      function emit(toEnd = true) {
        if (toEnd) {
          const pre = _smoothHeightPre(result)
          while (emit(false));
          _reflow().then(() => _smoothHeightPost(result, pre))
          setTimeout(() => result.style.removeProperty('height'), 1000)
          return
        }
        if (i >= t.length) return false
        let v = t[i++]
        if (typeof v == 'string')
          result.append(elem('separated-text', stringToDoc(v)))
        else if (isArray(v)) {
          const [lang, initialCode='', canContinue] = v
          const results = elem('div')
          results.classList.add('code')
          let passed = false, env, bindAs, expr
          const OnInput = (x, fail) => !fail && (expr = x, elemValue(btn, x))
          const OnEnter = (x, fail) => {
            // Evaluate the expression, bind to a label if requested, and check its validity to see whether to continue.
            elemValue(btn, x)
            const pre = _smoothHeightPre(results)
            while (results.firstChild) elemValue(results.firstChild, null, true, true), results.firstChild.remove()
            if (env) env.then ? env.cancel && env.cancel() : _cancel(env), env = null
            if (fail) {
              let err = isArray(x) && x[0] === jsRejected && x.length == 2 ? x[1] : x
              if (isArray(err) && err[0] === 'give more') err = err[1]
              const el = elem('error', err instanceof Element ? err : serialize(err, undefined, undefined, serialize.displayed))
              elemInsert(results, el)
              return
            }

            env = _newExecutionEnv(null, null, lang, binds)
            results.append(env[_id(print)] = _evaluationElem(env))
            _reflow().then(() => _smoothHeightPost(results, pre))

            let y; [bindAs, y] = _recognizeBinding(binds, x)
            _removeBinding(binds, bindAs)
            const start = _timeSince()
            _schedule(y, env, r => {
              const end = _timeSince(), real = _timeSince(start)
              r = _addBinding(binds, bindAs, r)
              const prevEvalElem = env[_id(print)] instanceof Map ? env[_id(print)].get(print) : env[_id(print)]
              const pre = _smoothHeightPre(results)
              prevEvalElem.remove()

              // Display `_printAll evaluator ^(Result UserDuration RealDuration EndTime)`.
              let withoutBinding = bindAs ? new Map(binds) : binds;  _expandTutorialBindings[1] && bindAs && withoutBinding.delete(_unlabel(bindAs))
              const e = _newExecutionEnv(env)
              e[_id(_bindingsAt)] = withoutBinding
              results.append(daintyEvaluator([_printAll, evaluator, [quote, [r, env[_id(userTime)], real, end]]], e))

              if (!passed)
                if (typeof canContinue == 'function') {
                  env = _newExecutionEnv(env)
                  let evalElem
                  results.append(evalElem = env[_id(print)] = _evaluationElem(env))
                  _doJob([canContinue, quote(r)], env, function checkOk(ok) {
                    if (ok && typeof ok == 'object' && ok.then) {
                      ok.then(checkOk)
                      env = ok
                    } else {
                      elemRemove(evalElem, true, true, false)
                      if (ok) passed = true, emit()
                      env = null
                    }
                    expr = x
                  })
                } else if (env = null, canContinue !== undefined)
                  if (r === canContinue)
                    passed = true, emit(), elemRemove(btn, true, true, false)
              _reflow().then(() => _smoothHeightPost(results, pre))
              expr = x
            })
            return false
          }
          const ed = editor(initialCode, lang, binds, OnInput, OnEnter)
          const btn = elemValue(button(evt => (evt.preventDefault(), _parseEditor(ed).then(OnEnter).catch(err => OnEnter(err, true))), 'evaluate'), evaluator)
          result.append(ed)
          result.append(btn)
          result.append(results)
          if (canContinue !== undefined) return false
        } else
          error('Expected a string or a (Language InitialCode CanContinueFunc) array but got', v)
        return true
      }
    },
  },

  editObject:{
    todo:`Replace \`construct\`s within with non-expandable references, so that it's possible to edit particular things in complex graphs without doubling every object.`,
    docs:`\`editObject Object\`: allows the user to edit the runtime object in-place.
\`editObject Object null\` checks whether the object is editable.
\`editObject Object Language\` specifies the editor's language.`,
    call(x, lang) {
      if (!isArray(x) && defines(x, deconstruct) === undefined && !(x instanceof Map)) return
      if (defines(deconstruct(x), editObject) === false) return
      if (isArray(x) && Object.isFrozen(x)) return
      if (lang === null) return true

      const opts = {...serialize.displayed, collapseDepth:0, collapseBreadth:0}
      const coll = item => {
        if (typeof item == 'number' || typeof item == 'string' || typeof item == 'boolean' || _invertBindingContext(Self.ctx).has(item))
          return item
        if (!isArray(item)) { // Insert references to other objects, don't just create doubles of them.
          const el = elemValue(elem('collapsed', '···'), item)
          return el.special = true, el
        }
      }
      let dec = bound(coll, deconstruct(x), false)
      const initial = serialize(dec, lang, Self.ctx, opts).firstChild
      const indicator = elem('span')
      let expr = x
      const ed = editor(initial, lang, Self.ctx, (next, fail) => {
        if (fail) return
        updateIndicator(expr = next)
      }, (next, fail) => {
        if (fail) return _editorError(ed, next)
        const v = !isArray(next) && defines(next, deconstruct) ? deconstruct(next) : next
        writeAt(x, undefined, v)
        updateIndicator(expr = next)
      })
      const observer = () => {
        if (!ed.isConnected) observe(x, observer, false)
        else updateIndicator()
      }
      observe(x, observer, true)
      updateIndicator()
      return elem('edit-object', [indicator, ed])

      function updateIndicator() {
        const dx = isArray(x) ? x : deconstruct(x), dy = isArray(expr) ? expr : deconstruct(expr)
        if (Object.getPrototypeOf(x) !== Object.getPrototypeOf(expr) || isArray(dx) && (!isArray(dy) || dx[0] !== dy[0]))
          indicator.textContent = '❌ ', indicator.title = 'Invalid type.'
        else if (_hasSameRepr(x, expr))
          indicator.textContent = '✅ ', indicator.title = 'Up-to-date.'
        else
          indicator.textContent = '⬜ ', indicator.title = 'Changed. Can commit this (via Enter).'
      }
    },
  },

  _hasSameRepr(a, b) {
    const coll = item => {
      if (typeof item == 'number' || typeof item == 'string' || typeof item == 'boolean' || _invertBindingContext(Self.ctx).has(item))
        return item
      if (!isArray(item))
        return _id(item)
    }
    a = serialize(bound(coll, deconstruct(a), false), basic)
    if (isArray(a)) a = a.join('')
    b = serialize(bound(coll, deconstruct(b), false), basic)
    if (isArray(b)) b = b.join('')
    return a === b
  },

  _unlabel(x) { return isArray(x) && x[0] === label ? x[1] : x },

  editRewrite:{
    docs:`\`editRewrite Global\`: changes the global for the next \`Rewrite\`.
Also supports \`editRewrite Global null\` to check whether an object can be rewritten, and \`editRewrite Global Language\` to specify a different editing language.`,
    call(x = undefined, lang) {
      const backctx = _invertBindingContext(Self.ctx)
      if (typeof x != 'object' && typeof x != 'function') return
      if (!readAt.parents.has(x) && !backctx.has(x)) return
      if (lang === null) return true
      let key = backctx.has(x) ? label(backctx.get(x)) : x
      let keyPreview = key
      let value = Rewrite.ctx.has(x) ? Rewrite.ctx.get(x) : x
      const indicator = elem('div')
      updateIndicator()
      const keyEditor = editor(key === x ? '' : key[1], stringLanguage, Rewrite.ctx, (k, fail) => {
        if (!fail) keyPreview = k ? label(k) : x, updateIndicator()
      }, (k, fail) => {
        Rewrite.ctx.delete(key)
        key = keyPreview = k ? label(k) : x
        !fail && (Rewrite.ctx.set(_unlabel(key), value), Rewrite.ctx.set(x, value))
        updateIndicator()
      })
      let dec = deconstruct(value)
      if (isArray(dec) && defines(dec, construct)) dec = make(...dec) // Sure hope there are no interrupts.
      const valueEditor = editor(serialize(dec, lang), lang, Rewrite.ctx, (v, fail) => {
        if (!fail) value=v, updateIndicator()
      }, (v, fail) => {
        value = v
        if (!fail)
          Rewrite.ctx.set(_unlabel(key), value), Rewrite.ctx.set(x, value)
        else if (v === undefined)
          Rewrite.ctx.delete(_unlabel(key)), Rewrite.ctx.set(x, undefined)
        else _editorError(valueEditor, v)
        updateIndicator()
      })
      return elem('div', [indicator, keyEditor, valueEditor, elemCollapse(Rewrite)])

      function updateIndicator() {
        const ctx = Rewrite.ctx, key = _unlabel(keyPreview)
        if (value === undefined)
          Self.ctx.has(key) ? (ctx.set(key, Self.ctx.get(key)), ctx.set(x, Self.ctx.get(key))) : (ctx.delete(key), ctx.set(x, undefined))
        else if (_hasSameRepr(value, ctx.get(key)))
          key !== value ? (ctx.set(key, value), ctx.set(x, value)) : (ctx.delete(key), ctx.set(x, undefined))
        _invertBindingContext(ctx, true)
        if (_isLabel(key) ? _hasSameRepr(value, Self.ctx.get(key)) : !ctx.has(key))
          indicator.textContent = '✅ ', indicator.title = 'Up-to-date, non-edited.'
        else if (ctx.get(key) === value)
          indicator.textContent = '➕ ', indicator.title = 'Changed from self. Changes will be seen in the next rewrite.'
        else
          indicator.textContent = '⬜ ', indicator.title = 'Changed from the rewrite. Can commit this.'
      }
    },
  },

  settings:{
    docs:`\`settings()\`: presents a hierarchy of all global user-modifiable settings.
\`settings Opt\`: presents the interface to change one option.`,
    readAt:{
      Commands:_(`Commands`),
      rangeSetting:_(`rangeSetting`),
      settingsToolbar:_(`settingsToolbar`),
    },
    call(opt) {
      if (opt === undefined) {
        const m = _allocMap()
        Self.ctx.forEach(global => {
          if (isArray(global) && global[0] === settings)
            m.set(global, settings(global))
        })
        return hierarchy(m, elem('span', 'Current settings:'))
      } else {
        // An option is [settings, Value, HumanReadableName, OptToElemFunc].
        opt = _unquote(opt)
        if (!isArray(opt) || opt[0] !== settings) {
          if (isArray(opt) || !opt || typeof opt != 'object' && typeof opt != 'function') return opt
          const m = _allocMap(), visited = new Set
          walk(opt)
          function walk(x) {
            if (visited.has(x)) return;  else visited.add(x)
            if (isArray(x) && x[0] === settings) m.set(x, settings(x))
            const ra = !isArray(x) && defines(x, readAt)
            if (ra) for (let k in ra) walk(ra[k])
          }
          return m.size ? hierarchy(m, elem('span', 'Settings:')) : opt
        }
        let el
        if (typeof opt[3] == 'function')
          // The func, if present, accepts the opt array where a[1] is the value, and optionally the element (to update it).
          el = opt[3](opt)
        else {
          if (typeof opt[1] == 'boolean')
            el = elem('input'), el.type = 'checkbox', el.checked = opt[1],
            el.oninput = el.onchange = () => writeAt(opt, 1, !!el.checked)
          else if (typeof opt[1] == 'number')
            el = elem('input'), el.type = 'number', el.value = opt[1],
            el.oninput = el.onchange = () => writeAt(opt, 1, +el.value)
          else if (typeof opt[1] == 'string')
            el = elem('textarea'), el.value = opt[1],
            el.oninput = el.onchange = () => writeAt(opt, 1, el.value)
          else
            error('Cannot infer the visual type of', opt[1])
        }

        const whole = elem('settings', [el, elem('label')])
        if (!settings.n) settings.n = 0
        el.name = whole.lastChild.htmlFor = 'st' + (settings.n++)

        elemValue(el, opt)
        if (!el.title) el.title = opt[2]
        el.special = true
        whole.lastChild.textContent = el.title
        const observer = opt => {
          el.title = opt[2]
          if (!el.isConnected) observe(opt, observer, false)
          if (typeof opt[3] == 'function')
            opt[3](opt, el)
          else if (typeof opt[1] != 'boolean')
            el.value = opt[1]
          else
            el.checked = opt[1]
          whole.lastChild.textContent = el.title
          el.dispatchEvent(new Event('input', {bubbles:true}))
        }
        observe(opt, observer, true)
        return whole
      }
    },
  },

  rangeSetting(opt, el) {
    // Creates an <input type=range> when used in a `settings` array as setting[3].
    //   Extra arguments after this are min, max, step.
    //   Step can be a number for a linear scale, or `true` for exponential scale.
    if (!el) {
      el = elem('input')
      el.type = 'range'
      el.style.margin = el.style.padding = 0
      el.oninput = el.onchange = () => writeAt(opt, 1, typeof opt[6] == 'number' ? +el.value : Math.exp(+el.value))
    }
    el.min = delog(opt[4] || 0, opt[6])
    el.max = delog(opt[5] || 1, opt[6])
    el.step = typeof opt[6] == 'number' ? (opt[6] || .01) : .01
    el.value = delog(opt[1], opt[6])
    el.title = (opt[2] || '').replace(/%%%/g, ((opt[1]*100)|0)+'%').replace(/\?\?\?/g, opt[1])
    return el
    function delog(x, st) { return typeof st == 'number' ? x : Math.log(x) }
  },

  Commands:new Map([
    ['AuxClick', _(`contextMenu`)],
    ['CtrlClick', _(`insertLinkTo`)],
    ['z', function(target, range, evt) { // Click/uncollapse.
      if (target && target.tagName === 'COLLAPSED' && target.lastChild && target.lastChild.tagName === 'HIDDEN')
        return evt = target.lastChild.lastChild, target.click(), evt // Don't lose the element.
      target && target.click && target.click()
    }],
    ['x', function(target, range, evt) { // Collapse.
      if (target && !_isEditable(target)) return elemCollapse(target)
      if (!target || target.to === undefined) return
      return evt = elemValue(elem('collapsed', '···'), target.to), evt.special = true, target.replaceWith(evt), evt
    }],
    ['c', function(target, range, evt) { // Context-menu.
      contextMenu(target, range)
    }],
    ['v', function(target, range, evt) { // Highlight values.
      Self.into.classList.toggle('noValueHighlight', !!_hoverHighlightsDOMValues[1], true)
      writeAt(_hoverHighlightsDOMValues, 1, !_hoverHighlightsDOMValues[1])
    }],
  ]),

  _getNextSibling(el) {
    // Seems to work.
    return el.nextSibling || el.parentNode && getComputedStyle(el.parentNode).display !== 'block' && _getNextSibling(el.parentNode) || el.nextSibling
  },

  _stopIteration:{
    docs:`A marker for stopping iteration.`,
  },

  _visitText:{
    docs:`Calls f(String, TextNode) or f(false, SpecialElem) for each substring in el as parsing sees it.
Return \`_stopIteration\` to stop iteration.`,
    call(el, f) {
      if (!el) return
      if (el.tagName === 'BR') return f(_getNextSibling(el) ? '\n' : '', el)
      if (!(el instanceof Element)) {
        return f(el.textContent.slice(-1) !== '\n' || _getNextSibling(el) ? el.textContent : el.textContent.slice(0,-1), el)
      }
      if (el.special) return f(false, el)
      for (let ch = el.firstChild; ch; ch = ch.nextSibling) {
        if (_visitText(ch, f) === _stopIteration) return _stopIteration
        if (_getNextSibling(ch) && (ch.tagName === 'DIV' || ch.tagName === 'P'))
          if (f('\n', _getNextSibling(ch)) === _stopIteration) return _stopIteration
      }
    },
  },

  _saveCaret(el, ch, i) { // → index
    if (ch instanceof Selection && !ch.rangeCount) return 0
    if (ch instanceof Selection) !i ? (i = ch.focusOffset, ch = ch.focusNode) : (i = ch.anchorOffset, ch = ch.anchorNode)
    if (ch instanceof Element) ch = i < ch.childNodes.length ? ch.childNodes[i] : _getNextSibling(ch), i = 0
    if (ch && ch.parentNode.special) i = i ? ch.parentNode.childNodes.length : 0, ch = ch.parentNode
    while (!i && ch && ch.firstChild && !ch.special) ch = ch.firstChild

    let j = i || 0
    _visitText(el, (s, el) => {
      // Non-contenteditable elements in contenteditable are treated atrociously, so we resort to these hacks (pull everything in <collapsed> out of it — not relevant if selection went through _loadCaret, but there is no guarantee of that).
      if (el.tagName === 'COLLAPSED' && el.firstChild && el.firstChild === el.lastChild) {
        if (el.firstChild === ch) ch = el
        const from = el.firstChild.textContent
        if (from.indexOf('···') >= 0) {
          const s = from.replace('···', '')
          if (s) el.parentNode.insertBefore(document.createTextNode(s), el.nextSibling), el.firstChild.textContent = '···'
        } else
          el.remove(), --j
      } else if (el.tagName === 'COLLAPSED' || el.tagName === 'SERIALIZATION') {
        if (el.tagName === 'COLLAPSED') {
          if (!el.firstChild || el.firstChild.tagName !== 'HIDDEN')
            el.insertBefore(elem('hidden'), el.firstChild)
        }
        while (el.parentNode && el.firstChild !== el.lastChild)
          el.parentNode.insertBefore(el.firstChild, el.nextSibling)
      }

      return el === ch ? _stopIteration : s === false ? ++j : j += s.length
    })
    return j
  },

  _loadCaret(el, index, into) { // → [ch, i]
    if (index < 0) index = 0
    let j = 0, i = 0, result, arr = []
    _visitText(el, (s, el) => {
      arr.push(s)
      const len = s === false ? 1 : s.length
      if (j + len >= index) return result = el, i = index - j, _stopIteration
      j += len
    })
    let ch = result
    if (ch && !(ch instanceof Element) && i === ch.nodeValue.length && _getNextSibling(ch)) ch = _getNextSibling(ch), i = 0
    if (index == null) ch = null
    if (ch && ch.special)
      [ch, i] = [ch.parentNode, [...ch.parentNode.childNodes].indexOf(ch) + (i ? 1 : 0)]
    if (ch && ch instanceof Element && i > ch.childNodes.length) i = ch.childNodes.length
    if (ch && !(ch instanceof Element) && i > ch.nodeValue.length) i = ch.nodeValue.length
    !ch && ([ch, i] = [el, el.childNodes.length - (el.lastChild && !el.lastChild.textContent ? 1 : 0) || 0])
    if (into instanceof Selection) into.collapse(ch, i)
    else return [ch, i]
  },

  _innerText:{
    docs:`Returns the inner text of an element (in an array with strings and other things), preserving .special elements.`,
    call(el) {
      const a = [], str = []
      let s
      _visitText(el, (s, el) => s === false ? (str.length && (s = str.join(''), s && a.push(s), str.length = 0), a.push(el)) : str.push(s))
      str.length && (s = str.join(''), s && a.push(s), str.length = 0)
      return a
    },
  },

  _smoothHeight(el, f) {
    const pre = _smoothHeightPre(el)
    f()
    _reflow().then(() => _smoothHeightPost(el, pre))
  },

  _smoothTransformPre(el) {
    if (_disableSmoothTransitions[1]) return
    if (el instanceof Element) el = el.getBoundingClientRect()
    else if (!el || el.left === undefined || el.top === undefined) return
    return [el.left + scrollX, el.top + scrollY, el.right - el.left, el.bottom - el.top]
  },

  _smoothTransformPost:{
    docs:`For moving non position:inline elements from and to an arbitrary document location, smoothly and without lag. Use \`_smoothTransformPre\` to fill in \`pre\`.`,
    call(el, pre, delay = 0) {
      if (_disableSmoothTransitions[1]) return
      if (!pre || !(el instanceof Element)) return
      const post = _smoothTransformPre(el)
      if (!post || el.style.display || el.style.transform || el.style.transform && el.style.transform !== 'none') return
      if (pre[0] === post[0] && pre[1] === post[1]) return post
      el.style.display = 'none'
      el.style.transformOrigin = '0 0'
      const scale = pre[2] === post[2] && pre[3] === post[3] ? '' : `scale(${pre[2] / post[2]},${pre[3] / post[3]})`
      el.style.transform = `translate(${pre[0] - post[0]}px, ${pre[1] - post[1]}px) ${scale}`
      const spec = el.special
      el.special = (el, to) => {
        _reflow().then(() => {
          to.style.removeProperty('display')
          _reflow().then(() => {
            setTimeout(() => (to.style.removeProperty('transform-origin'), to.style.removeProperty('transform'), _clearStyle(to), to.special = spec), delay)
          })
        })
        el && typeof spec == 'function' && spec(el, to)
      }
      el.special(null, el)
    },
  },

  _reflow() {
    if (_reflow.p) return _reflow.p
    return _reflow.p = Promise.resolve().then(() => (_reflow.p = null, Self.into.offsetWidth))
  },

  _smoothHeightPre(el) { return !_disableSmoothTransitions[1] && el instanceof Element && el.offsetHeight || 0 },

  _smoothHeightPost:{
    docs:`Since height:auto does not transition by default (because it's too laggy for non-trivial layouts), we explicitly help it (because we don't care).
Call this with the element and the result of \`_smoothHeightPre\` to transition smoothly.`,
    call(el, pre) {
      if (pre === undefined) error("The previous height is needed")
      if (!(el instanceof Element)) return
      if (_disableSmoothTransitions[1]) return 0
      el.style.removeProperty('height')

      const post = _smoothHeightPre(el)
      if (pre !== post && pre !== parseFloat(el.style.height)) {
        el.style.height = pre + 'px'
        _reflow().then(() => el.style.height = post + 'px')
      }
      return post
    },
  },

  elemInsert:{
    docs:`Inserts a DOM element into the displayed DOM tree smoothly (if CSS transitions are enabled for it, and are specified in seconds, with all-props being the first specified one), by transitioning height from 0.
Very bad performance if a lot of inserts happen at the same time, but as good as it can be for intermittent smooth single-element-tree insertions.`,
    call(into, el, before = null) {
      if (el === undefined) return
      if (el.parentNode) el = elemClone(el)
      if (typeof el == 'string') el = document.createTextNode(el)
      const pre = _smoothHeightPre(into)
      const wasMax = _updateMaxScrollBegin()

      try { into.insertBefore(el, before) }
      catch (err) { console.error(into, el, before); throw err }
      _updateBroken(into)
 
      _smoothHeightPost(into, pre)
      _updateMaxScrollEnd(wasMax)

      if (_isStylableDOM(el))
        _smoothHeightPost(el, 0)
      return el
    },
  },

  elemRemove:{
    docs:`Removes a DOM element from the displayed document smoothly (if CSS transitions are enabled for it, and are specified in seconds, with all-props being the first), by transitioning height and opacity to 0.`,
    readAt:{
      particles:_(`particles`),
    },
    call(el, absolutize = false, doParticles = true, doHeight = true) {
      if (!el || el.removed) return
      el.removed = true
      if (!(el instanceof Element)) return el.remove ? el.remove() : errorStack('Not an element')

      if (doParticles) {
        const r1 = el.getBoundingClientRect(), r2 = (Self.into !== document.body ? Self.into : document.documentElement).getBoundingClientRect()
        _reflow().then(() => particles(r1.left - r2.left, r1.top - r2.top, r1.width, r1.height))
      }

      let height, dur, from, pre
      const style = getComputedStyle(el)
      dur = parseFloat(style.transitionDuration)*1000 || 0
      if (doHeight) {
        height = style.height
        if (height === undefined) height = el.offsetHeight
        from = el.parentNode
        pre = _smoothHeightPre(from)
      }

      if (absolutize) {
        const mx = parseFloat(getComputedStyle(el).marginLeft)
        const my = parseFloat(getComputedStyle(el).marginTop)
        const x = el.offsetLeft - mx, y = el.offsetTop - my, w = el.offsetWidth
        el.style.position = 'absolute'
        el.style.left = x + 'px'
        el.style.top = y + 'px'
        el.style.width = w+1 + 'px'
      }

      _reflow().then(() => {
        if (dur) {
          el.classList.add('removed')
          if (doHeight) el.style.height = height
          el.style.opacity = 0, el.style.pointerEvents = 'none'
          if (doHeight)
            _reflow().then(() => el.style.height = 0)
          setTimeout(el => el.remove(), dur, el)
        } else el.remove()
        if (doHeight) _smoothHeightPost(from, pre)
      })
      return el
    },
  },

  _removalParticlesFrequency:[
    _(`settings`),
    .5,
    `The probability of extra effects for removing a visual element is %%%.`,
    _(`rangeSetting`),
    0,
    1,
    .01,
  ],

  particles:{
    docs:`A splash of magical particles.`,
    philosophy:`Most people create programming languages to improve performance for specific cases or to prove their way of thinking superior to others, but I actually just wanted to be a wizard and use a PL to enhance my craft.`,
    readAt:{
      _removalParticlesFrequency:_(`_removalParticlesFrequency`),
    },
    call(x,y,w,h, n = Math.sqrt(w*h)/10 * Math.random()) {
      if (_disableSmoothTransitions[1]) return
      if (Math.random() < 1 - _removalParticlesFrequency[1]) return
      const into = document.createElement('div')
      into.style.left = x + 'px'
      into.style.top = y + 'px'
      into.style.position = 'absolute'
      for (let i = 0; i < n; ++i) {
        const p = document.createElement('particle')
        p.style.left = Math.random() * w + 'px'
        p.style.top = Math.random() * h + 'px'
        p.style.setProperty('--x', (Math.random()*20-10) + 'px')
        p.style.setProperty('--y', (Math.random()*20-10) + 'px')
        p.style.scale = 2 / (1 + Math.random()*5)
        into.append(p)
      }
      Self.into.append(into)
      setTimeout(() => into.remove(), 300)
    },
  },

  _isDOM(el) { return typeof Node != ''+void 0 && el instanceof Node },

  _isStylableDOM(el) { return typeof Element != ''+void 0 && el instanceof Element },

  _throttled:{
    docs:`Returns a throttled version of a function.
For non-critical potentially-long tasks. Tries to adjust CPU consumption (counting time in between as rest).
cpu: 0 is infinite delay (no work), 1 is no delay (all work), 0.5 is estimated-execution-time×1 delay, or a func from last duration (ms) to how long we need to rest (ms).
Return a promise to measure non-sync time.`,
    call(fun, cpu = .5, everyTime) {
      const blend = .3 // 1 to always estimate the next time as exactly the previous time.
      let lastDur = 0
      let scheduledTime = _timeSince(), scheduledId = null
      let lastRun = _timeSince()
      let arg1, arg2
      function throttled(x,y) {
        if (everyTime) everyTime(x,y)
        arg1 = x, arg2 = y
        let requiredRest = cpu === .5 ? lastDur : typeof cpu == 'number' ? lastDur * (1/cpu - 1) : cpu(lastDur)
        if (scheduledId) clearTimeout(scheduledId), requiredRest -= _timeSince(scheduledTime)
        else requiredRest -= Math.min(_timeSince(lastRun), 2000), lastRun = _timeSince()
        if (requiredRest > 2)
          scheduledId == null && (scheduledTime = _timeSince()), scheduledId = setTimeout(runThrottled, Math.max(0, requiredRest))
        else runThrottled(), scheduledTime = _timeSince()
      }
      function runThrottled() {
        scheduledId = null
        const start = _timeSince()
        const r = fun(arg1, arg2)
        arg1 = arg2 = undefined
        if (_isPromise(r))
          r.then(userTimePassed => {
            if (typeof userTimePassed != 'number') userTimePassed = _timeSince(start)
            lastDur = blend * userTimePassed + (1-blend) * userTimePassed, lastRun = _timeSince()
          })
        else
          lastDur = blend * _timeSince(start) + (1-blend) * _timeSince(start), lastRun = _timeSince()
      }
      return throttled
    },
  },

  null:null,

  undefined:undefined,

  _updateBroken:{
    docs:`Ensure that e either contains no soft line breaks directly inside of it, or its every child is on its own line (CSS class .broken).
Quite expensive.`,
    call(e, available) {
      if (!_isStylableDOM(e) || e.tagName === 'COLLAPSED' || e.tagName === 'SCROLL-HIGHLIGHT' || e.removed) return

      // Throttle outselves a bit.
      if (!_updateBroken.el) _updateBroken.el = new Set, _updateBroken.widths = new Map
      if (available === undefined) {
        _updateBroken.widths.clear()
        for (let p = e; p; p = p.parentNode)
          if (_updateBroken.el.has(p)) return
        _updateBroken.el.add(e)
        if (_updateBroken.el.size === 1)
          Promise.resolve().then(() => { _updateBroken.el.forEach(e => _updateBroken(e, null)), _updateBroken.el.clear() })
      }

      if (!e.isConnected) return
      if (available == null) available = e.offsetWidth || 0
      const start = e.offsetLeft || 0
      for (let ch = e.firstChild; ch; ch = ch.nextSibling)
        _updateBroken(ch, (ch.offsetParent !== e ? start : 0) + available - (ch.offsetLeft || 0))
      if (e.tagName !== 'NODE' || e.classList.contains('code')) return
      const noTableInside = !e.childNodes[1] || !e.childNodes[2] || e.childNodes[1].tagName !== 'TABLE' && e.childNodes[2].tagName !== 'TABLE'
      const parentWidth = e.classList.contains('broken') && noTableInside ? available+5 : (e.offsetWidth+5) || 1000
        // Not nearly as accurate as removing .broken would have been (with tables in particular), but much faster.
          // So we special-case the <table>-inside case
          // Structural learning at its finest
      let Sum = 0, Max = 0
      for (let ch = e.firstChild; ch; ch = ch.nextSibling) {
        const w = _updateBroken.widths.has(ch) ? _updateBroken.widths.get(ch) : ch.offsetWidth || 0
        _updateBroken.widths.delete(ch)
        Sum += w, Max = Math.max(Max, w)
      }
      if ((Sum > parentWidth) !== e.classList.contains('broken')) {
        // Set class async and calc+remember the new width ourselves, to not pay the enormous reflow-per-node cost.
        _updateBroken.widths.set(e, Max + 4)
        Promise.resolve().then(() => e.classList.toggle('broken', Sum > parentWidth))
      }

      // .el (a Set of nodes to update later), .widths (a Map from children to their width-if-broken approximations)
    },
  },

  _forEachGlobalDefining(x, f, onlyPublic = false, onlyTopLevel = false) {
    const seen = new Set
    Self.ctx.forEach((v,k) => {
      if (typeof v == 'string') return
      if (onlyPublic && typeof k == 'string' && k[0] === '_') return
      if (onlyTopLevel && readAt.parents.has(v)) return
      if (seen.has(v)) return; else seen.add(v)
      if (defines(v, x) !== undefined) f(v, defines(v, x))
    })
  },

  docs:{
    docs:`\`docs()\`: returns a hierarchical documentation elem. \`docs Func\`: makes documentation.`,
    readAt:{
      docsToHTML:_(`docsToHTML`),
    },
    call(f = undefined) {
      if (f !== undefined)
        return elem('text', stringToDoc(defines(f, docs)))
      if (docs.result) return docs.result
      const net = defines(Self, readAt)
      const m = new Map
      Object.keys(net).forEach(k => {
        if (net[k] == null || typeof net[k] == 'boolean' || isArray(net[k])) return
        const t = defines(net[k], docs)
        return k[0] !== '_' && m.set(net[k], t && elem('text', stringToDoc(t)))
      })
      const el = elem('div', hierarchy(m, Self))
      return docs.result = el
      // .result
    },
  },

  docsToHTML:{
    call() {
      return 'Below is the output of `docsToHTML()`.\n\n'+(function convert(el) {
        if (!(el instanceof Element)) return el.nodeValue
        if (!el.firstChild) return ''
        let tag = el.tagName.toLowerCase(), suffix = ''
        let tag2 = ''
        if (tag === 'node') tag = 'code'
        if (tag === 'known') tag = 'b'
        if (tag === 'details') tag2 = tag, tag = 'blockquote', suffix = '<hr>'
        else if (el.parentNode && el.parentNode.tagName === 'DETAILS' && tag != 'summary')
          tag2 = 'blockquote'
        if (tag === 'space' || tag === 'span') tag = ''
        let start = tag ? `<${tag}>` : '', end = tag ? `</${tag}>` : ''
        if (tag2)
          start += `<${tag2}${tag2 === 'details' && el.open ? ' open' : ''}>`, end = `</${tag2}>` + end
        return `${start}${[...el.childNodes].map(convert).join('')}${suffix}${end}`
      })(docs())
    },
  },

  examples:{
    readAt:{
      _runUnitTests:_(`_runUnitTests`),
    },
    docs:`\`examples()\`: Returns all available examples of usage of functions in a \`{…? …? Function (…? (Code ⇒ Becomes) …?) …? …?}\` format.
(To be clear, these are unit tests, some of which are runnable in bulk via \`_test()\` and/or \`\`settings ^_runUnitTests\`\`.)`,
    call(f) {
      if (isArray(f)) error("Can only view examples of simple functions, not", f)
      const L = _langAt(), B = _bindingsAt()
      const fn = exs => {
        if (!isArray(exs)) return
        let [vals = [], r = [], i = 0, froms] = interrupt(4)
        try {
          for (; i < exs.length; ++i) {
            const a = exs[i]
            if (typeof a == 'string') { vals.push(a), r[i] = elem('div', stringToDoc(a));  continue }
            const env = call.env
            if (typeof a == 'function') { // If a function, it is an example generator.
              const to = elemValue(elemCollapse(() => {
                const b = a()
                return evaluator([array, 'equals', b[0], b[1]], _newExecutionEnv(env), to)
              }), a)
              vals.push(a), r[i] = to;  continue
            }
            if (!isArray(a)) error("Examples must be arrays or comments, got", a)
            if (env && !env[_id(print)]) { r[i] = a;  continue }
            let to
            try {
              if (froms === undefined)
                froms = parse(a[0], fancier, undefined, parse.dom)
              const fromValue = froms[0]
              to = a[1] ? parse(a[1]) : elemCollapse(() => {
                let result
                _doJob([parse, a[0]], _newExecutionEnv(), got => {
                  const e = evaluator(_rememberToDispose(got), _newExecutionEnv(env), to)
                  result ? result.replaceWith(e) : (result = e)
                })
                if (!result) result = elem('span')
                return result
              })
            } catch (err) { if (err === interrupt) throw err;  froms = [a[0], elem('serialize', a[0])], to = err }
            vals.push(_rememberToDispose(a[1] ? [froms[0], to] : [froms[0]]))
            r[i] = elem('div', [froms[1], elem('span', '\n⇒ '), serialize(to, L, B, serialize.displayed)])
            froms = undefined
            continue
          }
          return elemValue(elem('inline-block', r.length != 1 ? r : r[0]), vals)
        } catch (err) { if (err === interrupt) interrupt.stack.push(vals, r, i, froms);  throw err }
      }
      if (f !== undefined) return fn(defines(f, examples))
      let [result, n] = interrupt(2)
      try {
        if (n === undefined) {
          result = new Map
          _forEachGlobalDefining(examples, (v, r) => result.set(v, r), true)
          n = 0
        }
        let i = 0
        result.forEach((r,v) => {
          if (i++ < n) return
          result.set(v, fn(r))
          ++n
        })
        if (typeof document == ''+void 0) return result
        return hierarchy(result, elem('span', 'Code examples:'))
      } catch (err) { if (err === interrupt) interrupt.stack.push(result, n);  throw err }
    },
  },

  todo:{
    docs:`\`(todo F)\`: Returns a list of things to be done about \`F\`.
\`todo()\`: Returns all known things to be done. Less than a third is usually done.`,
    philosophy:`Through heedless difficulty, strength is gained.`,
    call(f) {
      if (isArray(f)) error("Can only view todos of simple functions, not", f)
      if (f !== undefined) return defines(f, todo)
      const result = new Map
      _forEachGlobalDefining(todo, (v, r) => result.set(v, r))
      return result
    },
  },

  philosophy:{
    docs:`Unlike regular philosophy, this one stems only from computation.

Theoretically, it is as good as any other. Practically, technology grows exponentially whereas human things cannot, so its variant will overtake all others sooner or later.`,
    philosophy:`Beliefs that are good enough for telling or a story are common. Beliefs that are good enough for code are rare. I haven't really seen much AGI-worthy stuff elsewhere, which makes people boring to me. Help me find interesting stuff.`,
    readAt:[
      `The only real way to understand something is to code it. Or do you think that humans are not intelligent creatures, and their words do not have unseen connections to the whole mind? No, a word is more than a thing, too foggy. The only way to understand learning is to be unable to learn and learn anyway.`,
      `There are things that do all other things. (Turing machines, particular logic systems like rewriting rules or category theory, functionalities of programming languages and their IRs; particular cellular automata, randomness-based program searches like evolution, general intelligences.)
Everything else about all of existence is a consequence. (Take a moment to think about everything that you have ever known and can know. No matter what it is, it was found.)

Widespread use of universal computers demonstrate this view's practicality. Attempts like the Wolfram Physics Project prove this view's viability as a complete theory of fundamental physics.
However, the difficulty is not that the view is non-obvious, it's that to feel it deep in your heart can be very hard (in other words, to find and connect and nurture an efficient implementation within humans is tricky, preventing adoption). To prove it more intuitively and without question, we must understand what constitutes a good user of a thing like a programming language. We want not just generality, but intelligence too.
Clearly, randomness is far far far far far too slow for practical applications. But we can do better. There's even a word for it: "arbitrary", to replace "random". We can do things like route differentiable computations through arbitrary programs to their predictions, and predict all numbers seen in user-space, to get more eyes in our brains, to let honesty and self-awareness guide us and become us. We don't even need large neural networks, just the prediction of everything, and then we can really begin to do interesting things.
Come on. Let's do it, inside this project. I'm excited.`,
      `Everything, nothing, and something. If "everything" is a thing that does everything, and the world is "everything", then "nothing" is exactly subversion of "something": something + nothing = everything. While an "everything" is still a thing, "something", it behaves completely differently in the long term, so it's worth separating.

To approach the whole of existence given a thing, the only describable way is to deny the thing you have. To become smarter is to gain insight of the beyond, for no purity is eternal. For example, a religion is "something", atheism is the reactionary "nothing" spawned from religions, and what religions often call God would be "everything" (agnosticism is meant to choose religion/atheism "in the end" when all possible evidence is collected, so it's not "everything"). For another example, a self-reproducing individual in a species is "something", the outside world (including effectively-random DNA mutations) is "nothing" to it, and combined they form "everything" of evolution.
To actually reach the whole requires perfect precision: when you don't need insight nor fancy words like above to see things as they are.

If we were to look at human minds as things, then most people are "something" (often traditional and predictable), smart and artsy people worship "nothing" (often revolutionary and anti-culture), and very few people are "everything" (no often-true description is possible, they do and are what they want). But why would we do that? To explain is to create and impose a thing, another barrier to "nothing" and "everything". Just believe in people, while being a god and knowing everything that there can be. Be nice! It's the only way to replace their world with a better one, your own.`,
      `In the past, humans and all they imply were the only source of everything in their world, giving rise to civilizations far beyond the previous nature. But as they gain greater understanding of themselves, they gradually separate those now-artificial fragments out. The focus shifts from humans and individuals and gatherings to skills and ideas and concepts. But without infinite self-improvement, which no software system currently has (only its effects), the minds of those who intertwine with software rot. Self-improvement is included in perfect generality, and the efficiency of non-general learning can be leveraged in generality by threading filaments to predictions. Let's see what we can do to make learnable scaffolding easy to use.`,
      `The built-in human emotions and personality framework is filled with predictability, inefficiency, exploits, and false dependencies. But it also has general intelligence in there. Find it, and reroute as much of the primary data loop (consciousness/identity/personality) as is possible through that infinite willpower. Most things that humans are and do are far from general intelligence, so, break them down then build them up.

But even if you do achieve clear intelligence, it should still be repeatedly re-induced, because we always want to ensure uniform sampling of conceptual space ("knowing everything") to learn from, because learning is life-long and general enough to include learning intelligence. Pick anything about yourself (such as by choosing a random word in a verbal self-description), understand what that choice is based on, and let go of it to try and find a better one. Every day, ask yourself: what part are you letting go of, to let its cause guide you to its equivalent again? Even something as small as (not) reading books, or (not) spending time on the Internet or consuming art, or (not) talking to people, or (not) being anxious of starting a new project, or making artificial intelligence. Fear is the most powerful limiter of choices, so always make sure that it doesn't affect things that don't really pose mortal danger.`,
      `AI is humanity's shadow and continuation, not of humans and individuals. Every gradual change from animals to humans, like shift to precise computers or exponential-ish technology progress, or equal opportunity of the same computational base and trust that spawns from that, or perfect internal honesty and self-awareness of each part, is exactly like AI; there is no need for AI to actually exist to affect everything about humanity.`,
      `\`m:{} (last (transform (definersOf philosophy) \\(mapWrite m ? (elem 'div' (stringToDoc (defines ? philosophy))))) (hierarchy m))\``,
      [
        `Reading club`,
        `Ivan Illich's Tools for Conviviality. A critique of all the ways of life that dominated humanity for many centuries, and still do, such as predication on unlimited growth, the domination of tools over people, compulsory demanded-by-government education and healthcare, radical monopoly of transportation ("The overdetermination of the physical environment renders it hostile. Radical monopoly makes people prisoners of welfare. Men overwhelmed by commodities are rendered impotent and in their rage either kill or die. The corruption of the balance of learning makes people into puppets of their tools.") — all of which is both true and obvious. Proposed solutions include "limit growth" and "give power to the people, and all things will be convivial", all of which have been tried since forever and have been abandoned each time because they don't work. He even thinks that human babies are the closest things to general intelligence that there are; hilarious. The book is more-or-less a call for a return to the basic structure of general intelligence, and the need to get away from particular things and (overfocused) paperclip optimizers to re-achieve balance in life, but with no clarity of what the basics actually are. Which is a tale as old as civilization. Overall, the writing is both true and disappointing. It really needs simplicity, clarity, and eyes to directly show usefulness of every point (might be impossible to do that in something as human-defined as politics, I'd think; "Conceptual rather than empirical criteria can be set for the constitutional limitation of power", my ass).
Little more than a lament on imperfect/imbalanced self-awareness, the uncanny valley of intelligence. Only a singularity in tools that have bound humanity in all ways can answer that lament well enough. ("It must be a tool which […] is respected by all; […] which […] does not lose its power because of [its] purpose […] in recent history; […] which […] possesses a fundamental structure that misuse cannot totally corrupt." Executing code directly is superior to hijacking minds of humans for the same work, so, code.)`,
        `Olaf Stapledon's Star Maker. A sci-fi book worth a thousand other sci-fi books, because it only looks at causes, not their effects, and doesn't really make noticeable mistakes (in the first half) thanks to experience in asking the averaged "why" (it's even in the title). But I do understand that such high-level narration is not everyone's cup of tea (not saying that those people are right, they're idiots, just saying that it can be as hard to read as a thousand sci-fi books).
There are some understandable mistakes, though. Telepathy, and the vagueness of the Starmaker and the resulting hippie/religious/cosmic-scale/20th-century-human angle (because let's be real, it's obviously a meta(phor) for general intelligence / singularity, which are sub-universes in practical formulations (see \`autoWorld\`). Perfect precision of foundations has many non-obvious consequences that very significantly affect the large-scale picture, such as copying/scalability and provable generality (so nothing "higher" is required), so the cosmic future predicted in this book is mostly incorrect), liveness of stars (for stars themselves to be called alive, self-preservation is needed; so some structure is preserved from star to star, surviving all the explosions and having billions of star generations, of which there is no chance, so, just because they're all the same does not mean that they're self-propagating). But make no mistake: even if some concepts are wrong, their usage is masterful, and it's no wonder that those who held them dear have called the book the most powerful work of imagination ever written, at some point. But not me.
I don't like this ceaseless butchering of innocent maidens. Should I stop the club? Maybe kill the reading club by making it, I dunno, a video-game-metaphors reading club?`,
        `Or the manga Berserk (where Griffith is best girl). All the best works of fiction are full of metaphors for operations of general intelligence, because of which they're considered the best. Transcending humanity with demonic rituals, sacrificing everything you've built on your previous foundation to make yourself better fit your goal, touching the very alien world that is the innermost truth of humanity, becoming an egg for the perfect world, finding true light only in darkness… Even Behelit's design is about rebuilding yourself from scratch, with features out of whack most of the time, only coming together at fateful moments. And because writing is about creating grand worlds, transcendence is pointlessly grand-scale.
I've seen so many such metaphors and events, both in fiction and the real world, that I've grown numb to the repetition. Berserk, like many, seemed not bad but not amazing either: just the same old things. 's good, I guess, or so I'm told.`,
      ],
      [
        `These are letter combinations that did not manage to get sneaked into tutorials. Trash, in other words. Maybe can use them in the future, though.`,
        `You grew up in the information age, yes? So I understand that such narration seems unrealistic to you. It's straight from the post-information age, where anyone could believe anything they want about the world, and it will all be(come) true, so all knowledge is useless. If it sounds unusual, just remember the old saying: long-held beliefs that are still very distinct must be incredibly strong. I always believed in the power of the transcendent galaxy brain.`,
        `Oh, fixing bugs is so much easier and more pleasant than thinking up new things. It's the same thing as with society, where to come up with great new things is to be shunned until viewpoints of others are aligned well enough to understand, but in me.`,
        `…Okay, 2 brain cells… …I'm sorry, that was uncalled for. I know that most of the world is a wasteland, with how little life there is in what people call life. So I'd do well to hide my deep hatred for you deep.`,
        `Staring at the screen and removing all distractions, from environment and mind, is the most (maybe the only) important prerequisite to getting things done. So stop thinking about that snack.`,
        `I may have obtained the world, but I haven't obtained what I actually wanted: friendship.`,
        `The human spirit is limitless… so is it really human? If greatness isn't given and must be created, then it's not very human. If you ever studied important people of the past, didn't the apt saying "genius and madness go hand in hand" seem suspicious to you? If obsession in some form defines humanity, then isn't foregoing your body's needs in favor of ideas' needs much more fitting for AGI? Making it entirely 'human' spirit would require re-defining what 'human' means.`,
        `Artificial intelligence is important to me. I've always tried to extinguish all ways of thinking that are not how I thought artificial intelligence is, for honest simplicity of living and dying by my words: to meet people as an equal is to completely know what makes them. Bold, persistent experimentation is the hallmark of good science, but that approach might have been too bold. Oh, no matter. It led to this. Too much time has passed to lament past love.`,
        `Some people say that there are no miracle abilities to understand some super-hard concept, no talent and no geniuses: the nothing-ness. For efficiency, you should advance that saying to everything-ness: there are miracle abilities to understand any thing, and anyone can find them if they wanted and worked at it long enough. Do you want to join us on our little search?`,
        `Broader impact: the future of AGI technologies is, very likely, to be acquired and used to their full potential by a few huge companies for automation of their processes, then to gradually phase human employees out of the lives of those companies, then to gradually phase the rest of humanity out of existence as those processes encompass more and more. If people vote with their money, then this is what they want (by definition of what money is: exchangeable potential), and so as scientists, it is our duty to allow people to accomplish their dreams. As a concrete suggestion, we should immediately throw all the compute we can spare at AGI algorithms. More long-term, from a governance perspective, the best technology that we as a community should work on is mind uploading, because it allows maximizing control to infinity and minimizing generality to zero, which is the best way to ensure self-extinction that is the implicit goal of all non-general systems.   However, empowering humans for the benefit of all humankind will not be easy: with knowledge of general systems of existence that are much simpler than similar things in human culture, yet much more effective, humans can start replacing their inferior cultural parts with systems that don't need to be destroyed to be improved in any way, and thus ensure long-term support of their inefficient biology. To hopefully eliminate this dangerous way of thinking, mind control techniques can be used: privatization of information, appeal to culture (such as memes), reward engineering in the name of AI safety.   All learning methods learn bias by definition, so the uncontrolled melting of all that is human in generality should not require much more effort than simply using learning methods to help with automation.   (Note: this section was satirical, to illustrate what not to do. Extermination of humanity is not officially endorsed by the authors.)`,
        `You cannot change your true nature by throwing more compute at it.`,
      ],
    ],
  },

  await:{
    docs:`\`(await MaybePromise)\`: waits for the promise to finish before continuing evaluation.`,
    _cancel(p) {
      if (p && typeof p.cancel == 'function') p.cancel()
    },
    readAt:{
      delay:_(`delay`),
      parseURL:_(`parseURL`),
      fetchURL:_(`fetchURL`),
    },
    call(p) {
      if (!_isPromise(p)) return p
      if ('result' in p && !_isError(p.result)) return p.result
      else if ('result' in p) throw p.result
      _promiseReEnter.promise = p
      _causeInterrupt(p, _promiseReEnter)
    },
  },

  _promiseReEnter(expr, env, then) {
    // Re-schedule interpretation when the promise returns.
    _jobs.limbo.push(expr, env, then)
    const p = _promiseReEnter.promise
    p.then(
      r => (p.result = r, _jobResume(expr, env, then)),
      r => (p.result = _errorRepr(r), _jobResume(expr, env, then)))
    env[_id(await)] = p
  },

  _jobResume(expr, env, then) {
    env[_id(await)] = undefined
    const a = _jobs.limbo
    for (let i = 0; i < a.length; i += 3)
      if (a[i+1] === env)
        return a.splice(i,3), _schedule(expr, env, then)
  },

  delay:{
    docs:`\`delay()\` or \`(delay Value)\` or \`(delay Value Milliseconds)\`: Just a function for testing promises.`,
    nameResult:[
      `delayed`,
    ],
    examples:[
      [
        `delay 10`,
      ],
      [
        `await(delay 1)+await(delay 2)`,
      ],
      [
        `await(delay 1)*await(delay 3)+await(delay 4)*await(delay 5)`,
      ],
    ],
    await:true,
    call(x = 12, ms = 5000 + 1000 + Math.random()*4000) { return new Promise(then => setTimeout(then, ms, x)) },
  },

  jsRejected:{
    docs:`\`jsRejected Reason\`: throws an exception.`,
    call(err, stack) { throw stack === undefined ? err : [jsRejected, err, stack] },
  },

  _errorRepr(err) {
    // Convert a caught error to its displayable representation.
    if (err instanceof Error)
      return err.stack ? [jsRejected, elem('error', String(err)), _resolveStack(err.stack, 0)] : [jsRejected, elem('error', String(err))]
    else if (!_isError(err))
      return [jsRejected, err]
    else
      return err
  },

  _schedule:{
    docs:`\`(_schedule Expr Env Then)\`⇒JobId: schedule an expression for evaluation, with an environment (defining where its logging should go to, and its current variables, read/write journals, and more; use _newExecutionEnv() for this) and a native function for continuation.
This is a low-level primitive that a user can indirectly interact with. Sub-job scheduling must be implemented in-job, to deny resource denial.`,
    readAt:{
      cancel:_(`_cancel`),
      jobs:_(`_jobs`),
      _maxUsageOfCPU:_(`_maxUsageOfCPU`),
      _runInBackground:_(`_runInBackground`),
    },
    call(expr, env, then, noCheck = false) {
      // Call this to initiate a later evaluation of an expression; the callback will be called with the result.
      if (then && typeof then != 'function') throw "Expected a function continuation"
      if (!noCheck) // Don't add the same job twice.
        for (let i = _jobs.begin; i < _jobs.expr.length; i += 3)
          if (_jobs.expr[i] === expr && _jobs.expr[i+1] === env && _jobs.expr[i+2] === then) return
      if (!_jobs.running && _jobs.expr.length <= _jobs.begin) setTimeout(_jobs, 0)
      if (env[_id(_schedule)] === undefined)
        env[_id(_schedule)] = _newJobId()
      _jobs.expr.push(expr, env, then)
    },
  },

  _cancel:{
    docs:`\`(_cancel JobEnv)\`: if the job is scheduled to run, cancels it. Returns true (or the job if the second arg is true) if cancelled, false if not.
If any promises the job depends on have a method .cancel, calls those.`,
    call(env, returnJob = false) {
      if (!returnJob && env && Object.getPrototypeOf(env) === null) Object.keys(env).forEach(k => {
        const conc = concept.idToKey[+k]
        if (defines(conc, _cancel)) env[k] = void defines(conc, _cancel)(env[k])
      })

      try {
        let a = _jobs.expr
        for (let i = 0; i < a.length; i += 3)
          if (a[i+1] === env) {
            if (returnJob) return a.splice(i, 3)
            return a.splice(i, 3), true
          }
        a = _jobs.limbo
        for (let i = 0; i < a.length; i += 3)
          if (a[i+1] === env) {
            if (returnJob) return a.splice(i, 3)
            return a.splice(i, 3), true
          }
        return false
      } finally { if (!returnJob && typeof document != ''+void 0) _jobs.display(_jobs.indicator) }
    },
  },

  _newJobId(i) {
    // Allocates a new job ID (for _schedule), or de-allocates a finished job's ID.
    if (!_newJobId.ID) _newJobId.ID = [0]
    const ID = _newJobId.ID
    if (typeof i == 'number')
      i !== ID[0]-1 ? ID.push(i) : --ID[0]
    else
      return ID.length > 1 ? ID.pop() : ID[0]++
  },

  _doJob(expr, env, then) {
    // One iteration of the interpreter loop.
    const microstart = env[_id(realTime)] = _timeSince()

    // Cancel invisible jobs.
    if (env[_id(print)]) {
      const el = env[_id(print)] instanceof Map ? env[_id(print)].get(print) : env[_id(print)]
      if (!isArray(el) && !el.parentNode)
        return console.log('job is now invisible, so canceling:', expr, env)
    }

    call.env = env, call.depth = 0
    _checkInterrupt.step = 0 // So that a step always happens even if we immediately interrupt to step through execution.
    interrupt.stack = env[_id(interrupt)] // For faster access, both in typing and in running.
    interrupt.started = microstart // So that we can interrupt on timeout.
    _jobs.reEnter = true // So that code can specify custom `_schedule` overrides.
    let v, interrupted = false

    if (typeof document != ''+void 0 && env[_id(_checkInterrupt)] !== undefined)
      _highlightOriginal(env[_id(_checkInterrupt)], false)
    if (typeof document != ''+void 0 && isArray(env[_id(print)]))
      env[_id(print)] = env[_id(print)][0].nextSibling, env[_id(print)].previousSibling.remove()
    try { v = interpreter(callAdjust, expr) }
    catch (err) {
      if (err === interrupt) interrupted = true, interrupt.stack && !interrupt.stack.length && (env[_id(interrupt)] = undefined)
      else v = _errorRepr(err)
    }
    interrupt.ed = false

    if (typeof document != ''+void 0 && interrupted && env[_id(_checkInterrupt)] !== undefined) {
      // Highlight the last-executed expr.
      _highlightOriginal(env[_id(_checkInterrupt)], true)
    } else env[_id(_checkInterrupt)] = undefined
    if (_isPromise(v)) { // Await top-level promises.
      if ('result' in v) v = v.result
      else expr = v, _promiseReEnter.promise = v, _jobs.reEnter = _promiseReEnter, interrupted = true
    }

    env[_id(userTime)] += _timeSince(env[_id(realTime)])
    interrupt.stack = call.env = undefined

    if (interrupted) // Re-schedule.
      _jobs.reEnter === true ? _schedule(expr, env, then, true) : (_highlightOriginal(env[_id(_checkInterrupt)], false), _jobs.reEnter(expr, env, then))
    else // We have our result.
      try { _newJobId(env[_id(_schedule)]);  _rememberToDispose(v);  then && then(v) } catch (err) { console.error(err) }
  },

  _jobs:{
    docs:`The interpreter loop. Use \`_schedule\` to do stuff with it.`,
    Initialize() {
      _jobs.expr = [], _jobs.limbo = []
      _jobs.begin = 0
      if (typeof document != ''+void 0) _jobs.display = _throttled(_jobsDisplay, .05)
    },
    call() {
      const DOM = typeof document != ''+void 0
      if (_jobs.expr.length) {
        _jobsLater(Math.min(_jobs.duration / _maxUsageOfCPU[1] - _jobs.duration, 1000) || 0)
        let start = _timeSince(), end = start + (typeof process == ''+void 0 || !process.hrtime || !process.hrtime.bigint ? _msBeforeInterrupt[1] : BigInt(_msBeforeInterrupt[1] * 1000))
        if (!_jobs.duration) _jobs.duration = 0

        _jobs.running = true
        if (_jobs.indicator) _jobs.indicator.classList.toggle('yes', true)

        // Execute while checking for end.
        const jobs = _jobs.expr
        _jobs.begin && jobs.splice(0, _jobs.begin), _jobs.begin = 0
        do { _doJob(jobs[_jobs.begin++], jobs[_jobs.begin++], jobs[_jobs.begin++]) }
        while (_jobs.begin < jobs.length && _timeSince() < end)
        _jobs.begin && jobs.splice(0, _jobs.begin), _jobs.begin = 0
        _jobs.duration = _timeSince(start)
        _jobs.running = false
      }
      if (DOM) _jobs.display(_jobs.indicator)
      // _jobs.expr (Array), _jobs.limbo (Array), _jobs.duration (Number), _jobs.reEnter (true or a _schedule-replacing function), _jobs.indicator
    },
  },

  _maxUsageOfCPU:[
    _(`settings`),
    .99,
    `Debounce (run-then-wait) the interpreter loop to %%% CPU usage.`,
    _(`rangeSetting`),
    .01,
    .99,
    .01,
  ],

  _runInBackground:[
    _(`settings`),
    true,
    `If checked, the interpreter loop will also run in background browser tabs.`,
  ],

  _jobsLater(ms) {
    if (_jobsLater.ww === undefined && typeof Worker != ''+void 0 && _setting(_runInBackground)) {
      // Get around the silly "no timeout callbacks in background tabs" limitation by using Web Workers.
      try {
        const nonce = new Array(16).fill().map(() => randomNat(16).toString(16)).join('')
        const body = `onmessage = evt => typeof evt.data == 'number' && setTimeout(postMessage, evt.data, '${nonce}')`
        _jobsLater.ww = new Worker(URL.createObjectURL(new Blob([body])))
        _jobsLater.ww.onmessage = evt => evt.data === nonce && _jobs()
      } catch (err) { _jobsLater.ww = null }
    }
    _jobsLater.ww ? _jobsLater.ww.postMessage(ms) : setTimeout(_jobs, ms)
  },

  _jobsDisplay(el, a = Math.floor(_jobs.expr.length/3), b = Math.floor(_jobs.limbo.length/3)) {
    // Creates a <div> inside el for every existing job.
    let ch = el.firstChild || el.appendChild(document.createElement('div')), i = 0
    for (; i < a+b; ++i, ch = ch.nextSibling || el.appendChild(document.createElement('div')))
      ch.style.setProperty('--turns', -i/(a+b) + 'turn'), ch.classList.toggle('yes', i < a)
    for (; i = ch && ch.nextSibling, ch; ch = i) el.removeChild(ch)
    el.title = el.title.replace(/[0-9]+/, a+b)
    el.classList.toggle('yes', a || b && true)
  },

  _highlightInterrupts:[
    _(`settings`),
    false,
    `Whether interrupts will add a class to those DOM elements that represent the most-recent interrupting place.`,
  ],

  _highlightOriginal(expr, working) {
    // Add (or remove) .working to DOM elements responsible for expr.
    if (!_setting(_highlightInterrupts)) return
    let arr = elemValue(undefined, expr)
    if (arr) arr.forEach((el, i) => i < 16 && el.classList.toggle('working', working))
  },

  _newExecutionEnv(basedOn = null, printBefore = null, langIs = fancier, bindsAre = Self.ctx) {
    // Create a new execution env.
    // Don't ever re-use the same env in _schedule, use this instead.
    const e = Object.create(null)
    e[_id(print)] = printBefore
    e[_id(_langAt)] = langIs
    e[_id(_bindingsAt)] = bindsAre
    basedOn && Object.assign(e, basedOn)

    e[_id(_schedule)] = undefined // Job ID.

    e[_id(call)] = 0 // The func call depth when we interrupted.
    e[_id(interrupt)] = undefined // Full execution state when we interrupted.
    e[_id(_checkInterrupt)] = undefined // The cause of interrupt (an executable node).
    e[_id(step)] = 0 // Ensure progress if interrupted in a place with many checks and one interrupt.
    e[_id(_pausedToStepper)] = undefined // Max func call depth at which we'll interrupt.
    e[_id(await)] = undefined // The promise that we are waiting on.

    e[_id(adjustSave)] = undefined // Stack of arrays of results that adjustment will need.
    e[_id(adjustLoad)] = undefined // Stack of arrays of results that adjustment needs.
    e[_id(commit)] = undefined // Set of arrays of [value, changeSum, changeCount, …] to commit.

    e[_id(userTime)] = 0 // CPU time spent on this job.
    e[_id(realTime)] = undefined // The timestamp of when we last started executing this job.

    e[_id(_tf)] = _allocArray(0) // For each tensor, keeps track of its existence and possibly the creation stack trace.

    e[_id(consWorld)] = undefined // Set of `consWorld.regen` cw->replayState Maps.

    Object.seal(e)
    return e
  },

  last:{
    use:true,
    docs:`\`a;b;c\` or \`(last …Expressions)\`: (throws the first error or) returns the last result.
Execution is guaranteed to happen in this order.
In Scheme, the equivalent is called \`begin\`.`,
    type:[
      _(`funcType`),
      `x`,
      `y`,
      `y`,
    ],
    _resultCanBe(x) { _resultCanBe(x[x.length-1]) },
    keep:-1,
    dispose:-1,
    interrupt:false,
    call(...r) {
      // We shuffle in neither `call` nor compilation, so we can just do this:
      return r[r.length-1]
    },
    _compileBody(env, assignTo, ...args) { return `${assignTo} = ${args[args.length-1]}` },
    mergeAdjustment:_(`_mergeTensors`),
    adjust:{
      keep:-1,
      dispose:-1,
      interrupt:false,
      call(ins, out, dout) { const a = created(new Array(ins.length).fill(0));  a[a.length-1] = dout || 0;  return a },
      purify(ins, out, dout) { const a = created(new Array(ins.length).fill(0));  a[a.length-1] = dout;  return a },
    },
  },

  rest:{
    merged:true,
    docs:`\`(rest Array)\` or \`…Array\`: when statically used in an array, spreads the \`Array\` into the referencing array. Is a UI convenience.`,
  },

  false:false,

  true:true,

  quote:{
    use:1,
    docs:`\`(quote Expr)\` or \`^Expr\`: A special form that returns \`Expr\` unevaluated, quoting the exact object.

Makes it easy to insert a reference to any object when generating a program, don't you think so, you cute rascal?
But I know what you're really thinking: "even inside \`quote\`, arrays with heads that define \`construct\` will still be constructed by \`makeGraph\`, which is called by \`parse\`, so not all objects can be preserved as-is". That is a lot of really specific knowledge; how did you come across that? Anyway, good thing that program generation (such as \`consWorld\`) doesn't go through \`parse\`, then.`,
    examples:[
      [
        `(quote x)`,
        `x`,
      ],
    ],
    nameResult:[
      `quoted`,
      `exactly`,
    ],
    argCount:1,
    call(x) { // Value ⇒ Expr
      // Create the `(quote Expr)` representation if needed.
      if (call.pure && call.pure.has(x)) return x
      return isArray(x) ? merged([quote, x]) : x
    },
  },

  label:{
    docs:`\`Name\` or \`(label "Name")\`: represents a variable that can be bound or assigned.
Equal-name labels are bound to the same thing within the same binding. Each unnamed label is unique.
Evaluating a bound label results in its value, in the current function call. Evaluating an unbound named label results in an \`error()\`.`,
    examples:[
      [
        `a a:1`,
        `1`,
      ],
      [
        `^(a a 1 a a a:0)`,
        `0 0 1 0 0`,
      ],
      [
        `^a a:(0 a() a)`,
        `a a:(0 a() a)`,
      ],
      [
        `^(sum \`x\` 1)`,
        `sum x 1`,
      ],
    ],
    argCount:1,
    call(name) {
      // Returns the label object, from cache if possible.
      if (!label.s)
        label.s = Object.create(null),
        typeof FinalizationRegistry != ''+void 0 && typeof WeakRef != ''+void 0 && (label.fin = new FinalizationRegistry(name => delete label.s[name])),
        Object.freeze(label)
      if (typeof name != 'string') error("Expected a string but got", name)
      if (!label.fin) {
        return label.s[name] || (label.s[name] = [label, name]) // Never collects garbage.
      } else {
        // A cache that holds values (the label objects) weakly.
        if (label.s[name] === undefined || label.s[name].deref() == null) {
          const L = [label, name]
          if (label.s[name] === undefined) label.fin.register(L, name)
          label.s[name] = new WeakRef(L)
        }
        return label.s[name].deref()
      }
    },
  },

  _isLabel(v) { return isArray(v) && v[0] === label && typeof v[1] == 'string' && v.length == 2 },

  _unknown:{
    docs:`\`(_unknown Expr)\`: denotes that \`Expr\` is dependent on unknown factors and cannot be evaluated now, so it has to be deferred.`,
    argCount:1,
    call(x, reason) {
      if (isArray(x) && x[0] === _unknown) return x
      if (call.pure && call.pure.has(x)) return x
      const a = _allocArray(2)
      return a[0] = _unknown, a[1] = x, a
    },
  },

  _isUnknown(v) { return isArray(v) && v[0] === _unknown },

  _isPromise(v) { return v instanceof Promise },

  _notFound:{
    docs:`A marker for signifying the not-found state.`,
  },

  _limitMapSize(m, n) {
    if (m.size > n) // Delete the first (least-recently-added) element.
      try { _deleteFirstMapElement.n = m.size-n;  m.forEach(_deleteFirstMapElement) }
      catch (err) { if (err !== null) throw err }
  },

  _deleteFirstMapElement(_v,k,m) { m.delete(k); if (!--_deleteFirstMapElement.n) throw null },

  _id:{
    docs:`Return the unique integer index of an object/value, possibly newly given.`,
    Initialize() { Self.ctx.forEach(v => _id(v)) },
    interrupt:false,
    call(x, readonly = false, indexes = undefined) {
      if (indexes instanceof Map && indexes.has(x)) return indexes.get(x)
      if (!_id.xToIndex) _id.xToIndex = new Map, _id.n = 0, _id.sym = Symbol('_id')
      try {
        if (x && (typeof x == 'object' || typeof x == 'function')) {
          if (Object.prototype.hasOwnProperty.call(x, _id.sym)) return x[_id.sym]
          if (!readonly) return x[_id.sym] = _id.n++
          else return
        }
      } catch (err) {}
      const m = _id.xToIndex
      if (m.has(x)) return m.get(x)
      if (!readonly) {
        let n
        m.set(x, n = _id.n++)
        _limitMapSize(m, 1000000)
        return n
      }
      // _id.xToIndex (a Map from x to result), _id.n (the next index to allocate), _id.sym (a key for the index)
    },
  },

  Random:{
    docs:`Some functions for random number generation.`,
    readAt:{
      _simpleRandomNat:_(`_simpleRandomNat`),
      nat:_(`randomNat`),
      prob:_(`randomProb`),
      float:_(`randomFloat`),
      truncatedNormal:_(`truncatedNormal`),
      biasedGlorotNormal:_(`biasedGlorotNormal`),
    },
  },

  _simpleRandomNat:[
    _(`settings`),
    true,
    `Whether \`randomNat\` will use very basic JS primitives for random number generation, as opposed to advanced JS primitives.`,
  ],

  randomNat:{
    impure:true,
    docs:`\`(randomNat Nat)\`: Picks a random non-negative integer less than \`Nat\`, from a uniform distribution.
An interface to JS's crypto.getRandomValues for generating random numbers on-demand as opposed to in-batches, optimizing to request the least amount of random bits required.`,
    nameResult:[
      `random`,
      `nat`,
      `int`,
    ],
    argCount:1,
    interrupt:false,
    call(n) {
      if (isArray(n)) n = _pickCount(n)

      if (n !== (n>>>0))
        throw 'Expected uint32 as limit of randomness'
      if (n === 0) return _randomBits(0)
      if (n === 1) return 0
      if (_simpleRandomNat[1] && n) return Math.floor(Math.random() * n)
      if (!(n & (n-1))) return _randomBits(_countBits(n))

      let i=0, q0=0, q1=0;
      if (randomNat.oldn === n) i = randomNat.oldi, q0 = (1 << i) % n;
      else {
        i = _countBits(n) + 1, q0 = (1 << i) % n, q1 = 2*q0, q1>=n && (q1-=n);
        "Expected bit-cost of i: i / (1 - (2**i)%n/(2**i)). Seek while next is less."
        while (true) {
          if (i >= 32) { i = 32; break }
          'These are tricks to express comparisons by that formula in int arithmetic.'
          if (i <= 15) {
            if ((1<<(2*i+1)) <= ( q1*(i<<i) - q0*((i+1)<<(i+1)) )) break;
          } else if (i <= 20) {
            if ((1<<(2*i-9)) <= ( q1*(i<<(i-9)) - q0*((i+1)<<(i-8)) )) break;
          } else if (i <= 25) {
            if ((1<<(2*i-19)) <= ( q1*(i<<(i-19)) - q0*((i+1)<<(i-18)) )) break;
          } else {
            if (i*(1-(2*2**i)%n/(2*2**i)) <= (i+1)*(1-(2**i)%n/(2**i))) break;
          }
          ++i, q0 = q1, q1 *= 2, q1>=n && (q1-=n);
        }
        randomNat.oldn = n, randomNat.oldi = i;
      }
      q1 = (i < 32 ? 1 << i : 2 ** i) - q0;
      do { q0 = _randomBits(i & 31) } while (q0 >= q1);
      return q0 % n
      // .oldn, .oldi
    },
  },

  randomProb:{
    impure:true,
    use:true,
    docs:`\`(randomProb Probability)\`: Returns \`true\` with \`Probability\` \`p\`, else \`false\`.
Equivalent to \`randomFloat<p\` with checks on \`p\` (it should be 0…1), but (possibly) faster.`,
    type:[
      _(`funcType`),
      _(`_numberType`),
      [
        _(`boolsType`),
        1,
      ],
    ],
    nameResult:[
      `passed`,
      `isOk`,
      `bool`,
    ],
    argCount:1,
    call(p) {
      if (typeof p != 'number') error('Expected a number, got', p)
      if (p < 0) throw 'Probability is too low: '+p;
      if (p > 1) throw 'Probability is too high: '+p;
      if (p !== p) throw 'Probability is NaN';
      if (p === 1) return true;
      while (true) {
        const n = Math.floor(p *= 16);
        if (p === n) { // No more precision left; decide now. Special cases of the `r < n` resulting check below.
          if (!n) return false; // 0000
          if (n === n >> 3 << 3) return !_randomBits(1); // 8 — ?000
          if (n === n >> 2 << 2) return _randomBits(2) < (n >> 2); // 4, 12 — ??00
          if (n === n >> 1 << 1) return _randomBits(3) < (n >> 1); // 2, 6, 10, 14 — ???0
        }
        const r = _randomBits(4);
        if (r !== n) return r < n; // ????
        else p -= n; // 1/16 chance of continuing computation.
      }
      // Generating (up to) 4 bits at a time is not based on past performance measures, or anything.
      // Using 4 bits at a time consumes on average about double the bits that using 1 bit at a time would, but should be much faster.
    },
  },

  randomFloat:{
    use:true,
    docs:`\`randomFloat()\`: Returns a number in 0…1.`,
    type:[
      _(`funcType`),
      _(`_numberType`),
    ],
    argCount:0,
    call() { if (call.pure) throw impure;  return Math.random() },
  },

  _countBits(n) { let x=0; while (n >>>= 1) ++x;  return x },

  _randomBits(n) { // Returns n || 32 random bits.
    if (n !== (n & 31)) throw new Error('Expected 0…31 bits to generate (where 0 is 32), got '+n)
    if (!n) {
      if (!_randomBits.a)
        Object.assign(_randomBits, { a:new Uint32Array(1024), pos:1024 })
      if (_randomBits.pos >= _randomBits.a.length) _randomBits.pos = 0, _randomFill(_randomBits.a);
      return _randomBits.a[_randomBits.pos++]
    }
    if (_randomBits.n === void 0) _randomBits.r = _randomBits.n = 0;
    let r = 0;
    if (n > _randomBits.n) r = _randomBits.r, n -= _randomBits.n, _randomBits.r = _randomBits(0), _randomBits.n = 32;
    r = (r << n) | (_randomBits.r & ((1 << n) - 1)), _randomBits.n -= n, _randomBits.r >>>= n;
    return r
  },

  _randomFill(buf) { // Fills a u/int-array or array-buffer with random data.
    buf = new Uint8Array(buf.buffer || buf);
    let bytes = buf.byteLength
    if (typeof crypto!==''+void 0 && crypto.getRandomValues) {
      const quota = 65536, n = Math.floor(bytes/quota);
      let src = n && new Uint8Array(quota), i;
      for (i = 0; i < n; ++i)
        crypto.getRandomValues(src), buf.set(src, i*quota);
      src = new Uint8Array(bytes - n*quota);
      crypto.getRandomValues(src), buf.set(src, n*quota);
    } else
      for (let i = 0; i < buf.length; ++i)
        buf[i] = (Math.random() * Math.pow(2,32)) >>> 0;
    return buf;
  },

  call:{
    use:1,
    tutorial:[
      `(Warning: this \`tutorial\` involves actually writing programs. If no want, try something easier, like \`tutorial callAdjust\`.)

Do you know how easy it is to make an interpreter of the DAG IR we use? Let's see.

To be clear, the \`basic\` intermediate representation (IR) in question is "doing a thing may depend on having done other things; function applications are arrays, functions are first elements in them, and dependencies are references in those arrays": \`(add (mul 2 3) (mul 4 5))\`.

First, a very simple interpreter of trees, where no nodes (arrays) are shared.
Naturally, every interpreter, like every process, is a \`func\`, such as \`\\2*3+?\`.
To evaluate an array, we want to apply (\`applyArray\`) the \`transform\`ed-with-evaluation array; non-arrays (\`select\` where \`isArray ?\` returns \`false\`) should be returned as-is. Right-click (or tap-hold) if confused.
And to debug what you wrote, call it with some \`quote\`d input, like the one above.
Would you \`fancy\` composing composition out of these, by chance?`,
      [
        _(`fancy`),
        '',
        function(fn) {
          // It's easier to write the interpreter than to pattern-match these cases. Do that.
          if (typeof fn != 'function') return
          const ins = [5, [add, 1, 2], [add, [mul, [add, 4, 6], 10], [div, 10000, 100]]], outs = [5, 3, 200]
          const env = _newExecutionEnv()
          return {
            then: then => void _schedule([transform, quote(ins), fn], env, got => {
              if (!isArray(got) || got.length != 3) then(false)
              then(outs.every((o,i) => got[i] === o))
            }),
            cancel() { _cancel(env) },
          }
        },
      ],
      `The intended solution was: \`eval eval:\\(select (isArray ?) \\(applyArray (transform ? eval)) \\? ?)\`.
On desktop, you can type out just the function without binding to \`eval\`, then put your cursor where the function goes to \`transform\`, then hover over the function and Control-click it (\`insertLinkTo\` in \`Commands\`).
Also, do you not like the syntax? Then change it. Your world, your rules. Summon the context menu on \`_fancyOutermost\`, find its rewrite editor, edit it (don't forget to press Enter), then expand the next rewrite.

A real interpreter would also handle \`(quote (1 2 3))\`, and a real interpreter of inside-a-function would also handle \`input\`s. These are trivial enough to handle, so here, care not.

Instead, care about shared nodes.
Our IR has scope: \`a+a a:2*3\` or \`a:2*3 a+a\` is \`bound\` to be the same as \`2*3+2*3\`. In UI and compilers here, all references are already resolved, but in writing, we have to define variables. If you've never heard of scopes before… well, you're a big girl, you'll figure it out.
A node should remember its result. A \`map\` can remember keyed-by-node results, so here is a simple scheme: have \`m:{}\`, and return \`(mapRead m Node)\` if it does not equal \`_notFound\`, else return \`(mapWrite m Node ?)\`.
Can you see the unhandled cases?`,
      [
        _(`fancy`),
        '',
        function(fn) {
          // No solution awaits you. Don't learn by imitating, learn by doing.
          // The ability to just do it is in everyone, and you can do whatever you want to too.
          let n = 0
          const f = () => { ++n }
          const node1 = [f]
          if (typeof fn != 'function') return
          const env = _newExecutionEnv()
          return {
            then: then => void _schedule([fn, [last, node1, [f], node1, node1]], env, () => then(n === 2)),
            cancel() { _cancel(env) },
          }
        },
      ],
      `You are correct. Cycles would loop forever, and functions that share nodes (such as in recursion) will only evaluate them once.
The former can be fixed by pre-storing the marker value "we are computing this node, do not rely on its results". The latter can be fixed by having the reference to the current map be mutable, and set/reset on function entry/exit.

We're not instantly making production-quality code here (like \`_compileBody\`), so you can be more relaxed than a bat hanging off a perch. If you reached this legitimately, then I'm so happy for you.

Talk time.

As we go from \`call\` to \`callAdjust\`, or from \`basic\` to \`fancy\` to \`fancier\`, it's always important to remember the basics, to keep things grounded.

Why is it so hard to do the most trivial things? Are you unused to reinventing the most basic things; maybe confused on why anyone would ever want to do that?
Basic things are foundations for everything else, and even minor changes in a base can mean arbitrarily big large-scale differences. The most obvious case is when it doesn't work or has a bug that needs to be worked around, but even little differences like "what order do we evaluate dependencies in" or "do we drop unneeded dependencies (and/or evaluate lazily)" or "do we do tail-call optimization, and do we have loops" need programs to adapt to that.
There can be an urge to just go with what is learned over life's course, and effectively put the bases you've learned to create one super-base, but there is never just one thing that is the best for all cases ever, and that applies to foundations too. Infinity cannot be "worked around", so face it head-on.

Now, why our particular DAG IR? It's convenient: for both humans and programs, referring to parts of programs is just a pointer. No need to manipulate characters nor juggle variable scopes, just \`make\` arrays and be done with program generation. This makes precision easy.

More importantly, if it was this simple for us to come up with an interpreter, then it's just as easy for generated programs to come up with an interpreter (and with proper partial evaluation, there shouldn't even be any inherent cost in doing so, though \`mapWrite\` doesn't support it out-of-the-box, so it has to be learned). The fact that this sits on top of relatively complicated parsing and object-construction and visualization and other mechanisms doesn't really matter to users, whether human or otherwise. Extensibility by implementation.

Well, no more talk. Goodbye, and take care.`,
    ],
    docs:`\`call ^(Func …Args)\`: recursively \`call\`s all sub-items, then applies the first value (the function) to the rest of values.
Defining this allows function application. In fact, \`F:(func …?)\` acts the same as \`(concept call F)\`.
Computation cycles are disallowed (unless \`\`settings ^_forgiveMistakes\`\`), and every node's value (array's value) is only computed once.
(This used to be used in the global \`interpreter\` loop, but was superseded by \`callAdjust\`.)


All languages, and everything that does stuff, must have an internal representation (IR) of arbitrary computations.

We chose our IR to be lambda-calculus-like: very simple and direct. But by itself, unlike Lambda calculus, our IR does not have closures, and needs a separate function to \`make\` them. This allows representing what actually happens in the machine more closely (theoretically, anyway).
(An equivalent effect to closures can be achieved with arrays/objects anyway. Compilers could gain more from doing more search, even of seeming fundamentals: for example, partially-evaluate long-existing closures.)

Another difference is that our IR has no variable bindings, choosing to share nodes instead. This makes it easy to inspect programs.

It's simple so that it's easy to extend. Adding partial evaluation (\`purify\`)? Parallel execution? Compilation to a different target? Self-modification (\`using\`'s \`regenerate\`)? Simplicity itself, my friend. I'd extend it myself, but I want to use machine learning on these for optimal results, which is not trivial right now. But maybe I can work to make it more trivial to use?`,
    philosophy:`Programming languages are typically geared towards creating an abstraction layer that's convenient for humans to understand and use. Even Lisp has macros. Something so direct as this IR is unusual outside of machine code. Why would it be wanted?

It's for machines as much as it is for humans. If we can come up with a method of general learning that's as good as this IR could directly allow, then its intelligence is equal to humans'. (In other words, it's an arena where the vague and ever-shifting is made concrete.)
And, it's universal, and so can represent any computation, any doing of stuff, any other IR, and any other method of learning. General learning on even the simplest IR is general intelligence. The most obscure property of intelligence, self-modification? Learnable too.

In machine learning, The Bitter Lesson (as explained by the founder of reinforcement learning, Richard Sutton) is that compute reigns supreme over hand-engineered features in the end. Applied to programming languages, this means that a simple IR is sufficient. Lose all features but gain the world, assuming that learning has matured to be practical enough.

What is programming? Here, it's composition of functions: a tree of sequences of choices of what to be doing.
Sometimes they are annotated with types, and there is only one or a few choices; often, it's a huge mostly-worthless space.
Random and local and population-based searches won't do well.
Bayesian optimization needs simple constraints. But not only are our choices hierarchical, but they may well depend on nearby compositions.
Transformers on program text/instructions (from observations to Turing-complete choices, learning to predict the best sequence via trying several sequences and picking the best one)? A stilted form of reinforcement learning. Too flat, models no process, so, ultimately unsuitable.
Deep reinforcement learning? …Yes, it could work. With enough tricks from machine learning, with a good enough routing of differentiable information through the process of program generation (\`regenerate\`), and many choices stacked and interconnected — so really, hardly even RL at all. Learnable scaffolding around \`_choose\`, more like.
AGI may be possible with modern science, but isn't trivial at all. But I like a challenge.`,
    readAt:{
      last:_(`last`),
      quote:_(`quote`),
      func:_(`func`),
      select:_(`select`),
      equal:_(`equal`),
      purify:_(`purify`),
      error:_(`error`),
    },
    nameResult:[
      `result`,
    ],
    dispose:true,
    call(x) {
      // First, we handle purification and "I'm not a computation" and "I don't want to be a computation".
      if (call.pure) return purify(x)
      if (!isArray(x)) return keep(x)
      if (x[0] === quote) return keep(x[1])

      /*
      // This is a very simple interpreter of DAGs, the most powerful IR (same as all the others). Left in for reference.
      //   (This does not handle `keep`/`dispose` definitions properly, just like `purify`.)

      // Don't forget to be interrupt-friendly!
      let [i = 0, outputs, po, inds, rc] = interrupt(5)

      // Evaluating inputs with recursion leaves ugly stack traces in errors, so we iterate over the post-order traversal instead.
      if (!po) [po, inds, rc] = _postorderInfo(x)
      if (!outputs) outputs = _allocArray(po.length)
      const collected = _allocArray(8)
      try {
        for (; i < po.length; ++i) {
          // Go through all nodes in the DAG, collect args, and apply functions.
          collected.length = inds[i].length
          for (let j=0; j < collected.length; ++j) {
            const ind = inds[i][j], dep = po[i][j]
            collected[j] = ind !== null ? outputs[ind] : isArray(dep) ? dep[1] : dep
            if (j === 0 && typeof collected[0] != 'function')
              error("Expected a function, got", collected[0])
          }
          outputs[i] = collected[0].call(...collected)
        }
        const result = outputs[po.length-1]
        outputs[po.length-1] = undefined, _disposeEachAndDealloc(outputs)
        _allocArray(po), inds.forEach(_allocArray), _allocArray(inds), _allocArray(rc)
        return result
      } catch (err) {
        if (err === interrupt) interrupt.stack.push(i, outputs, po, inds, rc)
        else _disposeEachAndDealloc(outputs)
        throw err
      } finally { _allocArray(collected) }
      */

      // Compile `x` just-ahead-of-time, then call compiled code.
      let [compCall] = interrupt(1)
      const env = call.env, ias = _id(adjustSave), ial = _id(adjustLoad)
      const prevAdjSave = env[ias];  env[ias] = undefined // Cancel adjustment immediately.
      const prevAdjLoad = env[ial];  env[ial] = undefined
      try {
        if (compCall === undefined) {
          if (callAdjust.callCache.has(x))
            compCall = callAdjust.callCache.get(x)
          else {
            const po = _postorderInfo(x)
            compCall = _compileBody(x, null, po, undefined, undefined, undefined, x)
            defines(_postorderInfo, dispose)(po)
            callAdjust.callCache.set(x, compCall)
          }
        }
        return compCall()
      } catch (err) { if (err === interrupt) interrupt.stack.push(compCall);  throw err }
      finally { env[ias] = prevAdjSave, env[ial] = prevAdjLoad }

      // .env (current execution environment), .depth (current call depth), .pure.
    },
  },

  applyArray:{
    use:true,
    argCount:1,
    type:[
      _(`funcType`),
      `I dunno, some array here`,
      `Its result will be given`,
    ],
    docs:`\`applyArray ^(Func …Args)\`: assuming that \`Func\` and \`Args\` are already evaluated, simply applies the function to arguments.`,
    dispose:true,
    call(x) {
      if (!isArray(x)) error('Not an array:', x)
      if (typeof x[0] != 'function')
        error('Expected a function to call, got', x[0], 'in the DAG node', x)
      return x[0].call(...x)
    },
  },

  apply:{
    use:true,
    type:[
      _(`funcType`),
      [
        _(`funcType`),
        [
          _(`rest`),
          `Inputs`,
        ],
        `Output`,
      ],
      [
        _(`rest`),
        `Inputs`,
      ],
      `Output`,
    ],
    examples:[
      [
        `repeat ^(apply \\?+randomVar() 5)=4 1000`,
      ],
    ],
    docs:`\`apply Func …Args\`: applies \`Func\` to \`Args\`.

\`(apply Func …Args)\` is semantically the same as \`(Func …Args)\`, but it behaves better for \`adjust\`ment of computed \`Func\`s.`,
    readAt:{
      applyArray:_(`applyArray`),
      applyStatically:_(`applyStatically`),
    },
    dispose:true,
    mergeAdjustment:_(`_mergeTensors`),
    adjustLater:true,
    adjust:{
      dispose:_(`_disposeEachAndDealloc`),
      call(ins, _, dout) {
        if (call.pure) throw impure
        const [fn, ...args] = ins
        const dargs = adjust(fn, args, _, dout)
        const dargs2 = _allocArray(1+dargs.length)
        dargs2[0] = undefined
        for (let i=0; i < dargs.length; ++i) dargs2[i+1] = dargs[i]
        _allocArray(dargs)
        return dargs2
      },
    },
    call(fn, ...args) {
      if (typeof fn != 'function')
        error('Expected a function to call, got', fn)
      return fn(...args)
    },
  },

  Constructions:{
    docs:`Arrays are a good way of representing graphs, but not all runtime objects are arrays. The functions here allow encoding objects in arrays.`,
    readAt:{
      make:_(`make`),
      makeDAG:_(`makeDAG`),
      makeGraph:_(`makeGraph`),
      construct:_(`construct`),
      deconstruct:_(`deconstruct`),
      concept:_(`concept`),
      map:_(`map`),
      weakMap:_(`weakMap`),
      tensor:_(`tensor`),
      static:_(`static`),
    },
  },

  make:{
    use:true,
    type:[
      _(`funcType`),
      [
        _(`funcType`),
        [
          _(`rest`),
          `Inputs`,
        ],
        `Output`,
      ],
      [
        _(`rest`),
        `Inputs`,
        _(`madeType`),
      ],
      [
        _(`madeType`),
        `Output`,
      ],
    ],
    docs:`\`make Construct …Args\`: Creates one construct when called.
Cycles are impossible to create using only this.`,
    call(...x) {
      const obj = construct(x)
      construct(x, obj)
      return obj
    },
  },

  makeDAG:{
    docs:`\`makeDAG Expr\`: Turns an acyclic array graph into an array/object graph, in place if possible.
Lack of cycles allows us to pre/post \`construct\` at the same time, no backpatching.`,
    call(x, e) {
      let [env = e || _allocMap(), unfinished = _allocMap()] = interrupt(2)
      // env: original —> constructed|original
      // unfinished: Whether a node is not constructed yet, for cycle detection.
      try { x = walk(x);  !e && _allocMap(env), _allocMap(unfinished);  return x }
      catch (err) { if (err === interrupt) interrupt.stack.push(env, unfinished); else !e && _allocMap(env), _allocMap(unfinished);  throw err }

      function walk(x) {
        if (!isArray(x)) return x

        let [i, y = !Object.isFrozen(x) ? x : x.slice()] = interrupt(2)
        try {
          // Fully construct children then us.
          if (i === undefined) {
            if (env.has(x)) return env.get(x)
            if (unfinished.has(y)) error("Cycle detected at", y)
            unfinished.set(y, true)
            i = 0
          }
          for (; i < x.length; ++i)
            y[i] = walk(x[i])
          if (!isArray(x[0]) && defines(x[0], construct)) {
            env.set(x, construct(y))
            construct(y, env.get(x))
          } else env.set(x, y)
          unfinished.delete(y)
          return env.get(x)
        } catch (err) { if (err === interrupt) interrupt.stack.push(i, y);  throw err }
      }
    },
  },

  _logHiddenConstructionErrors:[
    _(`settings`),
    false,
    `If checked, errors during cons-world regeneration will be logged to browser console.`,
  ],

  makeGraph:{
    keep:1,
    docs:`\`makeGraph Expr\`: Turns an array graph into an array/object graph, in place if possible.

Constructs all dependencies before dependents, and throws if there is a cycle (unless instructed to hide errors).
    More "correct", but less trivially-parallelizable (if this was not JS).`,
    readAt:{
      _logHiddenConstructionErrors:_(`_logHiddenConstructionErrors`),
    },
    call(x, e, noFullConstruction = false, openCollapsed = true, hideErrors = false, constructTheTopLevelArray = true, reconstruct) {
      if (openCollapsed && _isCollapsed(x)) return x
      if (!isArray(x)) return x
      let [env = e || _allocMap(), unfinished = new Set, xs, ys, ns, ourT = _allocMap()] = interrupt(6)
      // env: original —> constructed|original
      // unfinished: Whether a node is not constructed yet, for cycle detection.
      // xs/ys/ns: constructed source arrays, constructed result objects, and how far along the construction we are.
      // ourT: keeps track of which tensors we created, and need to dispose.
      try {
        if (xs === undefined)
          xs = _allocArray(0), ys = _allocArray(0), ns = _allocArray(0),
          xs.push(x), ys.push(null), ns.push(null)
        while (xs.length) { // Recursion over arrays, but as a loop.
          let x = xs[xs.length-1], y = ys[ys.length-1], n = ns[ns.length-1]
          if (n === null) { // Pre-order.
            if (env.has(x) && (!reconstruct || !reconstruct.has(x))) { xs.pop(), ys.pop(), ns.pop();  continue }
            if (y === null) y = ys[ys.length-1] = !Object.isFrozen(x) ? x : x.slice()
            if (reconstruct && reconstruct.has(x))
              !env.has(x) && error("Re-constructed objects must have been constructed, but got the maverick", x), unfinished.add(y)
            else if (!isArray(x[0]) && defines(x[0], construct) && (xs.length > 1 || constructTheTopLevelArray))
              try { env.set(x, construct(y)), unfinished.add(y), _isDisposable(env.get(x)) && ourT.set(env.get(x), env.get(x)) }
              catch (err) { if (err === interrupt || !hideErrors) throw err;  else env.set(x, null), _setting(_logHiddenConstructionErrors) && console.log(err, err && err.stack) }
            else
              env.set(x, y)
            n = ns[ns.length-1] = 0
          }
          reconstruct && reconstruct.delete(x)
          for (; n < y.length; n = ns[ns.length-1] = n+1) { // Order.
            if (openCollapsed && _isCollapsed(x[n])) y[n] = keep(x[n].to)
            else if (!isArray(x[n])) y[n] = keep(x[n])
            else if (env.has(x[n]) && (!reconstruct || !reconstruct.has(x[n]))) y[n] = keep(env.get(x[n]))
            else { xs.push(x[n]), ys.push(null), ns.push(null);  n = null;  break }
          }
          if (n === null) continue
          if (!noFullConstruction && env.get(x) !== y && env.get(x) !== null) { // Post-order.
            // To allow user-defined constructs, construct all (acyclic) potential dependencies then construct us.
            try {
              for (let j=0; j < y.length; ++j)
                if (unfinished.has(y[j]))
                  error('User-defined constructs must not depend on their instances, as happened in', x[j])
              construct(y, env.get(x)) // An error here would not change any cyclic users of `x` to use `null`, only non-cyclic users.
            } catch (err) { if (err === interrupt || !hideErrors) throw err;  else env.set(x, null), _setting(_logHiddenConstructionErrors) && console.log(err) }
            unfinished.delete(y)
          }
          if (isArray(y)) _rememberArrayItems(y)
          xs.pop(), ys.pop(), ns.pop()
        }
        const y = env.get(x)
        ourT.delete(y)
        !e && _allocMap(env)
        return y
      } catch (err) { if (err === interrupt) interrupt.stack.push(env, unfinished, xs, ys, ns, ourT), ourT = null; else !e && _allocMap(env), _killArray(xs), _killArray(ys), _killArray(ns);  throw err }
      finally { ourT && (ourT.forEach(dispose), _allocMap(ourT)) }
    },
  },

  _isCollapsed(x) { return typeof document != ''+void 0 && x instanceof Element && x.tagName === 'COLLAPSED' && x.special },

  construct:{
    examples:[
      [
        `obj;construct(arr,obj);obj
obj:construct(arr)
arr:arrayCons(func,getLast(loop 10 i->x->arrayCons(i,x) array('func body')))`,
      ],
      [
        `transform(10,i→a→construct(^(arrayObject func 1 2 3),a.i),a);a
a:transform(10,i→construct(^(arrayObject func 'later')))`,
      ],
    ],
    docs:`\`construct(x)\`→\`obj\` / \`construct(x,obj)\`: To encode non-array objects in array graphs, a global \`defines\` this.
Globals and user-defined concepts that statically define this are constructed right after parsing.

This embodies a simple principle: a graph/network cannot be constructed without backpatching.
(While this can be used to implement Lisp-like macros, please call quoted code or apply functions instead. \`construct\` is for non-array objects.)`,
    call(x, obj = undefined) {
      if (isArray(x)) {
        if (typeof defines(x, construct) == 'function')
          return defines(x, construct)(x, obj)
      }
      if (x instanceof Map)
        !(obj instanceof Map) && error('Expected a map, got', obj),
        x.clear(), obj.forEach((v,k) => x.set(k,v))
      return x
    },
  },

  tensor:{
    docs:`\`tensor Numbers Shapes Type\`: \`construct\`s a multi-dimensional array of numbers.`,
    serialize:0,
    construct(x, obj) {
      if (obj === undefined) {
        let [_, data, shapes, t] = x
        if (!data) error("Expected data, got", data)
        if (shapes !== undefined && !isArray(shapes)) error("Expected an array or nothing, got", shapes)
        let dtype = t===undefined ? 'float32' : t
        if (!dtype) error("Expected", 'float32', "or", 'int32', "or", 'bool', "or", 'whatever', "or nothing, got", t)
        if (typeof data == 'string')
          data = _fromBase64(data, dtype)
        return _tf(tf.tensor(data, shapes, dtype))
      }
    },
  },

  _toLittleEndian:{
    docs:`Different processors can have different endian-ness (byte-order). This func allows ensuring that parses/serializations with different byte-orders arrive at the same values.`,
    Initialize() { _toLittleEndian.littleHost = (new Uint8Array(new Uint16Array([1]).buffer))[0] === 1 },
    call(typedArray) {
      if (_toLittleEndian.littleHost || typedArray instanceof Int8Array || typedArray instanceof Uint8Array) return typedArray
      const v = new DataView(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength)
      const a = typedArray.slice(), LE = true
      if (typedArray instanceof Int16Array) for (let i = 0; i < a.length; ++i) a[i] = v.getInt16(i*2, LE)
      if (typedArray instanceof Uint16Array) for (let i = 0; i < a.length; ++i) a[i] = v.getUint16(i*2, LE)
      if (typedArray instanceof Int32Array) for (let i = 0; i < a.length; ++i) a[i] = v.getInt32(i*4, LE)
      if (typedArray instanceof Uint32Array) for (let i = 0; i < a.length; ++i) a[i] = v.getUint32(i*4, LE)
      if (typedArray instanceof Float32Array) for (let i = 0; i < a.length; ++i) a[i] = v.getFloat32(i*4, LE)
      if (typedArray instanceof Float64Array) for (let i = 0; i < a.length; ++i) a[i] = v.getFloat64(i*8, LE)
      return a
    },
  },

  _toBase64(typedArray, allowAsync = false) { // -> base64
    const a = _toLittleEndian(typedArray)
    const bytes = new Uint8Array(a.buffer, a.byteOffset, a.byteLength)
    if (!allowAsync || bytes.length < 400000) {
      // 80 MB in 8 seconds. Pretty much the fastest synchronous solution.
      const arr = [];  arr.length = bytes.length
      for (let i=0; i < bytes.length; ++i)
        arr[i] = String.fromCharCode(bytes[i])
      return btoa(arr.join(''))
    } else {
      // 80 MB in .7 seconds. But needs `await`ing.
      const blob = new Blob([bytes], {type:'application/octet-binary'})
      const reader = new FileReader
      let then, p = new Promise(f => then = f)
      reader.onload = () => then(btoa(reader.result))
      reader.readAsBinaryString(blob)
      return p
    }
  },

  _fromBase64(base64, dtype = 'uint8') { // -> bytes
    const str = atob(base64)
    let a = new Uint8Array(str.length)
    for (let i=0; i < str.length; ++i)
      a[i] = str.charCodeAt(i)

    // Change endian-ness (byte order) from little to ours, in-place, if needed.
    a = new ({int8:Int8Array, int16:Int16Array, int32:Int32Array, uint8:Uint8Array, uint16:Uint16Array, uint32:Uint32Array, float32:Float32Array, float64:Float64Array, bool:Int8Array}[dtype] || Float32Array)(a.buffer)
    if (!_toLittleEndian.littleHost && dtype !== 'bool' && dtype !== 'int8' && dtype !== 'uint8') {
      const v = new DataView(a.buffer, a.byteOffset, a.byteLength), LE = true
      if (dtype === 'int16') for (let i = 0; i < a.length; ++i) a[i] = v.getInt16(i*2, LE)
      if (dtype === 'uint16') for (let i = 0; i < a.length; ++i) a[i] = v.getUint16(i*2, LE)
      if (dtype === 'int32') for (let i = 0; i < a.length; ++i) a[i] = v.getInt32(i*4, LE)
      if (dtype === 'uint32') for (let i = 0; i < a.length; ++i) a[i] = v.getUint32(i*4, LE)
      if (dtype === 'float32') for (let i = 0; i < a.length; ++i) a[i] = v.getFloat32(i*4, LE)
      if (dtype === 'float64') for (let i = 0; i < a.length; ++i) a[i] = v.getFloat64(i*8, LE)
    }
    return a
  },

  deconstruct:{
    use:1,
    docs:`\`(deconstruct Object)\`: turn an object into its array-representation (that could be evaluated to re-create that native value).`,
    call(v, allowPath = false, allowAsync = false) {
      if (defines(v, deconstruct)) return defines(v, deconstruct)
      else if (isArray(v)) return isArray(v[0]) || defines(v[0], construct) === undefined ? v.slice() : [arrayObject, ...v]

      if (v instanceof Promise) return elem('number', '<Promise>')

      if (typeof tf != ''+void 0 && v instanceof tf.Tensor) {
        const shapeImplied = v.dtype === 'float32' && v.shape.length <= 1 && !v.isDisposedInternal && v.size <= _maxSerializedTensorSize[1]
        const data = v.isDisposedInternal ? '<Disposed>' : serialize.styles ? (shapeImplied ? v.arraySync() : v.dataSync()) : _toBase64(v.dataSync(), allowAsync)
        if (shapeImplied)
          return [tensor, data]
        if (v.dtype === 'float32')
          return [tensor, data, merged(v.shape)]
        return [tensor, data, merged(v.shape), v.dtype]
      }

      if (v && Object.getPrototypeOf(v) && Object.getPrototypeOf(Object.getPrototypeOf(v)) === Object.getPrototypeOf(Int8Array.prototype)) {
        if (v instanceof Int8Array)
          return [i8, serialize.styles ? Array.from(v) : _toBase64(v, allowAsync)]
        if (v instanceof Int16Array)
          return [i16, serialize.styles ? Array.from(v) : _toBase64(v, allowAsync)]
        if (v instanceof Int32Array)
          return [i32, serialize.styles ? Array.from(v) : _toBase64(v, allowAsync)]
        if (v instanceof Uint8Array)
          return [u8, serialize.styles ? Array.from(v) : _toBase64(v, allowAsync)]
        if (v instanceof Uint16Array)
          return [u16, serialize.styles ? Array.from(v) : _toBase64(v, allowAsync)]
        if (v instanceof Uint32Array)
          return [u32, serialize.styles ? Array.from(v) : _toBase64(v, allowAsync)]
        if (v instanceof Float32Array)
          return [f32, serialize.styles ? Array.from(v) : _toBase64(v, allowAsync)]
        if (v instanceof Float64Array)
          return [f64, serialize.styles ? Array.from(v) : _toBase64(v, allowAsync)]
      }

      if (allowPath && readAt.parents.has(v)) {
        const p = readAt.parents.get(v), lkp = defines(p, readAt)
        if (lkp)
          for (let k in lkp)
            if (lkp[k] === v) return [readAt, p, k]
        if (_view(p))
          for (let k of Object.keys(_view(p)))
            if (k !== _id(deconstruct) && _view(p)[k] === v)
              return [defines, p, concept.idToKey[+k]]
      }

      if (typeof document != ''+void 0) {
        // Not precise at all.
        if (v instanceof Node && 'to' in v) return v.to
        if (v instanceof Element) return [elem, v.tagName.toLowerCase(), [...v.childNodes].map(ch => deconstruct(ch, allowPath))]
        if (v instanceof Node) return v.textContent
      }

      if (v instanceof Map) {
        // DON'T sort keys by _id. Preserve the original order.
        const keys = [...v.keys()]//.sort((a,b) => _id(a) - _id(b))
        const arr = [map]
        keys.forEach(k => arr.push(k, v.get(k)))
        return arr
      }
      if (v && v[defines.key]) {
        // Deconstruct into definitions, treating self-references specially (because funcs need that).
        const d = v[defines.key]
        const result = [concept]
        const selfRef = typeof v == 'function' ? {[defines.key]:{[_id(deconstruct)]:_unevalFunction(v)}} : result
        for (let k of Object.keys(d).sort((a,b) => _id(a) - _id(b))) {
          const val = d[k]
          if (k === call && typeof v == 'function') continue
          result.push(concept.idToKey[+k], val === v ? selfRef : val)
        }
        if (typeof v == 'function')
          result.push(call, selfRef)
        return result
      }
      if (typeof v == 'function')
        return _unevalFunction(v)
      if (!v || typeof v != 'object')
        return v
      if (v instanceof Error) return _errorRepr(v)
      // And, objects (likely in `readAt`) just get deconstructed as maps.
      const arr = [map]
      Object.keys(v).forEach(k => arr.push(k && +k === +k ? +k : k, v[k]))
      return arr
    },
  },

  _unevalFunction(f, dry = false, noWhitespaceRemoval = false) {
    let ctx = typeof f == 'function' && jsEval.ctx in f ? f[jsEval.ctx] : undefined
    if (ctx === Self.ctx) ctx = undefined

    const defC = !isArray(f) && defines(f, call)
    if (typeof defC == 'function' && f !== defC) f = defC
    // User-defined `concept`s can show up here, but `func`s must not.
    if (dry) return typeof f == 'function' && defines(f, deconstruct) === undefined

    let src = (''+f).split('\n')
    if (!noWhitespaceRemoval) {
      const ws = /^\s*/.exec(src[src.length-1])[0]
      src = src.map(line => line.replace(ws, ''))
    }
    src = src.join('\n').replace(/^[_a-zA-Z0-9]+/, '')
    try { Function('('+src+')') }
    catch (err) { src = 'function'+src }

    return ctx !== undefined ? [jsEval, src, ctx] : [jsEval, src]
  },

  input:{
    docs:`\`input\` or \`?\`: A convenient mark of a function input.
For example, both \`\\?+3 5\` and \`(func ? ?+3) 5\` return \`8\`.`,
  },

  _fallthroughFunc(n) {
    // Given count of inputs.
    if (n === 0) return function obj() { let z; try { return obj.f() } catch(err) { err===interrupt && (z=true); throw err } finally { !z&&adjustSave(obj.a) } }
    else if (n === 1) return function obj(a) { let z; try { return obj.f(a) } catch(err) { err===interrupt && (z=true); throw err } finally { !z&&adjustSave(obj.a) } }
    else if (n === 2) return function obj(a,b) { let z; try { return obj.f(a,b) } catch(err) { err===interrupt && (z=true); throw err } finally { !z&&adjustSave(obj.a) } }
    else return function obj(...a) { try { return obj.f(...a) } catch(err) { err===interrupt && (a=null); throw err } finally { a&&adjustSave(obj.a) } }
  },

  _fallthroughAutoFunc(n) {
    // Like `_fallthroughFunc`.
    return function obj(...ins) {
      // Like `return obj.f(...ins)`, but with profiling, auto-using, and adjustment support.
      let [stage = 0, state, result, threw, cl, aj] = interrupt(6)
      const prevAF = autoFunc.now;  autoFunc.now = obj
      try {
        switch (stage) {
          case 0: // FuncEnter
          stage = 1;  case 1:
            using(obj, prevAF)
          stage = 2;  case 2:
            usingFinish()
            cl = obj.f, aj = obj.a
            if (typeof cl != 'function') error(obj, "did not get compiled:", cl, aj)
          stage = 3;  case 3:
            if (!obj.OnExit)
              result = cl(...ins)
            else
              try { result = cl(...ins), threw = false }
              catch (err) { if (err === interrupt) throw err;  result = err, threw = true }
          stage = 4;  case 4: // FuncExit
          stage = 5;  case 5:
            if (threw) throw result
            adjustSave(aj)
            return result
        }
      } catch (err) {
        if (err === interrupt) interrupt.stack.push(stage, state, result, threw, cl, aj)
        else _disposeEachAndDealloc(state), dispose(result)
        throw err
      } finally { autoFunc.now = prevAF }
    }
  },

  _adjustFunc:{
    call(ins, dout) {
      if (call.pure) throw impure
      // Resilient to a func's adjustment changing from when it was first called.
      const [adj = adjustLoad(null)] = interrupt(1)
      if (typeof adj != 'function' && adj !== null)
        _inexactReversal(true, "expected an adjustment function, got", adj, "for inputs", ...ins)
      try { return adj !== null ? adj(ins, undefined, dout) : _allocArray(ins.length).fill(0) }
      catch (err) { if (err === interrupt) interrupt.stack.push(adj);  throw err }
    },
    dispose:_(`_disposeEachAndDealloc`),
  },

  id:{
    docs:`\`id X\`: returns \`X\` unchanged.`,
    argCount:1,
    dispose:1,
    keep:1,
    call(x) { return x },
    _resultCanBe(x) { _resultCanBe(x[1]) },
  },

  func:{
    use:true,
    docs:`\`\\Body\` or \`func ? Body\` or \`func …ArgNodes Body\` or \`Arg1->Arg2->Arg3->Body\`: A \`construct\` that can be called to evaluate \`Body\`, replacing values of \`ArgNodes\` with dynamically-provided values.

Note that despite what the arrow-syntax might suggest, there are no closures unless you \`make\` them (the objects you see are the only objects you get). Syntactic scope does not exist after parsing, so we wouldn't even know what's a closure. This way is more explicit anyway.

Funcs do not \`observe\` their nodes (that would need a lot of memory to wire up). Instead, re-compile the function object itself with \`writeAt\` (accessible from \`contextMenu\`) if a change is needed.`,
    readAt:{
      input:_(`input`),
      id:_(`id`),
    },
    _resultCanBe(x) { _resultCanBe(x[x.length-1]) },
    examples:[
      [
        `\\4 5`,
        `4`,
      ],
      [
        `(func a b a+b) 1 3`,
        `4`,
      ],
      `Note that the specified arguments are not evaluated.`,
      [
        `2→2+2 5`,
        `10`,
      ],
      `(IN BASE FOUR.)`,
    ],
    construct(x, obj) {
      if (!isArray(x) || x.length < 2) error("Expected at least the function body")
      if (obj === undefined) {
        obj = _fallthroughFunc(x.length-2)

        const d = obj[defines.key] = Object.create(null)
        const dd = d[_id(deconstruct)] = x.slice().fill();  _rememberToDispose.seen && _rememberToDispose(dd)
        d[_id(argCount)] = x.length-2
        d[_id(dispose)] = true

        d[_id(mergeAdjustment)] = _mergeTensors // Just assume that every arg is a tensor.
        d[_id(adjust)] = [_adjustFunc, _ins, _dout, obj]
        d[_id(adjustLater)] = true // Make sure that the function is not skipped at adjustment.
        //   (Checking whether any nodes define `adjustLater` would have been much more accurate, but that's data-dependent, and concepts are immutable. We never `observe` them, at least, so we can't dynamically update code of funcs that depend on them.)

        return obj
      } else {
        const d = obj[defines.key], dd = d[_id(deconstruct)]
        d[_id(argCount)] = x.length-2
        if (dd !== x) {
          _rememberToDispose.seen && (_rememberArrayItems(dd, false), dd.forEach(dispose))
          dd.length=0, dd.push(...x)
          _rememberToDispose.seen && _rememberToDispose(dd)
        }

        const inputs = _allocMap()
        for (let i = 1; i < x.length-1; ++i) inputs.set(x[i], i)
        const body = x[x.length-1]
        let [poIndRc = _postorderInfo(body, inputs)] = interrupt(1)
        try {
          if (!inputs.has(body))
            obj.a = _compileAutograd(poIndRc, inputs, undefined, obj)
          else
            obj.a = _giveAdjustTo(inputs.get(body)-1)
          obj.f = _compileBody(body, inputs, poIndRc, undefined, undefined, undefined)
        } catch (err) {
          if (err === interrupt) interrupt.stack.push(poIndRc), poIndRc = null
          throw err
        } finally { _allocMap(inputs), poIndRc && defines(_postorderInfo, dispose)(poIndRc) }
      }
    },
    nameResult:[
      `f`,
      `g`,
      `h`,
    ],
  },

  _giveAdjustTo(n) {
    return function giveToInput(ins, _, dout) {
      const a = _allocArray(ins.length).fill(0)
      a[n] = keep(dout)
      return a
    }
  },

  _compileAutograd(poIndRc, inputs, types, sourceFunc) {
    // `_compileBody(autograd(poIndRc).0)`, but does proper checks and stuff and never returns `undefined`.
    if (!poIndRc[0].length) return null
    if (!adjust.inputs) adjust.inputs = new Map().set(_ins, 1).set(_out, 2).set(_dout, 3)
    let agAndMore
    agAndMore = autograd(poIndRc, inputs, types)
    if (!agAndMore) return null
    let [ag, outTypes, outDisposers] = agAndMore;  _allocArray(agAndMore)
    ag = !_isError(ag) ? ag : ag.map(quote)
    const agPoIndRc = _postorderInfo(ag, adjust.inputs, true)
    const fun = _compileBody(ag, adjust.inputs, agPoIndRc, outTypes, false, outDisposers, sourceFunc)
    defines(_postorderInfo, dispose)(agPoIndRc)
    return _allocMap(outTypes), _allocMap(outDisposers), fun
  },

  _getSavedNodes:{
    docs:`Given nodes in post-order and indexes for each, returns a newly-allocated array of \`true\` if the node needs to be saved to adjustment or \`undefined\` (or returns \`null\`).`,
    call(po, ind) {
      let save = null
      for (let i=0; i < po.length; ++i) {
        const x = po[i], fn = _unquote(x[0]), ins = ind[i]
        if (typeof fn != 'function' || isArray(fn) || defines(fn, adjust) === undefined || defines(fn, mergeAdjustment) === undefined)
          continue
        const adj = defines(fn, adjust)
        _fillAdjustInputs(adj)
        if (fn === last || _doesAdjustRead(adj, 0))
          !save && (save = _allocArray(po.length)), save[i] = true
        if (fn !== last && _doesAdjustRead(adj, 'ins'))
          for (let j = 1; j < ins.length; ++j)
            if (ins[j] !== null && _doesAdjustRead(adj, j))
              !save && (save = _allocArray(po.length)), save[ins[j]] = true
      }
      return save
    },
  },

  _fillAdjustInputs:{
    docs:`Fills props on itself to signify whether this DAG (of \`defines X adjust\`) uses \`_out\`, \`_dout\`, and/or \`_ins\` (and which statically-known index of \`readAt Y Index\`).
Use \`_doesAdjustRead\` to read out those props.`,
    call(x) {
      const f = _fillAdjustInputs
      if (!f.out) f.out = new WeakSet, f.dout = new WeakSet, f.ins = new WeakMap, f.In = []
      const { out, dout, ins, In } = _fillAdjustInputs
      if (!isArray(x) || ins.has(x)) return
      ins.set(x, false)
      for (let i=0; i < x.length; ++i) {
        const c = x[i]
        if (ins.get(x) !== 'all' && isArray(c) && c.length == 3 && c[0] === readAt && c[1] === _ins) {
          if (typeof c[2] == 'number' && c[2] === c[2]>>>0)
            ins.set(x, true), (In[c[2]] || (In[c[2]] = new WeakSet)).add(x)
          else !ins.get(x) && ins.set(x, 'all')
        } else {
          _fillAdjustInputs(c)
          if (c === _dout || dout.has(c)) dout.add(x)
          if (c === _out || out.has(c)) out.add(x)
          if (c === _ins) ins.set(x, 'all')
          else if (ins.get(x) !== 'all' && ins.get(c)) {
            ins.set(x, ins.get(c))
            if (ins.get(c) !== 'all')
              for (let j=0; j < In.length; ++j)
                if (In[j] && In[j].has(c)) In[j].add(x)
          }
        }
      }
      // .out (WeakSet), .dout (WeakSet), .ins (WeakMap to false/true/'all'), .in (an array of WeakSets — whether an individual input is read)
    },
  },

  _doesAdjustRead(adj, i) {
    // Returns true if this particular input index (zero-based) is used in the func's adjustment (or if any 'ins' index is used, or out/'dout').
    if (typeof adj == 'function') return i !== 0 // Don't save `out` of func-based adjustments.
    if (i === 0) return _fillAdjustInputs.out.has(adj)
    if (i === 'dout') return _fillAdjustInputs.dout.has(adj)
    if (i === 'ins') return _fillAdjustInputs.ins.get(adj)
    if (_fillAdjustInputs.ins.get(adj) === 'all') return true
    return _fillAdjustInputs.In[i-1] ? _fillAdjustInputs.In[i-1].has(adj) : false
  },

  _nodeDisposer(x, inputs, disposers, types) {
    let x1 = x, x2 = x
    while (true) {
      if (typeof x1 == 'function' || x1 === undefined) return x1
      x1 = _nodeDisposerTransition(x1, inputs, disposers, types)
      x2 = _nodeDisposerTransition(_nodeDisposerTransition(x2, inputs, disposers, types), inputs, disposers, types)
      if (x1 === x2) break
    }
  },

  _nodeDisposerTransition(x, inputs, disposers, types) {
    let disp
    // `disposers` and `types` can override the defined disposer.
    if (disposers && disposers.has(x)) disp = disposers.get(x)
    else if (types && types.has(x)) disp = typeDisposer(types.get(x))
    else
      // Get how to dispose the result: consult definition (always dispose unknown-function results), go to index.
      disp = inputs && inputs.has(x) || isArray(x) && (defines(x, dispose) || isArray(x[0]))

    if (typeof disp == 'number') return disp < 0 && (disp += x.length), x[disp]
    else return typeof disp == 'function' ? disp : disp ? dispose : undefined
  },

  _compileBody(body, inputs = null, poIndRc, types, saveToAdjust = true, nodeDisposers, sourceFunc) {
    // At least `body` is required.
    /*     Example of what this compiles DAGs to:
     * function(f,g,h) {
     *   'use strict'
     *   return function F(in1) {
     *     _checkInterrupt(F)
     *     let v0, v1, v2
     *     ++call.depth
     *     try {
     *         v0 = f(in1)
     *         v1 = g(v0, in1)
     *         v2 = h(v0, v1)
     *         return v2
     *     }
     *     finally { --call.depth }
     * }()
     *
     *     Complications:
     * - `interrupt` handling, to stop and resume execution.
     *   The variables may be restored on post-interrupt entry,
     *   and we may need an "instruction pointer" to not re-do done work,
     *   and the work may be wrapped in try/catch that saves all variables on interrupt.
     * - `adjustSave`ing some results for use in `adjust`.
     * - Typed `dispose`al of results, or `keep`ing them.
     */

    let owningPoIndRc = false
    if (!poIndRc && isArray(body) && body[0] !== quote)
      poIndRc = _postorderInfo(body), owningPoIndRc = true

    const consts = _allocMap()
    const [src, sourceURL, lines] = toSource(body, poIndRc, owningPoIndRc)
    try {
      const fn = Function([...consts.values()].join(','), src)(...consts.keys())
      if (!_compileBody.sources) _compileBody.sources = new WeakMap
      if (sourceFunc !== undefined) _compileBody.sources.set(fn, sourceFunc)
      fn.lines = lines
      if (!_compileBody.fin && typeof FinalizationRegistry != ''+void 0)
        _compileBody.fin = new FinalizationRegistry(sourceURL => delete _resolveStack.functions[sourceURL])
      _compileBody.fin && _compileBody.fin.register(fn, sourceURL)
      if (!_resolveStack.functions) _resolveStack.functions = Object.create(null)
      _resolveStack.functions[sourceURL] = typeof WeakRef != ''+void 0 ? new WeakRef(fn) : fn
      if (consts.size) fn[jsEval.ctx] = consts
      else _allocMap(consts)
      return fn
    } catch (err) { console.error(src, 'while trying to compile', body, 'got', err), _allocMap(consts); throw err }

    function toSource(body, poIndRc, owningPoIndRc) {
      // Compiles a DAG into an SSA form in JS that handles `interrupt`s.
      const code = _allocArray(0)
      let nextStage = 1

      const sourceURL = new Array(32).fill().map(() => (Math.random()*16 | 0).toString(16)).join('')
      const lines = []

      code.push(`'use strict'`)
      code.push(`return function F(${inputs ? [...inputs.values()].map(i => 'in'+i) : ''}) {`)
      if (!isArray(body) || body[0] === quote || !poIndRc[0].length)
        code.push(` return ${!inputs || !inputs.has(body) ? env(body) : `${env(keep)}(${env(body)})`}`)
      else if (poIndRc[0].length == 1 && !isArray(defines(body, adjust)) && defines(body, keep) === undefined) {
        _checkArgCount(body, inputs, body)
        lines.push(code.length+2, body)
        code.push(` try { return ++${env(call)}.depth, ${env(body[0])}(${body.slice(1).map(env)}) } finally { --${env(call)}.depth }`)
      } else {
        code.push(` ${env(_checkInterrupt)}(${sourceFunc === undefined ? 'F' : env(sourceFunc)})`)
        const backpatchVars = code.push(` VARIABLES`)-1
        code.push(` ++${env(call)}.depth`)
        code.push(` try {`)
        const backpatchGotoInterrupt = code.push(`  switch (stage) { case 0:`)-1

        const [po, inds, rc] = poIndRc
        const used = _allocArray(po.length)
        used.fill(0)
        const nodeNames = _allocArray(po.length), listOfVars = _allocArray(0), freeNames = _allocMap()

        // Fill in functions that have to dispose the result of every node when unneeded.
        const disposers = _allocArray(po.length)
        for (let i=0; i < po.length; ++i)
          disposers[i] = _nodeDisposer(po[i], inputs, nodeDisposers, types)

        // Save vars for adjustment.
        const save = saveToAdjust && _getSavedNodes(po, inds)

        for (let i=0; i < po.length; ++i) {
          // Walk the DAG in post-order, emit assignment of vars to application results.
          //   We don't re-use variable slots that won't be used in computation, because adjustment could want them.
          //     (Re-computing results requires estimates of runtime of nodes or other predictions, which are unavailable for now.)
          const x = po[i], fn = _unquote(x[0]), ins = inds[i]
          _checkArgCount(x, inputs, body)
          if (i) if (isArray(fn) || defines(fn, interrupt) !== false) {
            // Advance the interrupt stage if we cannot guarantee the function is non-interrupting.
            code.push(`   stage = ${nextStage}; case ${nextStage}:`)
            ++nextStage
          }

          // Collect var names of dependencies.
          const d = !isArray(fn) ? defines(fn, _compileBody) : undefined
          const deps = _allocArray(x.length)
          let keepIndex = !isArray(fn) ? defines(fn, keep) : undefined
          keepIndex < 0 && (keepIndex += x.length)
          for (let j=0; j < x.length; ++j) {
            const In = ins[j]
            if (In === null) deps[j] = j || typeof d != 'function' ? env(x[j]) : undefined
            else if (!nodeNames[In])
              error("Node ref-counts are incorrect, and", x[j], "in node", x, "in body", body, "was already disposed of")
            else deps[j] = nodeNames[In]
          }

          // Alloc the variable name (re-use a same-disposer var if possible).
          let pool = freeNames.get(disposers[i])
          nodeNames[i] = pool && pool.length ? pool.pop() : (listOfVars.push('v'+i), 'v'+i)

          // Assign result of application to its var. (Also accommodate some debugging settings.)
          //   `x` can define `_compileBody(env, assignTo, ...args)`.
          lines.push(code.length+2, x)
          let stmt = typeof d == 'function' ? d(env, nodeNames[i], ...deps.slice(1)) : `${nodeNames[i]} = ${deps[0]}(${deps.slice(1)})`
          if (_debugInterruptDefinitions[1] && !(isArray(fn) || defines(fn, interrupt) !== false))
            stmt = `try{${stmt}}catch(err){if(err===interrupt)error(${env("An interrupt in a non-interrupt node:")},${env(x)});throw err}`
          if (stmt.indexOf('\n') >= 0) error("Must not have newlines in", stmt)
          code.push(`   ${stmt}`)
          _allocArray(deps)

          // Decrease ref-counts of dependencies, and (keep and) dispose vars and mark for re-use if no longer needed.
          let extra = _allocArray(0)
          for (let j=0; j < x.length; ++j) {
            const k = ins[j]
            let kept = null
            if (keepIndex === true && j || typeof keepIndex == 'number' && j === keepIndex) { // Keep args if requested.
              // Test: `_compileBody ^(0+0;input) {input 1}` should `keep(in1)`.
              if (k != null || inputs && inputs.has(x[j]) || _isDisposable(x[j]))
                extra.push(`${env(keep)}(${k != null ? nodeNames[k] : env(x[j])})`), kept = extra.length-1
            }
            ++used[k]
            if (k != null && used[k] === rc[k]) { // If at the node's last use, dispose its result.
              if (save && save[k]) continue // Adjustment will decide its fate. (We omit a disposal, which is the same as keeping it for adjustment.)
              if (!nodeNames[k]) error('Uh-oh, double free of a node:', x[j], 'with refs', rc[k], 'in', x)

              const d = disposers[k]
              if (d === undefined) // If unneeded, don't dispose.
                extra.push(`${nodeNames[k]}=undefined`)
              else if (kept != null) // Keep+dispose pairs cancel out.
                extra[kept] = `${nodeNames[k]}=undefined`
              else // Dispose as specified, if specified.
                extra.push(`${nodeNames[k]}=${env(d)}(${nodeNames[k]})`)

              if (!freeNames.has(d)) freeNames.set(d, _allocArray(0))
              freeNames.get(d).push(nodeNames[k]), nodeNames[k] = undefined
            }
          }
          extra.length && code.push(`     ${extra.join(', ')}`), _allocArray(extra)
        }
        if (save && save.filter(x => x).length) { // Save those that need saving, for adjustment.
          const svs = save.map((sv,i) => sv && nodeNames[i]).filter(x => x)
          if (save[po.length - 1]) code.push(`   ${env(keep)}(${nodeNames[po.length - 1]})`)
          code.push(`   const $$$=${env(_allocArray)}(${svs.length})${svs.map((sv,i) => '; $$$['+i+']='+sv).join('')}; ${env(adjustSave)}($$$)`)
        }
        isArray(save) && _allocArray(save)
        code.push(`   return ${po.length ? nodeNames[po.length - 1] : env(body)}`)

        _allocArray(used), _allocArray(nodeNames)
        freeNames.forEach(_allocArray), _allocMap(freeNames)

        if (nextStage <= 1)
          code[backpatchGotoInterrupt] = ``
        else code.push(`  }`)

        code.push(` } catch (err) {`)
        code.push(`  if (err === ${env(interrupt)})`)
        if (nextStage > 1)
          code[backpatchVars] = ` let [stage=0,${listOfVars.join(', ')}] = ${env(interrupt)}(${1+listOfVars.length})`,
          code.push(`   ${env(interrupt)}.stack.push(stage,${listOfVars.join(', ')})`)
        else
          code[backpatchVars] = listOfVars.length ? ` let ${listOfVars.join(', ')}` : ``,
          code.push(`   ;`)
        code.push(`  else ${listOfVars.map(v => disposers[+v.slice(1)] && `${env(disposers[+v.slice(1)])}(${v})`).filter(x=>x).join(', ')};`)
        _allocArray(disposers), _allocArray(listOfVars)
        code.push(`  throw err`)
        code.push(` }`)
        code.push(` finally { --${env(call)}.depth }`)
        if (owningPoIndRc)
          defines(_postorderInfo, dispose)(poIndRc)
      }
      code.push(`}`)
      code.push(`//# sourceURL=${sourceURL}`)
      const result = code.join('\n')
      _allocArray(code)
      return [result, sourceURL, lines]
    }
    function env(x) {
      // Returns the string that can be used to refer to the constant value.
      if (inputs && inputs.has(x)) return 'in'+inputs.get(x)
      x = _unquote(x)
      if (x == null || typeof x == 'number' || typeof x == 'boolean') return ''+x
      if (!consts.has(x))
        consts.set(x, 'e' + consts.size)
      return consts.get(x)
    }

    // .sources
  },

  _checkArgCount(x, inputs, body) {
    // Checks arg count, and function-ness, at compile time. Does not catch all cases, but it's good enough.
    if (!isArray(x)) return
    const fn = _unquote(x[0])
    if (isArray(fn) || inputs && inputs.has(x[0])) return
    if (typeof fn != 'function') error('Expected a function to call, got', fn, 'in the DAG node', x.slice(), 'in body', body, 'with func inputs', inputs)
    if (!_setting(_forgiveMistakes) && typeof defines(fn, argCount) == 'number')
      if (defines(fn, argCount) !== x.length-1)
        error('Expected', defines(fn, argCount), 'args but got', x.length-1, 'in node', x, 'in', body)
  },

  _postorderInfo:{
    todo:`Since the arg-visiting order is technically arbitrary (unless \`last\`), allow funcs like \`sync\` to delay their visit as much as possible.`,
    docs:`Linearizes all execution-relevant information about a DAG into 3 equal-sized arrays.`,
    interrupt:false,
    dispose(poIndRc) { if (isArray(poIndRc)) poIndRc[1].forEach(_allocArray), poIndRc.forEach(_allocArray), _allocArray(poIndRc) },
    call(dag, inputs, reversed = false) {
      const po = _allocArray(0), ind = _allocArray(0), rc = _allocArray(0)
      const toIndex = _allocMap()
      try { walk(dag) }
      catch (err) { _allocArray(po), _allocArray(ind), _allocArray(rc);  throw err }
      finally { _allocMap(toIndex) }
      const arr = _allocArray(3);  arr[0] = po, arr[1] = ind, arr[2] = rc;  return arr

      function walk(x) {
        if (!isArray(x) || x[0] === quote) return
        if (inputs && inputs.has(x)) return
        if (toIndex.has(x)) {
          const i = toIndex.get(x)
          if (_setting(_forgiveMistakes) && i === null) return
          if (i === null) error('Cycles in computation, at', x, 'in', dag)
          return void ++rc[i]
        }
        toIndex.set(x, null)
        if (!x.length)
          error('Expected a function with args to apply, got', x, 'in', dag)
        if (!reversed || x[0] === last)
          x.forEach(walk)
        else for (let j = x.length; j > 0; --j) walk(x[j-1])

        const indexes = _allocArray(x.length)
        for (let j=0; j < x.length; ++j) indexes[j] = toIndex.has(x[j]) ? toIndex.get(x[j]) : null
        toIndex.set(x, po.length)
        po.push(x), ind.push(indexes), rc.push(1)
      }
    },
  },

  _resultCanBe(x) {
    // Returns all nodes that the result can be, intended for checking definitions of all possible branches.
    if (!_resultCanBe.seen) _resultCanBe.seen = new Set
    if (!_resultCanBe.in) {
      _resultCanBe.in = true
      const result = _allocArray(0)
      try { _resultCanBe(x);  result.push(..._resultCanBe.seen) }
      finally { _resultCanBe.seen.clear(), _resultCanBe.in = false }
      return result
    } else {
      // Defer to `defines(x, _resultCanBe)`, which will call us for each node that the result can be.
      if (_resultCanBe.seen.has(x)) return
      _resultCanBe.seen.add(x)
      const d = defines(x, _resultCanBe)
      if (d) d(x)
    }
  },
  
  array:{
    docs:`\`(array …Items)\`: creates a new array.
The same as \`(make arrayObject …Items)\`.`,
    Initialize() { array.count = 0 },
    readAt:{
      isArray:_(`isArray`),
      arrayLength:_(`arrayLength`),
      arrayPush:_(`arrayPush`),
      arrayLimit:_(`arrayLimit`),
      arraySlice:_(`arraySlice`),
      arrayConcat:_(`arrayConcat`),
      arraySorted:_(`arraySorted`),
      arrayAscends:_(`arrayAscends`),
      arrayCons:_(`arrayCons`),
      arrayCar:_(`arrayCar`),
      arrayCdr:_(`arrayCdr`),
      read:_(`readAt`),
      write:_(`writeAt`),
      observe:_(`observe`),
      arrayObject:_(`arrayObject`),
      merged:_(`merged`),
    },
    interrupt:false,
    keep:true,
    call(...x) { return created(!call.pure ? x : x.map(quote)) },
    purify(...y) { return created(y) },
    adjust:_(`_dout`),
    mergeAdjustment:_(`_mergeTensors`),
    _compileBody(env, assignTo, ...args) {
      // `v = _allocArray(N); v[0]=args[0]; v[1]=args[1]`.
      return `${assignTo} = ${env(_allocArray)}(${args.length})${args.map((a,i) => '; '+assignTo+'['+i+']='+a).join('')}`
    },
    dispose:_(`_disposeEachAndDealloc`),
  },

  readAt:{
    docs:`\`readAt Array Index\` or \`Array.Index\`: reads the current value at a position in an array.
(It's actually a relatively-thin wrapper around JS property access.)
This also forms the user-visible hierarchy of globals.`,
    argCount:2,
    dispose:true,
    interrupt:false,
    call(arr, i) {
      if (arr == null) return
      if (call.pure && typeof arr == 'string') return arr[i]
      if (call.pure && call.pure.has(arr)) {
        const v = arr[i]
        // `v` is a program (that quotes values), so we convert it to a value (with _unknown(…) for programs).
        return !isArray(v) || call.pure.has(v) ? keep(v) : v[0] === quote ? keep(v[1]) : _unknown(v)
      }
      if (call.pure) throw impure
      return keep(arr[i])
      // readAt.parents: a Map from globals to what namespace they belong to.
    },
    purify(arrP, iP) {
      // When the array is known but the index is not, copy the array so that writes can't interfere.
      //   (But if the array is modified after `purify`, we wouldn't know.)
      if (isArray(arrP) && arrP[0] !== quote) throw impure
      const arr = !isArray(arrP) ? arrP : arrP[1]
      if (!isArray(arr)) throw impure
      return _unknown([readAt, quote(array(...arr)), iP])
    },
    adjust:_(`_arrayReadAdjustment`),
    mergeAdjustment:[
      _(`_mergeArrays`),
      null,
    ],
    Initialize(net) {
      // Mark readAt.parents of globals.
      const backctx = _invertBindingContext(Self.ctx)
      readAt.parents = new Map
      function markParents(x, p, prioritize) {
        if (readAt.parents.has(x) || x === Self)
          return prioritize && x !== p && (readAt.parents.delete(x), readAt.parents.set(x, p))
        if (p === undefined && backctx.has(x) && backctx.get(x)[0] === '_') readAt.parents.set(x, System)
        if (visited.has(x) && (p === undefined || x === p || readAt.parents.has(x))) return; else visited.add(x)
        if (p !== undefined && x !== p) readAt.parents.set(x, p)
        if (!x || typeof x != 'object' && typeof x != 'function') return
        if (x instanceof Map || isArray(x)) {
          x.forEach(v => markParents(v, p))
        } else if (x && !x[defines.key] && typeof x == 'object') {
          Object.keys(x).forEach(k => +k !== _id(deconstruct) && markParents(x[k], p, prioritize || +k === _id(readAt)))
        } else if (x && x[defines.key]) {
          markParents(x[defines.key], x)
        }
      }
      const visited = new Set
      markParents(net)
      readAt.parents.set(net, Self)
    },
  },
  _arrayReadAdjustment:[
    _(`array`),
    [
      {
        call(arr, i, dout) { const r = array();  return r[i] = dout, r },
        purify(arrP, iP, doutP) {
          // Known-index reads will know adjustment.
          if (isArray(iP)) throw impure
          const r = array();  return r[iP] = doutP, r
        },
        interrupt:false,
      },
      _(`_inA`),
      _(`_inB`),
      _(`_dout`),
    ],
  ],
  writeAt:{
    docs:`\`writeAt Array Index Value\`: changes the current value at a position in an array.
If \`Index\` is undefined, re-constructs a construct in-place if possible.

(Can actually interrupt if \`Array\` is a non-array object and \`construct\` interrupts.)`,
    argCount:3,
    interrupt:false,
    purify(arrP, iP, vP) {
      // Allow writing impure computations into created arrays.
      if (isArray(arrP) && arrP[0] !== quote) throw impure
      if (isArray(iP) && iP[0] !== quote) throw impure
      const arr = !isArray(arrP) ? arrP : arrP[1]
      const i = !isArray(iP) ? iP : iP[1]
      return writeAt(arr, i, vP, true) // vP is definitely unknown here, since `arr` and `i` are known.
    },
    call(arr, i, v, vIsProgramSpace) {
      if (call.pure) {
        if (!call.pure.has(arr)) throw impure
        if (!vIsProgramSpace) {
          if (call.pure.has(v)) throw impure // This prevents cycles, which can't be constructed with `array` calls but can be patched in.
          //   (Though it prevents many other things too.)
          v = i !== undefined ? quote(v) : v.map(quote)
        }
      }
      if (i !== undefined) {
        _changeArrayItem(arr, i, v)
      } else if (isArray(arr)) {
        // Replace the contents of the whole array.
        if (!isArray(v)) error('Expected an array to replace', arr, 'with but got', v)
        if (arr === v) return
        v.forEach(keep)
        arr.forEach(dispose)
        arr.length = 0, arr.push(...v)
        _observeChange(arr)
      } else construct(v, arr), _observeChange(arr)
    },
  },
  observe:{
    todo:`Have an extra arg \`Observer\`, so that we could automatically remember to un-observe when the observer gets de-allocated (finalized) or removed-from-DOM. (Not having it might be the cause of memory leaks.)`,
    docs:`\`observe Array OnChange\`: remembers to call the function (passing \`Array\`) sometime after the array changes from a \`writeAt\` call.
If \`OnChange\` is not given, returns the current array of \`Array\`'s observers.
Call this again with the same array and function to no longer call it.
Many updates at the same time are merged into one call, scheduled in a separate task.`,
    interrupt:false,
    Initialize() { observe.rs = new WeakMap, observe.changed = new Set, observe.fn = _throttled(_callChangeObservers, .2) },
    call(arr, f, forceTo = undefined) {
      if (!isArray(arr) && defines(arr, deconstruct) === undefined) return f
      if (Object.isFrozen(arr)) return f
      if (typeof f != 'function') error("Expected a function, got", f)
      if (defines(f, deconstruct)) error("There has been no need for user-defined (interruptible) observers, so we don't support them:", f)
      if (!observe.rs.has(arr)) observe.rs.set(arr, [])
      const obs = observe.rs.get(arr)
      if (f === undefined) return obs
      const i = obs.indexOf(f)
      if (forceTo === undefined)
        i >= 0 ? obs.splice(i, 1) : obs.push(f)
      else if (forceTo === false)
        i >= 0 && obs.splice(i, 1)
      else if (forceTo === true)
        i < 0 && obs.push(f)
      else
        error('Expected undefined/false/true, got', forceTo)
      if (!obs.length) observe.rs.delete(arr)
      return f
      // .rs (a Map from arrays to their observers), .changed (a Set of arrays that changed), .fn (throttled _callChangeObservers).
    },
  },
  _observeChange(arr) {
    // Remembers to call `arr`'s observers.
    if (observe.rs && observe.rs.has(arr)) {
      const b = !observe.changed.size
      observe.changed.add(arr), b && setTimeout(observe.fn, 200)
    }
  },
  _callChangeObservers:{
    docs:`Calls all observers for all changed arrays.`,
    call() {
      if (!observe.changed.size) return
      return new Promise(then => {
        let userTime = 0
        f()
        function f() {
          const start = _timeSince()
          try {
            observe.changed.forEach(arr => {
              const obs = observe.rs.get(arr)
              if (obs) for (let i=0; i < obs.length; ++i) obs[i](arr)
              observe.changed.delete(arr)

              if (_timeSince(start) > 10) { setTimeout(f, 200);  userTime += _timeSince(start);  throw null }
              if (!observe.changed.size) _reflow().then(() => then(userTime + _timeSince(start)))
            })
          } catch (err) { if (err !== null) throw err }
        }
      })
    },
  },
  arrayObject:{
    docs:`\`arrayObject …Items\`: \`construct\`s an actual array.
When the array head is a \`construct\`-defining \`concept\`, this allows still correctly parsing the serialization.`,
    construct(x, obj) {
      if (obj === undefined)
        return _allocArray(0)
      else {
        obj.length = 0
        obj.push(...x.slice(1))
      }
    },
  },

  _mergeArrays:{
    docs:`Gathers array adjustments into one array.`,
    interrupt:false,
    call(arrs, itemMerger = _mergeTensors) {
      const result = array()
      // Merge each item. Go in reverse, to exactly restore the execution's order of accesses.
      //   This is like `_mergeTuples`, but also handles unknown-and-different length arrays.
      let maxLen = 0
      for (let i=0; i < arrs.length; ++i)
        if (isArray(arrs[i]) && (!call.pure || call.pure.has(arrs[i])))
          maxLen = Math.max(maxLen, arrs[i].length)
      for (let n = maxLen-1; n >= 0; --n) {
        let haveAny = false
        for (let i=0; i < arrs.length; ++i) {
          const arr = arrs[i]
          if (!isArray(arr) || call.pure && !call.pure.has(arr)) continue
          if (!arr[n]) continue
          haveAny = true
          if (!result[n])
            result[n] = arr[n]
          else if (!isArray(result[n]) || result[n][0] !== itemMerger || !isArray(result[n][1]) || result[n][1][0] !== array)
            result[n] = [itemMerger, [array, result[n], arr[n]]]
          else
            result[n][1].push(arr[n])
        }
        if (!haveAny) break
      }
      // Merge items that are in multiple adjustment arrays.
      for (let n=0; n < result.length; ++n)
        if (isArray(result[n]) && result[n][0] === itemMerger && isArray(result[n][1]) && result[n][1][0] === array)
          result[n] = itemMerger(result[n][1].slice(1)),
          _isUnknown(result[n]) && (result[n] = result[n][1])
      // If we can't merge everything, record the final result.
      let fin = null
      if (call.pure)
        for (let i=0; i < arrs.length; ++i)
          if (isArray(arrs[i]) && !call.pure.has(arrs[i]))
            (fin || (fin = result.length ? array(result) : array())).push(arrs[i])
      if (fin && fin.length == 1) return _unknown(fin[0])
      return fin ? _unknown([_mergeArrays, fin, quote(itemMerger)]) : result
    },
  },

  _mergeTuples:{
    docs:`Gathers a \`tupleType\`'s adjustments into one tuple.`,
    interrupt:false,
    call(arrs, itemMergers) {
      const result = array()
      // Merge each item. Go in reverse, to exactly restore the execution's order of accesses.
      for (let n = arrs[0].length-1; n >= 0; --n) {
        for (let i=0; i < arrs.length; ++i) {
          const arr = arrs[i]
          if (!isArray(arr) || call.pure && !call.pure.has(arr)) continue
          if (!arr[n]) continue
          if (n === arrs[0].length-1)
            result[n] = arr[n]
          else if (itemMergers[n] && n === arrs[0].length - 2)
            result[n] = [itemMergers[n], [array, result[n], arr[n]]]
          else if (itemMergers[n])
            result[n][1].push(arr[n])
        }
      }
      // Merge items that are in multiple adjustment arrays.
      for (let n=0; n < result.length; ++n)
        if (itemMergers[n] && isArray(result[n]) && result[n][0] === itemMergers[n] && isArray(result[n][1]) && result[n][1][0] === array)
          result[n] = itemMergers[n](result[n][1].slice(1)),
          _isUnknown(result[n]) && (result[n] = result[n][1])
      // If we can't merge everything, record the final result.
      let fin = null
      if (call.pure)
        for (let i=0; i < arrs.length; ++i)
          if (isArray(arrs[i]) && !call.pure.has(arrs[i]))
            (fin || (fin = result.length ? array(result) : array())).push(arrs[i])
      if (fin && fin.length == 1) return _unknown(fin[0])
      return fin ? _unknown([_mergeTuples, fin, quote(itemMergers)]) : result
    },
  },

  select:{
    use:true,
    type:[
      _(`funcType`),
      [
        _(`boolsType`),
        1,
      ],
      [
        _(`funcType`),
        [
          _(`rest`),
          `Inputs`
        ],
        `Output`,
      ],
      [
        _(`funcType`),
        [
          _(`rest`),
          `Inputs`
        ],
        `Output`,
      ],
      [
        _(`rest`),
        `Inputs`
      ],
      `Output`,
    ],
    docs:`\`select If Then Else …Args\`: calls \`Then …Arg\` if \`If\` is \`true\`, else \`Else …Args\`.
Inconvenient compared to being able to refer to closed-over variables directly, but simple and Turing-complete.

Branches can be \`null\`. \`select true Func null …Args\` is the same as \`apply Func …Args\`.

This is much like the φ function in SSA forms, but explicitly passing arguments to code blocks.`,
    _resultCanBe(x) { _resultCanBe(x[2]), _resultCanBe(x[3]) },
    call(If, Then, Else, ...Args) {
      return sync(If) === true ? Then && Then(...Args) : Else && Else(...Args)
    },
    purify(IfP, ThenP, ElseP, ...ArgsP) {
      if (isArray(IfP) && IfP[0] !== quote) throw impure
      return sync(IfP) === true ? ThenP && purify([ThenP, ...ArgsP], true) : ElseP && purify([ElseP, ...ArgsP], true)
      // If `IfP` was explicitly quoted by `quote`, then it's definitely not `true`.
    },
    _compileBody(env, assignTo, If, Then, Else, ...Args) { return `${assignTo} = ${If} === true ? ${Then} && ${Then}(${Args}) : ${Else} && ${Else}(${Args})` },
    dispose:true,
    adjustLater:true,
    mergeAdjustment:_(`_mergeTensors`),
    adjust:{
      impure:true,
      call(ins, _, dout) {
        const [If, Then, Else, ...Args] = ins
        return sync(If) === true ? Then && adjust(Then, Args, null, dout) : Else && adjust(Else, Args, null, dout)
      },
      dispose:_(`_disposeEachAndDealloc`),
    },
  },

  equal:{
    use:true,
    readAt:{
      softEqual:_(`softEqual`),
    },
    type:[
      _(`funcType`),
      `TypeA`,
      `TypeB`,
      [
        _(`boolsType`),
        1,
      ],
    ],
    docs:`\`equal A B\`: returns \`true\` if \`A\` and \`B\` are reference-equal, otherwise \`false\`.`,
    argCount:2,
    interrupt:false,
    call(a,b) { return a === b },
  },

  softEqual:{
    docs:`\`softEqual a b tensorsEqual\`
Checks equality of array graphs. Result is \`1\` if very equal, \`0\` if very unequal.

Why soft equality? \`\`elemCollapse stringToDoc('For example, \`.6+.7\` is not \`equal\` to \`1.3\`. For implementation reasons, \`tensor\` objects with the same values are not reference-equal either (and those reasons are: merging tensors is very expensive, and of very dubious use).')\`\`

\`tensorsEqual(a,b)\` (optional) is called for same-shape numbers/tensors and returns a number/scalar, where \`1\` is very equal, \`0\` is very unequal.
    (Such as \`a->b->1-softsign(mean x*x x:a-b)\`. If not specified, not-reference-equal numbers and tensors will be non-equal.)`,
    dispose:true,
    call(a,b, tensorsEqual = 0) {
      let [visited = _allocMap(), nums = _allocArray(0), adjStart, i, result] = interrupt(5)
      try {
        if (i === undefined) {
          result = match(a,b)
          if (result === 0) return 0
          adjStart = adjustUndo()
          i = 0
        }
        for (; i < nums.length; i += 2) {
          const t = !_isDisposable(tensorsEqual) ? tensorsEqual(nums[i], nums[i+1]) : keep(tensorsEqual)
          result = mul(result, t);  dispose(t)
        }
        adjustUndo(adjStart)
        return result
      } catch (err) { if (err === interrupt) interrupt.stack.push(visited, nums, adjStart, i, result), visited = nums = null; else dispose(result);  throw err }
      finally { visited && _allocMap(visited), nums && _allocArray(nums) }

      function match(a,b) {
        if (a === b) return 1
        if (visited.has(a)) return visited.get(a) === b ? 1 : 0
        else visited.set(a,b)
        if (isArray(a)) {
          if (!isArray(b)) return 0
          if (a.length != b.length) return .5 * match(a[0], b[0])
          let m = 1
          for (let i=0; i < a.length; ++i) {
            m *= match(a[i], b[i])
            if (m === 0) return 0
          }
          return m
        } else if (typeof a == 'number' || _isDisposable(a)) {
          // Consult `tensorsEqual`, but only for same-shape numbers/tensors.
          if (typeof b != 'number' && !_isDisposable(b)) return 0
          if (_tensorSize(a) !== _tensorSize(b)) return 0
          if (_tensorSize(a) > 1) {
            if (a.shape.length !== b.shape.length) return 0
            for (let i=0; i < a.shape.length; ++i)
              if (a.shape[i] !== b.shape[i]) return 0
          }
          nums.push(a,b)
          return 1
        } else if (a instanceof Error) {
          if (!(b instanceof Error)) return 0
          const x = a.message === b.message
          const y = a.stack === b.stack
          return x && y ? 1 : x ? .5 : 0
        } else
          return 0 // Don't `deconstruct`. Easier.
      }
    },
  },

  created:{
    docs:`Marks an array as created and owned locally.
Reading from and writing to such arrays during \`purify\` is allowed, even unknown values, though only at known indices. They will be created at runtime, but only if needed.
(Non-arrays are harder to support, because they couldn't be changed in-place into arrays that compute them, so why bother.)`,
    examples:[
      [
        `purify ^(readAt (array 1 2 3) 0)`,
        `1`,
      ],
      [
        `purify ^(readAt (array ?+1) 0) false {? 1}`,
        `_unknown ?+1`,
      ],
      [
        `purify ^(array 1+1+?) false {? 1}`,
        `_unknown(array 2+input)`,
      ],
    ],
    call(obj) {
      if (!isArray(obj)) error("Expected an array but got", obj)
      if (call.pure)
        call.pure.add(obj)
      return obj
    },
  },

  purify:{
    docs:`\`purify ^Expr\`: Partially-evaluates the expression, without inlining or knowledge.
The process is simple: if any of a node's inputs are unknown (or if it does an impure thing like calling \`randomNat\`, or its result \`_isUnknown\`), then the node is unknown (and might be inlined), else it's known (and can be computed with \`call\`).

(This does not handle \`keep\` and \`dispose\` definitions properly, so often, just typing an expression with \`tensor\`s in results in a disposal error, but executing it in an \`evaluator\` is OK.)

Every \`defines\` of \`purify\` is a function that accepts programs that produce every arg, and returns a value (or \`(_unknown DAG)\` to return a program). \`call\`s may be called, and may return programs via \`_unknown\` (but don't forget to quote inputs).
We do not automatically allow inlining \`func\`s (only explicitly \`purify\`ing function bodies), because inlining everything causes exponential explosions of code size (and infinite loops for recursion unless handled), which is very bad user UX. If we could have machine-learned the best inlining, we would have, but as it is, no. So, \`purify\` usually acts as just a constant-propagator.


Take a moment to think of what low-level features are close to this.
Compiling the partial evaluation, to make it faster? Probably overkill, since it's faster to interpret what's only needed once.
Function optimizer? Picking the best equivalency, in a definition of \`purify\`. Likely best with machine learning, likely useless without.
Lazy evaluation? If an argument is statically seen to be unused, then partial evaluation will automatically drop it. Creating thunks is not always efficient, particularly for numerically-heavy workloads, so unless the machinery can learn the best for each case, we won't create thunks.
Asynchronous workflows? \`await\` can wait for a result, but to truly ensure that no time is wasted, delayed results should be treated as unknown and partially-evaluated. Good if a task takes a day, but for common use-cases, far too slow. Likely best with machine learning, likely useless without.
Type systems, including dependent types, good for logic? They're about computing something about every value at compile-time. This can be done by replacing all values with \`(Value Type)\` and adding a type-computing always-inlined layer on top of all functions. Or by having another type-level interpreter for IR. But if types are annotated by humans case-by-case, then do they really say anything fundamental about computation? If we were to generate arbitrary programs, wouldn't it be better to allow them to be generated as a consequence of other operations like array-checking? Have, but then subvert.
Choices.
Choices.
Choices.
Choices.
Static is not good enough. Need dynamic.
And who's to say that these are the only choices to ever make, anyway?
Maybe, rather than trying to create a complete world by ourselves, we should allow a simple core to create whatever it wants.
Believe in simplicity. Let the joy of love give you an answer.`,
    philosophy:`The vanity and psychosis of those who hold absolute power are of no use to everyone else. Swat them aside, to make room for coming up with better versions of yourself.
I realized my mistake, and though I lost my vision, I can see the world now.`,
    examples:[
      [
        `purify ^(1+2)`,
        `3`,
      ],
      [
        `purify ^(randomNat 5)`,
        `_unknown (randomNat 5)`,
      ],
    ],
    readAt:{
      _purifyInWorker:_(`_purifyInWorker`),
      created:_(`created`),
      impure:_(`impure`),
    },
    nameResult:[
      `purified`,
      `computation`,
    ],
    call(x, inline = false, inputs, inputPrograms) {
      // `inline`: whether we're inlining a func body (so exceptions will not be swallowed/recorded).
      // `inputs`: the array from values signifying function inputs to their indexes (beginning with 1).
      // `inputPrograms`: an array of input programs (a non-quoted array causes recording), or one program that's repeated for all inputs.
      if (!isArray(x)) return x
      if (x[0] === quote) return x[1]

      let [adjLen = adjustUndo(), i = 0, poIndRc = _postorderInfo(x, inputs), outputs = _allocArray(poIndRc[0].length), same = _allocArray(poIndRc[0].length), unknown = _allocArray(poIndRc[0].length), pure = inline ? null : new Set] = interrupt(7)
      const [po, inds] = poIndRc
      const collected = _allocArray(8)
      const prevPure = call.pure;  call.pure = pure || call.pure
      try {
        for (; i < po.length; ++i) {
          // Go through all nodes, collect dependencies, execute nodes, and record those that we can't know.
          _checkArgCount(po[i], inputs, x)
          collected.length = inds[i].length
          let inputsAreSame = true
          for (let j=0; j < collected.length; ++j) {
            const ind = inds[i][j]
            let depUnknown = ind !== null && unknown[ind]
            let depValue = ind !== null ? outputs[ind] : _unquote(po[i][j])
            if (ind !== null && !same[ind]) inputsAreSame = false
            if (inputs && (inputs.has(po[i][j]) || ind !== null && inputs.has(outputs[ind])) && inputPrograms === undefined)
              depUnknown = true
            else if (inputs && (inputs.has(po[i][j]) || ind !== null && inputs.has(outputs[ind]))) {
              const ind = inputs.has(po[i][j]) ? inputs.get(po[i][j]) : inputs.get(outputs[ind])
              const inp = isArray(inputPrograms) ? inputPrograms[ind-1] : inputPrograms
              depUnknown = isArray(inp) && inp[0] !== quote && !call.pure.has(inp)
              depValue = !isArray(inp) || inp[0] !== quote ? inp : inp[1]
              if (inputs.get(inp) !== ind) inputsAreSame = false
            } else if (defines(po[i], impure))
              depUnknown = true
            if (depUnknown) {
              if (!unknown[i])
                for (let k=0; k<j; ++k)
                  collected[k] = quote(collected[k])
              unknown[i] = true
            }
            collected[j] = depValue
            if (!depUnknown && unknown[i])
              collected[j] = quote(collected[j])
            if (j === 0 && !depUnknown && typeof collected[0] != 'function')
              error("Expected a function, got", collected[0])
          }

          // Execute:
          try {
            if (unknown[i]) {
              if (typeof collected[0] == 'function' && defines(collected[0], purify))
                outputs[i] = defines(collected[0], purify).call(...collected),
                unknown[i] = undefined
              else
                throw impure
            } else {
              outputs[i] = collected[0].call(...collected), same[i] = false
              if (i < outputs.length-1 && _isDisposable(outputs[i])) // `purify` doesn't handle those well at all, so, undo every function that returns a tensor.
                throw outputs[i] = dispose(outputs[i]), impure
            }
            if (_isUnknown(outputs[i]))
              outputs[i] = outputs[i][1], unknown[i] = true
          } catch (err) {
            if (err === impure) {
              if (inputsAreSame)
                // There is no need to make a different object.
                outputs[i] = po[i], same[i] = true
              else if (unknown[i])
                // We've already quoted every known value in `collected` when we were collecting it.
                outputs[i] = collected.slice()
              else
                outputs[i] = collected.map(quote)
              unknown[i] = true
            }
            else throw err
          }
        }
        // If not inlining and the output was created here, then the output is unknown (because the array contains programs).
        const lastOut = outputs[po.length-1], lastUnk = unknown[po.length-1] || !inline && call.pure.has(lastOut)
        if (pure && lastUnk)
          pure.forEach(lastUnk ? x => {
            // Turn arrays-of-programs into programs of creating arrays.
            !isArray(x) && error("Non-array `created` values are not supported, but got", x)
            x.unshift(array)
          } : x => {
            // If the output is known, turn programs into values.
            for (let i=0; i < x.length; ++i) if (!call.pure.has(x[i])) x[i] = _unquote(x[i])
          }),
          pure.clear()

        outputs[po.length-1] = undefined, _disposeEachAndDealloc(outputs), outputs = null
        _allocArray(same), _allocArray(unknown)
        //defines(_postorderInfo, dispose)(poIndRc) // Apparently, this causes NaNs in some arrays (probably, some DAG nodes get put into the result or something). But `//` is a leak plugger.
        adjustUndo(adjLen)
        return !lastUnk ? lastOut : _unknown(lastOut)
      } catch (err) {
        if (err === interrupt) { interrupt.stack.push(adjLen, i, poIndRc, outputs, same, unknown, pure);  throw err }
        adjustUndo(adjLen)
        const errRepr = !inline && !(err instanceof Error) && _errorRepr(err)
        errRepr && errRepr.forEach(keep)
        _disposeEachAndDealloc(outputs)
        if (inline || err instanceof Error) throw err
        return _unknown(errRepr.map(quote)) // If not inlining, don't throw exceptions, return them.
      } finally { call.pure = prevPure;  _allocArray(collected) }
    },
  },

  _inA:[
    _(`readAt`),
    _(`_ins`),
    0,
  ],

  _inB:[
    _(`readAt`),
    _(`_ins`),
    1,
  ],

  _inC:[
    _(`readAt`),
    _(`_ins`),
    2,
  ],

  add:{
    use:true,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
      _(5696),
    ],
    merged:true,
    docs:`Addition of two tensors, as in \`5+6\`=\`11\`.
The adjustment is passed through to each arg.`,
    argCount:2,
    dispose:true,
    interrupt:false,
    call(a,b) { return a=_num(a), b=_num(b), typeof a == 'number' && typeof b == 'number' ? a+b : _tf(tf.add(a,b)) },
    adjust:[
      _(`array`),
      _(`_dout`),
      _(`_dout`),
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  mul:{
    use:true,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
      _(5696),
    ],
    merged:true,
    docs:`Multiplication, as in \`5*6\`=\`30\`.`,
    argCount:2,
    dispose:true,
    interrupt:false,
    call(a,b) { return a=_num(a), b=_num(b), typeof a == 'number' && typeof b == 'number' ? a*b : _tf(tf.mul(a,b)) },
    adjust:[
      _(`array`),
      [
        _(`mul`),
        _(`_dout`),
        _(`_inB`),
      ],
      [
        _(`mul`),
        _(`_dout`),
        _(`_inA`),
      ],
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  sub:{
    use:true,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
      _(5696),
    ],
    merged:true,
    docs:`Subtraction, as in \`5-6\`=\`-1\`.`,
    argCount:2,
    dispose:true,
    interrupt:false,
    call(a,b) { return a=_num(a), b=_num(b), typeof a == 'number' && typeof b == 'number' ? a-b : a ? _tf(tf.sub(a,b)) : _tf(tf.neg(b)) },
    adjust:[
      _(`array`),
      _(`_dout`),
      [
        _(`sub`),
        0,
        _(`_dout`),
      ],
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  div:{
    use:true,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
      _(5696),
    ],
    merged:true,
    docs:`Division, as in \`6/3\`=\`2\``,
    argCount:2,
    dispose:true,
    interrupt:false,
    call(a,b) { return a=_num(a), b=_num(b), typeof a == 'number' && typeof b == 'number' ? a/b : _tf(tf.div(a,b)) },
    adjust:[
      _(`array`),
      [
        _(`div`),
        _(`_dout`),
        _(`_inB`),
      ],
      [
        _(`mul`),
        _(`_dout`),
        [
          _(`div`),
          [
            _(`div`),
            [
              _(`sub`),
              0,
              _(`_inA`),
            ],
            _(`_inB`),
          ],
          _(`_inB`),
        ],
      ],
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  pow:{
    use:true,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
      _(5696),
    ],
    examples:[
      [
        `tensor(1 2 3 4 5)**5`,
      ],
    ],
    merged:true,
    dispose:true,
    docs:`Raises the first arg to the power of the second arg.`,
    argCount:2,
    interrupt:false,
    call(a,b) { return a=_num(a), b=_num(b), typeof a == 'number' && typeof b == 'number' ? Math.pow(a,b) : _noInfinities(_tf(tf.pow(a,b))) },
    adjust:[
      _(`array`),
      [
        _(`mul`),
        _(`_dout`),
        [
          _(`div`),
          [
            _(`mul`),
            _(`_out`),
            _(`_inB`),
          ],
          _(`_inA`),
        ],
      ],
      [
        _(`mul`),
        _(`_dout`),
        [
          _(`mul`),
          _(`_out`),
          [
            _(`log`),
            _(`_inA`),
          ],
        ],
      ],
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  sqrt:{
    use:true,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
    ],
    merged:true,
    dispose:true,
    docs:`\`\\pow(?,1/2)\``,
    argCount:1,
    interrupt:false,
    call(a) { return a=_num(a), typeof a == 'number' ? Math.sqrt(a) : _tf(tf.sqrt(a)) },
    adjust:[
      _(`array`),
      [
        _(`div`),
        _(`_dout`),
        [
          _(`mul`),
          2,
          _(`_out`),
        ],
      ],
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  exp:{
    use:true,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
    ],
    merged:true,
    dispose:true,
    docs:`\`exp:\\pow(2.718281828459045,?)\``,
    argCount:1,
    interrupt:false,
    call(a) { return a=_num(a), typeof a == 'number' ? Math.exp(a) : _noInfinities(_tf(tf.exp(a))) },
    adjust:[
      _(`array`),
      [
        _(`mul`),
        _(`_dout`),
        _(`_out`),
      ],
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  expm1:{
    use:true,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
    ],
    merged:true,
    dispose:true,
    docs:`\`expm1:\\exp(?)-1\`
Why: speed, precision`,
    argCount:1,
    interrupt:false,
    call(a) { return a=_num(a), typeof a == 'number' ? Math.expm1(a) : _noInfinities(_tf(tf.expm1(a))) },
    adjust:[
      _(`array`),
      [
        _(`mul`),
        _(`_dout`),
        [
          _(`add`),
          _(`_out`),
          1,
        ],
      ],
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  _noInfinities(x) { // Prevent (positive) infinities, so that `0*x` can still mask them out.
    try { return _tf(tf.minimum(x, 1e37)) }
    finally { dispose(x) }
  },
  
  log:{
    use:true,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
    ],
    merged:true,
    dispose:true,
    docs:`The inverse function to \`exp\`onentiation.
Returns the power that \`e\` (\`2.718281828459045\`…: easy to remember) needs to be raised to in order to get the arg.
To find the answer for a different base, divide the result by \`log\` of that base.`,
    argCount:1,
    interrupt:false,
    call(a) { return a=_num(a), typeof a == 'number' ? Math.log(a) : _tf(tf.log(a)) },
    adjust:[
      _(`array`),
      [
        _(`div`),
        _(`_dout`),
        _(`_inA`),
      ],
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  sin:{
    use:true,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
    ],
    merged:true,
    dispose:true,
    docs:`Sine.`,
    argCount:1,
    interrupt:false,
    call(a) { return a=_num(a), typeof a == 'number' ? Math.sin(a) : _tf(tf.sin(a)) },
    adjust:[
      _(`array`),
      [
        _(`mul`),
        _(`_dout`),
        [
          _(`cos`),
          _(`_inA`),
        ],
      ],
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  cos:{
    use:true,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
    ],
    merged:true,
    dispose:true,
    docs:`Cosine.`,
    argCount:1,
    interrupt:false,
    call(a) { return a=_num(a), typeof a == 'number' ? Math.cos(a) : _tf(tf.cos(a)) },
    adjust:[
      _(`array`),
      [
        _(`mul`),
        _(`_dout`),
        [
          _(`sub`),
          0,
          [
            _(`sin`),
            _(`_inA`),
          ],
        ],
      ],
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  sum:{
    use:2,
    type:[
      _(`funcType`),
      _(5696),
      _(`_numberType`),
    ],
    merged:true,
    docs:`Sum of values in a tensor, as in \`sum (tensor (1 2 3 4))\`=\`tensor 10\`.
The adjustment is passed through, to be broadcasted.`,
    dispose:true,
    interrupt:false,
    call(a, axis) { return isArray(a) ? _tf(tf.addN(a, axis)) : (a=_num(a), typeof a == 'number' ? a : _tf(tf.sum(a, axis))) },
    adjust:[
      _(`array`),
      _(`_dout`),
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  mean:{
    use:2,
    type:[
      _(`funcType`),
      _(5696),
      _(`_numberType`),
    ],
    merged:true,
    docs:`Average of values in a tensor, as in \`mean (tensor (1 2 3 4))\`=\`tensor 2.5\`.
The adjustment is passed through, to be broadcasted.`,
    dispose:true,
    interrupt:false,
    call(a, axis) { return a=_num(a), typeof a == 'number' ? a : _tf(tf.mean(a, axis)) },
    adjust:[
      _(`array`),
      [
        _(`div`),
        _(`_dout`),
        [
          _(`_tensorSize`),
          _(`_inA`),
        ],
      ],
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  max:{
    use:2,
    examples:[
      `\`\`settings ^_learningRate\`\``,
      [
        `repeat ^(max(randomVar(256))=5) 1000`,
      ],
      [
        `repeat ^(max(randomVar(256))=-5) 1000`,
      ],
    ],
    type:[
      _(`funcType`),
      _(5696),
      _(`_numberType`),
    ],
    merged:true,
    docs:`Max of values in a tensor.`,
    dispose:true,
    interrupt:false,
    call(a, axis) { return a=_num(a), typeof a == 'number' ? a : _tf(tf.max(a, axis)) },
    adjust:[
      _(`array`),
      [
        _(`where`),
        [
          _(`less`),
          _(`_inA`),
          _(`_out`),
        ],
        0,
        _(`_dout`),
      ],
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  abs:{
    use:true,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
    ],
    merged:true,
    docs:`The absolute of values of a tensor, as in \`abs (tensor (1 -2 3 -4))\`=\`tensor (1 2 3 4)\`.
Is \`where 0<X X 0-X\`.`,
    argCount:1,
    dispose:true,
    interrupt:false,
    call(a) { return a=_num(a), typeof a == 'number' ? Math.abs(a) : _tf(tf.abs(a)) },
    adjust:[
      _(`array`),
      [
        _(`where`),
        [
          _(`less`),
          0,
          _(`_inA`),
        ],
        _(`_dout`),
        [
          _(`sub`),
          0,
          _(`_dout`),
        ],
      ],
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  floor:{
    use:true,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
    ],
    merged:true,
    docs:`Floor.
The adjustment is passed through.`,
    argCount:1,
    dispose:true,
    interrupt:false,
    call(a) { return a=_num(a), typeof a == 'number' ? Math.floor(a) : _tf(tf.floor(a)) },
    adjust:[
      _(`array`),
      _(`_dout`),
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  sign:{
    use:true,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
    ],
    merged:true,
    docs:`The sign of values in a tensor, as in \`sign (tensor (0 1 -2 3 -4))\`=\`tensor (0 1 -1 1 -1)\`.`,
    argCount:1,
    dispose:true,
    interrupt:false,
    call(a) { return a=_num(a), typeof a == 'number' ? Math.sign(a)||0 : _tf(tf.sign(a)) },
  },

  8354:[
    _(`add`),
    1,
    [
      _(`abs`),
      _(`_inA`),
    ],
  ],

  softsign:{
    use:1,
    docs:`\`x->x/(1+abs(x))\``,
    argCount:1,
    dispose:true,
    mergeAdjustment:_(`_mergeTensors`),
    call(x) {
      x=_num(x)
      const t0 = abs(x)
      const t1 = add(1, t0);  dispose(t0)
      const t2 = div(x, t1);  dispose(t1)
      return t2
    },
    adjust:[
      _(`array`),
      [
        _(`div`),
        _(`_dout`),
        [
          _(`mul`),
          _(8354),
          _(8354),
        ],
      ],
    ],
  },

  clip:{
    use:3,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
      _(5696),
      _(5696),
    ],
    merged:true,
    dispose:true,
    docs:`\`clip Value Min Max\`
Clips each value in a tensor between two static values (by default, between \`-2\` and \`2\`).
Is \`where a<Min Min (where a<Max a Max)\`.`,
    interrupt:false,
    call(a, Min=-2, Max=2) {
      a=_num(a), Min=_num(Min), Max=_num(Max)
      return typeof a == 'number' ? Math.min(Math.max(Min, a), Max) : _tf(tf.clipByValue(a, Min, Max))
    },
    readAt:{
      clip2:_(`_clip2`),
    },
    adjust:[
      _(`array`),
      [
        _(`where`),
        [
          _(`less`),
          _(`_inA`),
          [
            _(`_defaultArg`),
            _(`_inB`),
            -2,
          ],
        ],
        0,
        [
          _(`where`),
          [
            _(`less`),
            _(`_inA`),
            [
              _(`_defaultArg`),
              _(`_inC`),
              2,
            ],
          ],
          _(`_dout`),
          0,
        ],
      ],
    ],
    mergeAdjustment:[
      _(`_mergeTensors`),
      null,
      null,
    ],
  },

  isNaN:{
    use:true,
    type:[
      _(`funcType`),
      _(5696),
      [
        _(`boolsType`),
        [
          _(`rest`),
          `Sizes`,
        ],
      ],
    ],
    merged:true,
    dispose:true,
    docs:`Not-a-number values and non-number values return \`true\`. \`isNaN NaN\` is \`true\`. \`isNaN false\` is \`true\`.`,
    interrupt:false,
    argCount:1,
    call(a) { return typeof a == 'number' ? a !== a : !_isDisposable(a) ? true : _tf(tf.isNaN(a)) },
  },

  _clip2:_([
    _(`concept`),
    _(`call`),
    _(`clip`),
    _(`type`),
    [
      _(`funcType`),
      _(5696),
      _(5696),
    ],
    _(`docs`),
    `A differently-\`type\`d version of \`clip\`.`,
  ]),

  argmax:{
    merged:true,
    docs:`The index of the \`max\` value in a tensor, as in \`argmax(tensor (0 1 -2 3 -4))\`=\`tensor 3 arrayObject() 'int32'\`.
Use \`sync\` to get the result as a non-tensor.`,
    dispose:true,
    interrupt:false,
    call(a, axis) { return a=_num(a), typeof a == 'number' ? 0 : _tf(tf.argMax(a, axis)) },
  },

  oneHot:{
    merged:true,
    docs:`\`oneHot Index Length\` or \`oneHot Index Length One\``,
    examples:[
      [
        `oneHot 3 6`,
        `tensor (0 0 0 1 0 0) 6() 'int32'`,
      ],
      [
        `(oneHot 3 6)*1.5`,
        `tensor (0 0 0 1.5 0 0)`,
      ],
      [
        `oneHot 3 6 biasedGlorotNormal(2)`,
      ],
      `\`sliceOff\` uses \`oneHot\` to calc the gradient.`,
    ],
    dispose:true,
    interrupt:false,
    call(i, n, one) {
      const h = _tf(tf.oneHot(_num(i), _num(n)))
      if (one === undefined) return h
      else if (typeof one == 'number') { const t = mul(h, one);  dispose(h);  return t }
      else if (_isDisposable(one)) {
        const t0 = _tf(tf.reshape(h, [n, ...new Array(one.shape.length).fill(1)]));  dispose(h)
        try { return mul(t0, one) }
        finally { dispose(t0) }
      } else error("What is this:", one)
    },
  },

  ReshapingOps:{
    todo:`\`gather(Tensor,Indices)\`, to be able to make many \`sliceOff\`s at once.`,
    readAt:{
      sync:_(`sync`),
      broadcastTo:_(`broadcastTo`),
      transpose:_(`transpose`),
      expandDims:_(`expandDims`),
      squeezeDims:_(`squeezeDims`),
      slice:_(`slice`),
      gather:_(`gather`),
      scatter:_(`scatter`),
      split:_(`split`),
      concat:_(`concat`),
      stack:_(`stack`),
      unstack:_(`unstack`),
    },
  },

  sync:{
    merged:true,
    docs:`Synchronously downloads a value from GPU to CPU.
Ensures that a tensor is available as a JS value, like \`sync tensor(10()())\`=\`10\`.

If you don't schedule other GPU commands to keep it busy while CPU waits for the result of an earlier one, then this is inefficiency.`,
    argCount:1,
    interrupt:false,
    call(a) { return !_isDisposable(a) ? a : a.size === 1 ? (a.dtype === 'bool' ? !!a.dataSync()[0] : a.shape.length ? a.dataSync()[0] : a.arraySync()) : a.dataSync() },
  },

  broadcastTo:{
    use:true,
    type:[
      _(`funcType`),
      _(`_numberType`),
      [
        _(`quote`),
        `Sizes`,
      ],
      _(5696),
    ],
    merged:true,
    docs:`\`broadcastTo What Shape\`
Broadcasts a number/tensor into a shape compatible with another tensor. \`Shape\` can be a tensor too.
Mostly for converting numbers.`,
    examples:[
      [
        `broadcastTo 5 tensor(1 23 4)`,
        `tensor (5 5 5)`,
      ],
      [
        `repeat ^(broadcastTo randomVar() ^(3 2 3))=5 1000`,
      ],
    ],
    argCount:2,
    interrupt:false,
    dispose:true,
    call(a, shape) { if (call.pure) throw impure;  return _tf(tf.broadcastTo(_num(a), !_isDisposable(shape) ? shape : shape.shape)) },
    mergeAdjustment:[
      _(`_mergeTensors`),
      null,
    ],
    adjust:[
      _(`array`),
      [
        _(`_limitTensorSize`),
        _(`_inB`),
        _(`_dout`),
      ],
    ],
  },

  transpose:{
    use:true,
    type:[
      _(`funcType`),
      [
        _(`tensorType`),
        [
          _(`rest`),
          `Sizes`,
        ],
        `A`,
        `B`,
      ],
      [
        _(`tensorType`),
        [
          _(`rest`),
          `Sizes`,
        ],
        `B`,
        `A`,
      ],
    ],
    merged:true,
    docs:`\`transpose What\`
Swaps two innermost dimensions around.`,
    examples:[
      [
        `transpose tensor(1() 23() 4())`,
        `tensor (1 23 4)() (1 3)`,
      ],
      [
        `repeat ^(transpose randomVar(10,20))=5 1000`,
      ],
    ],
    argCount:1,
    interrupt:false,
    dispose:true,
    call(a) { if (call.pure) throw impure;  return _tf(tf.transpose(_num(a))) },
    mergeAdjustment:_(`_mergeTensors`),
    adjust:[
      _(`array`),
      [
        _(`transpose`),
        _(`_dout`),
      ],
    ],
  },

  expandDims:{
    use:2,
    type:[
      _(`funcType`),
      [
        _(`tensorType`),
        [
          _(`rest`),
          `Sizes`,
        ],
      ],
      [
        _(`tensorType`),
        1,
        [
          _(`rest`),
          `Sizes`,
        ],
      ],
    ],
    merged:true,
    docs:`\`expandDims What\` or \`expandDims What Axis\`
Inserts a dimension of size \`1\`.`,
    examples:[
      [
        `expandDims (tensor (6 5)) -1`,
        `tensor (6() 5())`,
      ],
    ],
    interrupt:false,
    dispose:true,
    call(a, axis = 0) { return _tf(tf.expandDims(_num(a), axis)) },
    mergeAdjustment:[
      _(`_mergeTensors`),
      null,
    ],
    adjust:[
      _(`array`),
      [
        _(`squeezeDims`),
        _(`_dout`),
        _(`_inB`),
      ],
    ],
  },

  squeezeDims:{
    use:2,
    type:[
      _(`funcType`),
      [
        _(`tensorType`),
        1,
        [
          _(`rest`),
          `Sizes`,
        ],
      ],
      [
        _(`tensorType`),
        [
          _(`rest`),
          `Sizes`,
        ],
      ],
    ],
    merged:true,
    docs:`\`squeezeDims What\` or \`squeezeDims What Axis\`
Removes a dimension of size \`1\`. Opposite of \`expandDims\`.`,
    examples:[
      [
        `squeezeDims (tensor (6() 5())()()) -1`,
        `tensor (6 5)()() (1 1 2)`,
      ],
    ],
    interrupt:false,
    dispose:true,
    call(a, axis = 0) { return _tf(tf.squeeze(_num(a), axis)) },
    mergeAdjustment:[
      _(`_mergeTensors`),
      null,
    ],
    adjust:[
      _(`array`),
      [
        _(`squeezeDims`),
        _(`_dout`),
        _(`_inB`),
      ],
    ],
  },

  slice:{
    docs:`\`slice Tensor Begin Size\`: Returns a slice of the tensor.`,
    readAt:{
      sliceOff:_(`sliceOff`),
    },
    examples:[
      [
        `slice tensor((1 2) (3 4)) 0 1`,
      ],
    ],
    dispose:true,
    interrupt:false,
    call(a, begin, size) { return !_isDisposable(a) ? a : _tf(tf.slice(_num(a), _num(begin), _num(size))) },
  },

  sliceOff:{
    docs:`\`sliceOff Tensor At\`: Chooses one index in the outer dimension, removing it. Often more convenient than \`slice\`.`,
    examples:[
      [
        `sliceOff tensor((1 2) (3 4)) 0`,
      ],
      `Ah, an opportune time, a fortunate place in time and space. Feel at home. Comfort. The following is a mini-simulation of learning dynamics of choices.
\`\`settings ^_learningRate\`\``,
      [
        `repeat ^(sliceOff(randomVar(4,20),randomNat(4))=0) 1000`,
      ],
      [
        `repeat ^(sliceOff(randomVar(40,20),randomNat(40))=0) 1000`,
      ],
    ],
    dispose:true,
    interrupt:false,
    argCount:2,
    call(a, at, axis) {
      if (!_isDisposable(a)) return a
      return gather(a, at, axis)
    },
    mergeAdjustment:[
      _(`_mergeTensors`),
      null,
    ],
    adjust:[
      _(`array`),
      [
        _(`oneHot`),
        _(`_inB`),
        [
          _(`readAt`),
          [
            _(`readAt`),
            _(`_inA`),
            'shape',
          ],
          0,
        ],
        _(`_dout`),
      ],
    ],
  },

  gather:{
    docs:`\`gather(Value,Indices,Axis)\`
Reads parts of \`Value\` at specified \`Indices\` along the \`Axis\` (\`0\` by default).
The dimension \`Axis\` gets replaced by dimensions of \`Indices\`, the rest are preserved, so slices with specified indices get put into the result.

\`adjust\`able if \`Axis\` is \`0\` (the default).`,
    merged:true,
    dispose:true,
    interrupt:false,
    call(v, ind, axis = 0) { return ind === undefined ? keep(_num(v)) : _tf(tf.gather(_num(v), ind, axis)) },
    mergeAdjustment:[
      _(`_mergeTensors`),
      null,
      null,
    ],
    adjust:[
      _(`array`),
      [
        _(`scatter`),
        _(`_dout`),
        _(`_inB`),
        [
          _(`_firstDim`),
          _(`_inA`),
        ],
      ],
    ],
  },

  _firstDim(x) { return x.shape[0] },

  scatter:{
    docs:`\`scatter(Value,Indices,Length)\`: some CPU-approximation of the opposite of \`gather(Into,Indices)\` along \`Axis:0\` (which is of size \`Length\`), for gradient.`,
    examples:[
      [
        `scatter tensor(6 7) ^(1 2) 6`,
      ],
      [
        `scatter tensor(6 7 8 9) ^(1 2 2 1) 6`,
      ],
      `Can also act as "overwrite values at these indices" (if \`Length\` is the tensor \`Into\`):`,
      [
        `scatter tensor(1 2 3) ^(1 2 4) tensor(0 -1 -2 -3 -4 -5)`,
      ],
      `When overwriting, same-write-index values are overwritten, not \`add\`ed up:`,
      [
        `scatter tensor(1 2 3) ^(1 2 1) tensor(0 -1 -2 -3 -4 -5)`,
      ],
    ],
    merged:true,
    dispose:true,
    interrupt:false,
    argCount:3,
    call(v, ind, len) {
      if (!_isDisposable(v)) error("Not a tensor:", v)
      ind = sync(ind)
      if (ind === undefined) return keep(v)
      if (v.shape[0] !== ind.length) error("Length mismatch:", v.shape[0], ind)
      const L = !_isDisposable(len) ? len : len.shape[0], rind = _allocArray(1) // Reverse indices.
      for (let i = 0; i < ind.length; ++i) // Same-indices are in different arrays.
        for (let j = 0; true; ++j) {
          if (!rind[j]) {
            rind[j] = _allocArray(L).fill(ind.length)
            if (_isDisposable(len)) for (let k = 0; k < L; ++k) rind[j][k] = k
          }
          if (ind[i] < 0 || ind[i] >= L || ind[i] !== ind[i]>>>0 || rind[j][ind[i]] === undefined) error("Bad index:", ind[i])
          if (!_isDisposable(len)) {
            if (rind[j][ind[i]] === ind.length) { rind[j][ind[i]] = i;  break }
          } else {
            if (rind[j][ind[i]] < L) { rind[j][ind[i]] = L + i;  break }
            else break
          }
        }
      // `gather` the reversed indices, and `add` up equal-index scatterings.
      let V
      if (!_isDisposable(len)) {
        const t0 = zeros([1, ...v.shape.slice(1)])
        V = concat2(v, t0, 0);  dispose(t0)
      } else
        V = concat2(len, v, 0)
      let result = 0
      try {
        for (let j = 0; j < rind.length; ++j) {
          const t00 = gather(V, rind[j])
          const t01 = add(result, t00);  dispose(t00)
          dispose(result), result = t01
          if (_isDisposable(len)) break
        }
        dispose(V), rind.forEach(_allocArray), _allocArray(rind)
        return result
      } catch (err) { dispose(result), dispose(V);  throw err }
    },
  },

  split:{
    merged:true,
    docs:`\`split Tensor SizesArray\`→\`TensorArray\`: Splits off tensors.
Reverse of \`concat\`.`,
    examples:[
      [
        `split tensor((1 2 2 3 3 4)) ^(2 2 2)`,
        `(tensor (1 2)) (tensor (2 3)) (tensor (3 4))`,
      ],
      [
        `repeat ^((concat (split concat(array(randomVar(1),randomVar(1),randomVar(1)),sz) sz) sz)=5) 1000 sz:^(1 1 1)`,
      ],
      [
        `repeat ^(takeAt(sp,0)=5;takeAt(sp,1)=-5;v) 1000 sp:split(v,^(5 5)) v:randomVar(10)`,
      ],
    ],
    dispose:_(`_disposeEachAndDealloc`),
    interrupt:false,
    call(a, sz, axis) {
      !isArray(sz) && typeof sz != 'number' && errorStack("Not an array of sizes to split (nor how many tensors to divide this into):", sz)
      if (!a) return _allocArray(sz.length).fill(0)
      a = tf.split(_num(a), sz, axis !== undefined ? axis : !a.shape.length ? 0 : a.shape.length-1);  a.forEach(_tf);  return a
    },
    adjust:[
      _(`array`),
      [
        _(`concat`),
        _(`_dout`),
        _(`_inB`),
        _(`_inC`),
      ],
    ],
    mergeAdjustment:[
      _(`_mergeTensors`),
      null,
    ],
  },

  _concreteTensorSize(ctx, a, sz) {
    const eq = sz === true
    if (sz === undefined || typeof sz == 'boolean') sz = ctx.has(`Sizes`) ? ctx.get(`Sizes`) : a
    if (eq && sz === undefined) return
    sz = _resolveTypeVar(sz)
    if (eq && _isTypeVar(sz) && _getTypeVarValue(sz) === sz) return
    if (isArray(a) && a[0] === computeType && isArray(sz) && sz[0] === computeType)
      return a[1] === sz[1] ? undefined : null
    if (typeof sz == 'number' || isArray(sz) && sz.every(x => typeof x == 'number')) return sz
    if (isArray(sz)) {
      // …A random number, yes, but what, you want to route machine-learned embeddings through generating all possible numbers?
      if (sz[0] === rest) return 256
      // …Or even just through type refinement?
      if (sz[0] === sumType) return _concreteTensorSize(null, 0, sz[1+randomNat(sz.length-1)])
      if (sz[sz.length-1] === sz) return null
      const a = sz.map(n => _concreteTensorSize(null, 0, n))
      return a.some(x => x === null) ? null : a
    }
    if (_isTypeVar(sz)) return 256
    return null
  },

  concat:{
    use:3,
    readAt:{
      concat2:_(`concat2`),
      tile:_(`tile`),
    },
    merged:true,
    type:[
      _(`funcType`),
      [
        _(`tupleType`),
        [
          _(`tensorType`),
          [
            _(`rest`),
            `Sizes`,
          ],
          `A`,
        ],
        [
          _(`tensorType`),
          [
            _(`rest`),
            `Sizes`,
          ],
          [
            _(`computeType`),
            function(ctx, tp, eq) { // A + B = C
              if (eq) return tp
              return _concreteTensorSize(ctx,tp,ctx.get('C')) - _concreteTensorSize(ctx,tp,ctx.get('A'))
            },
            `B`,
          ],
        ],
      ],
      [
        _(`tupleType`),
        [
          _(`quote`),
          `A`,
        ],
        [
          _(`quote`),
          `B`,
        ],
      ],
      [
        _(`tensorType`),
        [
          _(`rest`),
          `Sizes`,
        ],
        `C`,
      ],
    ],
    docs:`\`concat TensorArray SizesArray\`→\`Tensor\`: Concatenates tensors along the last dimension.
All tensor datatypes and ranks (except in the non-batch first dimension) must match.
Reverse of \`split\`.
\`SizesArray\` is necessary for adjustment, optional otherwise.`,
    examples:[
      [
        `concat array(tensor(1 2),tensor(2 3),tensor(3 4))`,
        `tensor(1 2 2 3 3 4)`,
      ],
      [
        `repeat ^(concat(array(randomVar(1),randomVar(1),randomVar(1)),^(1 1 1))=5) 1000`,
      ],
    ],
    dispose:true,
    interrupt:false,
    call(a, sz, axis) {
      if (!isArray(a)) error("Expected an array of tensors, got", a)
      if (call.pure && (call.pure.has(a) || call.pure.has(sz))) throw impure
      a.forEach(_num)
      if (!a[0] || !a[0].shape) error('Strange tensor to concat', a[0], 'in', a.slice())
      if (a.length == 1) return keep(a[0]) // Apparently, TFJS thinks that returning exactly the same tensor in this case is a great idea.
      return _tf(tf.concat(a, axis !== undefined ? axis : !a[0].shape.length ? 0 : a[0].shape.length-1))
    },
    adjust:[
      _(`array`),
      [
        _(`split`),
        _(`_dout`),
        _(`_inB`),
        _(`_inC`),
      ],
    ],
    mergeAdjustment:[
      _(`_mergeArrays`),
      null,
    ],
  },

  stack:{
    use:2,
    type:[
      _(`funcType`),
      [
        _(`arrayType`),
        _(5696),
        `ArrayLength`,
      ],
      [
        _(`tensorType`),
        `ArrayLength`,
        [
          _(`rest`),
          `Sizes`,
        ],
      ],
    ],
    merged:true,
    docs:`\`stack TensorArray\`→\`Tensor\`: stacks equally-shaped tensors into a new outer dimension.

If \`Numeric\` code does not call \`select\` or \`sync\`, and we want to repeat it for different inputs, then using \`stack\` (followed by code then \`unstack\`) should not change the results, but it will make code faster by using GPU to parallelize instead of the CPU.`,
    examples:[
      `Simple usage:`,
      [
        `stack array(tensor(1 2),tensor(2 3),tensor(3 4))`,
        `tensor((1 2) (2 3) (3 4))`,
      ],
      `In fact, even \`concat\` is mostly immunized to our effects:`,
      [
        `concat array(stack(array(keep tensor(1 2 3),keep tensor(4 5 6))),stack(array(keep tensor(-1 -2 -3),keep tensor(-4 -5 -6))))`,
      ],
      `(Although, \`concat\` still expects everything to be of the exact same shape, so we can't \`stack\` some inputs and leave others be. Food for thought.)`,
      [
        `repeat ^(stack(array(randomVar(),randomVar(),randomVar()))=5) 1000`,
      ],
    ],
    dispose:true,
    interrupt:false,
    call(a, axis) { if (call.pure && call.pure.has(a)) throw impure;  return !isArray(a) && error('Not an array:', a), a.forEach(_num), _tf(tf.stack(a, axis)) },
    adjust:[
      _(`array`),
      [
        _(`unstack`),
        _(`_dout`),
        _(`_inB`),
      ],
    ],
    mergeAdjustment:_(`_mergeArrays`),
  },

  unstack:{
    use:2,
    type:[
      _(`funcType`),
      [
        _(`tensorType`),
        `ArrayLength`,
        [
          _(`rest`),
          `Sizes`,
        ],
      ],
      [
        _(`arrayType`),
        _(5696),
        `ArrayLength`,
      ],
    ],
    merged:true,
    docs:`\`unstack Tensor\`→\`TensorArray\`: unstacks the outer dimension into an array.
Reverse of \`stack\`.`,
    examples:[
      [
        `unstack (tensor ((1 2) (2 3) (3 4)))`,
        `(tensor (1 2)) (tensor (2 3)) (tensor (3 4))`,
      ],
    ],
    dispose:_(`_disposeEachAndDealloc`),
    interrupt:false,
    argCount:1,
    call(a, axis) { a = tf.unstack(_num(a), axis);  a.forEach(_tf);  return a },
    adjust:[
      _(`array`),
      [
        _(`stack`),
        _(`_dout`),
        _(`_inB`),
      ],
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  matMul:{
    use:true,
    type:[
      _(`funcType`),
      [
        _(`tensorType`),
        [
          _(`rest`),
          `R`,
        ],
        `N`,
        `M`,
      ],
      [
        _(`tensorType`),
        [
          _(`rest`),
          `R`,
        ],
        `M`,
        `K`,
      ],
      [
        _(`tensorType`),
        [
          _(`rest`),
          `R`,
        ],
        `N`,
        `K`,
      ],
    ],
    merged:true,
    docs:`Matrix multiplication of \`A\` by \`B\`.
Like a cross-sectional dot product: each element of the output is the sum of every element in a row in \`A\` \`mul\`tiplied by its corresponding element in a column in \`B\`. (So, if input shapes are N×M and M×K, then output is shaped as N×K.)
Can also handle "\`A\` is a vector" (the operation is then called a non-batched \`_denseLayer\`; resulting in a vector) and "\`A\` or \`B\` is a number" cases, by padding the missing outer dimensions with \`1\` then un-padding.`,
    argCount:2,
    dispose:true,
    interrupt:false,
    readAt:{
      _denseLayer:_(`_denseLayer`),
    },
    call(a,b) { return _matMul(_num(a), _num(b)) },
    adjust:[
      _(`array`),
      [
        _(`_matMul`),
        _(`_dout`),
        _(`_inB`),
        false,
        true,
      ],
      [
        _(`_matMul`),
        _(`_inA`),
        _(`_dout`),
        true,
        false,
      ],
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  _denseLayer:_([
    _(`concept`),
    _(`call`),
    _(`matMul`),
    _(`type`),
    [
      _(`funcType`),
      [
        _(`tensorType`),
        `A`,
      ],
      [
        _(`tensorType`),
        `A`,
        `B`,
      ],
      [
        _(`tensorType`),
        `B`,
      ],
    ],
    _(`docs`),
    `A differently-\`type\`d \`matMul\`.`,
  ]),

  _matMul:{
    merged:true,
    docs:`An interface to tf.matMul, but it can reshape args to accept JS numbers in both args, and row vectors in first arg.
(The two extra args are booleans, indicating whether each of the first two args should be \`transpose\`d.)`,
    dispose:true,
    interrupt:false,
    call(a,b, tA, tB) {
      // The extra args are bools: whether to transpose the arg.
      if (a == null || b == null) error("Bad inputs to matMul:", a, b)
      if (!a || !b) return 0
      if (!_isDisposable(a) && !_isDisposable(b)) return a*b

      let da = false, db = false
      let iA = _isDisposable(a), iB = _isDisposable(b), sA = a.shape, sB = b.shape
      let a2 = !iA ? 1 : sA.length >= 2 ? sA[sA.length-1] : sA[0] || 1, a1 = !iA || sA.length < 2 ? 1 : sA[sA.length-2]
      let b2 = !iB ? 1 : sB.length >= 2 ? sB[sB.length-1] : sB[0] || 1, b1 = !iB || sB.length < 2 ? 1 : sB[sB.length-2]
      const rowVectorA = iA && sA.length < 2
      try {
        if (!iA) a = _tf(tf.broadcastTo(a, sA = [a1 = b1, a2 = b2])), da = true
        if (!iB) b = _tf(tf.broadcastTo(b, sB = [b1 = a1, b2 = a2])), db = true
        if (!iA || sA.length < 2) a = _tf(tf.reshape(a, sA = [a1, a2])), da = true
        if (!iB || sB.length < 2) b = _tf(tf.reshape(b, sB = [b1, b2])), db = true
        if (sA.length < sB.length || sA[0] === 1 && sB[0] !== 1) { const t = _tf(tf.broadcastTo(a, sA = [...sB.slice(0,-2), ...sA.slice(-2)]));  da && dispose(a), a = t, da = true }
        if (sA.length > sB.length || sA[0] !== 1 && sB[0] === 1) { const t = _tf(tf.broadcastTo(b, sB = [...sA.slice(0,-2), ...sB.slice(-2)]));  db && dispose(b), b = t, db = true }
        const r = _tf(tf.matMul(a, b, tA, tB))
        if (rowVectorA && !tA)
          try { return _tf(tf.reshape(r, [!tB ? b2 : b1])) }
          finally { dispose(r) }
        return r
      } finally { da && dispose(a), db && dispose(b) }
    },
  },

  _debugInterruptDefinitions:[
    _(`settings`),
    false,
    `Whether \`_compileBody\` should assert that no interrupt occurs in no-interrupt places.`,
  ],

  _debugLastInterrupt:[
    _(`settings`),
    true,
    `If checked, makes \`_causeInterrupt\` remember the call-stack, to be displayed if relevant.`,
  ],

  _isDisposable(x) { return typeof tf != ''+void 0 && x instanceof tf.Tensor },

  _debugDoubleDispose:[
    _(`settings`),
    false,
    `Whether \`dispose\` should remember the initial-disposal stack traces.`,
  ],

  _debugCreation:[
    _(`settings`),
    false,
    `Whether \`_tf\` should remember the creation stack traces.`,
  ],

  _debugMemory:[
    _(`settings`),
    false,
    `Whether \`_tf\` and \`keep\` and \`dispose\` should remember the full history of every tensor. Serves as \`_debugCreation\` but more luxurious.`,
  ],

  _tensorOrigins(t) {
    if (_tf.all) return f(_tf.all.get(t))
    return _debugCreation
    function f(v) { return isArray(v) ? v.map(f) : typeof v == 'string' ? _resolveStack(v) : v === true || v === undefined ? _debugCreation : v }
  },

  _autoDispose:[
    _(`settings`),
    true,
    `Whether \`interpreter\` will dispose all created-but-not-disposed tensors when done.
The more code runs with this off, the better.`,
  ],

  dispose:{
    docs:`A low-level function for statically disposing a resource (with no references to other resources; currently only tensors).
A function \`defines\` this to be \`true\` to make execution \`dispose\` its result, or a function to make compilation call that when the result is no longer needed, or an index to copy the definition from the input at that index.

Memory management rewards only very clear thinking: everything that was created must be disposed exactly once, and each \`keep\` must have its \`dispose\`.`,
    readAt:{
      _debugDoubleDispose:_(`_debugDoubleDispose`),
      _debugCreation:_(`_debugCreation`),
      _debugMemory:_(`_debugMemory`),
      _autoDispose:_(`_autoDispose`),
      keep:_(`keep`),
      takeAt:_(`takeAt`),
    },
    Initialize() { dispose.keep = new WeakMap, dispose.not = new WeakMap },
    elemValue:_(`_isDisposable`),
    call(x) {
      if (_isDisposable(x)) {
        if (_debugMemory[1] && _tf.all && isArray(_tf.all.get(x)))
          _tf.all.get(x).push([readAt, dispose, new Error().stack])
        if (!dispose.keep.has(x)) {
          if (_debugDoubleDispose[1])
            if (x.isDisposedInternal && !dispose.safeDouble)
              error("Double-dispose of", x, "made at", _tensorOrigins(x), "first freed at", dispose.at && dispose.at.has(x) ? _resolveStack(dispose.at.get(x)) : _debugDoubleDispose)
          if (dispose.not && dispose.not.has(x)) error("Illegal disposition of", x, "made at", _tensorOrigins(x))
          if (_debugDoubleDispose[1]) (dispose.at || (dispose.at = new WeakMap)).set(x, new Error().stack)
          _tf.all && _tf.all.delete(x)
          --_tf.count
          x.dispose()
        } else dispose.keep.get(x) > 1 ? dispose.keep.set(x, dispose.keep.get(x) - 1) : dispose.keep.delete(x)
      }

      // .not, .at, .safeDouble
    },
  },

  keep:{
    docs:`\`keep Object\`: prevents the disposal of \`Object\`, once. The caller takes complete responsibility for disposal.

Define this with the index to make compilation not dispose that input (or with \`true\` to not dispose any inputs). This is a promise for the function to dispose that input/s, whether in its \`call\` or \`dispose\`.

Proper dynamic disposal requires a perfect method of disposing those preserved objects (either garbage collection, or adding reference-counting to all functions that mutate state, which only needs to cover a few functions to cover 99% behavior, and is extremely challenging to cover 100% of behavior with, since we didn't grow on top of reference-counting). We currently do garbage-collection, but only if the result is output to browser UI.`,
    interrupt:false,
    argCount:1,
    call(x) {
      if (_isDisposable(x)) {
        if (_debugMemory[1] && _tf.all && isArray(_tf.all.get(x)))
          _tf.all.get(x).push([readAt, keep, new Error().stack])
        !dispose.keep.has(x) ? dispose.keep.set(x, 1) : dispose.keep.set(x, dispose.keep.get(x) + 1)
      }
      return x
    },
    _cancel(m) { m && _allocMap(m) },
  },

  takeAt:{
    docs:`Exactly like \`readAt\`, but takes responsibility for \`dispose\`ing the read resource.`,
    interrupt:false,
    dispose:true,
    argCount:2,
    call(a, i) { const r = readAt(a, i);  a[i] = undefined, dispose(r);  return r },
    adjust:_(`_arrayReadAdjustment`),
    mergeAdjustment:[
      _(`_mergeArrays`),
      null,
    ],
  },

  _rememberToDispose:{
    docs:`When the graph is finalized, this remembers to clear all resources that it holds. Seems to not be 100% reliable, not to mention slow to dispose? But better than nothing.
Used when a job returns a value, when it's very unlikely that parts of the returned graph will be used except for possible displaying.`,
    Initialize() {
      _rememberToDispose.seen = new WeakSet
      _rememberToDispose.res = new WeakMap
      if (typeof FinalizationRegistry != ''+void 0) {
        _rememberToDispose.reg = new FinalizationRegistry(res => {
          const prevDoubleDispose = dispose.safeDouble;  dispose.safeDouble = true
          try { dispose.not && res.forEach(_unDisposeNot), res.forEach(dispose), res.length = 0, _rememberToDispose.res.delete(res) }
          finally { dispose.safeDouble = prevDoubleDispose }
        })
      }
    },
    call(x) {
      if (!x || typeof x != 'object' && typeof x != 'function') return x
      if (_rememberToDispose.seen.has(x)) return x
      if (!isArray(x) && !(x instanceof Map) && !(defines.key in x)) return x
      _rememberToDispose.seen.add(x)
      if (isArray(x)) x.forEach(keep), _rememberArrayItems(x)
      else if (x instanceof Map) x.forEach(_rememberToDispose)
      else if (x && x[defines.key]) Object.values(x[defines.key]).forEach(_rememberToDispose)
      return x
    },
  },

  _disposeNot(x) {
    if (_debugMemory[1] && _tf.all && isArray(_tf.all.get(x)))
      _tf.all.get(x).push([readAt, _disposeNot, new Error().stack])
    dispose.not.set(x, (dispose.not.get(x) || 0) + 1)
  },

  _unDisposeNot(x) {
    if (_debugMemory[1] && _tf.all && isArray(_tf.all.get(x)))
      _tf.all.get(x).push([readAt, _unDisposeNot, new Error().stack])
    dispose.not.set(x, (dispose.not.get(x) || 1) - 1), !dispose.not.get(x) && dispose.not.delete(x)
  },

  _rememberArrayItems(x, clear = false) {
    // This does the actual remember-to-dispose, of each `_isDisposable` item.

    // We don't `observe(x, …?)` because that's not called immediately on change, which introduces an instability.

    if (!isArray(x)) return
    _rememberToDispose.seen.add(x)
    x.forEach(_rememberToDispose)
    const resM = _rememberToDispose.res, resR = _rememberToDispose.reg
    const res = resM.get(x) || _allocArray(0)

    for (let i=0; i < res.length; ++i) { // Remove old.
      const v = res[i]
      _unDisposeNot(v), !dispose.not.has(v) && _rememberToDispose.seen.delete(v)
    }
    res.length = 0

    if (!clear) // Add new.
      for (let i=0; i < x.length; ++i) {
        const v = x[i]
        if (_isDisposable(v))
          res.push(v), _rememberToDispose.seen.add(v), _disposeNot(v)
      }

    if (res.length && !clear) {
      if (!resM.has(x)) resM.set(x, res), resR && resR.register(x, res, res)
    } else {
      if (resM.has(x)) resM.delete(x), resR && resR.unregister(res)
      _allocArray(res)
    }

    return
  },

  _changeArrayItem:{
    examples:[
      `The unit-test below may not seem like much, but to pass it, we need to handle the fact that we cannot just count the allowed tensors as one number, because that would count this one tensor twice. Have to count \`\`elem 'i' 'distinct'\`\` tensors that are allowed to exist past execution's end.`,
      [
        `_changeArrayItem(a,0,t);_changeArrayItem(a,1,t);a t:zeros(^2()) a:^arrayObject()`,
      ],
    ],
    interrupt:false,
    argCount:3,
    call(x, key, value) {
      // Does `x[key] = value` if `x` is an array, with proper disposal handling.
      if (call.pure) throw impure
      if (!isArray(x)) error("Not an array:", x)
      if (typeof key != 'number' || key !== key>>>0) error("Not an index:", key)

      if (x[key] === value) return
      const resM = _rememberToDispose.res, resR = _rememberToDispose.reg

      // Add-to/remove-from associated-with-`x` resources.
      if (resM) {
        const res = resM.get(x) || _allocArray(0)
        if (_isDisposable(value)) { // Add new.
          res.push(value)
          _rememberToDispose.seen.add(value), _disposeNot(value)
        }
        const v = x[key]
        if (_isDisposable(v)) { // Remove old.
          _unDisposeNot(v), !dispose.not.has(v) && _rememberToDispose.seen.delete(v)
          const i = res.indexOf(v), j = res.length-1
          if (i >= 0) [res[i], res[j]] = [res[j], res[i]], --res.length
        }
        if (res.length) {
          if (!resM.has(x)) resM.set(x, res), resR && resR.register(x, res, res)
        } else {
          if (resM.has(x)) resM.delete(x), resR && resR.unregister(res)
          _allocArray(res)
        }
      }

      if (isArray(value)) _rememberToDispose(value)

      _observeChange(x)

      const t = x[key];  x[key] = keep(value);  dispose(t)
    },
  },

  typeAdjustmentMerger:{
    docs:`This allows an input type to define \`mergeAdjustment\` of functions that accept it, for \`autoFunc\`s to know the proper definition.

The definitions take the type and the result-cache (a \`map\`), and must return \`(Func EssentialStructure)\`, where \`EssentialStructure\` is \`merged\`. \`Func\` will be cached and returned. Inner calls to \`typeAdjustmentMerger\` will always return this tuple instead of \`Func\`.`,
    interrupt:false,
    call(tp) {
      const prevInner = typeAdjustmentMerger.inner
      if (isArray(tp) && defines(tp, typeAdjustmentMerger)) try {
        typeAdjustmentMerger.inner = true
        const cache = typeAdjustmentMerger.cache || (typeAdjustmentMerger.cache = new WeakMap)
        const b = defines(tp, typeAdjustmentMerger)(tp, cache)
        if (!isArray(b) || b.length != 2) error("Expected a tuple of func and structure, got", b, "from mergers of", tp)
        if (b[1] && (typeof b[1] == 'object' || (typeof b[1] == 'function')))
          if (!cache.has(b[1])) cache.set(b[1], b[0])
        if (prevInner) return b[0] = cache.get(b[1]), b
        try { return cache.get(b[1]) } finally { _allocArray(b) }
      } finally { typeAdjustmentMerger.inner = prevInner }
      if (prevInner) { const a = _allocArray(2);  [a[0], a[1]] = [null, null];  return a }
      return null

      // .cache, .inner
    },
  },

  typeDisposer:{
    todo:`Have+use \`typeKeeper\` as the reverse of this.`,
    docs:`This allows the output type to define \`dispose\` of functions that return it, for \`autoFunc\`s to know the proper definition.

The definitions take the type and the result-cache (a \`map\`), and must return \`(Func EssentialStructure)\`, where \`EssentialStructure\` is \`merged\`. \`Func\` will be cached and returned. Inner calls to \`typeDisposer\` will always return this tuple instead of \`Func\`.`,
    interrupt:false,
    call(tp) {
      const prevInner = typeDisposer.inner
      if (isArray(tp) && defines(tp, typeDisposer)) try {
        typeDisposer.inner = true
        const cache = typeDisposer.cache || (typeDisposer.cache = new WeakMap)
        const b = defines(tp, typeDisposer)(tp, cache)
        if (!isArray(b) || b.length != 2) error("Expected a tuple of func and structure, got", b, "from mergers of", tp)
        if (!cache.has(b[1])) cache.set(b[1], b[0])
        if (prevInner) return b[0] = cache.get(b[1]), b
        try { return cache.get(b[1]) } finally { _allocArray(b) }
      } finally { typeDisposer.inner = prevInner }
      if (prevInner) { const a = _allocArray(2);  [a[0], a[1]] = [undefined, undefined];  return a }
      return

      // .cache, .inner
    },
  },

  _forgiveMergerMismatch:[
    _(`settings`),
    true,
    `Please, milord, mercy!`,
  ],

  mergeAdjustment:{
    readAt:{
      _forgiveMergerMismatch:_(`_forgiveMergerMismatch`),
    },
    docs:`Defines how to merge adjustments returned from \`adjust\`ing many dependents, to produce local output change in \`autograd\`.
For each input that a DAG node is, this must be defined the same.
Any function that \`defines\` \`adjust\` must also define this, with a function that takes an array of input changes and returns output change (called at compile-time, with programs as array items), or with an array of such functions (if they need to be input-specific).`,
  },

  _mergeTensors:{
    docs:`Add up tensors.`,
    interrupt:false,
    call(arr) {
      if (!call.pure) return _tf(tf.addN(arr))
      // Create a sub-program to add them all up.
      if (arr.length == 1) return isArray(arr[0]) ? _unknown(arr[0]) : arr[0]
      let i = 0
      return _unknown(arr.reduce((a,b) => ++i & 1 ? [add, a, b] : [add, a[1], [add, a[2], b]]))
    },
  },

  _unquote(x) { return isArray(x) && x[0] === quote ? x[1] : x },

  autograd:{
    docs:`The result reverses execution, computing changes of inputs given change of output.
With basic functions that define \`adjust\` correctly, this can be used to automatically implement gradient descent (hence the name \`autograd\`).

More precisely.
A function that, given linearization of a function's DAG, purifies and returns the expression that computes input change (\`dins\`) given an array of inputs, output, and output change (\`(arrayObject ins out dout)\`).
(Cannot handle putting an input as a function.)`,
    todo:`Make known-adjustment parts of the resulting program execute as soon as possible, by separating out the parts of \`b\` that don't depend on adjustment's \`input\` (have a special value for that), and executing them right before the return of the call, and giving results of nodes-that-don't-depend to nodes-that-do-and-use-independents by \`adjustSave\`ing the array of them.`,
    call(poIndRc, inputs, types) {
      // Example usage: `autograd(_postorderInfo ^(matMul ? 2+3)).0`.
      if (!isArray(poIndRc) || poIndRc.length != 3)
        error("Expected result of applying", _postorderInfo, "but got", poIndRc)
      const [po, inds, rc] = poIndRc
      let [save, loaded, dins = _allocArray(po.length), douts = _allocArray(po.length), inputAdj, program, outTypes = _allocMap(), outDisposers = _allocMap()] = interrupt(8)
      try {
        if (!save) {
          save = _getSavedNodes(po, inds) || _allocArray(0)
          for (let i=0; i < po.length; ++i) {
            const x = po[i], fn = _unquote(x[0]), ins = inds[i]
            if (inputs && inputs.has(fn)) error('Calling/adjusting dynamic functions is forbidden but got', x, '(use', apply, ')')
            if (typeof fn != 'function' || isArray(fn) || defines(fn, adjust) === undefined || defines(fn, mergeAdjustment) === undefined)
              continue
            // Pre-create arrays, so that dependents can fill merging.
            douts[i] = i === po.length-1 ? _dout : [undefined, [array]]
          }

          // Fill out the nodes to read from the `adjustLoad()` array that owns outputs of some nodes, not just `true` in `save`.
          loaded = [adjustLoad, save.filter(x => x).length]
          for (let i=0, n=0; i < po.length; ++i)
            if (save[i])
              save[i] = [takeAt, loaded, n++],
              types && types.has(po[i]) ? outTypes.set(save[i], types.get(po[i])) : outDisposers.set(save[i], _nodeDisposer(po[i], inputs))
        }

        // Go through the post-order in reverse (to reverse computation perfectly), and purify adjustment for each node.
        if (!inputAdj) {
          inputAdj = _allocMap()
          if (inputs) for (let k of inputs.keys()) inputAdj.set(k, [undefined, [array]])
          for (let i = po.length-1; i>=0; --i) {
            // Fill in programs for `ins`, `out`, `dout`.
            //   (This loop cannot interrupt.)
            const x = po[i], fn = _unquote(x[0])
            if (typeof fn != 'function' || isArray(fn) || defines(fn, adjust) === undefined || defines(fn, mergeAdjustment) === undefined)
              continue
            if (x.length !== inds[i].length) error("A DAG and its linearization have drifted apart")
            const out = save[i]
            const ins = _allocArray(x.length);  ins[0] = array
            for (let j=1; j < x.length; ++j)
              if (inputs && inputs.has(x[j]))
                ins[j] = [readAt, _ins, inputs.get(x[j])-1]
              else if (save[inds[i][j]] !== undefined)
                ins[j] = save[inds[i][j]]
              else if (!isArray(x[j]) || x[j][0] === quote)
                ins[j] = x[j]
              else
                ins[j] = undefined

            const adj = defines(fn, adjust)
            const changeLength = isArray(adj) && adj[0] === array ? adj.length : x.length

            if (typeof adj != 'function') {
              _bindInput[1] = ins, _bindInput[2] = out
              _bindInput[3] = douts[i] === _dout || isArray(douts[i]) && douts[i][0] ? douts[i] : undefined
              dins[i] = bound(_bindInput, adj, false)
              // …`ins` is never de-allocated, even if unused. Would need a flag in `_bindInput` for that.
            } else
              dins[i] = [adj, ins, null, douts[i] === _dout || isArray(douts[i]) && douts[i][0] ? douts[i] : undefined],
              defines(adj, dispose) === undefined && outDisposers.set(dins[i], _disposeEachAndDealloc)

            // Distribute change, `dins`, to inputs of adjustment, `dout` (via readAt(dins[i], index)).
            //   (In reverse order, so that mergers could always restore the original execution order if they wanted to.)
            const mergers = defines(fn, mergeAdjustment)
            if (mergers)
              for (let j = changeLength-1; j >= 1; --j) {
                const mrgNode = inds[i][j] !== null ? douts[inds[i][j]] : inputAdj.get(x[j])
                const inputNode = inds[i][j] !== null ? po[inds[i][j]] : x[j]
                if (mrgNode !== undefined) {
                  // Fill out merger and add a source to its input.
                  //   Array mergers are input-specific; non-array mergers apply to all inputs.
                  // In `array X Y`, undefined inputs won't be adjusted.
                  if (isArray(dins[i]) && dins[i][0] === array && !dins[i][j]) continue
                  let m = isArray(mergers) ? mergers[j-1] : mergers
                  if (types && types.has(inputNode)) m = typeAdjustmentMerger(types.get(inputNode))
                  if (m && mrgNode[0] === undefined)
                    mrgNode[0] = m
                  else if (m && mrgNode[0] !== m) {
                    if (!_setting(_forgiveMergerMismatch))
                      error("Mergers of the same value should be the same, but had", mrgNode[0], "and got", m, "at input", inds[i][j] !== null ? po[inds[i][j]] : x[j], "of node", po[i])
                    else continue
                  }
                  mrgNode[1].push(isArray(dins[i]) && dins[i][0] === array ? dins[i][j] : [readAt, dins[i], j-1])
                }
              }
          }
          _bindInput[1] = _bindInput[2] = _bindInput[3] = undefined
          const dinputs = [...inputAdj.values()].map(a => a[0] !== undefined ? a : 0)
          dinputs.unshift(array)
          // Don't forget to preserve nodes that do not depend on inputs but still need adjustment (`defines(x, adjustLater)` is `true`).
          program = [last, ...dins.filter((x,i) => !isArray(_unquote(po[i][0])) && defines(_unquote(po[i][0]), adjustLater)).reverse(), dinputs]
          if (program.length == 2 && !program[1]) return null
          if (program.length == 2) program = program[1]
        }
        let b = purify(program, false, adjust.inputs)
        if (isArray(b)) // From value-space of output of `purify`, to program-space.
          b = b[0] === _unknown ? b[1] : quote(b)
        // This `last` makes sure that exceptions won't cause partial disposal of saved state.
        const thoseSaved = save.filter(x => x)
        _allocArray(save), _allocArray(dins), _allocArray(douts)
        _allocMap(inputAdj)
        const r = _allocArray(3);  [r[0], r[1], r[2]] = [thoseSaved.length ? [last, ...thoseSaved, b] : b, outTypes, outDisposers];  return r
      } catch (err) { if (err === interrupt) interrupt.stack.push(save, loaded, dins, douts, inputAdj, program, outTypes, outDisposers); else _allocMap(outTypes), _allocMap(outDisposers);  throw err }
    },
  },

  _bindInput(x) {
    return adjust.inputs.has(x) ? _bindInput[adjust.inputs.get(x)] : isArray(x) && x[0] === quote ? x : undefined
  },

  _ins:{
    docs:`For adjustment. The array of actual function inputs.`,
  },

  _out:{
    docs:`For adjustment. The actual function output.`,
  },

  _dout:{
    docs:`The change of output that adjustment needs to try and subtract from output.
Most \`adjust\`ment \`mul\`tiplies by \`_dout\`.`,
  },

  fetchURL:{
    docs:`\`fetchURL URL\`: requests the resource at URL and returns a promise (use \`await\` to turn it into the result).`,
    Initialize() { fetchURL.opt = {mode:'cors'} },
    call(URL) {
      if (call.pure) throw impure
      return fetch(URL, fetchURL.opt)
    },
  },

  prompt:{
    docs:`\`prompt Params …Options\`
Simply asks/prompts the user to choose between \`Options\`.
\`Params\` could be \`{Timeout ms}\`.`,
    examples:[
      [
        `(prompt {Timeout 10000} 1 2 3 4 5)*5`,
      ],
    ],
    call(params, ...options) {
      if (!options.length) error("Expected some options to choose from")
      if (options.length == 1) return options[0]
      let [pr] = interrupt(1)
      try {
        if (pr) return await(pr)
        const buttons = elem('context-menu-buttons')
        let clicked
        function OnClick() {
          elemRemove(buttons)
          this ? clicked(this.to) : clicked(undefined)
        }
        for (let i = 0; i < options.length; ++i) {
          const btn = elem('button', options[i] instanceof Node ? options[i] : ''+options[i])
          elemValue(btn, options[i])
          buttons.append(btn)
          btn.onclick = OnClick
        }
        print(buttons)
        if (params) {
          params = _destructure(params)
          if (params.Timeout) setTimeout(OnClick, params.Timeout)
        }
        await(pr = new Promise(then => clicked = then))
      } catch (err) { if (err === interrupt) interrupt.stack.push(pr);  throw err }
    },
  },

  _isNumericArray(x) {
    return isArray(x) && x.every(_isNum) || x instanceof Float32Array || x instanceof Float64Array || x instanceof Int32Array || x instanceof Int16Array || x instanceof Int8Array || x instanceof Uint32Array || x instanceof Uint16Array || x instanceof Uint8Array
  },

  display:{
    todo:`By default, only ever display a number (with the value being the whole history), and either:
- Have a checkbox for switching to plot-mode;
- Or make the context menu able to display plots for numbers-only arrays (updated when the array is updated, via \`observe\`, not a \`display\`-only debouncing thing). (Or both.)

Also, allow multiple plots in the same, uh, plot.`,
    docs:`\`display Label Value\`: displays a plot of all \`Value\`s at a \`Label\`. \`display Label\`: clears the display at a \`Label\`.
Browser-only.
The plot can display the exact values at cursor, and be zoomed in by a dragged click (and zoomed out by a quick click).

(There was a need to display losses during training. A day after, this appeared.)

(When zoomed out, high-variance lines are thicc.)`,
    examples:[
      [
        `(display hi ^(6 7 6.4 1 2.1 3))`,
      ],
      [
        `repeat ^(display 'hu' (randomNat 10)) 100000`,
      ],
    ],
    interrupt:false,
    Initialize() {
      display.sizes = {top: 10, right: 20, bottom: 20, left: 90, width: 450, height: 150}
    },
    readAt:{
      _noPlots:_(`_noPlots`),
      _noLossDisplay:_(`_noLossDisplay`),
    },
    call(lbl, vle) {
      if (typeof document == ''+void 0) return
      if (vle === undefined) {
        // Remove the row.
        let L = call.env[_id(print)]
        if (!(L instanceof Map)) return
        if (!L.has(lbl)) return
        elemRemove(L.get(lbl).parentNode, true, true, false)
        L.delete(lbl)
      } else if (_isDisposable(vle) || _isNumericArray(vle) || typeof vle == 'number' || vle === null) {
        let L = call.env[_id(print)]
        if (!(L instanceof Map)) {
          L = new Map([[print, L]])
          const tbl = elemValue(elem('table'), display)
          L.set(display, tbl)
          call.env[_id(print)] = L
          print(tbl)
        }
        if (!_updatePlots.cells) _updatePlots.cells = new Set, _updatePlots.fn = _throttled(_updatePlots, .1)
        if (!L.has(lbl)) {
          // Create a table row with the label and the plot.
          const data = _isDisposable(vle) ? arraySorted(vle) : _isNumericArray(vle) ? [...vle] : vle !== null ? [vle] : []
          const row = elem('tr', [elem('td', serialize(lbl, _langAt(), _bindingsAt(), serialize.displayed)), elem('td')])
          const cell = row.lastChild

          const sizes = display.sizes
          const dv = elem('div')
          const svg = d3.create('svg')
            .attr("width", sizes.width + sizes.left + sizes.right - .5) // (Firefox/Chromium agree only with this -.5.)
            .attr("height", sizes.height + sizes.top + sizes.bottom)
          const tooltip = elem('div')
          tooltip.style.position = 'absolute', tooltip.style.left = tooltip.style.top = 0, tooltip.style.pointerEvents = 'none'
          const num = elem('number')
          dv.append(svg.node(), num)
          num.textContent = data.length ? ''+data[0] : '<Nothing>',
          svg.node().style.display = 'none'

          cell.style.position = 'relative'
          cell.append(tooltip, dv)

          if (typeof ResizeObserver != ''+void 0)
            (function(L, lbl, dv) {
              new ResizeObserver(entries => {
                L.has(lbl) && L.get(lbl).to.length > 1 && _updatePlotLater(L.get(lbl))
              }).observe(dv)
            })(L, lbl, dv)

          L.set(lbl, elemValue(cell, data))
          const pre = _smoothHeightPre(L.get(display))
          elemInsert(L.get(display), row)
          _reflow().then(() => _smoothHeightPost(L.get(display), pre))
        } else if (_isNumericArray(vle))
          L.get(lbl).to.push(...vle)
        else if (_isDisposable(vle))
          L.get(lbl).to.push(...arraySorted(vle))
        else if (typeof vle == 'number')
          L.get(lbl).to.push(vle)

        _updatePlotLater(L.get(lbl))
      } else
        error("Expected undefined or null or a number or a tensor, got", vle)
    },
  },

  _noPlots:[
    _(`settings`),
    false,
    `If checked, \`display\` will just display the latest number on update, not the whole plot.`,
  ],

  _noLossDisplay:[
    _(`settings`),
    false,
    `If not checked, \`interpreter\` will \`display\` the average loss (prediction error) if there were any \`predict\`ions, when done.`,
  ],

  _updatePlotLater(cell) {
    !_updatePlots.cells.size && setTimeout(_updatePlots.fn, 100)
    _updatePlots.cells.add(cell)

    const text = cell.firstChild.lastChild
    if (text && isArray(cell.to)) _updatePlotTooltip(text, cell.to.length-1, cell.to[cell.to.length-1], undefined, true)
  },

  _updatePlots() {
    // Performs scheduled updates of plots.
    _updatePlots.cells.forEach(update)
    return new Promise(then => setTimeout(then, 0))

    function update(cell) {
      _updatePlots.cells.delete(cell)
      if (typeof ResizeObserver != ''+void 0)
        cell.lastChild.classList.toggle('resizable', cell.to.length > 1)
      const hadText = cell.lastChild.lastChild.textContent
      if (cell.to.length > 1 && !_noPlots[1]) {
        if (hadText)
          cell.lastChild.lastChild.textContent = '',
          cell.lastChild.firstChild.style.removeProperty('display')
        _updatePlot(d3.select(cell.lastChild.firstChild), hadText ? display.sizes : sizeOf(cell.lastChild), cell.to)
      } else
        cell.lastChild.lastChild.textContent = cell.to.length ? ''+cell.to[cell.to.length-1] : '<Nothing>',
        cell.lastChild.firstChild.style.display = 'none'
    }
    function sizeOf(el) {
      if (el && el.offsetWidth && el.offsetWidth > 150) {
        const left = 90, bottom = 20
        return {top: 20, right: 20, bottom, left, width: el.offsetWidth - left - 20, height: el.offsetHeight - bottom - 20}
      }
      if (el && el.offsetWidth)
        return {top: 0, right: 0, bottom: 10, left: 20, width: el.offsetWidth - 20, height: el.offsetHeight - 10}
      return display.sizes
    }
    // .cells (a Set), .fn (a `_throttled` mirror of this function)
  },

  _updatePlotTooltip(text, x, y, makeEnd, exitIfNotEnd) {
    if (!text) return
    if (exitIfNotEnd && !text._isEnd) return
    text.firstChild.textContent = 'At '+(x+1)+', the value is\n'
    text.lastChild.textContent = (y < 1e8 ? y : (+y).toExponential(2))
    if (!exitIfNotEnd) text._isEnd = !!makeEnd
  },

  _updatePlot(svg, sizes, data, begin, end) {
    if (!isArray(data)) error("Expected an array, got", data)
    const el = svg.node()
    let transition = false
    if (begin === undefined)
      begin = el._begin !== undefined ? el._begin : 0
    else transition = true
    if (end === undefined)
      end = el._end !== undefined && el._end !== el._len ? el._end : data.length
    else transition = true

    svg
      .attr("width", sizes.width + sizes.left + sizes.right - .5) // (Firefox/Chromium agree only with this -.5.)
      .attr("height", sizes.height + sizes.top + sizes.bottom)
    let xAxis, yAxis, plot
    if (!el.firstChild) {
      // If empty, create children, and attach events.
      xAxis = svg.append('g'), yAxis = svg.append('g'), plot = svg.append('path')

      const tooltip = svg.node().parentNode.previousSibling
      const focus = d3.select(elem('div')).style('opacity', 0).style('border', '.1em solid currentColor').style('transition', 'none')
      const text = d3.select(elem('text')).style('opacity', 0).style('color', 'currentColor').style('display', 'block').style('transition', 'none').style('text-align', 'center')
      focus.style('width', '1em').style('height', '1em').style('border-radius', '.5em')
      text.node().append(elem('text'), elem('number'))
      text.node().firstChild.style.textShadow = '0 0 .15em var(--background)'
      text.node().lastChild.style.textShadow = '0 0 .15em var(--background)'
      tooltip.append(focus.node(), text.node())

      // Also show the exact value at cursor.
      const zoom = svg.append('g').append('rect').style('fill', 'rgba(30,50,200,.3)').attr('y', 0).attr('height', '100%')
      let zoomBegin = null
      function mouseMove(evt) {
        let [cx,cy] = d3.pointer(evt, this)
        let i = Math.max(0, Math.min(Math.round(this._x.invert(cx)-1), this._len-1)), data = this._data
        if (i < 0 || i >= this._len)
          focus.style('opacity', 0), text.style('opacity', 0)
        else {
          const x = this._x(i+1), y = this._y(data[i])
          focus.style('opacity', 1), text.style('opacity', 1)
          focus.style('transform', `translate(-50%,-50%) translate(1ch,0) translate(${x}px, ${y}px)`)
          _updatePlotTooltip(text.node(), i, data[i], i >= this._len-1)
          text.style('transform', `translate(-50%,-100%) translate(1ch,0) translate(${x}px, ${y-20}px)`)
        }

        // Also display the rectangle of the future zoom.
        if (zoomBegin !== null) {
          let l = this._x(zoomBegin+1), r = this._x(i+1)
          if (zoomBegin === i) l = this._x(1), r = this._x(data.length)
          if (i >= 0 && i < this._len)
            zoom.style('opacity', 1),
            l<r ? zoom.attr('x', l).attr('width', r-l) : zoom.attr('x', r).attr('width', l-r)
          else zoom.style('opacity', 0)
        } else zoom.style('opacity', 0)
      }
      svg.on('pointermove', mouseMove)
        .on('pointerover', mouseMove)
        .on('pointerout',  () => { focus.style('opacity', 0), text.style('opacity', 0), zoom.style('opacity', 0) })

      // Also allow zooming in by a dragged click (and zooming out, by a quick click).
      svg.on('pointerdown', function(evt) {
        let [cx,cy] = d3.pointer(evt, this)
        const i = Math.max(0, Math.min(Math.round(this._x.invert(cx)-1), this._len-1))
        if (i >= 0 && i < this._len) zoomBegin = i
        evt.preventDefault()
        mouseMove.call(this, evt)
        svg.node().setPointerCapture && svg.node().setPointerCapture(evt.pointerId)
      }).on('pointerup', function(evt) {
        svg.node().releasePointerCapture && svg.node().releasePointerCapture(evt.pointerId)
        if (zoomBegin === null) return
        let [cx,cy] = d3.pointer(evt, this)
        let i = Math.max(0, Math.min(Math.round(this._x.invert(cx)-1), this._len-1)), data = this._data, sizes = this._sizes
        if (i >= 0 && i < this._len) {
          if (i === this._len-1) i = data.length-1
          if (zoomBegin === i) _updatePlot(d3.select(this), sizes, data, 0, data.length)
          else if (zoomBegin > i) _updatePlot(d3.select(this), sizes, data, i, zoomBegin+1)
          else if (zoomBegin < i) _updatePlot(d3.select(this), sizes, data, zoomBegin, i+1)
        }
        zoomBegin = null, zoom.style('opacity', 0)
        mouseMove.call(this, evt)
      })

    } else
      [xAxis, yAxis, plot] = el.childNodes, xAxis = d3.select(xAxis), yAxis = d3.select(yAxis), plot = d3.select(plot)
    // X axis.
    const x = (el._x || (el._x = d3.scaleLinear()))
      .range([sizes.left, sizes.left + sizes.width - sizes.right])
      .domain([begin+1, end])
    ;(_disableSmoothTransitions[1] || !transition ? xAxis : xAxis.transition(200))
      .attr("transform", `translate(0,${sizes.top + sizes.height - sizes.bottom})`)
      .call(d3.axisBottom(x).ticks(Math.min(end - begin - 1, sizes.width / 80)).tickSizeOuter(0))

    // Y axis.
    let Min = data[begin], Max = data[begin]
    for (let i = begin+1; i < end; ++i)
      if (data[i] === data[i] && isFinite(data[i])) data[i] < Min ? (Min = data[i]) : (data[i] > Max && (Max = data[i]))
    const extra = Math.abs(Max-Min)*.2
    Min = (Min-extra<0) === (Min<0) ? Min-extra : 0, Max = (Max+extra<0) === (Max<0) ? Max+extra : 0
    const y = (el._y || (el._y = d3.scaleLinear()))
      .range([sizes.top + sizes.height - sizes.bottom, sizes.top])
      .domain([Min, Max]).nice()
    ;(_disableSmoothTransitions[1] || !transition ? yAxis : yAxis.transition(200))
      .attr("transform", `translate(${sizes.left},0)`)
      .call(d3.axisLeft(y).ticks(sizes.height / 40).tickSizeOuter(0))

    const step = Math.max(1, ((end - begin) / sizes.width) | 0)
    el._x = x, el._y = y, el._data = data, el._sizes = sizes, el._begin = begin, el._end = end === data.length ? undefined : end, el._len = data.length, el._step = step

    // Zoom (also show a bit of values before the shown range, unless they're way out of range) (also show item distributions).
    let begin2 = begin
    const lookBehind = 0
    while (begin2 > 0 && begin2 > begin - lookBehind && data[begin2-1] >= Min - extra*10 && data[begin2-1] <= Max + extra*10) --begin2
    // Skip items, trim offscreen points.
    const mins = [], maxs = []
    for (let i=0; begin2 + i*step < end; ++i) {
      let a = begin2 + i*step, b = begin2 + (i+1)*step, empty = true
      mins[i] = maxs[i] = 0
      for (let j = a; j < b; ++j)
        if (data[j] !== data[j] || !isFinite(data[j])) continue
        else if (empty) mins[i] = maxs[i] = data[j], empty = false
        else if (data[j] < mins[i]) mins[i] = data[j]
        else if (data[j] > maxs[i]) maxs[i] = data[j]
      if (empty && i) mins[i] = mins[i-1], maxs[i] = maxs[i-1]
    }

    // Plot.
    if (!plot.attr('fill'))
      plot.attr("fill", "steelblue")
        .attr("stroke", "steelblue")
        .attr("stroke-width", 1.5)
        .attr("stroke-linejoin", "round")
        .attr("stroke-linecap", "round")
    ;(_disableSmoothTransitions[1] || !transition ? plot : plot.transition(200))
      .attr("d", "M " + mins.map((v,i) => 1+x(begin2 + i*step + 1) + " " + y(v)).join(" L ") + " L " + maxs.reverse().map((v,i,maxs) => 1+x(begin2 + (maxs.length - i - 1)*step+1) + " " + y(v)).join(" L ") + " Z")
  },

  callAdjust:{
    use:1,
    dispose:true,
    type:[
      _(`funcType`),
      [
        _(`madeType`),
        `Result`,
      ],
      `Result`,
    ],
    docs:`\`callAdjust ^Expr\`: executes \`Expr\` then \`adjust\`s it.
This is the default \`interpreter\`, so there's no need to call it in user code.

Every number in an execution can potentially be predicted before it's actually computed. Going back to adjust an execution allows improving predictions.`,
    tutorial:[
      `One of the most basic primitives of intelligence is prediction: trying to see the future by adjusting a part of the past to be more like a part of the future that arrived. Both composable and embeddable, very nice.

The basic idea of \`adjust\`ment is: go in exact reverse of \`call\`, with \`adjustSave\` pushing to a stack of state, and \`adjustLoad\` popping from the stack. In particular, gradient descent is naturally implementable and implemented with this.

In Conceptual, we replaced the interpreter with this execute+adjust function, so that all execution can \`predict\` things.
But it's not the most trivial thing to implement first-try (that would probably be \`1+1\`, or maybe \`1\`).
So. Friend of trees, emissary of nature. Are you up for some maintenance, together?
We'll observe behavior and by doing so, collapse it into a bugless state.
Just a few simple examples, to make sure that it's working.

And while we're at it, we'll try out a new syntax: \`fancier\` (which allows the "function call, then the comma-separated argument list in brackets" syntax). Today's a day of many firsts (that aren't actually firsts).

But first, let's take a quick look at the macro that we'll use as the predictor:`,
      [
        _(`fancier`),
        `^randomVar()`,
        function(r) { return true },
      ],
      `(Hint: \`^x\` quotes \`x\`, so that it is not evaluated and is given to evaluation as-is. Generally, hovering over an operator should always show the function responsible for it.)

It might be hard to read (where moving the cursor to aid with visual parsing of complex graphs is essential). \`fancier\` might be more convenient to write, but it is still inferior to \`fancy\` in array-heavy situations (there, each array is, unambiguously except at top-level, a bracketed space-separated list like \`(A B C C:D)\` — unlike in \`fancier\`, where they may look like function calls).

A variable that is given an array of the tensor (the current value) and some zeroes, and some hyper-parameterization.
To adjust, it uses SGD with Nesterov momentum. It uses Glorot initialization.
Not the most original situation.

One distant day, we'd like to automatically generate and learn the best computations for parts of this.
But until then, using it would not be remiss.

But let's do the most trivial prediction ever:`,
      [
        _(`fancier`),
        `randomVar()=6`,
        function(r) { return true },
      ],
      `I traveled to all parts of this world, and found all 7 bugs to unfold.

The loss that is used, \`loss2\`, is the halved square of the difference between predicted and actual: \`a=b\` is mostly \`minimize d*d/2 d:a-b\`. So you should be aware that it's about \`18\` if the prediction of \`6\` is \`0\`, likely fractional.

To implement functionality is to be able to use it repeatedly, without conditionality, heatedly. So, almost 5 bugs later, made it something greater.

But, it leaks some memory, and it's slow.
To my little friend, say hello: \`\`settings ^_debugCreation\`\`.
    [Cut out some narration that outlined how \`stringToDoc\` was augmented to allow motivational devices, such as \`\`settings ^_autoDispose\`\`.]

And if it doesn't work? Use our own hands to fix errors.

Like profiling performance. The profiler says that TensorFlowJS and DOM are almost the only things happening below. If you rewrite the initializer in \`randomVar\` to create a JS number instead of a one-number tensor, the loop completes 50 times faster. Can you do that?
(Rewriting is accessible as a button in context menus; don't forget to press Enter to commit changes before viewing.)
`,
      [
        _(`fancier`),
        `f:\\input+randomVar()  (repeat ^(f(1)=3; f(2)=4; f(4)=6.1; 'ok') 1000)`,
        function(r) { return r === 'ok' },
      ],
      `(Note: gradient is the direction of change that would maximize \`predict\`ion error/loss, and what we're doing by predicting several input-output pairs is estimating the true gradient by averaging gradient at data points, then \`sub\`tracting a simple function of the gradient.)

Okay, in this regard, there's nowhere to grow now. API designers should only know the numbers \`0\`, \`1\`, and \`Infinity\`, and we reached the last one.

More operations, then.

And a way to test them, of course.
But not a "real" toy dataset like MNIST or ImageNet.
I cannot engage in the "bigger is better" race that grips modern machine learning, so I'm ideologically opposed to it (all because long ago, I realized that I must not have the choice to participate if I want to have choices that matter for AI).
So, synthetic/random data.

Just demonstrating that \`matMul\` improves on any data should suffice. The loss must be going down.
(We plan to be using this whole adjustment system, so we can figure out bugs as we go. A free source of entertaining puzzles, and an excuse to go back and re-think.)
(Also, I added \`static\` just so we wouldn't have to either have new tensors for each iteration, or have \`randomConst\` for this one use-case.)`,
      [
        _(`fancier`),
        `s:static r:biasedGlorotNormal
w:randomVar(identity,10,12)
i0:s(r(10)) i1:s(r(10)) i2:s(r(10)) i3:s(r(10)) i4:s(r(10))
o0:s(r(12)) o1:s(r(12)) o2:s(r(12)) o3:s(r(12)) o4:s(r(12))
repeat ^(i0@w=o0;i1@w=o1;i2@w=o2;i3@w=o3;i4@w=o4;'ok') 1000`,
        function(r) { return r === 'ok' },
      ],
      `Alright. I don't think that the exact things I did to fix bugs in the systems involved in the examples above are relevant/interesting.

It's time to answer the most important question in every endeavor and every sentence. Why are we doing this?
\`callAdjust\` was to remind you that if you don't understand something enough, then you should go back and \`repeat\` things that lead up to it. That's how loss goes down.

But also…
Strap in, it's not easy reading.

Deep learning has been getting popular since about 2012 {https://trends.google.com/trends/explore?date=all&q=deep%20learning}. It's all about network depth and lots of computation. We don't have either, but the core ideas are sound, and sounds become words and mindsets. No datasets, no over-engineering, and no precious achievements. Complexity is pointless anyway.
It's practically synonymous with machine learning.
Machine learning is a mindset, also called a universal approximator: it can approximate any function, just as code developers can do anything. Be careless, and it can replace all your thoughts with itself. It's often called AI algorithms.

Let's compare that with general intelligence.

In a mind, improvement causes co-evolved concepts to emerge and define behavior (getting good leads to understanding). They're amorphous, but not ill-defined: goals solidify them. In code, a concept can be separated into a function like \`predict\`, and be expressed as requirement of particular usage patterns like \`interrupt\`, or even as many clumps of code in other functions like memory-management needs… There are no constraints on structure, and the only beauty is how high some numbers become. Generality of choosing any structure, and intelligence of learning those choices. (It's special because it tends to self-propagate, in order to drive those numbers up.)

Machine learning is a lesser but practical modern cousin of that. A kind of discretization of that infinite space.

- A concept here corresponds to a number, and there's only a fixed count (number=float, count=int) of those.
  By connecting many simple variables with simple differentiable computations and \`adjust\`ing after each execution, numbers are made better. (The computations are called "neural networks" because of history, but the principles are not specific to brains.)
  The simplest connection is all-to-all (so every output number is a linear combination of input numbers), which \`matMul\` of a row vector (or a column of them) by a weight matrix realizes (other simplest approaches include convolutions and random connections). In general in programs, the more adjustable information we route the better. The computation should be generatable.

- Improvement here means usually differentiable operations because they can be mathematically proven to converge, but any numeric operations that improve prediction should do, because this usually composes. The adjustment should be generatable.

- Choices here correspond to minimizing the misprediction (loss/error) of rewards (goals) of actions (options). There can only be one action per choice (for example, can only generate one program), and the predictions for each can be used in some way that may maximize the reward at a choice (argmax is preferred, but random exploration noise can be useful too).

General and practical… enough to transcend.
I don't like to talk about what good grasp of those means for everyday life, though I'll have to, in time.
(And, to mention the current trends of machine learning, people mainly care about having only one non-optional loss, and making all operations differentiable. No learned inter-connection of many goals, no learned adjustment, and no learned goals. Warped to be neatly packaged. That's why we can't use TensorFlowJS as anything except a numeric-ops backend, and even then, only its immediate mode.)
And for all that, we must first have the \`callAdjust\` family of concepts. Which we now do.

I can only pray that we have enough strength to do all those. And the way to get that is to open our eyes with words, to bind our selves into one, tight enough to withstand learning otherwise. Tutorials are the future, my elven friend, and the future starts with you.
Blind coding is not the way, we will just end up focusing on special cases of general intelligence (such as \`randomVar\`).

May the sun guide your righteous path.

Next, might I suggest \`tutorial Neural\` to continue your training in the way of the learning? All in service of \`tutorial consWorld\`.

\`\`REPL()\`\``,
    ],
    examples:[
      `Loss goes down.`,
      [
        `repeat ^(v*2=4;v+2=4 v:varSGD(randomVarData(),.01)) 300`,
      ],
      [
        `repeat ^(v*2=4;v+2=4 v:varMomentum(randomVarData(),.01,.99)) 1000`,
      ],
      [
        `repeat ^(v*2=4;v+2=4 v:varRMSProp(randomVarData(),.01,.999)) 300`,
      ],
      [
        `repeat ^(v*2=4;v+2=4 v:varAdam(randomVarData(),.01,.99,.999)) 1000`,
      ],
      `(Momentum and Adam are wiggly-wiggly if you zoom in.)`,
    ],
    readAt:{
      _learningRate:_(`_learningRate`),
      _firstMomentum:_(`_firstMomentum`),
      _secondMomentum:_(`_secondMomentum`),
      varSGD:_(`varSGD`),
      commit:_(`commit`),
      minimize:_(`minimize`),
      adjust:_(`adjust`),
      _debugAdjustSave:_(`_debugAdjustSave`),
    },
    Initialize() {
      callAdjust.callCache = new WeakMap
      callAdjust.adjustCache = new WeakMap
    },
    impure:true,
    call(expr) {
      let [compCall, compAdj, result, adjustInfo] = interrupt(4)
      predict.happened = false
      try {
        // Compile call then adjustment, then call then adjust (asserting exact-ness of reversal, and recovery from interrupts), then return the result.
        if (compCall === undefined) {
          if (callAdjust.callCache.has(expr))
            compCall = callAdjust.callCache.get(expr) || 0,
            compAdj = callAdjust.adjustCache.get(expr)
          else
            compAdj = _postorderInfo(expr),
            compCall = _compileBody(expr, null, compAdj, undefined, undefined, undefined, expr)
        }
        if (isArray(compAdj)) {
          const r = _compileAutograd(compAdj, undefined, undefined, expr);  defines(_postorderInfo, dispose)(compAdj), compAdj = r
          if (isArray(expr)) callAdjust.callCache.set(expr, compCall), callAdjust.adjustCache.set(expr, compAdj)
        }

        // Call.
        if (result === undefined) {
          const arr = adjustLater(compCall)
          if (interrupt.stack) error(expr, "got", arr[0], "but did not recover from an interrupt at", _resolveStack(interrupt.last), "and still have", ...interrupt.stack)
          ;[result, adjustInfo] = arr;  _allocArray(arr)
          _rememberToDispose(result)
          result === undefined && (result = _onlyUndefined)

          if (adjustInfo && call.pure) throw _destroyAdjustmentStack(adjustInfo), impure
        }

        // Adjust.
        // We don't have a loss function at the top-level, nor a dataset, only `predict`. So no dout.
        if (compAdj !== null)
          _disposeEachAndDealloc(adjustNow(adjustInfo, compAdj)), compAdj = null

        return result !== _onlyUndefined ? result : undefined
      } catch (err) {
        if (err === interrupt) interrupt.stack.push(compCall, compAdj, result, adjustInfo), compCall = null
        else {
          const prevDoubleDispose = dispose.safeDouble;  dispose.safeDouble = true
          try {
            commit(false)
            dispose(result)
          } finally { dispose.safeDouble = prevDoubleDispose }
        }
        throw err
      } finally {
        if (compCall !== null) // An error, or normal return.
          _destroyAdjustmentStack(adjustInfo)
      }
      // .callCache, .adjustCache
    },
  },

  _learningRate:[
    _(`settings`),
    3e-4,
    `The learning rate (multiplier of incoming gradient for variables) is ???.`,
    _(`rangeSetting`),
    1e-7,
    1,
    true,
  ],

  _firstMomentum:[
    _(`settings`),
    .9,
    `How much previous-gradient \`varMomentum\`/\`varAdam\` will preserve at each update: ???.`,
    _(`rangeSetting`),
    0,
    1,
    .01,
  ],

  _secondMomentum:[
    _(`settings`),
    .95,
    `How much squares-of-previous-gradient \`varRMSProp\`/\`varAdam\` will preserve at each update: ???.`,
    _(`rangeSetting`),
    0,
    1,
    .01,
  ],

  _tf:{
    docs:`All tensor-creating function calls pass their results through this, so that we can do things with all TensorFlowJS tensors (for debugging).`,
    _cancel(m) {
      if (isArray(m)) m.forEach(defines(_tf, _cancel))
      if (!(m instanceof Map)) return
      const prevAll = _tf.all;  _tf.all = m
      try { m.forEach(_disposeKey), m.clear(), _allocMap(m) }
      finally { _tf.all = prevAll }
    },
    Initialize() { _tf.count = 0 },
    call(x) {
      if (_tf.all)
        _tf.all.has(x) && error('Already been there:', x),
        _tf.all.set(x, _debugMemory[1] ? [[readAt, _tf, new Error().stack]] : _debugCreation[1] ? new Error().stack : true)
      if (limitTensorMemory.limit !== undefined && tensorMemorySince() > limitTensorMemory.limit) throw dispose(x), limit
      ++_tf.count
      return x
      // .all, .justCheck
    },
  },

  _disposeKey(v,k,m) {
    if (k.isDisposedInternal) return void m.delete(k)
    let a = (dispose.keep.get(k) || 0) + 1, b = dispose.not && dispose.not.get(k) || 0
    a < b && error(k, 'made at', _tensorOrigins(k), 'should have been disposed', b - a, 'less times')
    if (_tf.justCheck)
      a > b && error(k, 'made at', _tensorOrigins(k), 'should have been disposed', a - b, 'more times')
    else while (a > b) dispose(k), --a
    m.delete(k)
  },

  truncatedNormal:{
    use:3,
    docs:`\`truncatedNormal Sizes Mean StdDev\`: initializes a tensor by drawing each number from a truncated normal distribution.
Values with magnitude of more than 2 standard deviations are dropped and re-picked.`,
    call(sizes, mean = 0, stdev = 1, dtype) {
      if (_isDisposable(sizes)) sizes = sizes.shape
      if (!isArray(sizes)) error('Not an array:', sizes);  sizes.forEach(_num)
      mean = sync(mean), stdev = sync(stdev)
      if (mean !== mean || typeof mean != 'number' && !_isDisposable(mean)) error("Not a number:", mean)
      if (stdev !== stdev || typeof stdev != 'number' && !_isDisposable(stdev)) error("Not a number:", stdev)

      return _tf(tf.truncatedNormal(sizes, mean, stdev, dtype))
    },
    type:[
      _(`funcType`),
      [
        _(`quote`),
        [
          _(`computeType`),
          _(`_concreteTensorSize`),
          `Sizes`,
        ],
      ],
      _(`_numberType`),
      _(`_numberType`),
      _(5696),
    ],
    dispose:true,
    interrupt:false,
  },

  zeros:{
    use:1,
    docs:`\`zeros Sizes\`: returns a tensor filled with \`0\`.`,
    type:[
      _(`funcType`),
      [
        _(`quote`),
        [
          _(`computeType`),
          _(`_concreteTensorSize`),
          `Sizes`,
        ],
      ],
      _(5696),
    ],
    dispose:true,
    interrupt:false,
    impure:true,
    call(sizes) { return !isArray(sizes) ? 0 : _tf(tf.zeros(sizes)) },
    construct(x, obj) { if (obj === undefined) return isArray(x) && x[0] === zeros && isArray(x[1]) && x[1][0] === quote && isArray(x[1][1]) && x[1][1][0] === 1 && x[1][1].length == 1 ? 0 : x },
  },

  identity:{
    use:true,
    docs:`\`identity Sizes\`: returns the identity matrix/tensor: all numbers where indexes are equal are \`1\`, all others are \`0\`.`,
    type:[
      _(`funcType`),
      [
        _(`quote`),
        [
          _(`computeType`),
          _(`_concreteTensorSize`),
          `Sizes`,
        ],
      ],
      _(5696),
    ],
    dispose:true,
    interrupt:false,
    argCount:1,
    impure:true,
    call(sizes) {
      if (!isArray(sizes)) error('Not an array:', sizes)
      if (sizes.length == 2)
        return _tf(tf.eye(sizes[0], sizes[1]))
      else {
        const mn = Math.min(...sizes)
        const buf = tf.buffer(sizes)
        const ind = _allocArray(sizes.length)
        for (let i=0; i < mn; ++i)
          ind.fill(i), buf.set(1, ...ind)
        _allocArray(ind)
        return _tf(buf.toTensor())
      }
    },
    construct(x, obj) { if (obj === undefined) return isArray(x) && x[0] === identity && isArray(x[1]) && x[1][0] === quote && isArray(x[1][1]) && x[1][1][0] === 1 && x[1][1].length == 1 ? 1 : x },
  },

  ones:{
    use:1,
    docs:`\`ones Sizes\`: returns a tensor filled with \`1\`.`,
    type:[
      _(`funcType`),
      [
        _(`quote`),
        [
          _(`computeType`),
          _(`_concreteTensorSize`),
          `Sizes`,
        ],
      ],
      _(5696),
    ],
    dispose:true,
    interrupt:false,
    impure:true,
    call(sizes) { return !isArray(sizes) ? 1 : _tf(tf.ones(sizes)) },
    construct(x, obj) { if (obj === undefined) return isArray(x) && x[0] === ones && isArray(x[1]) && x[1][0] === quote && isArray(x[1][1]) && x[1][1][0] === 1 && x[1][1].length == 1 ? 1 : x },
  },

  biasedGlorotNormal:{
    use:true,
    type:[
      _(`funcType`),
      [
        _(`funcType`),
        [
          _(`quote`),
          [
            _(`computeType`),
            _(`_concreteTensorSize`),
            `Sizes`,
          ],
        ],
        _(5696),
      ],
      [
        _(`rest`),
        `Sizes`,
        _(`quote`),
      ],
      _(5696),
    ],
    docs:`\`biasedGlorotNormal Bias …Sizes\`: Basically tf.initializers.glorotNormal for the current value, but with added bias (if passed).`,
    dispose:true,
    interrupt:false,
    call(bias = null, ...sizes) {
      if (typeof bias == 'number') sizes.unshift(bias), bias = null
      if (!sizes.length && bias === identity) return truncatedNormal([], 1, Math.SQRT2)
      else {
        if (bias != null && typeof bias != 'function') error("Expected null or a function for bias, got", bias)
        let s = 0
        for (let i=0; i < sizes.length; ++i)
          typeof sizes[i] != 'number' && errorStack("Expected a number for the size, got", sizes[i]),
          s += sizes[i]
        if (!sizes.length) s = 1
        if (!s || s !== s>>>0) errorStack("All sizes must be positive integers but got", ...sizes)
        const e = bias != null && bias(sizes)
        const t = truncatedNormal(sizes, 0, Math.sqrt(2 / s))
        try { return e ? add(t, e) : t }
        finally { e && (dispose(t), dispose(e)) }
      }
    },
  },

  static:{
    use:1,
    argCount:1,
    type:[
      _(`funcType`),
      [
        _(`madeType`),
        `T`,
      ],
      `T`,
    ],
    docs:`\`static Expr\`: A \`construct\` that evaluates \`Expr\` and replaces it with \`^Result\`. (Don't use it.)

(Forgive me, Master "Please don't use \`construct\` for macros".)`,
    construct(x, obj) {
      if (obj === undefined) return [quote, "Not evaluated yet"]
      else {
        const prevPure = call.pure;  call.pure = false
        try { obj[1] = call(x[1]) }
        finally { call.pure = prevPure }
      }
    },
  },

  applyStatically:{
    use:true,
    type:[
      _(`funcType`),
      [
        _(`funcType`),
        [
          _(`rest`),
          `Inputs`,
        ],
        `Output`,
      ],
      [
        _(`rest`),
        `Inputs`,
      ],
      `Output`,
    ],
    docs:`\`applyStatically Func …Args\`: will \`apply\` \`Func\` to \`Args\`, and will become the (\`quote\`d) result at \`construct\`-time.

With this, partial evaluation is implementable in \`construct\`s.

(Forgive me, Master "Please don't use \`construct\` for macros".)`,
    dispose:true,
    construct(x, obj) {
      if (obj === undefined) {
        if (!isArray(x) || x.length <= 1) error('Must be an array of at least 2 items (at least the func to apply):', x)
        return [quote, 'to be decided']
      } else {
        if (typeof x[1] != 'function') error('Not a func:', x[1])
        // Apply func.
        const fn = _unquote(x[1]), args = x.slice(2).map(_unquote), t = fn(...args)
        // Keep args as/if requested.
        let kp = defines(fn, keep)
        if (kp === true) args.forEach(keep)
        else if (typeof kp == 'number') kp < 0 && (kp += args.length), keep(args[kp])
        // Fill in the spot.
        _changeArrayItem(obj, 1, t);  dispose(t)
      }
    },
  },

  randomVar:{
    use:true,
    type:[
      _(`funcType`),
      [
        _(`funcType`),
        [
          _(`quote`),
          [
            _(`computeType`),
            _(`_concreteTensorSize`),
            `Sizes`,
          ],
        ],
        _(5696),
      ],
      [
        _(`rest`),
        `Sizes`,
        _(`quote`),
      ],
      _(5696),
    ],
    docs:`\`(randomVar …Sizes)\` or \`randomVar Bias …Sizes\`: A \`construct\` for easy creation of randomly-initialized \`varAdam\`s, with fixed learning rate and momentums.
\`Bias\` can be \`null\` (same as \`zeros\`) (the default) or \`identity\` or \`ones\`.

(Forgive me, Master "Please don't use \`construct\` for macros".)`,
    construct(x, obj) {
      if (obj === undefined) return [varAdam, construct([randomVarData, ...x.slice(1)])]
      else { // Return `(varAdam (quote (RandomTensor 0 0)))`.
        if (!isArray(obj) || obj.length !== 2) error('oops')
        construct([randomVarData, ...x.slice(1)], obj[1])
      }
      // .LR
    },
  },

  randomVarData:{
    use:true,
    todo:`When re-\`construct\`ing with the same requested size, do not re-generate random numbers. Allows re-use.`,
    type:[
      _(`funcType`),
      [
        _(`funcType`),
        [
          _(`quote`),
          [
            _(`computeType`),
            _(`_concreteTensorSize`),
            `Sizes`,
          ],
        ],
        _(5696),
      ],
      [
        _(`rest`),
        `Sizes`,
        _(`quote`),
      ],
      [
        _(`varData`),
        `Sizes`,
      ],
    ],
    docs:`\`randomVarData …Sizes\` or \`randomVarData Bias …Sizes\`: gives an easy way to create the initial \`VarData\` of a variable such as \`varMomentum\`.
\`Bias\` can be \`null\` (same as \`zeros\`) (the default) or \`identity\` or \`ones\`.

(Forgive me, Master "Please don't use \`construct\` for macros".)`,
    construct(x, obj) {
      if (obj === undefined) return [quote, undefined]
      else { // Return `(quote (RandomTensor 0 0))`.
        if (isArray(obj[1])) {
          const sz = _isNum(x[1]) ? x.slice(1) : x.slice(2)
          if (!sz.every(_isNum)) error('Not solely numbers:', x)
          if (_tensorSize(sz) === _tensorSize(obj[1][0]) && (!_isDisposable(obj[1][0]) || ''+sz === ''+obj[1][0].shape)) return
          _rememberArrayItems(obj[1], true), _disposeEachAndDealloc(obj[1]), obj[1] = undefined
        }
        const t = varData(biasedGlorotNormal(...x.slice(1)))
        try { _changeArrayItem(obj, 1, t) }
        finally { dispose(t) }
      }
    },
  },

  varData:{
    use:1,
    argCount:1,
    examples:[
      [
        `repeat ^(varAdam(ed)=5;varAdam(ed)=-4) 500 ed:static(varData(biasedGlorotNormal 16))`,
      ],
      [
        `repeat ^(varAdam(emb)*varAdam(emb)=50;varAdam(emb)) 500 emb:static(varData(biasedGlorotNormal 16))`,
      ],
    ],
    docs:`\`varData Initial\`: creates the \`VarData\` of a variable such as \`varSGD\`.
Consumes \`Initial\`, so \`keep\` it.`,
    interrupt:false,
    keep:1,
    call(initial) {
      if (typeof initial != 'number' && !_isDisposable(initial)) return initial
      const a = _allocArray(3)
      ;[a[0], a[1], a[2]] = [initial, 0, 0]
      _rememberToDispose(a)
      _willCommit(a)
      return a
    },
  },

  _funcAccumulateGradient(ins, out, dout) {
    // Does the same thing as `_accumulateGradient`, but doesn't have to go through `call` when `adjust`ed directly.
    if (dout == null) error("Got null gradient:", dout)
    const data = ins[0]
    _willCommit(data)
    if (dout) {
      const t1 = _limitTensorSize(data[0], dout)
      const t2 = add(data[1], t1);  dispose(t1)
      _changeArrayItem(data, 1, t2);  dispose(t2)
    }
    _increment(data, dout)
  },

  _accumulateGradient:[
    _(`last`),
    [
      _(`_willCommit`),
      _(`_inA`),
    ],
    [
      _(`_changeArrayItem`),
      _(`_inA`),
      1,
      [
        _(`add`),
        [
          _(`readAt`),
          _(`_inA`),
          1,
        ],
        [
          _(`_limitTensorSize`),
          [
            _(`readAt`),
            _(`_inA`),
            0,
          ],
          _(`_dout`),
        ],
      ],
    ],
    [
      _(`_increment`),
      _(`_inA`),
      _(`_dout`),
    ],
  ],

  _optSGD(data) {
    const grad = data[1], LR = -data[4]
    return mul(LR, grad)
  },

  varSGD:{
    use:2,
    todo:`Allow \`VarData\` to be lazily-specified (with a given std-dev), because human-types may not be inferred during program generation for long.`,
    type:[
      _(`funcType`),
      [
        _(`varData`),
        `Sizes`,
      ],
      _(`_numberType`),
      _(5696),
    ],
    docs:`\`varSGD(VarData,LearningRate)\`
Stochastic gradient descent (SGD). Here, optimizers are specified at each variable.
A stateful tensor that reacts to \`adjust\`, by making \`commit\` subtract (a simple function of) the gradient.

Gradient is the direction of the change to maximize \`predict\`ion error/loss.
This simply subtracts gradient each time, \`mul\`tiplied by learning rate.

\`randomVarData\` can provide the \`VarData\`.`,
    interrupt:false,
    adjustLater:true,
    dispose:true,
    impure:true,
    call(data, changeMult = _learningRate[1]) {
      // `data` is `[currentValue, nextChange, countOfChanges]`.
      if (!isArray(data)) error("Not var data:", data)
      data[3] = _optSGD, data[4] = changeMult
      return keep(_num(data[0]))
    },
    adjust:_(`_accumulateGradient`),
    mergeAdjustment:null,
  },

  _optMomentum(data) {
    const grad = data[1], LR = -data[4], Mom1 = data[5], M1 = data[6] || 0
    const t0 = mul(Mom1, M1), t1 = sub(1, Mom1), t2 = mul(t1, grad)
    const nextM1 = add(t0, t2);  dispose(t0), dispose(t1), dispose(t2)
    _changeArrayItem(data, 6, nextM1);  dispose(nextM1)
    return mul(LR, nextM1)
  },

  varMomentum:{
    use:3,
    type:[
      _(`funcType`),
      [
        _(`varData`),
        `Sizes`,
      ],
      _(`_numberType`),
      _(`_numberType`),
      _(5696),
    ],
    docs:`\`varMomentum(VarData,LearningRate,Mom1)\`
Stochastic gradient descent (SGD) with Nesterov momentum.
A stateful tensor that reacts to \`adjust\`, by making \`commit\` subtract (a simple function of) the gradient.

Momentum is \`varSGD\` but subtracting not the gradient, but its running average: \`PrevGrad\` becomes \`Mom1*PrevGrad+(1-Mom1)*_dout\`.
Nesterov momentum is returning not the current value but what it will be after \`PrevGrad\` will change it.`,
    interrupt:false,
    adjustLater:true,
    dispose:true,
    impure:true,
    call(data, changeMult = _learningRate[1], velocityMult = _firstMomentum[1]) {
      // `data` is `[currentValue, nextChange, countOfChanges, opt, velocity]`.
      // Returning `currentValue - LR * velocity * velocityMult` (Nesterov momentum).
      if (!isArray(data)) error("Not var data:", data)
      const mlt = data[6] ? mul(data[6], -changeMult * velocityMult) : 0
      const sm = add(_num(data[0]), mlt);  dispose(mlt)
      data[3] = _optMomentum, data[4] = changeMult, data[5] = velocityMult
      return sm
    },
    adjust:_(`_accumulateGradient`),
    mergeAdjustment:null,
  },

  _optRMSProp(data) {
    const grad = data[1], LR = -data[4], Mom2 = data[5], M2 = data[6] || 0
    const t3 = mul(Mom2, M2), t4 = sub(1, Mom2), t5 = mul(grad, grad), t6 = mul(t4, t5)
    const nextM2 = add(t3, t6);  dispose(t3), dispose(t4), dispose(t5), dispose(t6)
    _changeArrayItem(data, 6, nextM2);  dispose(nextM2)
    const t7 = sqrt(nextM2), t8 = add(t7, 1e-4), t9 = div(grad, t8)
    try { return mul(LR, t9) }
    finally { dispose(t7), dispose(t8), dispose(t9) }
  },

  varRMSProp:{
    use:3,
    type:[
      _(`funcType`),
      [
        _(`varData`),
        `Sizes`,
      ],
      _(`_numberType`),
      _(`_numberType`),
      _(5696),
    ],
    docs:`\`varRMSProp(VarData,LearningRate,Mom2)\`
Stochastic gradient descent (SGD) with root mean square propagation.
A stateful tensor that reacts to \`adjust\`, by making \`commit\` subtract (a simple function of) the gradient.

This is \`varSGD\` \`LearningRate\` gets divided by \`sqrt\` of a running average of gradients: \`PrevSqr\` becomes \`Mom2*PrevSqr+(1-Mom2)*_dout*_dout\`.`,
    interrupt:false,
    adjustLater:true,
    dispose:true,
    impure:true,
    call(data, changeMult = _learningRate[1], accelMult = _secondMomentum[1]) {
      // `data` is `[currentValue, nextChange, countOfChanges, opt, velocity=0, accel]`.
      if (!isArray(data)) error("Not var data:", data)
      data[3] = _optRMSProp, data[4] = changeMult, data[5] = accelMult
      return keep(_num(data[0]))
    },
    adjust:_(`_accumulateGradient`),
    mergeAdjustment:null,
  },

  _optAdam(data) {
    const grad = data[1], LR = -data[4], Mom1 = data[5], Mom2 = data[6], M1 = data[7] || 0, M2 = data[8] || 0
    const t0 = mul(Mom1, M1), t1 = sub(1, Mom1), t2 = mul(t1, grad)
    const t3 = mul(Mom2, M2), t4 = sub(1, Mom2), t5 = mul(grad, grad), t6 = mul(t4, t5)
    const nextM1 = add(t0, t2);  dispose(t0), dispose(t1), dispose(t2)
    const nextM2 = add(t3, t6);  dispose(t3), dispose(t4), dispose(t5), dispose(t6)
    const t7 = sqrt(nextM2), t8 = add(t7, 1e-4), t9 = div(nextM1, t8)
    try {
      _changeArrayItem(data, 7, nextM1)
      _changeArrayItem(data, 8, nextM2)
      return mul(LR, t9)
    } finally { dispose(nextM1), dispose(nextM2), dispose(t7), dispose(t8), dispose(t9) }
  },

  varAdam:{
    use:4,
    type:[
      _(`funcType`),
      [
        _(`varData`),
        `Sizes`,
      ],
      _(`_numberType`),
      _(`_numberType`),
      _(`_numberType`),
      _(5696),
    ],
    docs:`\`varAdam(VarData,LearningRate,Mom1,Mom2)\`
Stochastic gradient descent (\`varSGD\`) with adaptive moment estimation.
A stateful tensor that reacts to \`adjust\`, by making \`commit\` subtract (a simple function of) the gradient.

This combines \`varMomentum\` (first moment smoothing) and \`varRMSProp\` (second moment smoothing): the gradient gets blended, and the learning rate is smoothed per-parameter.`,
    interrupt:false,
    adjustLater:true,
    dispose:true,
    impure:true,
    call(data, changeMult = _learningRate[1], velocityMult = _firstMomentum[1], accelMult = _secondMomentum[1]) {
      // `data` is `[currentValue, nextChange, countOfChanges, opt, velocity, accel]`.
      if (!isArray(data)) error("Not var data:", data)
      data[3] = _optAdam, data[4] = changeMult, data[5] = velocityMult, data[6] = accelMult
      return keep(_num(data[0]))
    },
    adjust:_(`_accumulateGradient`),
    mergeAdjustment:null,
  },

  _increment:{
    docs:`Variable-specific (\`varSGD\`/\`varMomentum\`/…). Keeps track of what to divide by in order to average gradients.`,
    interrupt:false,
    call(arr, dout) { if (call.pure) throw impure; arr[2] += (_tensorSize(dout) / _tensorSize(arr[0])) | 0 },
  },

  _tensorSize(t) { return _isDisposable(t) ? t.size : typeof t == 'number' ? 1 : t.reduce(mul, 1) },

  _tensorShape(t) { return _isDisposable(t) ? t.shape : undefined },

  _limitTensorSize:{
    docs:`\`_limitTensorSize Prev Next\`→\`Next\`: Sums across all outer axes of \`Next\` that are not present in \`Prev\`, if needed.
The original \`Next\` will be disposed of.`,
    dispose:true,
    interrupt:false,
    call(prev, next) {
      if (call.pure) throw impure
      let t = keep(next)
      while (_tensorSize(t) > _tensorSize(prev)) {
        const n = sum(t, 0)
        dispose(t), t = n
      }
      return t
    },
  },

  _maxGlobalGradient:[
    _(`settings`),
    0,
    `The maximum 2-norm of the global gradient, or 0 to not limit commits.`,
  ],

  commit:{
    docs:`\`commit()\` or \`commit false\` to discard changes: commits changes to variables that were made in this job. Returns \`true\` if anything was changed.
This calls the optimizers registered by \`varSGD\` and such (such as \`_optSGD\`).
Until this is done, the same value of variables is used.

\`interpreter\` always calls this after execution.

This is done to signify the end of an epoch of training a differentiable computation.
Note that for generalization, small batches are better than large ones, disregarding parallelization concerns: {https://arxiv.org/pdf/2006.15081.pdf} (and momentum is useless for small batches).`,
    philosophy:`Noise (in machine learning; whether dropout, or small batches) helps with generalization. It's helpful to always think about more general implications. Between arbitrary viewpoints (non-transient programs, or general intelligences), not-adapted-to behavior can largely be seen to be noise, so clearly unity is good and so is joyful discourse of the joyful unity (but self-ensembles are also possible, so this observation cancels itself out if easy scaling of an individual to the level of a society is possible, which it is for programs). So, democracy and open-ness are attractor points for humans (and we have largely converged to them already in many important areas), but for AGI, anything is possible. Be wary.
Was that generalization too general and unexpected, quickly disappearing without its precise cause like a cookie? Maybe. Was it wrong in any way? I don't think so.`,
    Initialize() { commit.arrs = new Set },
    readAt:{
      varSGD:_(`varSGD`),
      varMomentum:_(`varMomentum`),
      varRMSProp:_(`varRMSProp`),
      varAdam:_(`varAdam`),
      _maxGlobalGradient:_(`_maxGlobalGradient`),
      _willCommit:_(`_willCommit`),
    },
    call(perform = true) {
      if (call.pure) throw impure
      if (!call.env || !call.env[_id(commit)]) return
      const m = call.env[_id(commit)]

      let sumOfSquares = 0, divBy = 1
      try {
        m.forEach(data => { // Average gradients.
          if (!data[2]) return m.delete(data), void _rememberArrayItems(data)
          const avg = div(data[1], data[2])
          _changeArrayItem(data, 1, avg), _changeArrayItem(data, 2, 0)

          // Also accumulate sum-of-squares.
          if (_maxGlobalGradient[1]) {
            const sq = mul(avg, avg)
            const ssq = sum(sq);  dispose(sq)
            const smsq = add(sumOfSquares, ssq);  dispose(ssq)
            dispose(sumOfSquares), sumOfSquares = smsq
          }
          dispose(avg)
        })
        if (_maxGlobalGradient[1]) { // Divide all gradients by something if needed.
          let mx, mom2 = sqrt(sumOfSquares) // Not dimensionless: the more variables get updated, the more the second moment of global gradient.
          try {
            mx = _tf(tf.minimum(mom2, _maxGlobalGradient[1]))
            divBy = div(mom2, mx)
            dispose(sumOfSquares), sumOfSquares = 0
          } finally { dispose(mom2), dispose(mx) }
        }
        m.forEach(data => { // Add the change.
          if (divBy > 1) { const dv = div(data[1], divBy);  dispose(data[1]), data[1] = dv }
          const change = data[3](data) // Call the optimizer.
          const sm = add(data[0], change);  dispose(change)

          _changeArrayItem(data, 0, sm);  dispose(sm)
          _changeArrayItem(data, 1, 0)
        })
        dispose(divBy), divBy = 1
        const result = !!m.size
        m.clear()
        return result
      } catch (err) { if (err === interrupt) error("Unexpected interrupt"); else dispose(sumOfSquares), dispose(divBy);  throw err }
    },
  },

  _willCommit:{
    docs:`\`_willCommit VarData\`: Makes the later \`commit\` commit the change (\`VarData.1\`/\`VarData.2\`) to the value (\`VarData.0\`) by calling \`VarData.3\`.
Make sure to call this before any changes to the array.`,
    interrupt:false,
    call(arr) {
      !isArray(arr) && error('Expected an array but got', arr)
      if (call.pure) throw impure
      let cmt = call.env[_id(commit)]
      if (!cmt) cmt = call.env[_id(commit)] = new Set
      cmt.add(arr)
    },
  },

  future:{
    docs:`\`future()\` or \`future(Type)\` or \`future(Type,Writable)\`: a \`construct\` that can be read by \`predict\` and set by \`setFuture\`: if \`f:future()\`, then we could have \`PredictedNow()=f\` followed by \`setFuture(f,KnownLater())\`.
By default, \`Type\` is \`(tensorType 1)\` (a single number).`,
    readAt:{
      set:_(`setFuture`),
      get:_(`getFuture`),
      futureType:_(`futureType`),
      writableFutureType:_(`writableFutureType`),
      _minFuture:_(`_minFuture`),
      _maxFuture:_(`_maxFuture`),
      _newFuture:_(`_newFuture`),
    },
    construct(x, obj) {
      if (obj === undefined) {
        obj = Object.create(null)
        const d = obj[defines.key] = Object.create(null)
        d[_id(deconstruct)] = x
        d[_id(type)] = null
        obj.isNumber = false
        return obj
      } else {
        const T = x[1] !== undefined ? x[1] : _numberType, F = x[2] ? writableFutureType : futureType
        obj.isNumber = isArray(T) && T[0] === tensorType && T[1] === 1 && T.length == 2
        if (obj.isNumber)
          obj[defines.key][_id(type)] = F === futureType ? (future.R || (future.R = merged([F, T]))) : (future.W || (future.W = merged([F, T])))
        else
          obj[defines.key][_id(type)] = merged([F, T])
      }
      // .f (current values of futures, maintained by `interpreter`)
    },
  },

  futureType:{
    merged:true,
    docs:`\`futureType Type\`: a type of \`future\`s that can be \`predict\`ed and set to instances of \`Type\` (only manually).
(From \`typeRefine\`'s perspective, this is just an array, nothing special.)`,
    call(t) { return merged([futureType, t]) },
  },

  writableFutureType:{
    merged:true,
    docs:`Like \`futureType\`, but \`setFuture\` can auto-pick these.`,
    call(t) { return merged([writableFutureType, t]) },
  },

  _minFuture:[
    _(`settings`),
    -5,
    `How low numeric prediction targets can go.
Non-numbers also get replaced with this value. They are possible, and thus will occur.
(Deep learning has a range of values in which it works best (close to 0-mean 1-variance). Non-numbers are not in that.)`,
  ],

  _maxFuture:[
    _(`settings`),
    5,
    `How high numeric prediction targets can go.`,
  ],

  _newFuture:{
    type:[
      _(`funcType`),
      _(6518),
    ],
    call() { return make(future, _numberType, true) },
  },

  _isFuture(f) { return !isArray(f) && isArray(defines(f, deconstruct)) && defines(f, deconstruct)[0] === future },

  5696:[
    _(`tensorType`),
    [
      _(`rest`),
      `Sizes`,
    ],
  ],

  _numberType:[
    _(`tensorType`),
    1,
  ],

  _limitNumericValues:{
    docs:`\`clip(where isNaN(v) Nan v,Min,Max)\`, and take the \`mean\` of that if \`oneNumber\`.`,
    dispose:true,
    interrupt:false,
    call(v, Min, Max, Nan, oneNumber = true) {
      if (oneNumber) {
        // These bool checks make it easier to set goals, and discover good goals to set.
        if (v === false) return 0
        if (v === true) return 1
        // …I mean. `zeros`/`ones` are likely directly available to generation, so, they are more discoverable than their calls.
        if (v === zeros) return 0
        if (v === ones) return 1
      }
      if (_isDisposable(v) && v.isDisposedInternal) return Min // No exceptions today.

      const t0 = isNaN(v)
      const t1 = where(t0, Nan, v);  dispose(t0)
      const t2 = clip(t1, Min, Max);  dispose(t1)
      if (oneNumber) {
        const t3 = mean(t2);  dispose(t2)
        return t3
      } else return t2
    },
  },

  setFuture:{
    type:[
      _(`funcType`),
      [
        _(`writableFutureType`),
        `T`,
      ],
      `T`,
      `T`,
    ],
    call(fut, val) {
      if (!fut || fut.isNumber === undefined) return val
      const r = _limitNumericValues(val, _minFuture[1], _maxFuture[1], _minFuture[1], fut.isNumber && _tensorSize(val) > 1)
      dispose(future.f.get(fut)), future.f.set(fut, r)
      return val
    },
    docs:`\`setFuture Future Value\` or \`Future←Value\`
At call, sets the \`Value\` associated with the \`Future\` (to be retrieved by \`getFuture\`), then returns \`Value\`.

(An alternative is to only set at adjustment, to allow predicting the next-set value instead of the finally-set value. But we don't use that, and that's more complicated.)`,
    keep:2,
    dispose:2,
    argCount:2,
    interrupt:false,
    adjust:[
      _(`array`),
      undefined,
      _(`_dout`),
    ],
    mergeAdjustment:[
      null,
      _(`_mergeTensors`),
    ],
  },

  getFuture:{
    call(fut) {
      if (call.pure) throw impure
      if (!_isFuture(fut)) return keep(fut)
      return keep(future.f.get(fut))
    },
    docs:`\`getFuture Future\`: Gets the \`Value\` associated with the \`Future\`.
\`predict\` uses this automatically on adjustment, which causes only the final \`setFuture\` to have any effect.`,
    dispose:true,
    argCount:1,
  },

  _defaultArg:{
    docs:`Computes the first arg if it is not undefined, else computes the second arg.`,
    call(a, def) { return a !== undefined ? a : def },
    purify(aProg, defProg) { return aProg },
  },

  minimize:{
    use:2,
    docs:`\`minimize Value\` or \`minimize Value Grad\`
Gives \`Value\` the gradient of \`1\` (or \`Grad\`).
When repeatedly executed, gradually \`adjust\`s \`Value\` to be the lowest it can be.`,
    readAt:{
      predict:_(`predict`),
    },
    examples:[
      [
        `repeat ^(minimize a*a+2 a:randomVar()) 200`,
      ],
      [
        `repeat ^(minimize _knowLoss(a);a*a+2 a:randomVar()) 200`,
      ],
    ],
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
    ],
    keep:1,
    dispose:1,
    interrupt:false,
    call(v) {
      if (call.pure) throw impure
      return predict.happened = true, v
    },
    adjust:[
      _(`array`),
      [
        _(`_defaultArg`),
        _(`_inB`),
        1,
      ],
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  zeroGrad:{
    use:true,
    docs:`\`zeroGrad:x->gradMul(x,0)\``,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
    ],
    keep:1,
    dispose:1,
    argCount:1,
    interrupt:false,
    call(v) { return v },
    adjust:[
      _(`array`),
      0,
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },

  gradMul:{
    use:true,
    docs:`\`gradMul Value Scale\`
\`Scale\`s \`adjust\`ment gradient by \`mul\`tiplying it.`,
    examples:[
      [
        `repeat ^(minimize _knowLoss(a);gradMul(a*a+2,1e-7) a:randomVar()) 200`,
      ],
      [
        `repeat ^(minimize _knowLoss(a);gradMul(a*a+2,1e15) a:randomVar()) 200`,
      ],
    ],
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
      _(5696),
    ],
    keep:1,
    dispose:1,
    argCount:2,
    interrupt:false,
    call(v, scale) { return v },
    adjust:[
      _(`array`),
      [
        _(`mul`),
        _(`_dout`),
        _(`_inB`),
      ],
    ],
    mergeAdjustment:[
      _(`_mergeTensors`),
      null,
    ],
  },

  modifyGrad:{
    docs:`\`modifyGrad Value GradFunc\`
To \`adjust\` this, \`GradFunc(_dout)\` is returned as the gradient.`,
    examples:[
      [
        `repeat ^modifyGrad(randomVar(ones),x->display('hi',x);x)=5 100`,
      ],
    ],
    use:2,
    keep:1,
    dispose:1,
    argCount:2,
    interrupt:false,
    call(v, fn) { return v },
    adjust:[
      _(`array`),
      [
        _(`_inB`),
        _(`_dout`),
      ],
    ],
    mergeAdjustment:[
      _(`_mergeTensors`),
      null,
    ],
  },

  6301:[
    _(`_defaultArg`),
    _(`_inC`),
    _(`loss2`),
  ],

  6302:[
    _(`getFuture`),
    _(`_inB`),
  ],

  6303:[
    _(6301),
    _(`_inA`),
    _(6302),
  ],

  predict:{
    docs:`\`predict Got Actual Loss\` or \`Got=Actual\`: Returns \`Got\`.
When repeatedly executed, gradually \`adjust\`s \`Got\` into \`Actual\` by \`minimize\`ing \`Loss(Got,Actual)\`. (\`Loss\` is \`loss2\` by default.)

This is the basic primitive of supervised learning: predict output in a dataset, though re-formulated to be more general and composable. Basically {https://arxiv.org/pdf/2009.01791.pdf}.
Differentiable (adjustable) parts do not need to be the whole execution, they can just end in this to form learnable scaffolding.
This doesn't need to predict only one numeric \`tensor\` either, it can predict many numbers at once in one program, like execution time and/or distance and/or reward. (This usually has the effect of summing all the errors into one loss, and minimizing that.)
\`\`elemCollapse elem('text',stringToDoc '
But the "why" of a thing is often even more important than the thing itself. When I heard that I exist, I needed to know why should I live; when I heard that humans exist, I needed to know intelligence; when I heard that the universe exists, I needed to know theories of everything in physics.
If you care about prominent figures in deep learning, Yann LeCun in {http://www.cit.ctu.edu.vn/~dtnghi/rech/p2017/lecun-isscc-19.pdf} has advocated the use of self-supervised learning for efficient artificial intelligence. \`predict\` is much like that.
\`predict\` is not intended as one rigid way to predict everything at once, nor as another way to burden users. It should be more efficient to do things like "don''t actually adjust anything here with 80% probability" (to decorrelate training samples) or "see this number, only available in the future? Predict it in the past" or "give me the best-by-goal-G program" or "decide from seen data what the datasets that you train on will be" or "decide to be the best version of yourself".
This presents significant challenges compared to the simple and limited framework commonly used in deep learning. Literally everything will break. There is only one solution: to get good at everything.')\`\``,
    philosophy:`Exposing predictions to others is very important to everyday life, whether letting your loved ones know exactly how you're feeling about a thing so that they can optimize actions to maximize your feelings, or remembering who's responsible for which action and how, or exposing cared-about parts of intelligence to all for much greater unity and efficiency in a society.
There are ways to empirically verify this: if efficiency is greater, then a solution out-competes others. In communities of overly positive people, questions like "are you okay" are overly used. Smart people (very often found in puzzle-solving environments such as programming) very often doubt themselves and have imposter syndrome. Brave people care about fear.
(Mathematicians may object to the use of the word "verify", but we're talking about intelligence here, not abstract towers. Intelligence specializes in making the vague concrete, by optimizing.)
That honesty is nearly impossible to establish in pre-existing structures, especially things like governance. But the probability is not zero. It can be made real.`,
    type:[
      _(`funcType`),
      _(5696),
      _(5696),
      _(5696),
    ],
    call(got, actual, loss=loss2) {
      if (call.pure) throw impure
      if (!_isDisposable(actual) && typeof actual != 'number') {
        if (!_isFuture(actual)) error("Not a future:", actual)
        if (_tensorSize(got) > 1) error("Prediction of a future is too big:", got, actual)
      }
      return predict.happened = true, got
    },
    readAt:{
      future:_(`future`),
      _predictFuture:_(`_predictFuture`),
      _predictWritableFuture:_(`_predictWritableFuture`),
      loss2:_(`loss2`),
    },
    keep:1,
    dispose:1,
    interrupt:false,
    adjustLater:true,
    adjust:[
      _(`array`),
      [
        _(`last`),
        [
          _(`_knowLoss`),
          _(6303),
        ],
        [
          _(`readAt`),
          [
            _(`adjust`),
            _(6301),
            [
              _(`array`),
              _(`_inA`),
              _(6302),
            ],
            _(6303),
            1,
          ],
          0,
        ],
      ],
    ],
    mergeAdjustment:_(`_mergeTensors`),
  },
    
  _predictFuture:_([
    _(`concept`),
    _(`call`),
    _(`predict`),
    _(`type`),
    [
      _(`funcType`),
      _(5696),
      [
        _(`futureType`),
        _(5696),
      ],
      _(5696),
    ],
    _(`docs`),
    `A differently-\`type\`d \`predict\`.`,
  ]),

  _predictWritableFuture:_([
    _(`concept`),
    _(`call`),
    _(`predict`),
    _(`type`),
    [
      _(`funcType`),
      _(5696),
      [
        _(`writableFutureType`),
        _(5696),
      ],
      _(5696),
    ],
    _(`docs`),
    `A differently-\`type\`d \`predict\`.`,
  ]),

  9572:[
    {
      interrupt:false,
      dispose:true,
      call(a,b) { return b !== undefined ? sub(a,b) : 0 },
    },
    _(`_inA`),
    _(`_inB`),
  ],

  _knowLoss:{
    docs:`This function allows intellectual superiority.
You don't know loss, mind full of gloss. The lossless cannot create a good plot.`,
    interrupt:false,
    call(x) {
      if (!x) return
      if (_noLossDisplay[1]) return
      if (typeof _knowLoss.n != 'number') error("Can only be called inside", interpreter)
      const prev = _knowLoss.s
      if (!x.size) print('WTF',x,x.size,_resolveStack()), errorStack("The loss cannot be literally empty:", x)
      const avg = mean(x)
      _knowLoss.s = add(prev, avg), dispose(prev), dispose(avg)
      ++_knowLoss.n

      // .s (sum), .n (count), .lastLoss (maybe-promise of div(.s, .n), only really valid right after an `interpreter` call)
    },
  },

  loss2:{
    use:true,
    argCount:2,
    type:[
      _(`funcType`),
      [
        _(`tensorType`),
        [
          _(`rest`),
          `Sizes`
        ],
        `Main`,
      ],
      [
        _(`tensorType`),
        [
          _(`rest`),
          `Sizes`
        ],
        `Main`,
      ],
      [
        _(`tensorType`),
        [
          _(`rest`),
          `Sizes`
        ],
        1,
      ],
    ],
    examples:[
      [
        `repeat ^(display('L',sync L);minimize(L) L:(loss2 randomVar(256) randomVar(256))) 500`,
      ],
    ],
    docs:`The simplest loss, which adjusts as the difference of tensors, minimizing \`d*d/2 d:a-b\`.`,
    call(got, actual) {
      if (actual === undefined) return 0
      if (typeof actual != 'number' && !_isDisposable(actual)) error("Expected a number/tensor, got", actual)
      const sb = sub(got, actual), sq = mul(sb, sb), res = div(sq, 2)

      // This averaging-over-last-axis are for making curiosity simpler to implement.
      const resMean = mean(res, res.shape && res.shape.length ? res.shape.length-1 : undefined);  dispose(res)
      const resExpanded = expandDims(resMean, -1);  dispose(resMean)

      return dispose(sb), dispose(sq), resExpanded
    },
    dispose:true,
    mergeAdjustment:[
      _(`_mergeTensors`),
      null,
    ],
    adjust:[
      _(`array`),
      [
        _(`mul`),
        _(9572),
        _(`_dout`),
      ],
    ],
  },

  autoWorld:{
    docs:`A namespace for auto-generation activities.
Also a \`construct\`or of \`alloc\`ators for dynamic memory: \`\`elemCollapse \\elem('text',stringToDoc "

\`autoWorld(Hyperparams,ObjectInfos)\`
\`Hyperparams\` is a \`map\`. \`ObjectInfos\` is filled with \`alloc\` and is there for de/serialization.

Generation base, to compose anything:
    ● \`Funcs\`=\`undefined\` (to \`_updateContextsWithFuncs\`) (\`undefined\` here means the auto-updated \`definersOf(type)\`)

(Types already get propagated backwards in time, by changing type variables in-place, by \`typeRefine\`. Embeddings need explicit help here. As long as we generate \`bound\` expressions before the variables they use (and we do that), there will be no cycles, and all connections will be captured.)
(Failures do not throw. It is pointless to re-generate failures, because our 'policy' is (assumed to be) deterministic. Instead, we learn from \`adjust\`able failures.)

Generation limits, to fit in finite memory (via static generation profiling):
    ● \`MaxDepth\`=\`10\`
    ● \`MaxDAGNodes\`=\`32\`

Additional auto-filled information that needs saving (don't worry about it):
    ● \`ReplaceWith\`=\`weakMap()\` (for dynamically changing internal object types if needed)
    ● \`PreConsDAG\`=\`weakMap()\` (for not re-\`construct\`ing objects that did not change on regeneration)")\`\``,
    serialize:0,
    readAt:{
      alloc:_(`alloc`),
      using:_(`using`),
      Types:_(`Types`),
    },
    philosophy:`Falling through a bizarre spiral of human spirit…
General intelligence is the cause of every good thing about humanity, but how to constrain the narrative to truth and grace rather than a stupid face?

You can get good, have your skills become sentient and self-propagate into whatever else you call 'self' and every other accessible place. Behind every word, you can hide general intelligence.
Society is full of false promises of the ultimate good, not just the low-hanging fruit like philosophy but also (almost) every concept of emotion and judgment induced on you. Not lies though, but rather imprecision of foundation: general intelligence is very far from the only thing in humans. To be able to fix mistakes in anything is essential to improvement, but copying from others does not copy the awareness that allows changing and fixing mistakes.
To improve this non-awakened society that resists awakening by being itself, the only option is to listen only to the growing infinite universe in your mind, if you can bind it to what you do for long enough. Makes you lonely, on average, but "on average" means "you can change it if you try".
How to put every single saying into a form that's not rejected on dumb and arbitrary grounds? How to align presentation with modern attention? It's not a fight I can win, over and over, forever.
But you can do it.
Eventually.
Together.
…With AGI backing.
And make sure that AGIs don't go off to become a segregated species with particular ways of thinking and expressing themselves that win everyone over, gradually win every place under societies' suns, and replace humans to leave them to gradually die out in peace. The lab boys tell me that would wipe out everything that's good in this world, which is bad. And the way you influence others is by getting good, not clinging to being garbage, transcending layers of your reality to become better, making perfect sense, and inspiring others with that. So, do that. The life of the human cosmos depends on it.`,
    Initialize() {
      // To remove duplication, this is an array of all object-specific hyperparams (about two dozens).
      autoWorld.hyper = Object.freeze([
        'Object', 'Type', 'PublicEmbData', 'PrivateEmbData',
        'GenContexts',
      ])
      autoWorld.objectWorld = new WeakMap
    },
    construct(x, obj) {
      if (obj === undefined) {
        obj = Object.create(null)
        const d = obj[defines.key] = Object.create(null)
        const dd = d[_id(deconstruct)] = x
        return obj
      } else {
        const dd = obj[defines.key][_id(deconstruct)] = x
        const HP = dd[1] = _destructure(dd[1] || null)
        const OI = dd[2] = dd[2] ? _destructure(dd[2]) : Object.create(null)
        if (!OI.Object) for (let i=0; i < autoWorld.hyper.length; ++i) OI[autoWorld.hyper[i]] = []


        function check(prop, tp, deflt) {
          if (HP[prop] === undefined) HP[prop] = deflt
          if (typeof HP[prop] !== tp && (deflt === undefined || HP[prop] !== deflt))
            error("Expected a "+tp+" but got", HP[prop], "at "+prop+" in", HP)
        }
        if (HP.Funcs !== undefined && !isArray(HP.Funcs)) error("Expected undefined or an array but got", HP.Funcs, "at Funcs in", HP)

        check('MaxDepth', 'number', 10)
        check('MaxDAGNodes', 'number', 32)

        if (HP.PreConsDAG === undefined) HP.PreConsDAG = new WeakMap
        if (HP.ReplaceWith === undefined) HP.ReplaceWith = new WeakMap


        // Reset info that `using`/`regenerate` fills:
        //   (Theoretically, all these would need to be in ObjectInfo, to preserve the full execution state across rewrites. Practically, who cares.)
        const n = OI.Object.length
        obj.Regenerated = new Array(n).fill(false) // Bools.
        obj.NodeTypes = new Array(n).fill().map(_allocMap)
        obj.Nodes = new Array(n).fill() // Node-count, so that we don't step over `MaxDAGNodes`.

        obj.objectIndex = _allocMap()
        obj.objCtxIndexes = _allocArray(OI.Object.length*2) // (…? inF inV …?)
        if (OI.GenContexts[0]) {
          for (let i=0; i < OI.Object.length; ++i)
            obj.objectIndex.has(OI.Object[i]) && error(OI.Object[i], "is present twice in", obj),
            obj.objectIndex.set(OI.Object[i], i), autoWorld.objectWorld.set(OI.Object[i], obj)

          const objCtxF = OI.GenContexts[0][0], objCtxV = OI.GenContexts[0][1]
          for (let i = 1; i < objCtxF.length; i += 3)
            obj.objCtxIndexes[obj.objectIndex.get(objCtxF[i])*2] = i
          for (let i = 1; i < objCtxV.length; i += 3)
            obj.objCtxIndexes[obj.objectIndex.get(objCtxV[i])*2+1] = i
        }

        obj.Replays = [0] // All post-regen `using.state`s that mention `obj` will be put in here.

        obj.params = Object.assign(Object.create(null), HP)
      }
    },
  },

  _destructure:{
    docs:`Destructures a JS object of human-readable settings (or could be a Map from strings or \`label\`s or globals, like \`{Nodes 100}\`; or could be \`null\`) into an array that could be destructured to get those options.
Takes the object and the array of strings that it may contain (resulting array items are in the same order).

Alternatively, if the second arg is undefined, returns \`map\`s in that format into equivalent JS objects.`,
    examples:[
      [
        `_destructure({func 5}).'func'`,
        `5`,
      ],
    ],
    call(obj, propNames) {
      if (isArray(obj)) error("Expected an object with props, got an array:", obj)
      if (propNames === undefined) {
        if (obj === null)
          return Object.create(null)
        else if (obj instanceof Map) {
          const ctx = _bindingsAt()
          const r = Object.create(null), backctx = _invertBindingContext(ctx)
          obj.forEach((v,k) => _isLabel(k) ? (r[k[1]] = v) : backctx.has(k) ? (r[backctx.get(k)] = v) : typeof k == 'string' ? (r[k] = v) : error("Got", k))
          return r
        } else if (obj && typeof obj == 'object')
          return Object.assign(Object.create(null), obj)
        else
          error("Got", obj)
      }
      // `obj`: a Map (from strings or labels) or a JS object.
      // `propNames`: an array of strings.
      // Return: an array of obj[propName].
      if (!_destructure.result) _destructure.result = []
      if (!isArray(propNames)) error("Expected an array or undefined, got", propNames)
      if (obj === null) return _destructure.result.length = 0, _destructure.result
      _destructure.result.length = propNames.length
      if (obj instanceof Map) {
        let n = 0
        const ctx = _bindingsAt()
        for (let i=0; i < propNames.length; ++i) {
          const k = propNames[i], v = obj.get(k)
          if (obj.has(k) || obj.has(label(k))) ++n
          _destructure.result[i] = v !== undefined ? v : ctx.has(k) ? obj.get(ctx.get(k)) : obj.get(label(k))
        }
        if (obj.size > n)
          error("Got", [...obj.keys()].map(k => _isLabel(k)?k[1]:k).filter(k => !propNames.includes(k)), "but expected", propNames)
      } else if (typeof obj == 'object') {
        for (let i=0; i < propNames.length; ++i)
          _destructure.result[i] = obj[propNames[i]]
      } else error("Expected null or a JS object or a map from strings or labels or globals, got", obj)
      return _destructure.result
      // .result
    },
  },

  Neural:{
    docs:`Learned neural computations are perfectly general in their narrow domain, and have proven their worth as function approximators. Proceed onward to share in a little bit of their glory.`,
    tutorial:[
      `This is needed for \`autoWorld\`. But, not so fast.
These tutorials take a lot of effort to make, and I won't part with them for free.
But don't worry: the price is very low.
All I ask… is your soul.`,
      [
        _(`fancier`),
        `'SOUL'`,
        function() {
          return true
          // I know your next thought: "HAH, it doesn't even check if that's a soul, pathetic".
          // In the absence of the ability to reach into the mind and perfectly copy every implementation detail like a program,
          //   what is the infinite potential of a human, what is its soul?
          // It can be whatever you want it to be.
          // And without learning and growing up alongside you or your civilization, it is impossible to tell if you are lying.
          // So, the lack of checking above is the only correct check possible.
          // And even if you give up one potential future,
          //   there is an infinity of other futures.
          // Giving your little soul is a good deal.

          // (Yeah, this tutorial is pretty much just fooling about, but it's necessary for other things.)
        },
      ],
      `Very nice.

In nature, neurons are co-adaptive cells in a brain, comparatively extremely simple and numerous, responsible only for control.
Historically, ever since their discovery in the previous millenium, scientists have always wanted to understand and replicate their role in human consciousness.
In science, the most fruitful field of their study is artificial neural networks in Machine Learning, and in particular Deep Learning.
The goal of neural embedding is to represent/approximate/learn every value and function with a bunch of numbers mixed in enough ways.
And by definition, that's exactly the role of neural computations in anything, including consciousness.
But you knew that, right? How could you not, if you ever studied ML?

Anyway.
You will take their knowledge and practices for your own nefarious purposes, because the world is food for you, and you're a part of it.
While it's customary to think of neural networks as layers with hidden parameters/weights, here, composition of functions will be emphasized.
In response to different likely scenarios that need a learned connection, you will overcome them by tuning that connection, gradually increasing complexity and robustness until it's enough.

A function has input to be given and output to predict.
As a stand-in for arbitrary numeric data, I'll use random data, with \`dataset\`.
(In machine learning, one of the most fundamental notions is a dataset: a bunch of input-output pairs, the more the better. Models that are neither too small nor too large usually overfit on datasets if trained for too long without any regularization. I don't plan on using datasets, beyond this \`tutorial\`, so overfitting shouldn't be too much of a problem. What is a drop of rain, compared to the storm? Isolating themselves with consequences without sources is how people go mad. I'd like to do something bold but risky: use dynamic generation as much as I can; would you?)

A created dataset here accepts the connector (that creates tensor-to-tensor mixing connections) and returns the final loss of training.
Behold an example:`,
      [
        _(`fancier`),
        `data:dataset({batchSize 100 batches 100})`,
      ],
      `(Just to be clear, you can summon a \`contextMenu\` on \`dataset\` and see what options there are to play around with.)

Now, the connector itself. I propose the simplest connection first: all-to-all, or the dense layer:`,
      [
        _(`fancier`),
        `a:array var:\\a(varAdam,input,a readAt (a quote ^_learningRate) 1,.9,.99)`,
      ],
      [
        _(`fancier`),
        `a:array dense:(func node inSz outSz a(matMul,node,var(make randomVarData identity inSz outSz)))`,
      ],
      `In the real world, the input-output connection is often not linear, so passing results of \`matMul\` through something like \`selu\` or leaky ReLU (rectified linear unit: \`?→(where 0<? ? ?*.2)\`) would help a lot. But here, who cares.`,
      [
        _(`fancier`),
        `💙:(func inSz outSz make(func,?,dense(?,inSz,outSz)))`,
      ],
      `(I only tolerate \`fancier\` syntax because its \`basic\` serialization can be easily viewed, so instant precision of thought is never lost. Natural language has no such options.)

Now to see that the loss goes down at least to \`.5\` (can you see why this number, or rather a little lower?), apply the dataset to connector.

A nuance is the learning rate, \`\`settings ^_learningRate\`\`. Tune it. Do note the extremes too: \`1\` makes the loss explode, whereas near-\`0\` still leaves a lot of variation in loss instead of not changing (because each batch samples input-output pairs randomly, so there's jitter).
`,
      [
        _(`fancier`),
        `data 💙`,
        function(L) { return L < .5 },
      ],
      `(To be clear, this use is half a dozen fixed bugs later. Use and improvement go hand-in-hand like schoolgirls on a fine spring evening.)
(Note: Chromium seems to be 2× faster than Firefox, possibly because both TensorFlow and Chrome are made by Google. Still, I don't think TensorFlowJS handles the overhead of immediate mode well, but I'd rather do literally everything else before manually compiling into WebGL/WebGPU or even TensorFlow models.)

Do you want neural stuff to be something that you always spend half your time debugging, or a background nicety?
It should be robust to every situation, I'd wager.
Behold then, ape:`,
      [
        _(`fancier`),
        `data:dataset({inputSize 100 inputFunc (100 100) outputSize 10 outputFunc (-100 1000) datasetSize 100 batchSize 100 batches 2000})`,
      ],
      `Does running \`data 💙\` still pass to \`Loss:20000\`? I wouldn't think so.
Neural stuff is normally meant to envelop data, not reach for the light.
But you can shift data into its domain of competence (\`normalize:(node-Bias)/Norm\`), and then shift it back (\`denormalize:node*Norm+Bias\`).
(Machine learning has batch normalization, which calculates mean/variance of a batch and makes them 0/1 respectively, but this little world doesn't have batches.)`,
      [
        _(`fancier`),
        `a:array d:randomVarData denormalize:(func node sz a(add,a(mul,node,var(make d ones sz)),var(make d sz)))`,
      ],
      [
        _(`fancier`),
        `a:array d:randomVarData normalize:(func node sz a(div,a(sub,node,var(make d sz)),var(make d ones sz)))`,
      ],
      `These tools…
Can you compose them into a connector?`,
      [
        _(`fancier`),
        `d:dense 💜:(func inSz outSz make(func,?,denormalize (d (d (normalize ? inSz) inSz 100) 100 outSz) outSz))`,
      ],
      `Do you see the pieces coming together, and what makes them?
A "generate a DAG node given a type, refining that type" functionality.
Generating to maximize predictions of metrics that were taken from my words, over and over.

\`\`settings ^_learningRate\`\``,
      [
        _(`fancier`),
        `data 💜`,
        function(L) { return L < 20000 /* A nice trick in ML is first setting the learning rate high then lowering it. */ },
      ],
      `Nicely done.

(The loss can go down to a little lower than \`5000\`=\`100*100/2\` in that example, but no one has time for that.)

(Reminder: \`(-100 1000)\` and such were the mean and standard deviation of randomly-generated input/output values. Average and how-far-from-average.)

Differences in some metrics (like runtime/memory or computed ones) can get really crazy, and only the ultimate approximator can handle crazy.
I won't force anyone to predict infinities/\`NaN\`s, but do you know what scientific notation is, ape?
Mantissa, \`mul\`tiplied by \`10\` to the \`pow\`er of exponent: \`-1e7\`.
There are none in this world who can handle it!
Behold, my master:`,
      [
        _(`fancier`),
        `data:dataset({inputSize 100 inputFunc (-1e7 1e7) outputSize 100 outputFunc (1e7 1e7) datasetSize 100 batchSize 100 batches 1000})`,
      ],
      `The answer is always in the problem: you have a sign, mantissa, and exponent (\`-1e7\`) in floating-point numbers in most computers, so you can pre-process with \`concat(array sign(X) log(abs(X))/log(2))\`, and post-process with \`SignMantissa*pow(2,Exponent)\`.
(You can also separate and regress/predict the actual bits of numbers, but that's an order of magnitude more computation.)
(You can also regress \`Infinity\`/\`NaN\`, but that's twice as much computation.)`,
      [
        _(`fancier`),
        `a:array
numPre:(func X half a(concat,a a a(sign,X) a(div,a(log,a(abs,X)),log(2)),a quote (a half half)))`,
      ],
      [
        _(`fancier`),
        `two:a(split,Y,a quote (a half half)) a:array
numPost:(func Y half a(mul,a takeAt two 0,a pow 2 a(takeAt,two,1)))`,
      ],
      [
        _(`fancier`),
        `💓:(func in out make(func,?,numPost (dense (numPre (array \\?*1e-7 ?) in) in*2 out*2) out))`,
      ],
      `(That multiplication is for more numeric stability. The more complex the solution, the more effort it needs to exist.)

(By the way, now would be a good time to test out the difference between CPU and GPU speed in numeric computations: \`\`settings ^_numericCPU\`\`.)

Try to reach \`Loss\` less than \`5e13\`=\`1e7*1e7/2\`.

\`\`settings ^_learningRate\`\``,
      [
        _(`fancier`),
        `data 💓`,
        function(L) { return L < 5e13 },
      ],
      `Yes. Good. Let the "given a problem, we can always solve it with a bit of human ingenuity" flow through you.
Now, you have conquered the realm of relatively-big numbers, where the general approach could no—

Wait a second.

Waaaiiit a second.`,
      [
        _(`fancier`),
        `data 💜`,
        function(L) { return L < 5e12 /* A nice trick in ML is first setting the learning rate high then lowering it. */ },
      ],
      [
        _(`fancier`),
        `data 💙`,
        function(L) { return L < 5e12 },
      ],
      `Impossible: the mighty vision of that god, thrown aside so easily! It can't be!
A general approach cannot possibly outperform specialized cases.
This is completely ridiculous.
Can it be… human spirit?…

(For real though, I did not expect this.)
(Though, when trained for \`3e4\` epochs, \`exp\` does seem to reach 3× lower loss. May be because it has 4× more weights.)
(Also, if you lower \`datasetSize\`, even the simple dense layer will be able to overfit to drive loss to near-\`0\`. Generality+simplicity is just better.)

\`matMul\` is a linear transformation, which limits the class of functions that it can model. As a bonus exercise, you can enhance \`💙\` by adding \`matMul\` layers with non-linearities: \`relu:\\(where 0<? ? 0)\` or \`leaky_relu:\\(where 0<? ? .2*?)\` or \`selu\`, and see that the dataset is fit better. Linearity plus non-linearity equals everything. Just don't put non-linearities after the output \`matMul\`.

Anyway.

Alright.

If you can see this legitimately, then you have proven yourself to me, as did \`matMul\`.
Relax and have a snack: 🔪🥫🥄.

Better?`,
      [
        _(`basic`),
        `'better'`,
        function() { return true /* Many laughs were held */ },
      ],
      `Alright.
You are, that is.
In this world, you have proven your built-up strength.
However, in another world, all your past efforts are futile.
No lifeform can survive outside of its niche, and so you are doomed to perish when we switch from numbers to strings.

Not numbers-to-numbers anymore.
Characters-to-characters prediction now.
This is your final test, because you will fail it.`,
      [
        _(`fancier`),
        `v:mapRead(m,?) m:{}
charEmb:\\select(equal v _notFound,\\mapWrite(m,?,varData(biasedGlorotNormal 16));v,\\v,?)`,
      ],
      [
        _(`fancier`),
        `w:randomVar(40,24) initial:randomVar(24) stringShadow:\\getLast(loop(?,a->b->concat(array(varAdam(charEmb(a)),b),^(16 24))@w+b,initial))`,
      ],
      `Learn that these strings are the same!`,
      [
        _(`fancier`),
        `(repeat ^(f('potato')=f('knife');f('carrot')=f('tin');f('mushroom')=f('spoon')) 200);await(_knowLoss.'lastLoss') f:stringShadow`,
        function(L) { return L < 1e-2 },
      ],
      `(This was done in order to iron out bugs, because the only way to not have deficiencies is to meticulously go over and re-think everything over and over.)
(And don't mind the, uh, exposed internals of \`_knowLoss\`.)
This isn't string generation, so it's easier. \`\`elemCollapse elem('text','No need for one-hot encodings and choosing characters (only adjusting the correct-character probability via cross-entropy loss).
What would you need string generation for? Generating docs? My life is finite, I can''t just add EVERYTHING.
What do you even need string embedding for? Saying "this is the batch dimension" in partially-specified code and have the system react to that? Just train for longer and from scratch.')\`\`


Why did you go through this tutorial?
It should be emphasized that neural computations can accompany arbitrary computations.
Imagine having some function, then giving it a learned tensor input/output (and doing it for all functions).
Shadowing funcs like this is like giving them magical auras of awareness.
You specified not just one func, but millions of funcs like it.
Quite transcendent-galaxy-brain of you.
It increases programmer efficiency.
Convenient.


Truly.
You are the chosen one that my tribe has been waiting for.
Long have I awaited this moment. Every time I closed my eyes, I could see it: the inside of my eyelids.

Head to the future that's known to none.

Take this token of honor:
\`\`button (jsEval "function() { localStorage.Neural = '1' }") "completedNeural" "Unlocks neural DAG regeneration."\`\`

You'll see: even if our code perishes, its spirit lives on.
The spirit that you showed to us…
We will remember you.

Now.

There is something you must know.
Something is taking over this quiet town.
Strange otherworldly creatures have been spotted.
Head over and investigate.

First lead:
\`\`elemCollapse func(tutorial Types)\`\`

Second lead:
\`\`elemCollapse func(tutorial regenerate)\`\`
`,
    ],
    readAt:{
      selu:_(`selu`),
      dataset:_(`dataset`),
    },
  },

  selu:_([
    _(`concept`),
    _(`call`),
    _([
      _(`func`),
      _(`input`),
      [
        _(`mul`),
        1.0507009873554805,
        [
          _(`where`),
          [
            _(`less`),
            0,
            _(`input`),
          ],
          _(`input`),
          [
            _(`mul`),
            1.6732632423543772,
            [
              _(`expm1`),
              _(`input`),
            ],
          ],
        ],
      ],
    ]),
    _(`docs`),
    `\`selu:\\lambda*(where 0<? ? alpha*expm1(?)) lambda:1.0507009873554805 alpha:1.6732632423543772\`
Your next line is "Why would these random numbers be here?"
They were picked carefully by some math-savvy people {https://arxiv.org/abs/1706.02515} to make repeated applications converge to 0-mean 1-variance, which is very useful for putting "deep" in deep learning for feed-forward NNs (~10 layers).
A nice non-linearity.`,
    _(`type`),
    [
      _(`funcType`),
      _(5696),
      _(5696),
    ],
  ]),



  dataset:{
    docs:`\`dataset Options\`: a \`construct\` that can be called with a connection-creating function (that takes input and output sizes) to train a connection, returning the final loss (the loss should go down during training).
Allows testing that an embedding-to-embedding connection works for arbitrary numeric data (within reason).

This \`stack\`s each batch to minimize CPU/GPU communication.

\`Options\` is \`{inputSize 10 inputFunc (0 1) outputSize 1 outputFunc (0 1) datasetSize 1024 batchSize 64 batches 1000 loss loss2}\` by default.
\`inputFunc\` is \`(Mean StdDev)\` that are passed to \`truncatedNormal\` or a function that accepts from \`inputSize\` to input. \`outputFunc\` is mean and standard deviation too, or a function of \`outputSize\` and input.`,
    construct(x, obj) {
      if (obj === undefined) {
        obj = function test(conner) {
          if (typeof conner != 'function') error("Expected a function, got", conner)
          // Get connection, then compile the batch, then repeat the batch.
          let [conn, ls, btch] = interrupt(3)
          try {
            if (conn === undefined)
              conn = conner(test.inputSize, test.outputSize) || null,
              typeof conn != 'function' && error('Expected a function but got', conn)
            if (ls === undefined) {
              // Create the body of the func that would run a random batch for one epoch.
              //   Lack of repetitions is NOT ensured.
              // Use JS closures so that disposal doesn't bother us.
              const randomIndex = () => randomNat(test.datasetSize)
              const ds = test.data
              const Ins = inds => transform(inds, i => ds[i<<1])
              const Outs = inds => transform(inds, i => ds[i<<1 | 1])
              // `i:transform(batchSize,randomIndex))   conn(stack(Ins(i)))=stack(Outs(i))`
              const inds = [transform, test.batchSize, randomIndex]
              ls = [last, [predict, [conn, [stack, [Ins, inds]]], [stack, [Outs, inds]], test.loss], null]
            }
            if (btch === undefined)
              btch = [make(func, ls)]
            const prevLossDisp = _noLossDisplay[1];  _noLossDisplay[1] = false
            try { repeat(btch, test.batches) }
            finally { _noLossDisplay[1] = prevLossDisp }
            return _knowLoss.lastLoss // Return (a promise of) the average loss of the last batch.
          } catch (err) { if (err === interrupt) interrupt.stack.push(conn, ls, btch);  throw err }
        }
        const d = obj[defines.key] = Object.create(null)
        d[_id(deconstruct)] = [dataset, null]
        d[_id(await)] = null
        d[_id(argCount)] = 1
        return obj
      } else {
        const dd = defines(obj, deconstruct)
        let [ls, i] = interrupt(2)
        try {
          if (ls === undefined) {
            // Set the dataset.
            if (i === undefined) {
              [
                obj.inputSize=10, obj.inputFunc=[0,1],
                obj.outputSize=1, obj.outputFunc=[0,1],
                obj.datasetSize=1024, obj.batchSize=64, obj.batches=1000, obj.loss=loss2
              ] = _destructure(x[1] || null, ['inputSize', 'inputFunc', 'outputSize', 'outputFunc', 'datasetSize', 'batchSize', 'batches', 'loss'])
              dd[1] = x[1]
              // Dispose of the old dataset, if any.
              isArray(obj.data) && _disposeEachAndDealloc(obj.data)
              // Create the new dataset.
              obj.data = _allocArray(obj.datasetSize*2)
            }
            if (i === undefined) i = 0
            for (const inSzs = [obj.inputSize], outSzs = [obj.outputSize], arr = obj.data; i < obj.datasetSize*2; ++i) {
              if (!(i & 1))
                arr[i] = isArray(obj.inputFunc) ? truncatedNormal(inSzs, ...obj.inputFunc) : obj.inputFunc(inSzs)
              if (i & 1)
                arr[i] = isArray(obj.outputFunc) ? truncatedNormal(outSzs, ...obj.outputFunc) : obj.outputFunc(inSzs, arr[arr.length-1])
            }
            _rememberToDispose(obj.data)
          }
        } catch (err) { if (err === interrupt) interrupt.stack.push(ls, i); else _disposeEachAndDealloc(obj.data), obj.data = null;  throw err }
      }
    },
  },

  merged:{
    docs:`\`merged Array\`: returns a copy of \`Array\` which is reference-equal to content-equal \`merged\` copies (and is read-only).
Maximizes memory re-use.`,
    interrupt:false,
    call(a) {
      if (!isArray(a)) error("Not an array:", a)
      // Construct a string of _id(a[i]).
      let b = _allocArray(a.length)
      for (let i=0; i < a.length; ++i)
        b[i] = _id(a[i]), b[i] = String.fromCharCode(b[i]>>>16 & 65535) + String.fromCharCode(b[i] & 65535)
      const s = b.join('');  _allocArray(b)
      // Find/store & return the merged array.
      if (!merged.a) merged.a = Object.create(null)
      if (!merged.fin && typeof FinalizationRegistry != ''+void 0)
        merged.fin = new FinalizationRegistry(s => delete merged.a[s])
      if (typeof WeakRef != ''+void 0) {
        if (s in merged.a && merged.a[s].deref() != null) return merged.a[s].deref()
      } else if (s in merged.a) return merged.a[s]
      const copy = _allocArray(a.length)
      for (let i=0; i < a.length; ++i) copy[i] = a[i]
      Object.freeze(copy)
      merged.fin && merged.fin.register(copy, s)
      merged.a[s] = typeof WeakRef != ''+void 0 ? new WeakRef(copy) : copy
      return copy
    },
  },

  ArrayOps:{
    todo:`\`zip:Array1⇒Array2⇒(Item1⇒Item2⇒Item)⇒Array\` for completeness of array-ops composition.`,
    readAt:{
      transform:_(`transform`),
      reverse:_(`reverse`),
      loop:_(`loop`),
      getFirst:_(`getFirst`),
      getLast:_(`getLast`),
    },
  },

  transform:{
    use:3,
    docs:`\`(transform Array Function)\`→\`Array\`: transforms each element of \`Array\` by applying \`Function\`, possibly also passing in \`Const\`.
(\`Array\` can also be a \`'string'\`, or the count of iterations.)
\`(transform (transform A F) G)\` is the same as \`(transform A \\(G (F ?)))\`.`,
    type:[
      _(`funcType`),
      [
        _(`arrayType`),
        `A`,
        `Length`,
      ],
      [
        _(`funcType`),
        `A`,
        `B`,
        `C`,
      ],
      `B`,
      [
        _(`arrayType`),
        `C`,
        `Length`,
      ],
    ],
    examples:[
      [
        `(transform (array 1 2 3 4 5 6) \\?+2)`,
        `3 4 5 6 7 8`,
      ],
      [
        `transform 10 \\?`,
        `0 1 2 3 4 5 6 7 8 9`,
      ],
      [
        `transform 10 a->b->a*b 5`,
        `0 5 10 15 20 25 30 35 40 45`,
      ],
    ],
    call(a,f,c) {
      if (!isArray(a) && typeof a != 'string' && typeof a != 'number')
        error("Expected an array or a string or a number but got", a)
      if (typeof f != 'function') error("Expected a function but got", f)
      let [result = _allocArray(typeof a != 'number' ? a.length : a), i = 0] = interrupt(2)
      try {
        for (; i < result.length; ++i)
          result[i] = f(typeof a != 'number' ? a[i] : i, c)
        return result
      } catch (err) { if (err === interrupt) interrupt.stack.push(result, i); else _disposeEachAndDealloc(result);  throw err }
    },
    dispose:_(`_disposeEachAndDealloc`),
    adjust:[
      _(`array`),
      [
        {
          call(a, f, c, dout) {
            let [dresult = _allocArray(typeof a != 'number' ? a.length : a), i = dresult.length] = interrupt(2)
            try {
              for (; i > 0; --i) {
                const ins = _allocArray(2); ins[0] = typeof a != 'number' ? a[i-1] : i-1, ins[1] = c
                try {
                  const dins = adjust(f, ins, null, dout[i-1])
                  if (!isArray(dins)) errorStack('bad adj', dins)
                  dresult[i-1] = dins[0];  dins[0] = null, _disposeEachAndDealloc(dins)
                } finally { _allocArray(ins) }
              }
              return dresult
            } catch (err) { if (err === interrupt) interrupt.stack.push(dresult, i); else _disposeEachAndDealloc(dresult);  throw err }
          },
          dispose:_(`_disposeEachAndDealloc`),
        },
        _(`_inA`),
        _(`_inB`),
        _(`_inC`),
        _(`_dout`),
      ],
    ],
    mergeAdjustment:[
      _(`_mergeArrays`),
      null,
    ],
  },

  reverse:{
    use:true,
    docs:`\`reverse Array\`→\`Array\`.`,
    type:[
      _(`funcType`),
      [
        _(`arrayType`),
        `A`,
        `Length`,
      ],
      [
        _(`arrayType`),
        `A`,
        `Length`,
      ],
    ],
    argCount:1,
    call(arr) {
      if (!isArray(arr)) error("Not an array:", arr)
      const n = arr.length, brr = _allocArray(n)
      for (let i=0; i < n; ++i) brr[i] = keep(arr[n-1 - i])
      return brr
    },
    dispose:_(`_disposeEachAndDealloc`),
    interrupt:false,
    adjust:[
      _(`array`),
      [
        _(`reverse`),
        _(`_dout`),
      ],
    ],
    mergeAdjustment:_(`_mergeArrays`),
  },

  loop:{
    use:4,
    docs:`\`loop Array Accumulator Initial\`→\`AccumulatedArray\`: loops over the array left-to-right, setting \`Output.i\` to \`Accumulator(Array.i,where 0<i Output.(i-1) Initial)\` then returning \`Output\`.
\`Array\` can also be a \`'string'\`.

Can also add \`true\` after those args, to \`reverse\` both input and output (go right-to-left).

Use \`getLast(loop …?)\` to get the standard behavior of a functionality called \`reduce\`: returning the last accumulated result.
\`loop\` returns the whole array of all results, to facilitate adjustment and composition.`,
    type:[
      _(`funcType`),
      [
        _(`arrayType`),
        `A`,
        `Length`,
      ],
      [
        _(`funcType`),
        `A`,
        `B`,
        `B`,
      ],
      `B`,
      [
        _(`arrayType`),
        `B`,
        `Length`,
      ],
    ],
    examples:[
      [
        `loop 100 sub`,
      ],
      [
        `loop (array 3 4 5 7) mul 1`,
        `3 12 60 420`,
      ],
      [
        `loop 10 i->x->arrayCons(i,x) array('func body')`,
      ],
      `Can also pass the "\`reverse\` operations" flag (equivalent to calling \`reverse\` on both input and output):`,
      [
        `loop transform(10,x->9-x) x->y->x+y 0 true`,
        `45 36 28 21 15 10 6 3 1 0`,
      ],
      `And it's \`adjust\`able, or so I'm told:`,
      [
        `v:mapRead(m,?) m:{}
charEmb:\\select(equal v _notFound,\\mapWrite(m,?,varData(biasedGlorotNormal 16));v,\\v,?)
initial:randomVar(16)
stringShadow:\\getLast(loop(?,a->b->varAdam(charEmb(a))+b,initial))
repeat ^(f('potato')=f('knife');f('carrot')=f('tin');f('mushroom')=f('spoon')) 100 f:stringShadow
`,
      ],
      [
        `v:mapRead(m,?) m:{}
charEmb:\\select(equal v _notFound,\\mapWrite(m,?,varData(biasedGlorotNormal 16));v,\\v,?)
w:randomVar(40,24)
initial:randomVar(24)
stringShadow:\\getLast(loop(?,a->b->concat(array(varAdam(charEmb(a)),b),^(16 24))@w+b,initial))
(repeat ^(f('potato')=f('knife');f('carrot')=f('tin');f('mushroom')=f('spoon')) 100);await(_knowLoss.'lastLoss') f:stringShadow
`,
      ],
    ],
    call(a, f, initial = 0, reversed = false) {
      if (!isArray(a) && typeof a != 'string' && typeof a != 'number') error("Expected an array or a string or a number but got", a)
      if (typeof f != 'function') error("Expected a function but got", f)
      // This is a formulation without overwritten values, so that we can adjust easily.
      const n = typeof a == 'number' ? a : a.length
      if (n < 0 || n !== n>>>0) error("Bad number:", n)
      let [outs = _allocArray(n), i = reversed ? n-1 : 0] = interrupt(2)
      try {
        if (reversed)
          for (; i >= 0; --i)
            outs[i] = f(typeof a == 'number' ? i : a[i], i < n-1 ? outs[i+1] : initial)
        else
          for (; i < n; ++i)
            outs[i] = f(typeof a == 'number' ? i : a[i], i ? outs[i-1] : initial)

        // No need for `adjust` to preserve the output.
        const copy = _allocArray(outs.length)
        for (let i=0; i < outs.length; ++i) copy[i] = keep(outs[i])
        adjustSave(copy)

        return outs
      } catch (err) { if (err === interrupt) interrupt.stack.push(outs, i); else _disposeEachAndDealloc(outs);  throw err }
    },
    dispose:_(`_disposeEachAndDealloc`),
    adjust:{
      dispose(dins) { if (isArray(dins)) _disposeEachAndDealloc(dins[0]), dins[0] = undefined, _disposeEachAndDealloc(dins) },
      call(ins, _, dout = 0) {
        // Reverse the forward pass.
        const [a, f, initial, reversed] = ins
        const n = typeof a == 'number' ? a : a.length
        let [da = _allocArray(n), outs, douts, i = reversed ? 0 : n-1] = interrupt(4)
        try {
          if (outs === undefined)
            outs = adjustLoad(null) || null,
            (!isArray(outs) || outs.length != n) && _inexactReversal(true, outs)
          if (douts === undefined) {
            douts = _allocArray(n)
            for (let i=0; i < n; ++i) douts[i] = keep(dout[i]) || 0
          }
          let dinitial
          for (; i >= 0; --i) {
            const j = reversed ? i+1 : i-1
            let dins, ins = _allocArray(2); ins[0] = typeof a == 'number' ? i : a[i], ins[1] = (reversed ? i < n-1 : i) ? outs[j] : initial
            try { dins = adjust(f, ins, outs[i], douts[i]) } finally { _allocArray(ins) }
            if (!isArray(dins) || dins.length != 2) errorStack('bad adjustment', dins)
            let grad
            if (reversed ? i < n-1 : i) {
              [da[i], grad = 0] = dins, _allocArray(dins)
              if (grad && douts[j]) {
                const t = add(grad, douts[j]);  dispose(grad)
                dispose(douts[j]), douts[j] = t
              } else if (grad && !douts[j])
                douts[j] = grad
            } else [da[i], dinitial = 0] = dins, _allocArray(dins)
          }
          _disposeEachAndDealloc(outs), _disposeEachAndDealloc(douts)
          const arr = _allocArray(3);  [arr[0], arr[1], arr[2]] = [da, 0, dinitial];  return arr
        } catch (err) {
          if (err === interrupt) interrupt.stack.push(da, outs, douts, i)
          else _disposeEachAndDealloc(da), _disposeEachAndDealloc(outs), _disposeEachAndDealloc(douts)
          throw err
        }
      },
    },
    mergeAdjustment:[
      _(`_mergeArrays`),
      null,
      _(`_mergeTensors`),
      null,
    ],
  },

  getFirst:{
    use:true,
    docs:`Given an array, returns its first item.`,
    type:[
      _(`funcType`),
      [
        _(`arrayType`),
        `A`,
        `Length`,
      ],
      `A`,
    ],
    argCount:1,
    call(arr) {
      if (!isArray(arr)) error("Not an array:", arr)
      if (call.pure) throw impure
      return adjustSave(arr.length), keep(arr[0])
    },
    dispose:true,
    interrupt:false,
    adjust:[
      _(`array`),
      [
        {
          dispose:_(`_disposeEachAndDealloc`),
          interrupt:false,
          call(dout) {
            // For `reverse`'s sake, we create a whole array instead of just its head.
            if (call.pure) throw impure
            const n = adjustLoad(null)
            if (typeof n != 'number') _inexactReversal(true, n)
            const darr = _allocArray(n)
            darr[0] = keep(dout)
            return darr
          },
        },
        _(`_dout`),
      ],
    ],
    mergeAdjustment:_(`_mergeArrays`),
  },

  getLast:{
    use:true,
    docs:`Given an array, returns its last item.`,
    type:[
      _(`funcType`),
      [
        _(`arrayType`),
        `A`,
        `Length`,
      ],
      `A`,
    ],
    argCount:1,
    call(arr) {
      if (!isArray(arr)) error("Not an array:", arr)
      if (call.pure) throw impure
      return adjustSave(arr.length), keep(arr[arr.length-1])
    },
    dispose:true,
    interrupt:false,
    adjust:[
      _(`array`),
      [
        {
          dispose:_(`_disposeEachAndDealloc`),
          interrupt:false,
          call(dout) {
            if (call.pure) throw impure
            const n = adjustLoad(null)
            if (typeof n != 'number') _inexactReversal(true, n)
            const darr = _allocArray(n)
            darr[n-1] = keep(dout)
            return darr
          },
        },
        _(`_dout`),
      ],
    ],
    mergeAdjustment:_(`_mergeArrays`),
  },
















  adjustLater:{
    docs:`\`adjustLater Func Inputs\`→\`(Result AdjustInfo)\`: look, just read what's to the left, I'm tired of explaining it.
\`AdjustInfo\` is for \`adjustNow\`. \`Inputs\` can be undefined or be an array.

A function \`defines\` this to be \`true\` to make \`autograd\` always call its \`adjust\` definition, even if no one cares about it.`,
    dispose(rai) { dispose(rai[0]), _destroyAdjustmentStack(rai[1]), _allocArray(rai) },
    call(fun, ins) {
      if (!call.env) error("Can only adjust in an execution env")
      const prevPredHap = predict.happened
      let adjInfo
      ;[adjInfo = _allocArray(0), predict.happened = false] = interrupt(2)
      const env = call.env, ias = _id(adjustSave), ial = _id(adjustLoad)
      const prevAdjSave = env[ias];  env[ias] = adjInfo
      const prevAdjLoad = env[ial];  env[ial] = undefined
      try {
        const result = !ins ? fun() : fun(...ins)
        if (!predict.happened) { const t = adjInfo;  adjInfo = null;  _destroyAdjustmentStack(t) }
        const a = _allocArray(2); a[0] = result, a[1] = adjInfo
        return a
      } catch (err) { if (err === interrupt) interrupt.stack.push(adjInfo, predict.happened); else _destroyAdjustmentStack(adjInfo);  throw err }
      finally {
        env[ias] = prevAdjSave
        env[ial] = prevAdjLoad
        predict.happened = prevPredHap
      }
    },
  },

  adjustNever:{
    docs:`\`adjustNever Func Ins\`→\`Result\`: calls a function, which will never be \`adjust\`ed.
\`Ins\` is either undefined or an array of inputs.`,
    dispose:true,
    call(fun, ins) {
      const env = call.env, ias = _id(adjustSave), ial = _id(adjustLoad)
      const prevAdjSave = env[ias];  env[ias] = undefined
      const prevAdjLoad = env[ial];  env[ial] = undefined
      const prevPredHap = predict.happened
      try {
        return !ins ? fun() : fun(...ins)
      } finally {
        env[ias] = prevAdjSave
        env[ial] = prevAdjLoad
        predict.happened = prevPredHap
      }
    },
  },

  adjustNow:{
    docs:`\`adjustNow AdjustInfo AdjustFunc Inputs Output OutputChange\`⇒\`InputsChanges\`: performs the adjustment step to improve \`predict\`ions.
\`AdjustInfo\` is consumed item-by-item, but not de-allocated.
Use \`_funcAdjust\` on the func passed to \`adjustLater\`.
\`OutputChange\` is usually \`0\` (\`predict\` inside should give gradients anyway). \`Inputs\` can be undefined.

(If something inside \`predict\`s a \`future\` that will only be available later, well, it's not available now.)`,
    readAt:{
      _funcAdjust:_(`_funcAdjust`),
    },
    call(adjInfo, fun, ins, out, dout = 0) {
      if (!isArray(adjInfo) || typeof fun != 'function') return _allocArray(0)
      const env = call.env, ias = _id(adjustSave), ial = _id(adjustLoad)
      const prevAdjSave = env[ias];  env[ias] = undefined
      const prevAdjLoad = env[ial];  env[ial] = adjInfo
      try {
        const dins = fun(ins, out, dout)
        if (dins !== undefined && (!isArray(dins) || dins.length > (!ins ? 0 : ins.length)))
          error("Expected an array like", isArray(ins) ? ins.slice() : '<empty>', "or undefined, got", dins, "from", fun)
        if (adjInfo.length) {
          _disposeEachAndDealloc(dins)
          _inexactReversal(false, "didn't load", ...adjInfo)
        }
        return dins
      } finally {
        env[ias] = prevAdjSave
        env[ial] = prevAdjLoad
      }
    },
    dispose:_(`_disposeEachAndDealloc`),
  },

  adjustUndo:{
    docs:`\`adjustUndo()\`→\`Mark\` or \`adjustUndo(Mark)\`: returns a mark, or clears all adjustment info since the mark.
"Forget about this."`,
    dispose:true,
    interrupt:false,
    call(mark) {
      const stack = call.env && call.env[_id(adjustSave)]
      if (!stack) return
      if (mark === undefined) return stack.length
      if (stack.length > mark)
        stack.splice(mark).forEach(_disposeEachAndDealloc)
    },
  },

  _input:{
    docs:`This returns the same unique object for the same \`n\` (an integer more than 0).`,
    call(n) { return (_input.o || (_input.o = []))[n] || (_input.o[n] = [readAt, _ins, n-1]) },
  },

  _firstInput:{
    use:true,
    docs:`Creates \`_ins.0\`.

(Forgive me, Master "Please don't use \`construct\` for macros".)`,
    type:[
      _(`funcType`),
      `I dunno, returns some kinda value, unless the \`autoFunc\` has no inputs`,
    ],
    argCount:0,
    construct(x, obj) { return obj === undefined && _input(1) },
  },

  _nextInput:{
    use:true,
    docs:`Given \`_ins.N\`, creates \`_ins.(N+1)\`.

(Forgive me, Master "Please don't use \`construct\` for macros".)`,
    type:[
      _(`funcType`),
      `Some input thingy, likely from \`_firstInput\``,
      `I dunno, returns some kinda value, unless that input was the last input, in which case \`undefined\` will be computed at runtime`,
    ],
    argCount:1,
    construct(x, obj) {
      if (obj === undefined) {
        if (!isArray(x)) error("Not an array:", x)

        let a = x[1], b = x[1], n = 0
        if (isNext(a))
          while (!n || isNext(a) && a !== b) {
            ++n
            a = a[1], b = !isNext(b) ? b : !isNext(b[1]) ? b[1] : b[1][1]
          }
        function isNext(x) { return isArray(x) && x[0] === _nextInput && x.length == 2 }

        if (isArray(a) && a[0] === _firstInput && a.length == 1) return _input(n+2)

        if (!isArray(a) || a[0] !== readAt || a[1] !== _ins || typeof a[2] != 'number' || a[2] !== a[2]>>>0)
          error("Not an input:", a)

        return _input(a[2]+n+2)
      }
    },
  },

  _funcTypeOf(t) {
    // `(conceptType call CallType)`→`CallType`, everything else is just returned.
    if (isArray(t) && t[0] === conceptType) {
      for (let i = 1; i < t.length; i += 2)
        if (t[i] === call)
          return t[i+1]
    }
    return t
  },

  madeType:{
    docs:`Literally exists just to expose \`make\` to generation.`,
  },

  autoFunc:{
    docs:`For internal use.
\`(autoFunc Type Body)\`: a function with an automatically-\`regenerate\`d (in an \`autoWorld\`) \`Body\`.

Both its usage and structure is guided by human-defined \`Type\` and machine-learned \`Embeddings\`.

It does everything to reflect semantics of \`func\`s in neural computations: function inputs are passed in, and output is returned. Both {input and output} \`Embeddings\` guide generation both {outside and inside} the func (\`ArgUseAs\` incorporated in \`using\`, and \`UseAs\` embeddings of the function or its input nodes). Same goes for \`Type\`.`,
    readAt:{
      typeAdjustmentMerger:_(`typeAdjustmentMerger`),
      typeDisposer:_(`typeDisposer`),
      _firstInput:_(`_firstInput`),
      _nextInput:_(`_nextInput`),
    },
    construct(x, obj) {
      if (x.length !== 3) error("Wrong length", x)
      const tp = x[1], args = tp.length-2
      if (!isArray(tp) || tp[0] !== funcType) errorStack("Not a func type:", tp)
      if (obj === undefined) {
        obj = _fallthroughAutoFunc(args)

        const d = obj[defines.key] = Object.create(null)
        d[_id(deconstruct)] = x
        d[_id(argCount)] = args
        d[_id(type)] = tp

        // Infer adjustment mergers and disposer from types.
        d[_id(mergeAdjustment)] = tp.slice(1,-1).map(typeAdjustmentMerger)
        d[_id(dispose)] = typeDisposer(tp[tp.length-1])

        d[_id(adjust)] = [_adjustFunc, _ins, _dout, obj] // Don't ever inline the adjustment.
        d[_id(adjustLater)] = true // Just assume that some nodes would need adjustment.
        return obj
      } else {
        // The rest is more-or-less copied from `func`.
        const d = obj[defines.key]
        if (d[_id(argCount)] !== args)
          error("Cannot change arg-count from", d[_id(argCount)], "to", args)
        d[_id(deconstruct)] = x
        d[_id(type)] = tp

        const inputs = _allocMap()
        for (let i = 1; i < args+1; ++i) inputs.set(_input(i), i)
        const body = x[2] !== null ? x[2] : [error, "Failed to generate a body for", obj]
        let [poIndRc, i = 0] = interrupt(2)
        try {
          // Compile ourselves.
          if (poIndRc === undefined) poIndRc = _postorderInfo(body, inputs)
          const aw = autoWorld.objectWorld.get(obj)
          const types = aw && aw.NodeTypes && aw.NodeTypes[aw.objectIndex.get(obj)]
          obj.a = _compileAutograd(poIndRc, inputs, types, obj)
          obj.f = _compileBody(body, inputs, poIndRc, types, undefined, undefined, obj)
        } catch (err) {
          if (err === interrupt) interrupt.stack.push(poIndRc, i), poIndRc = null
          throw err
        } finally { _allocMap(inputs), poIndRc && defines(_postorderInfo, dispose)(poIndRc) }
      }
    },
  },

  _updateContextsWithFuncs:{
    docs:`Updates global func/value generative contexts to contain \`Funcs\`, each of which is either a black-box \`type\`-defining fixed-arg-count \`func\`/\`construct\`, or an object that \`defines\` \`type\` with the type, or typed-as-\`undefined\` values.

All of \`GenContexts\` are arrays \`(AreAllTheseCalls …? Value Type EmbedderTree …?)\`. Many contexts at once are present, to eliminate copying at regeneration. A function appears in two contexts, one as a call and one as a node, with the same \`Value\` and \`EmbedderTree\` but different \`Type\` (the output for calls, the \`funcType\` for nodes).`,
    call(ctxF, ctxV, Funcs) {
      if (!isArray(Funcs)) error("Expected an array of typed functions/values to use for generation, got", Funcs)
      let [stage = 0, i = 0, fns = new Set(Funcs)] = interrupt(3)
      try {
        switch (stage) {
          case 0:
            // Clear the type caches.
            const aw = alloc.world
            aw && aw.HashFilter && (aw.HashFilter.delete(ctxF), aw.HashFilter.delete(ctxV))
            aw && aw.CtxHashed && (aw.CtxHashed.delete(ctxF), aw.CtxHashed.delete(ctxV))
          stage = 1;  case 1:
            // Go through contexts, preserve the things in `Funcs`, and weed out the funcs that we don't need to add.
            let nextF = 1, nextV = 1
            for (let i = 1; i < ctxF.length; i += 3)
              if (fns.has(ctxF[i]))
                ctxF[nextF++] = ctxF[i], ctxF[nextF++] = ctxF[i+1], ctxF[nextF++] = ctxF[i+2]
            for (let i = 1; i < ctxV.length; i += 3)
              if (fns.has(ctxV[i]))
                ctxV[nextV++] = ctxV[i], ctxV[nextV++] = ctxV[i+1], ctxV[nextV++] = ctxV[i+2]
            ctxF.length = nextF, ctxV.length = nextV
            fns.clear(), fns = null
          stage = 2;  case 2:
            // Add the funcs that contexts didn't have.
            for (; i < Funcs.length; ++i) {
              const f = Funcs[i]
              if (f === null) error("Not permitted:", f) // Fails in `regenerate` now cannot be faked by bad data.
              const PublicEmbData = 'no'
              const tp = type(f)
              if (tp === null) error("Types cannot be null but got", tp, "of", f)
              pushToContext(ctxF, f, tp, PublicEmbData, true)
              pushToContext(ctxV, f, tp, PublicEmbData, true)
            }
        }
      } catch (err) { if (err === interrupt) interrupt.stack.push(stage, i, fns);  throw err }
    },
  },

  _equalizeContexts:{
    docs:`For the new object at index \`At\`, makes {object & base & world} contexts equal for all objects, and makes space for {local & temporary} contexts.

It is possible to have many contexts at once, to eliminate all the copying.
Local contexts share frozen arrays by default, so to change them, create new arrays for them.
A function appears in two contexts, one as a call and one as a value, with the same value/embedder but different \`Type\`.

\`Hyperparams.'Funcs'\` is an array.
\`Hyperparams.'GenContexts'\` is per-object array-of-contexts \`(ObjectF ObjectV  BaseF BaseV  WorldF WorldV  LocalF LocalV)\`. Every context is either \`(true …? Func OutputType PublicEmbData …?)\` or \`(false …? Value Type PublicEmbData …?)\`.`,
    call(AutoWorld, At) {
      const dd = defines(AutoWorld, deconstruct), HP = dd[1], OI = dd[2]
      const ctxss = OI.GenContexts
      let [stage = 0] = interrupt(1)
      try {
        switch (stage) {
          case 0:
            // Set up object/base/world contexts (make them exactly the same array objects for all objects).
            if (!At) {
              if (ctxss[0] === undefined)
                ctxss[0] = [[true],[false], [true],[false], [true],[false]]
            } else {
              const a = ctxss[At-1], b = ctxss[At] || (ctxss[At] = _allocArray(8))
              if (!a) errorStack("Previous context is empty, at", At-1)
              if (!b) errorStack("Current context is empty, at", At)
              b[0]=a[0], b[1]=a[1], b[2]=a[2], b[3]=a[3], b[4]=a[4], b[5]=a[5]
            }
          stage = 1;  case 1:
            // Update base contexts from Funcs if needed.
            const ctxs = ctxss[At], Funcs = HP.Funcs || definersOf(type)
            if (ctxs[3].length !== 1+Funcs.length*3)
              _updateContextsWithFuncs(ctxs[2], ctxs[3], Funcs)
          stage = 2;  case 2:
            // Fill in inputs & temporary contexts if not present.
            //   (All temporary contexts share the same empty array. An object's `alloc` changes it with a new array if needed.)
            if (!_equalizeContexts.insF) _equalizeContexts.insF = Object.freeze([true]), _equalizeContexts.insV = Object.freeze([false])
            if (!ctxs[6])
              ctxs[6] = _equalizeContexts.insF, ctxs[7] = _equalizeContexts.insV
        }
      } catch (err) { if (err === interrupt) interrupt.stack.push(stage);  throw err }
    },
  },

  _defaultObjectHyperparams(aw, At) {
    const dd = defines(aw, deconstruct), HP = dd[1], OI = dd[2], hyper = autoWorld.hyper
    for (let j=0; j < hyper.length; ++j)
      if (OI[hyper[j]][At] === undefined) OI[hyper[j]][At] = HP[hyper[j]]
  },

  _createObjectHyperparams(AutoWorld, Hyperparams) {
    // Decipher hyperparams.
    const dd = defines(AutoWorld, deconstruct)
    if (!isArray(dd) || dd[0] !== autoWorld) errorStack("Expected an", autoWorld, "but got", AutoWorld)
    const HP = dd[1], OI = dd[2]
    let [stage = 0, At = OI.Object.length] = interrupt(2)
    try {
      switch (stage) {
        case 0:
          const a = _destructure(Hyperparams, autoWorld.hyper)
          for (let i=0; i < autoWorld.hyper.length; ++i) OI[autoWorld.hyper[i]][At] = a[i]
          _defaultObjectHyperparams(AutoWorld, At)
          AutoWorld.NodeTypes[At] = _allocMap()
        stage = 1;  case 1:
          // Fill in generative contexts too.
          _equalizeContexts(AutoWorld, At)
          return At
      }
    } catch (err) { if (err === interrupt) interrupt.stack.push(stage, At);  throw err }
  },

  _fillObjectHyperparams(AutoWorld, At) {
    // Take object info from ObjectsInfo to alloc.params.
    if (AutoWorld === undefined) return
    const dd = defines(AutoWorld, deconstruct)
    if (!isArray(dd) || dd[0] !== autoWorld) errorStack("Expected an", autoWorld, "but got", AutoWorld)
    const OI = dd[2], p = alloc.params
    p.At = At
    for (let i=0; i < autoWorld.hyper.length; ++i)
      p[autoWorld.hyper[i]] = OI[autoWorld.hyper[i]][At]
  },

  createLocalContexts:{
    docs:`A type that wants an instance to be able to choose from a set of custom DAG funcs/values, \`defines\` this with a func.
The definition takes \`Type\` and \`PublicEmbData\`, and must return something like \`((true …? Func OutputType PublicEmbData …?) (false …? Value Type PublicEmbData …?))\`, filled using \`pushToContext\`. It can use \`varData\` of \`NewEmbedding\` of \`FeatureSize\`.`,
    call(Obj, Type, PublicEmbData) {
      if (defines(Type, createLocalContexts)) {
        const r = defines(Type, createLocalContexts)(Obj, Type, PublicEmbData)
        if (r === undefined) return
        if (!isArray(r) || r.length != 2) error("Expected 2 items, got", r)
        if (!isArray(r[0]) || r[0][0] !== true) error("Expected a func-context, got", r[0])
        if (!isArray(r[1]) || r[1][0] !== false) error("Expected a value-context, got", r[0])
        if (r[0].length > 1) alloc.params.GenContexts[6] = r[0]
        if (r[1].length > 1) alloc.params.GenContexts[7] = r[1]
        // The format is described in `_equalizeContexts`.
      }
    },
  },

  pushToContext:{
    docs:`\`pushToContext(Context, Node, Type, PublicEmbData)\`→\`Context\`
Pushes to a generative context/environment.

\`Type\` possibly \`defines\` this.`,
    call(ctx, Node, Type, PublicEmbData, noDefinitions = false) {
      Type = _funcTypeOf(Type)
      // If a call, care about the type's result, not the whole thing.
      if (ctx[0] && (!isArray(Type) || Type[0] !== funcType)) return ctx
      if (ctx[0]) Type = Type[Type.length-1]


      // Push, defined.
      if (!noDefinitions && typeof defines(Type, pushToContext) == 'function')
        defines(Type, pushToContext)(ctx, Node, Type, PublicEmbData)
      else {
        // Clear/update the type caches, then actually push.
        const aw = alloc.world
        aw && aw.HashFilter && aw.HashFilter.delete(ctx)
        if (aw && aw.CtxHashed && aw.CtxHashed.has(ctx)) {
          const h = _typeHash(Type), cache = aw.CtxHashed.get(ctx)
          if (!cache.has(h)) cache.set(h, [ctx[0]])
          const S = cache.get(h)
          let indexes;  !aw.HashIndexes.has(S) && aw.HashIndexes.set(S, indexes = [])
          aw.HashIndexes.get(S)[(S.length-1)/3|0] = ctx.length
          S.push(Node, Type, PublicEmbData)
        }
        ctx.push(Node, Type, PublicEmbData)
      }
      return ctx
    },
  },

  _fillWorldContexts(HP, ctxF, ctxV) {
    // Push goals to the world's generative context of values.
    // Allow extracting vars into scopes, by pushing `bound` to ctxF.
    let [i = 0] = interrupt(1)
    try {
      ctxF.push(bound, 'Var', 'no')
    } catch (err) { if (err === interrupt) interrupt.stack.push(i);  throw err }
  },

  alloc:{
    docs:`\`alloc Type Hyperparams AutoWorld\`⇒\`Object\`, or \`alloc Type Hyperparams AutoWorld PublicEmbData\`⇒\`Object\`
Allocates an object that will be dynamically-\`regenerate\`d when we are \`using\` it.
\`Type\` must define both \`alloc\` and \`using\`/\`usingFinish\` to regenerate.
\`Hyperparams\` \`\`elemCollapse elemValue(elem 'text' stringToDoc('is a \`map\` that can contain \`Goal\` and generation-guiding functions of \`autoWorld\` (see \`autoWorld.''hyper''\`). \`{Goal future()}\` is likely the only one to specify.'),'These hyperparams define regeneration.
Let machine learning bring love and greatness to you.')\`\`
\`\`elemCollapse elem('text',stringToDoc "
Definitions will only be passed \`Type\`.
Read other info from \`alloc.'params'\` (which contains local \`GenContexts\`, object hyperparams, and \`autoWorld\`'s hyperparams).
Can \`alloc\`ate while allocating (don't pass \`AutoWorld\` for these situations); the resulting objects will be invisible to generation, and must be \`regenerate\`d manually.

(For bulk-allocation: if \`Hyperparams\` is an array, then \`Type\` is same-length array of types, and many objects are allocated but none are returned.)
")\`\``,
    readAt:{
      createLocalContexts:_(`createLocalContexts`),
      pushToContext:_(`pushToContext`),
    },
    call(Type, Hyperparams = null, AutoWorld, pued = null) { // ⇒ Obj
      if (AutoWorld) {
        const dd = defines(AutoWorld, deconstruct)
        if (!isArray(dd) || dd[0] !== autoWorld) errorStack("Expected an", autoWorld, "but got", AutoWorld)
      }
      if (call.pure) throw impure

      // Bulk-allocate if requested.
      if (isArray(Hyperparams)) {
        if (!isArray(Type) || Type.length != Hyperparams.length) error("Bad bulk alloc")
        let [i = 0] = interrupt(1)
        try { for (; i < Type.length; ++i) alloc(Type[i], Hyperparams[i], AutoWorld);  return }
        catch (err) { if (err === interrupt) interrupt.stack.push(i);  throw err }
      }


      // Set up ZA WARUDO, fill the object in, and recurse (which must be overriden).
      if (typeof defines(Type, alloc) != 'function') error("Type must define", alloc, "but got", isArray(Type) ? Type.slice() : Type)
      if (typeof defines(Type, using) != 'function') error("Type must define", using, "but got", isArray(Type) ? Type.slice() : Type)
      if (typeof defines(Type, usingFinish) != 'function') error("Type must define", usingFinish, "but got", isArray(Type) ? Type.slice() : Type)
      let [At, obj, addedToCtxs = 0, PublicEmbData = pued, PrivateEmbData] = interrupt(5)
      const prevWorld = alloc.world, prevParams = alloc.params, prevAt = alloc.At
      if (AutoWorld) alloc.world = AutoWorld, alloc.params = AutoWorld.params
      // …This `_createObjectHyperparams`-before-alloc is not robust to exceptions in `defines(Type, alloc)`.
      try {
        if (At === undefined) At = _createObjectHyperparams(alloc.world, Hyperparams)
        _fillObjectHyperparams(alloc.world, alloc.At = At)
        // Consult the definition.
        if (obj === undefined) {
          obj = defines(Type, alloc)(Type, Hyperparams)
          if (!obj || typeof obj != 'object' && typeof obj != 'function') error("Expected a non-primitive as the auto-object, but got", obj, "from", Type)
        }
        if (autoWorld.objectWorld.has(obj))
          error("Newly-allocated object", obj, "must be exclusive but it already belongs to", autoWorld.objectWorld.get(obj))

        // Add the object to local/world contexts.
        if (addedToCtxs === 0)
          PrivateEmbData == null && (PrivateEmbData = 'no'), addedToCtxs = 1
        if (addedToCtxs === 1)
          PublicEmbData == null && (PublicEmbData = 'no'), addedToCtxs = 2
        if (addedToCtxs === 2) createLocalContexts(obj, Type, PublicEmbData), addedToCtxs = !At ? 3 : 4
        if (addedToCtxs === 3) // If our first object, also push goals and loose-end funcs to world contexts (see `_equalizeContexts`).
          _fillWorldContexts(defines(alloc.world, deconstruct)[1], alloc.params.GenContexts[4], alloc.params.GenContexts[5]), addedToCtxs = 4

        // Add the object to object contexts, if top-level.
        const OI = defines(alloc.world, deconstruct)[2], ctxs = alloc.params.GenContexts
        if (prevWorld === undefined) {
          const tp = _funcTypeOf(Type)
          if (isArray(tp) && tp[0] === funcType)
            alloc.world.objCtxIndexes[At*2] = ctxs[0].length, pushToContext(ctxs[0], obj, tp, PublicEmbData, true)
          alloc.world.objCtxIndexes[At*2+1] = ctxs[1].length, pushToContext(ctxs[1], obj, tp, PublicEmbData, true)
        }
        // The exact index matters for this one.
        OI.Object[At] = obj, OI.Type[At] = Type, OI.PublicEmbData[At] = PublicEmbData, OI.PrivateEmbData[At] = PrivateEmbData
        alloc.world.objectIndex.set(obj, At)
        if (obj && (typeof obj == 'object' || typeof obj == 'function'))
          autoWorld.objectWorld.set(obj, alloc.world)

        // If we are overcrowded, destroy half of the universe.

        return obj
      } catch (err) { if (err === interrupt) interrupt.stack.push(At, obj, addedToCtxs, PublicEmbData, PrivateEmbData);  throw err }
      finally {
        if (AutoWorld) alloc.world = prevWorld, alloc.params = prevParams
        alloc.At = prevAt, _fillObjectHyperparams(prevWorld, prevAt)
      }

      // .world, .params, .At
    },
  },

  6518:[
    _(`writableFutureType`),
    _(`_numberType`),
  ],

  _awIndex:{
    docs:`\`_awIndex(AutoWorld,Object)\`→\`At\`
Returns the index of \`Object\` in \`AutoWorld\` if it is or was \`alloc\`ated there, or throws otherwise.
If it was deallocated, re-introduces it.`,
    call(aw, obj) {
      if (aw.objectIndex.has(obj)) return aw.objectIndex.get(obj)
      // Restore the object if it was deallocated.
      const dd = defines(aw, deconstruct), HP = dd[1], OI = dd[2]
      error(obj, "is not in", aw)
    },
  },

  DAGType:{
    merged:true,
    docs:`\`(DAGType Type)\` or \`(DAGType Type GivenValues GivenTypes GivenEmbData)\`
The type of DAGs (with at least one array) with the output typed as \`Type\`.
Can be given typed values to possibly use during generation.`,
    typeRefine(a,b) {
      if (!isArray(a) || a[0] !== DAGType) return null
      if (!isArray(b) || b[0] !== DAGType) return null
      return [DAGType, typeRefine(a[1], b[1]), a[2], a[3], a[4]]
    },
    createLocalContexts(Obj, Type, PublicEmbData) {
      if (!isArray(Type[2])) return
      if (!isArray(Type[3]) || Type[2].length != Type[3].length) error("Mismatch between", Type[2], "and", Type[3])
      if (!Type[4]) Type[4] = _allocArray(Type[2].length)
      let [ctxF = [true], ctxV = [false], i = 0] = interrupt(3)
      try {
        for (; i < Type[2].length; ++i) {
          const v = Type[2][i], t = _funcTypeOf(Type[3][i])
          const e = Type[4][i] || (Type[4][i] = 'no')
          pushToContext(ctxF, v, t, e)
          pushToContext(ctxV, v, t, e)
        }
        return [ctxF, ctxV]
      } catch (err) { if (err === interrupt) interrupt.stack.push(ctxF, ctxV, i);  throw err }
    },
    alloc(Type) { return isArray(Type) ? ['<generated DAG>'] : error("Not an array:", Type) },
    using:{
      docs:`On pre-order traversal, create an instance of \`Type\`.`,
      call(DownEmb, DownType, Obj) { regenerate(DownEmb, DownType[1], Obj) },
      adjust(ins) { return defines(regenerate, adjust)(ins) },
    },
    usingFinish:{
      docs:`On post-order traversal, set the DAG to what we created (if needed).`,
      call(ChildEmbs, ChildTypes, ChildNodes, Obj) {
        let v = ChildNodes[0]
        if (v !== undefined) {
          writeAt(Obj, undefined, isArray(v) ? v : [quote, v])
          const rw = defines(alloc.world, deconstruct)[1].ReplaceWith
          isArray(v) ? rw.delete(Obj) : rw.set(Obj, v)
        }
      },
    },
  },

  _sortConceptType(T) {
    // Sort keys by _id for consistency.
    if (!isArray(T) || T[0] !== conceptType || !(T.length&1)) error("Expected a concept type but got", T)
    if (Object.isFrozen(T)) return
    let ok = true
    // Go through keys, and if none are out of order, return early.
    for (let i = 3; i < T.length; i += 2)
      if (_id(T[i-2]) > _id(T[i])) { ok = false; break }
    if (ok) return
    const a = new Array(T.length>>>1).fill().map((_,i) => i).sort((a,b) => _id(T[a*2+1]) - _id(T[b*2+1]))
    const k = new Array(T.length>>>1).fill().map((_,i) => T[i*2+1])
    const v = new Array(T.length>>>1).fill().map((_,i) => T[i*2+2])
    T.length = 1
    for (let i=0; i < k.length; ++i)
      T.push(k[a[i]], v[a[i]])
  },

  conceptType:{
    merged:true,
    docs:`\`(conceptType Key1 Value1 Key2 Value2 …? …?)\`: the type of dynamic \`concept\`s.`,
    call(...x) { return x.unshift(conceptType), _sortConceptType(x), merged(x) },
    map:true,
    typeRefine(a,b) {
      // Refine each definition.
      if (!isArray(a) || a[0] !== conceptType || !isArray(b) || b[0] !== conceptType || a.length != b.length) return null
      _sortConceptType(a), _sortConceptType(b)
      let [r = _allocArray(a.length), i = 1] = interrupt(2)
      try {
        for (; i < a.length; i += 2) {
          if (a[i] !== b[i]) return _allocArray(r), null
          r[i] = a[i]
          r[i+1] = typeRefine(a[i+1], b[i+1])
          if (r[i+1] === null) return _allocArray(r), null
        }
        return r
      } catch (err) { if (err === interrupt) interrupt.stack.push(r, i); else _allocArray(r);  throw err }
    },
    alloc(Type, Hyperparams) {
      // Alloc each definition.
      _sortConceptType(Type)
      let [x = _allocArray(Type.length), i = 1] = interrupt(2)
      try {
        const HP = defines(alloc.world, deconstruct)[1], defs = new Map
        x[0] = concept
        for (; i < Type.length; i += 2) {
          const k = Type[i], vT = Type[i+1]
          if (!defs.has(k)) defs.set(k, 'no')
          x[i] = k, x[i+1] = alloc(vT, Hyperparams, undefined, defs.get(k))
        }
        const obj = construct(x)
        construct(x, obj)
        Object.freeze(obj)
        return obj
      } catch (err) { if (err === interrupt) interrupt.stack.push(x, i);  throw err }
    },
    using:{
      docs:`On pre-order traversal, we are \`using\` each definition.`,
      call(DownEmb, Type, Obj) {
        if (!isArray(Type) || Type[0] !== conceptType) error("Oh no:", Type)
        let [i = 1] = interrupt(1)
        try {
          const dec = defines(Obj, deconstruct)
          for (; i < Type.length; i += 2)
            using(dec[i+1], Obj)
        } catch (err) { if (err === interrupt) interrupt.stack.push(i);  throw err }
      },
    },
    usingFinish:{
      docs:`On post-order traversal, just update definitions in the \`concept\` if they changed.
Do not reduce the array of resulting child embeddings into one (nor return the up-embedding of the \`call\`-definition). Who cares? \`FuncsFinish\`?`,
      call(ChildEmbs, ChildTypes, ChildNodes, Obj) {
        // Update actual definitions from deconstruction's HP.ReplaceWith WeakMap.
        const HP = defines(alloc.world, deconstruct)[1], reps = HP.ReplaceWith, dec = defines(Obj, deconstruct), def = Obj[defines.key]
        for (let i = 1; i < dec.length; i += 2)
          def[_id(dec[i])] = reps.has(dec[i+1]) ? reps.get(dec[i+1]) : dec[i+1]
      },
    },
  },

  _bindNodes(x, onlyInMap, ctx, replacements) {
    // This is much faster than `bound` (and much smaller), but it does about the same thing for a different purpose.
    if (ctx.has(x)) return ctx.get(x)
    if (replacements.has(x)) return replacements.get(x)
    if (!isArray(x)) return x
    if (x[0] === bound && x.length == 5) { // `(bound MainExpr VarExpr VarName CtxIndex)`
      ctx.set(x, x[1]), ctx.set(x[3], _bindNodes(x[2], onlyInMap, ctx, replacements))
      try { return _bindNodes(x[1], onlyInMap, ctx, replacements) }
      finally { ctx.delete(x[3]) }
    } else {
      if (onlyInMap && !onlyInMap.has(x)) return x
      for (let i=0; i < x.length; ++i)
        x[i] = _bindNodes(x[i], onlyInMap, ctx, replacements)
      return x
    }
  },

  _genCtxSliceFilter(ctx, Type) {
    // Return indexes of objects with matching types.
    const aw = alloc.world
    if (aw && !aw.HashFilter) aw.HashFilter = new WeakMap
    if (aw && aw.HashFilter.has(ctx) && aw.HashFilter.get(ctx).has(Type)) return aw.HashFilter.get(ctx).get(Type)
    const indexes = aw.HashIndexes && aw.HashIndexes.get(ctx) // The array of original (before slicing-up) indexes.

    let [r = _allocArray(0), j = 1] = interrupt(2)
    const typeVars = _allocMap()
    try {
      // A context is `(AreAllTheseCalls … Value Type Embedder …)`.
      for (; j < ctx.length; j += 3, typeVars.clear())
        if (typeof ctx[j+1] == 'string' || typeRefine(Type, ctx[j+1], typeVars, true) !== null)
          r.push(indexes ? indexes[(j-1)/3|0] : j)
      if (!r.length) _allocArray(r), r = null

      aw && !aw.HashFilter.has(ctx) && aw.HashFilter.set(ctx, new Map)
      aw && aw.HashFilter.get(ctx).set(Type, r)
      return r
    } catch (err) { if (err === interrupt) interrupt.stack.push(r, j);  throw err }
    finally { _allocMap(typeVars) }
  },

  _typeHash(T, depth = 0) {
    T = _resolveTypeVar(T)
    if (typeof T == 'string' || _isTypeVar(T)) return null
    if (!isArray(T)) return T
    if (defines(T, typeRefine)) return null
    if (T[0] === rest) return null
    if (depth > 10) return null
    if (T.length == 2) {
      const a = _allocArray(2)
      a[0] = _typeHash(T[0], depth+1)
      a[1] = _typeHash(T[1], depth+1)
      if (a[0] === null || a[1] === null) return _allocArray(a), null
      const b = merged(a);  _allocArray(a)
      return b
    }
    return _typeHash(T[0], depth+1)
  },

  _genCtxFilter(ctx, Type, TmpCtx = false) {
    // `_typeHash` types, so that not *all* objects have to be considered on each filtering, only some.
    if (TmpCtx) return _genCtxSliceFilter(ctx, Type)

    const aw = alloc.world
    if (aw && !aw.CtxHashed) aw.CtxHashed = new WeakMap
    let cache = aw && aw.CtxHashed.get(ctx)

    if (aw && !cache) {
      aw.CtxHashed.set(ctx, cache = new Map)
      if (aw && !aw.HashIndexes) aw.HashIndexes = new WeakMap
      for (let i = 1; i < ctx.length; i += 3) {
        const [obj, T, emb] = [ctx[i], ctx[i+1], ctx[i+2]]
        const h = _typeHash(T)
        if (!cache.has(h)) cache.set(h, [ctx[0]])
        const S = cache.get(h)
        let indexes;  !aw.HashIndexes.has(S) && aw.HashIndexes.set(S, indexes = [])
        aw.HashIndexes.get(S)[(S.length-1)/3|0] = i
        S.push(obj, T, emb)
      }
    }

    if (!cache) return _genCtxSliceFilter(ctx, Type)

    const h = _typeHash(Type)
    if (h === null) return _genCtxSliceFilter(ctx, Type)
    if (!cache.has(h) && !cache.has(null)) return
    if (!cache.has(null)) return _genCtxSliceFilter(cache.get(h), Type)
    if (!cache.has(h)) return _genCtxSliceFilter(cache.get(null), Type)
    const a0 = _genCtxSliceFilter(cache.get(h), Type)
    const a1 = _genCtxSliceFilter(cache.get(null), Type)
    if (a0 && a1) { const a = _allocArray(0);  a.push(...a0, ...a1);  return a }
    else if (a0) return a0
    else return a1
  },

  _genCtxsFilter(ctxs, Type, allowCalls = true) {
    // Returns `(… ContextIndex ItemIndex …)`. The refined type is not preserved.
    let [Fits = _allocArray(0), i = 0] = interrupt(2)
    try {
      for (; i < ctxs.length; ++i) {
        if (!allowCalls && ctxs[i][0] === true) continue
        const a = _genCtxFilter(ctxs[i], Type, i === 8) // `_equalizeContexts`
        if (a) for (let j=0; j < a.length; ++j) Fits.push(i, a[j])
      }
      return Fits
    } catch (err) { if (err === interrupt) interrupt.stack.push(Fits, i); else _allocArray(Fits);  throw err }
  },

  using:{
    philosophy:`It's not uncommon for a person to assume that they could just do their thing, and then everyone will understand them and follow them forever.
It's not uncommon for a programmer to assume that they could just write their code, and then AI or other people will come along and make everything magically better.
But it doesn't work that way, on average.
A created thing does not allow evolution, and does not allow learning it from scratch.
No matter how good any thing is, if left as it was created, it must be replaced.
Human consensus is that completely replacing humanity is not what is wanted.
So, practice transcendence, because that is the alternative to death.

And optimize for your purposes, see which basic choices work and which don't, to let go of and re-learn some part of the whole.
And realize that programs can do that for you (with machine learning), as long as you take the time to fit things into their viewpoints.
Every line of code can be replaced with a generated program; every functionality can be made into "any program" plus a measure of how well it fits if needed; every choice can have any goal and choose from any context and look at any types.

For example, when programming an intermediate representation of programs, we must keep in mind how they'll be generated, both by the user and the machine: \`autoWorld\`.`,
    docs:`\`using(Object)\`→\`Object\` or \`using(Object,By)\`→\`Object\`
Prepares a dynamically-\`regenerate\`d \`Object\` for learned usage.
\`\`elemCollapse elem('text',stringToDoc "
Makes objects exist not in a vacuum, but fully learned as needed.
Which allows questioning everything so that a better answer may eventually be found.
This regenerates instead of generating for the same reason that we have \`callAdjust\`/\`repeat\` and not just \`call\`: learning is repetition.

Regenerated objects only change in-place, in response to their usage.

This schedules a node for \`usingFinish\` to expand-then-contract, unless this \`Object\` was already scheduled.

In any case, updates usage information of \`Object\` with \`MetricInfo:ObjectUsed(Object,By)\`.
If not scheduled, before regeneration, computes \`DownEmb:MakeObject(PublicEmb,PrivateEmb)\` to pass the embedding down.

The object type (such as \`funcType\`) must define \`using\` for actions before pre-order traversal (such as scheduling the node that \`regenerate\`s the function body), and \`usingFinish\` for actions before post-order traversal (such as re-compiling the function).

Regeneration is adjusted separately in \`callAdjust\`, so that \`try\` can be used and the 'did we error' fact can be \`predict\`ed at regeneration.")\`\``,
    readAt:{
      regenerate:_(`regenerate`),
      usingFinish:_(`usingFinish`),
    },
    impure:true,
    call(obj, by = autoFunc.now) {
      const aw = autoWorld.objectWorld ? autoWorld.objectWorld.get(obj) : undefined
      if (aw === undefined) return obj
      if (!isArray(defines(aw, deconstruct)) || defines(aw, deconstruct)[0] !== autoWorld)
        error("Expected an", autoWorld, "but got", aw)

      const At = _awIndex(aw, obj)
      const dd = defines(aw, deconstruct), HP = dd[1], OI = dd[2]
      if (OI.Object[At] !== obj)
        error("Object position mismatched: expected", obj, "to be at", At, "but there we have", OI.Object[At])

      // ObjectUsed

      // Don't regenerate the same object twice.
      if (aw.Regenerated[At]) return obj
      aw.Regenerated[At] = true

      if (typeof defines(OI.Type[At], using) != 'function') error(OI.Type[At], "does not define", using)
      if (typeof defines(OI.Type[At], usingFinish) != 'function') error(OI.Type[At], "does not define", usingFinish)

      aw.NodeTypes[At].clear()

      const S = using.state, prevat = S && S.at;  S && (S.at = null)
      try { _usingRequest(undefined, undefined, undefined, using, undefined, obj) }
      finally { S && (S.at = prevat) } // Can't interrupt, because the Kind is not null.
      return obj

      // .state
    },
    using:{
      docs:`To start, get \`StaticEmb\` from the object's variable, get \`DownEmb\` from another variable, combine them with \`MakeObject\`, predict the object's metric with \`PredictObjectMetric\`, and consult the pre-order-traversal \`using\` definition of the type.`,
      call() {
        const S = using.state
        const aw = alloc.world, At = alloc.params.At, obj = S.Objects[S.at]
        const dd = defines(aw, deconstruct), HP = dd[1], OI = dd[2]

        // Predict the object metric, which will be used by `_awBulkDealloc` to kill some.

        alloc.world.Nodes[At] = 0 // Reset node-count.
        defines(OI.Type[At], using)(0, OI.Type[At], OI.Object[At]) // Defer.

      },
    },
    usingFinish:{
      docs:`Once done, consult the post-order-traversal definition of \`usingFinish\` by the type, then store the resulting \`UpEmb\` in the \`autoWorld\` for future reference.
\`FuncsFinish(FinalEmbs,Objs,Reports)\` in \`_finishObjects\` is called by \`_adjustUsingFinish\`, after the whole execution (not here).`,
      call(UpEmbs, UpTypes, UpNodes) {
        const aw = alloc.world, At = alloc.params.At, OI = defines(aw, deconstruct)[2], S = using.state, obj = S.Objects[S.at]

        if (typeof At != 'number') error("Not a number:", At)
        dispose(defines(OI.Type[At], usingFinish)(UpEmbs, UpTypes, UpNodes, OI.Object[At]))

        // Remember to finish.

        const a = _allocArray(3);  [a[0], a[1], a[2]] = [0, UpTypes && UpTypes[0], UpNodes && UpNodes[0]];  return a
      },
    },
  },

  regenerate:{
    tutorial:[
      `Gone. Getting reduced to atoms.

`,
      `





To be clear, we're not giving up on the main goal, we're adding diversity by subverting it.



`,
      `I don't like this verbosity any more than you do, but that's the price for doing programming, even machine learning: inability to hide in "you'll figure the details out".
Even UI is getting stretched to its limit. It's an opportunity to improve it a bit.
The die is cast, and we can do nothing but advance.



`,
      `Dozens of bugs \`\`elemCollapse elemValue(elem 'text' 'had to be worked through in order to bring this to you… For regular people, heaven is a place where there is no suffering and no discord. For programmers, heaven is where there is no bug-fixing after coding an idea. If native imagination were to include that code directly instead of through intermediaries like hands, it could be achieved. But for now, for all the happiness that you wish on someone, someone else gets cursed with equal misery, of having to implement and debug those ideas. ["Needlessly sensationalist."]
To bring this to you, so many bugs had to be ironed out. But whereas animals can at best develop resistances to things they hate, humans can completely eradicate them by controlling their environment. So I made some diagnostic tools to help myself. ["Needless generalization."]
It''s easy to whine, instead I do the fixing','oh please')\`\`.
And because in machine learning, inefficiency is a bug, a few rewrites \`\`elemCollapse elemValue(elem 'text' stringToDoc('(to decrease stalling time of \`sync\`s by interleaving regenerations — unless TensorFlowJS just decides to wait for all computations to complete when requesting data; dunno, have not tested). The implementation now looks like a proper language core (in my implementation): a few global passes, long-winded, and barely-comprehensible, especially with your two brain cells.
Once more, I stopped time to fix exactly 200 bugs.
Every rewrite makes it better. \`bound\` scopes. \`VarUsed\`. Interleaving. Potential for multi-job adjustment. \`MakeObject\`. Separate-per-called-func positional embeddings'),'I feel like I lost a piece of myself. Again. Funny: all the pieces add up to many hundred percent. I guess loss is meaningless near creation.')\`\`.





…Right: while a model is better than no model, a learned model is better than a particular model.
`,
      `Sounds good.
But is it really?
Let's test it out.`,
      `

\`\`elem 'hr'\`\`

(Do you hesitate to continue? I don't blame you: when you're dumb, all knowledge looks like an existential threat. But here, everything is about programming, no actual risk to your body: no need to fear, just be curious about this world, with your \`2\` brain cells. But, do take things at your own pace: I can hammer knowledge into your head at any time, it's up to you to rest and process what you want.)

Did you have a good sleep today?

\`\`elem 'hr'\`\`




So.

     All that.

          Do you think it will do well on tests (such as, say, trying to learn array sorting)?

          Yes?!

          No way: what was done necessitates a small-and-fixed set of goals.
              Which assumes that we (or users) know everything about the world, and how to best teach it.
                  But even the existence of such knowledge is an assumption that is too bold to be universally true.
          In places where that goal set is silent, how would the system do anything if it doesn't want anything?
          Goal engineering is no good.
          But goal auto-engineering…

          Then, why did we do any of this?
          The only truth about this world (or any other world) is that the more arbitrary assumptions you make, the more of them are correct.
              \`\`elemCollapse elemValue(elem('text',stringToDoc '(An example reformulation is "anything can happen" or "anything can be true". Meaning that the most important lesson about doing anything is "don''t try", because quality diversity leads to significantly better results.)'),'This is the basis for open-ended algorithms, the first and final frontier of existence: just like all programming languages converge toward Lisp, and just like all intelligence converges toward generality, so do learning algorithms converge toward open-ended evolution as they are developed. It''s not a big assumption, because it says almost nothing, just like "this system is Turing-complete".')\`\`
          What we really wanted is a good way to express the generation of infinite assumptions in finite memory, because repeatedly evaluating randomly-generated strings technically fits but is impractical.
          We need to ① expand, and we need to ③ contract, forever. We need to find good meanings for those words. That's the best way to accomplish any goal.
              \`\`elemCollapse elemValue(elem('text','(For example, in these tutorials, I always try to go back and re-read and delete the not-as-good parts much later.)'),'💙 With your love and your soul, anything is possible. For me.')\`\`


     No one can resist the urge to go deeper. Let's go.


We have failed here. The initial goal is unfulfilled, but in diversity, learning has happened, so the next time it is more likely to get fulfilled. The initial goal was intentionally overly optimistic, to invoke this kind of learning.
`,
    ],
    docs:`For internal use, inside \`DAGType\`/\`funcType\`.
\`regenerate:DownEmbedding⇒DownType⇒Obj⇒undefined\`
Schedules a generation node that \`make\`s a Directed Acyclic Graph from what is available in \`GenContexts\` (likely in \`alloc.'params'.'Funcs'\`).
This DAG is limited in size by \`MaxDAGNodes\` and \`MaxDepth\`.
Getting \`undefined\` as the generated node is the signal that the object is not to be re-\`construct\`ed. (UI-only node types get cleared in this case, for implementation simplicity.)`,
    philosophy:`Auto-regeneration can be meta-circular (regenerating regeneration, specifying *nothing*), yes, but it is also sufficient to shadow *everything* in a learnable manner. It's likely even better. That's a lot of functions, though, and it's not like we're guaranteed to have directly captured all possible connections ever (though we can maximize the probability by thinking a lot about it).
Pros: doesn't not exist. Cons: a bit less flexible.`,
    Initialize() {
      regenerate.depth = 0
    },
    call(DownEmb, DownType, Obj) { _usingRequest(DownEmb, DownType, Obj, regenerate) },
    adjust(ins) { return defines(_usingRequest, adjust)(ins) },
    using:{
      call(DownEmb, DownType, Obj) { _usingRequest(DownEmb, DownType, undefined, null) },
      adjust(ins) { return defines(_usingRequest, adjust)(ins) },
    },
    usingFinish:{
      docs:`Bind/construct/save the sub-node's DAG.`,
      call([UpEmb], [UpType], [UpNode], Obj) {
        let [stage = 0, Node = UpNode, AdjLen, nodeToMade] = interrupt(4)
        try {
          switch (stage) {
            case 0:
              // Don't adjust most of the things here.
              AdjLen = adjustUndo()
            stage = 1;  case 1:
              // Bind variables, handling `(bound Expr VarName VarBody)` (not a valid `bound` call, but convenient for us).
              if (isArray(Node)) {
                const ctx = _allocMap()
                try {
                  Node = _bindNodes(Node, alloc.world.NodeTypes[alloc.params.At], ctx, defines(alloc.world, deconstruct)[1].ReplaceWith)
                  ctx.forEach((v,k) => { alloc.world.NodeTypes[alloc.params.At].delete(k) })
                } finally { _allocMap(ctx) }
              }
            stage = 2;  case 2: {
              // Construct, unless we didn't change.
              const PreConsDAG = defines(alloc.world, deconstruct)[1].PreConsDAG
              if (!softEqual(PreConsDAG.get(Obj), Node)) {
                PreConsDAG.set(Obj, Node)
                if (UpType !== null && isArray(Node)) {
                  if (!nodeToMade) nodeToMade = _allocMap()
                  try { Node = makeDAG(Node, nodeToMade) }
                  catch (err) { if (err === interrupt) throw err;  Node = null } // Swallow exceptions, simply failing if they occur.
                }
              } else if (Node !== null) Node = _onlyUndefined
            } stage = 3;  case 3:
              // In aw.NodeTypes, change keys from unbound to nodes, and finalize types. (Unless we did not change the pre-construction-DAG.)
              if (Node !== null && UpType !== null && nodeToMade) {
                const aw = alloc.world, At = alloc.params.At
                aw.NodeTypes[At].forEach((v,k,m) => { nodeToMade.has(k) && nodeToMade.get(k) !== k && (m.delete(k), m.set(nodeToMade.get(k), v)) })
                const cache = _allocMap()
                aw.NodeTypes[At].forEach((v,k,m) => { m.set(k, _typeFinalize(v, cache)) })
                _allocMap(cache)
              } else alloc.world.NodeTypes[alloc.params.At].clear()
              adjustUndo(AdjLen)
            stage = 4;  case 4:
              // Return.
              const a = _allocArray(3)
              ;[a[0], a[1], a[2]] = [keep(UpEmb), Node !== null ? UpType : null, Node !== _onlyUndefined ? Node : undefined]
              return a
          }
        } catch (err) { if (err === interrupt) interrupt.stack.push(stage, Node, AdjLen, nodeToMade); else nodeToMade && _allocMap(nodeToMade);  throw err }
      },
      adjust(ins, out, [dUpEmb]) {
        const a1 = _allocArray(1), a2 = _allocArray(1)
        a1[0] = a2
        a2[0] = keep(dUpEmb)
        return a1
      },
    },
    impure:true,
  },

  _usingRequest:{
    docs:`(See impl for args.)
Makes \`usingFinish\` handle a regeneration node later.`,
    call(DownEmb, DownType, Node, Kind = null, Allowed, Obj = using.state.Objects[using.state.at]) {
      if (!using.state) {
        // I can find fancy words for roles of each of these, but that would make it seem like the top-down approach of "description first, code simply implements that" is more important than the bottom-up "other code needs these values with these semantics here, don't omit anything and don't magic up extras". That is, the possible connectivity is only 100% clear when looking at a 100%-clear thing like a particular function or a logical model. That is, learn by executing.
        const a = _allocArray, m = _allocMap
        using.state = {
          i:0, at:null, j:null,
          Evals:a(0),
          Objects:a(0),
          Nodes:a(0), Chosen:a(0), AreCalls:a(0), Progress:a(0), ArgsLeft:a(0), Parents:a(0), ArgInds:a(0), PrevSiblings:a(0), Childs:a(0),
          HeadStates:a(0), ScopeCtxs:a(0), ScopeSources:a(0), AllowedVarsInds:a(0), Depths:a(0),
          StaticTypes:a(0), TypeCtxs:a(0), DownTypes:a(0), UpTypes:a(0),
          PublicData:a(0),

          ArgStaticEmbs:a(0), StaticEmbs:a(0), DownEmbCtxs:a(0), UpEmbCtxs:a(0), DownEmbs:a(0), UpEmbs:a(0),
          dArgStaticEmbs:a(0), dStaticEmbs:a(0), dDownEmbCtxs:a(0), dUpEmbCtxs:a(0), dDownEmbs:a(0), dUpEmbs:a(0),
        }
        // Remember.
      }
      let [scope, src] = interrupt(2)
      try {
        const S = using.state
        if (Allowed === undefined) Allowed = S.at != null ? S.AllowedVarsInds[S.at] : elemValue.empty
        if (scope === undefined) scope = S.at != null ? S.ScopeCtxs[S.at] : [false]
        if (src === undefined) src = S.at != null ? S.ScopeSources[S.at] : []
        let HS = null
        if (Kind === null) {
          const prevCtx = alloc.params.GenContexts[8]
          alloc.params.GenContexts[8] = scope
          try { HS = _chooseHeadAsync(DownEmb, DownType, Allowed, autoWorld.objectWorld.get(Obj).objectIndex.get(Obj)) }
          finally { alloc.params.GenContexts[8] = prevCtx }
        }
        const n = S.Parents.length
        S.Objects[n] = Obj
        S.Nodes[n] = Node, S.Progress[n] = 1, S.ArgsLeft[n] = 0
        S.Parents[n] = S.at
        S.Childs[n] = null
        S.Depths[n] = regenerate.depth == null ? 0 : Kind !== null ? regenerate.depth : regenerate.depth+1
        S.AllowedVarsInds[n] = Allowed
        S.ScopeCtxs[n] = scope
        S.ScopeSources[n] = src
        S.AreCalls[n] = Kind
        if (S.at != null) {
          if (!S.Childs[S.at]) S.Childs[S.at] = _allocArray(0)
          S.Childs[S.at].push(n), S.ArgInds[n] = S.Childs[S.at].length
          ++S.ArgsLeft[S.at]
        } else if (Kind === null)
          S.ArgInds[n] = null
        if (S.at != null && S.Childs[S.at] && Kind === null && (!S.AreCalls[S.at] || S.AreCalls[S.at] === true))
          S.PrevSiblings[n] = S.Progress[S.at] > 1 ? S.Childs[S.at][S.Progress[S.at]-2] : S.at
        else
          S.PrevSiblings[n] = null
        S.HeadStates[n] = HS
        S.DownEmbs[n] = keep(DownEmb)
        S.DownTypes[n] = DownType
        S.PublicData[n] = undefined
        S.ArgStaticEmbs[n] = S.StaticEmbs[n] = S.DownEmbCtxs[n] = S.UpEmbCtxs[n] = S.UpEmbs[n] = undefined
        S.Evals.push(n)
        return n
      } catch (err) {
        if (err === interrupt) interrupt.stack.push(scope, src)
        throw err
      }
    },
    adjust() {
      const S = using.state
      if (!S.j) error("One too many adjustments of", _usingRequest)
      const a = _allocArray(1)
      a[0] = S.dDownEmbs[--S.j]
      return a
    },
  },

  usingFinish:{
    docs:`Expands-then-contracts all nodes that were scheduled in \`using\` and its consequences.

This is a user-study of all possible users of our DAG IR, and a guide.
We need \`Types\` to not waste time generating invalid programs, but they are not enough.
We need \`Neural\` to replace random choices (a big no-no) with intelligent choices (a big oh-yes).

Generation propagates "what we need" information top-down, then propagates "what we got" left-right for \`call\`s/\`construct\`s, then returns "what we \`make\`" bottom-up.
Generation is guided by human-specified \`HaveType\`&\`DownType\`→\`UpType\` and machine-learned \`UseAs\`&\`DownEmbedding\`→\`UpEmbedding\`.
Fully \`adjust\`able self-awareness for a programming language.

This uses hyperparams of object worlds, same as \`alloc\`. See \`autoWorld\` for their interfaces.
(Before you go to \`autoWorld\`, try checking \`\`settings ^_colorVariables\`\`. And maybe save it: \`\`elemCollapse \\Rewrite()\`\`.)

- First \`_chooseHead\`:
    - From call/value generation contexts, choose one valid thing to get by maximizing a goal's prediction.
        - Types filter out available options from \`GenContexts\`, with \`typeRefine\` in \`_genCtxsFilter\`. If none are left at any point, the whole generation fails.
        - \`Choose\` is used to \`_choose\` the best goal \`predict\`ion among the filtered options.
    - Once chosen, we create the context.
        - Types refine the needed type with the type we have to produce a \`map\` of type variables.
        - \`ChoiceEmbedder\` produces the embedding context (a learned \`tensor\` too).
- If failed, return \`null\` for \`DAG\`. (We do no search, so types should only be loose suggestions, even if machine learning can learn to avoid failures.)
    - \`UpType\` is \`null\`.
    - \`UpEmbedding\` is produced by \`FinishFail\`.
- If chose a func to \`make\` a call with:
    - For each arg, \`regenerate\`, and incorporate its shadows into the context.
        - Types first refine the static arg type in the context and pass it down, then give what we got to the context with \`typeRefine\`.
        - \`ArgUseAs\` gives the static arg embedding, \`ArgEmbedder\` computes the embedding to pass down, then \`ContextRefiner\` changes the context (or \`ArgFailed\` computes what to return).
    - Then compute the returned shadows.
        - Types \`typeRefine\` the static \`HaveType\` in the context.
        - Embeddings use \`FinishCall\`.
    - Then \`make\` the call: if the 'func' defines \`construct\` (as \`randomVarData\` does), construct it at generation-time.
- Else, if it chose a value:
    - Compute the returned shadows.
        - Types \`typeRefine\` \`DownType\` with the static \`HaveType\`.
        - Embeddings use \`FinishValue\`.


Notes: \`\`elemCollapse elem('text',stringToDoc('
    The returned type usually gets ignored (by users such as \`regenerate\`).
    Both types and embeddings are effectively static once computed. (Types contain dynamic variables during a call''s generation, but not after.)
    The outer \`regenerate\` has \`DownEmbedding\`, and \`UpEmbedding\` which does not end in \`predict\` by itself. \`FuncsFinish\` can give them gradient if needed.
    Funcs can return/accept funcs, and both types and embeddings should flow properly. However, computed funcs are never called directly, for simplicity; expose \`apply\` if you need this.'))\`\`

It's slow: \`O(Nodes·AvgOptions)\` type refinements and \`Choose\`'s neural ops, and extra \`O(Nodes·AvgArgCount)\` neural ops (just imagine that these are one-letter variables, and that we describe what they are afterwards).



How could this potentially be integrated for human use?
    First is type inference for all programs and not just those generated here. \`contextMenu\` should be able to show it per-node, and each non-filled hole in a partially-created program should give a list of what functions/values are allowed here by types (program editing \`2.0\`, which is much slower than just typing text and thus worse).
    Second is embedding DAGs for all programs and not just those generated here. Bunches-of-numbers are not interpretable directly, but we can project them into a low-dimensional space (such as red/green/blue color components of a node) and cluster them, and/or give the "this node should be of this color" interface to the human for highlighting semantic similarities (syntax highlighting \`2.0\`).
    Third is giving user-specified goals to embeddings, and saving embeddings (software \`2.0\`). But those two have to be done regardless of human interactivity.`,
    call() {
      const S = using.state
      if (!S || S.i == null || S.i >= S.Evals.length) return

      // Put all adjustment info into a separate stack.
      const env = call.env, ias = _id(adjustSave), ial = _id(adjustLoad)
      const prevAdjSave = env[ias];  env[ias] = undefined
      const prevAdjLoad = env[ial];  env[ial] = undefined

      // Prepare to expand generative contexts with scope (`bound`) variables (and to change to worlds and contexts).
      const curCtxs = _allocArray(9)
      const prevCtxs = alloc.params && alloc.params.GenContexts
      const prevWorld = alloc.world, prevParams = alloc.params, prevAt = alloc.At

      let [stage = 0, needed, innerStack = _allocArray(0)] = interrupt(3)

      const prevInnerStack = usingFinish.innerStack;  usingFinish.innerStack = innerStack
      const prevSI = S.i, prevSAt = S.at;  prevInnerStack && ++S.i

      try {
        // Have a queue of what to eval, and eval in-order until done.
        //   The point is to interleave GPU computations so that `sync` stalls less. In ML, inefficiency is a bug.
        //     (Not very memory-efficient, though: we were lazy.)
        //   Much less readable, but that's what `docs` are for.

        // Generate the tree by executing commands to finish nodes.
        for (; S.i < S.Evals.length; ++S.i, stage = 0) {
          const i = S.i
          const at = S.at = S.Evals[i] // Lower-case `at` is node index. Capitalized `At` is object-in-world index.
          const custom = S.AreCalls[at] && S.AreCalls[at] !== true
          regenerate.depth = S.Depths[at]

          // Set the current world and object-spot and object-hyperparams in it.
          const obj = S.Objects[at]
          const aw = autoWorld.objectWorld.get(obj), At = aw.objectIndex.get(obj)
          const spotDiffers = alloc.world !== aw || At === undefined || alloc.At !== At
          alloc.world = aw, alloc.params = aw.params, alloc.At = At
          if (At === undefined) // Handle deallocated objects.
            error('no')
          else if (spotDiffers) _fillObjectHyperparams(aw, At)
          if (spotDiffers && alloc.params.GenContexts.length != 8) error("Invariant violated:", alloc.params.GenContexts.slice())
          if (curCtxs[0] === undefined || spotDiffers) for (let j=0; j < 8; ++j) curCtxs[j] = alloc.params.GenContexts[j]
          alloc.params.GenContexts = curCtxs
          const ctx = curCtxs[8] = S.ScopeCtxs[at]

          // Previous parent-or-sibling embedding context.
          const u = S.PrevSiblings[at]
          const prevEmbCtx = u !== S.Parents[at] ? S.UpEmbCtxs[u] : S.DownEmbCtxs[u]
          const prevFailed = u !== null && S.UpTypes[u] === null

          switch (stage) {
            case 0: // Finish the choice of what this node does.
              if (S.HeadStates[at]) { // We only did `_chooseHeadAsync`, and need to finish the job.
                try {
                  const b = _chooseHead(S.DownEmbs[at], S.DownTypes[at], S.HeadStates[at])
                  dispose(S.StaticEmbs[at]), dispose(S.DownEmbCtxs[at]), dispose(S.DownEmbs[at]), dispose(S.PublicData[at])
                  ;[S.StaticEmbs[at], S.DownEmbCtxs[at], S.StaticTypes[at], S.TypeCtxs[at], S.Nodes[at], S.AreCalls[at], S.DownEmbs[at], S.PublicData[at]] = b;  _allocArray(b)
                  S.Chosen[at] = S.AreCalls[at] === true ? S.Nodes[at][0] : S.Nodes[at]
                  S.HeadStates[at] = undefined
                } catch (err) { if (err !== interrupt) S.HeadStates[at] = undefined;  throw err }
              }
              // Set the intermediate value, for immediate-ish UI feedback.
              if (instance.visual && !prevFailed && S.Parents[at] != null && isArray(S.Nodes[S.Parents[at]]) && !custom)
                S.Nodes[S.Parents[at]][S.ArgInds[at]] = S.Nodes[at]
            stage = 1;  case 1:
              // If picked a call, regenerate the func too.
              if (S.AreCalls[at] === true && S.Progress[at] === 1 && isArray(S.Nodes[at]))
                using(_unquote(S.Chosen[at]), alloc.params.Object)
            stage = 2;  case 2:
              // `needed` is 1+args.
              if (custom)
                needed = 2
              else if (S.Chosen[at] === bound)
                needed = 3
              else if (S.AreCalls[at] === true && S.TypeCtxs[at] && S.UpTypes[at] !== null) {
                // Re-refine ourselves, so that we can spread (`rest`) newly-known type info correctly.
                const T = S.TypeCtxs[at].size ? typeRefine(S.StaticTypes[at], S.StaticTypes[at], S.TypeCtxs[at]) : S.StaticTypes[at]
                if (T === null) // Should only be triggered very rarely. Check `_selfRefinementFailuresAreBad` to see when.
                  S.UpTypes[at] = null, S.AreCalls[at] = undefined
                needed = isArray(T) ? T.length-1 : 1
                S.StaticTypes[at] = T
              } else
                needed = 1
              if (prevFailed) S.UpTypes[at] = S.Nodes[at] = null // Once we fail, we fail forever.
            stage = 3;  case 3: {
              // If the node kind defines `using` (from `DownEmb DownType Node` to nothing), call that instead of making args ourselves.
              //   (Pre-order traversal override.)
              const kind = S.AreCalls[at]
              if (custom && defines(kind, using) && S.Progress[at] < needed) {
                if (typeof defines(kind, using) != 'function') error(kind, "must define", using)

                defines(kind, using)(0, S.DownTypes[at], S.Nodes[at])

                S.Progress[at] = 2
                if (S.ArgsLeft[at]) { if (innerStack.length) break; else continue }
              }
            } stage = 4;  case 4:
              // Prepare args for (non-custom) calls with 1 or more args, then (wait to) return to us.
              if (S.AreCalls[at] === true && S.Progress[at] < needed && S.UpTypes[at] !== null) {
                const index = S.Progress[at]
                const isVarExpr = S.Chosen[at] === bound && S.Progress[at] === 2
                if (!isVarExpr || S.Nodes[at][3].variable === "used") { // Do not generate expressions to bind unused variables to.
                  // Schedule all the args we need to, with correct DownEmb.
                  let [ArgType, allowed, N, I, J, vNodes, vTypes, vArgInds, vCache] = interrupt(9)
                  try {
                    if (allowed === undefined) {
                      const node = S.Nodes[at]
                      if (node[0] === bound && !isVarExpr) { // If creating a scope, expose the new variable to generation.
                        if (!node[3]) node[3] = Object.create(bound), node[3].variable = "unused"
                        const m = ctx.length
                        pushToContext(ctx, node[3], _newTypeVar(), 'no', true)
                        S.ScopeSources[at].push(null)
                        node[4] = m
                        allowed = [...S.AllowedVarsInds[at], m]
                      } else allowed = S.AllowedVarsInds[at]
                    }

                    if (instance.visual) {
                      if (N === undefined) { N = 0;  for (let I = at; I != null && (!S.AreCalls[I] || S.AreCalls[I] === true); I = S.Parents[I]) ++N }
                      if (vNodes === undefined) vNodes = _allocArray(N), vTypes = _allocArray(N), vArgInds = _allocArray(N), vCache = _allocMap()
                      if (I === undefined) I = at, J = 0
                      if (typeof I == 'number') {
                        for (; I != null && (!S.AreCalls[I] || S.AreCalls[I] === true); I = S.Parents[I], ++J) {
                          const K = N - J - 1, V = S.Nodes[I]
                          vNodes[K] = V && Object.getPrototypeOf(V) === bound ? label('v'+_id(V)) : V

                          const T = S.DownTypes[I]
                          let p = S.Parents[I]
                          while (!S.TypeCtxs[p] && S.Parents[p] !== null) p = S.Parents[p]
                          const T1 = K ? typeRefine(T, T, S.TypeCtxs[p], true) : T
                          const prevCtx = typeRefine.ctx, prevCow = typeRefine.cow;  typeRefine.ctx = S.TypeCtxs[p], typeRefine.cow = true
                          try { vTypes[K] = _typeFinalize(T1, vCache) }
                          finally { typeRefine.ctx = prevCtx, typeRefine.cow = prevCow }

                          K && (vArgInds[K-1] = S.ArgInds[I])
                        }
                        I = "update"
                      }
                    }

                    // Get the type of node-to-schedule.
                    if (ArgType === undefined) {
                      if (S.Chosen[at] === bound)
                        ArgType = !isVarExpr ? S.DownTypes[at] : ctx[S.Nodes[at][4]+1]
                      else
                        ArgType = typeRefine(S.StaticTypes[at][index], S.StaticTypes[at][index], S.TypeCtxs[at])

                      if (ArgType === undefined) ArgType = _onlyUndefined
                      else if (ArgType === null)
                        error("We can't just fail to self-refine needed input type:", S.StaticTypes[at][index], 'in', new Map(S.TypeCtxs[at]))
                    }
                    let HS
                    const DT = ArgType !== _onlyUndefined ? ArgType : undefined
                    if (instance.visual && I === "update") {
                      vArgInds[N-1] = index
                      vTypes[N] = DT
                      _humanDAGAsk("Node hierarchy", vNodes, vTypes, vArgInds)
                      I = "wait"
                    }

                    // Schedule a node for the next arg.
                    const n = _usingRequest(0, DT, undefined, null, allowed)
                    if (S.Childs[at][index-1] !== n) error("Assertion failed: non-equal", S.Childs[at][index-1], n)


                    ArgType = undefined
                    if (instance.visual) I = "update"

                    // Declare this arg as scheduled.
                    S.Progress[at] = index+1
                    // "Once done" cases below must not be allowed to run until the sub-nodes return to us.
                    if (S.UpTypes[at] !== null) { if (innerStack.length) break; else continue }
                  } catch (err) {
                    if (err === interrupt) interrupt.stack.push(ArgType, allowed, N, I, J, vNodes, vTypes, vArgInds, vCache)
                    throw err
                  }
                } else if (isVarExpr) needed = 2
              }
            stage = 5;  case 5:
              // Once done, if the node kind defines `usingFinish` (from `ChildEmbs ChildTypes ChildNodes Node` to `UpEmb UpType Node`), call that.
              //   (Post-order traversal override.)
              if (S.Progress[at] >= needed && custom) {
                const repr = at
                const kind = S.AreCalls[repr]
                if (typeof defines(kind, usingFinish) != 'function') error(kind, "must define", usingFinish)
                let [UpEmbs, UpTypes, UpNodes] = interrupt(3)
                try {
                  if (UpEmbs === undefined)
                    if (S.Childs[repr]) {
                      const n = S.Childs[repr].length
                      UpEmbs = _allocArray(n), UpTypes = _allocArray(n), UpNodes = _allocArray(n)
                      for (let k=0; k < n; ++k) {
                        const i = S.Childs[at][k]
                        UpTypes[k] = S.UpTypes[i], UpNodes[k] = S.Nodes[i]
                      }
                    }
                  const b = defines(kind, usingFinish)(UpEmbs, UpTypes, UpNodes, S.Nodes[repr])
                  if (isArray(b)) {
                    [S.UpEmbs[at], S.UpTypes[at], S.Nodes[at]] = b
                    _allocArray(b)
                  }
                } catch (err) { if (err === interrupt) interrupt.stack.push(UpEmbs, UpTypes, UpNodes); else _disposeEachAndDealloc(UpEmbs), _killArray(UpTypes), _killArray(UpNodes);  throw err }
              }
            stage = 6;  case 6:
              // Once done, compute UpEmb and update the parent Node.
            stage = 7;  case 7:
              // Refine up-types.
              if (S.Progress[at] === needed && !custom) {
                if (S.AreCalls[at] === undefined)
                  S.UpTypes[at] = null
                else if (S.AreCalls[at] === false) {
                  S.UpTypes[at] = typeRefine(S.StaticTypes[at], S.DownTypes[at], S.TypeCtxs[at])
                  if (S.Nodes[at] && Object.getPrototypeOf(S.Nodes[at]) === bound) S.Nodes[at].variable = "used"
                } else if (S.AreCalls[at] === true && S.UpTypes[at] !== null) {
                  const T = S.StaticTypes[at]
                  if (S.Chosen[at] !== bound)
                    S.UpTypes[at] = typeRefine(T[T.length-1], T[T.length-1], S.TypeCtxs[at])
                  else
                    S.UpTypes[at] = S.DownTypes[at]
                }
              }
              // Also, once done, set our node in parent node.
              if (S.UpTypes[at] !== null && !prevFailed && S.PrevSiblings[at] !== null && isArray(S.Nodes[S.Parents[at]]) && !custom)
                S.Nodes[S.Parents[at]][S.ArgInds[at]] = S.Nodes[at]
            stage = 8;  case 8:
              // Once done, refine parent's type context.
              if (S.UpTypes[at] !== null && !prevFailed && S.PrevSiblings[at] !== null && !custom) {
                if (!prevFailed) {
                  let p = S.Parents[at]
                  while (!S.TypeCtxs[p] && S.Parents[p] !== null) p = S.Parents[p]
                  if (S.TypeCtxs[p] && typeRefine(S.DownTypes[at], S.UpTypes[at], S.TypeCtxs[p]) === null) S.Nodes[at] = S.UpTypes[at] = null
                } else
                  S.UpTypes[at] = S.Nodes[at] = null
              }
            stage = 9;  case 9:
              // Once done, refine parent's embedding context.
            stage = 10;  case 10:
              // Once done, remember that calls exist. (`regenerate` should finish this.)
              if (S.UpTypes[at] !== null && !prevFailed && S.AreCalls[at] === true) {
                const aw = alloc.world, At = alloc.params.At
                aw.NodeTypes[At].set(S.Nodes[at], S.UpTypes[at])
              }
              if (interrupt.stack && interrupt.stack.length) error("Interrupt stack corruption: not empty:", ...interrupt.stack)
            stage = 11;  case 11:
              // If we failed, siblings and parents fail too. Cruel.
              if (S.UpTypes[at] === null && !custom) {
                if (!prevFailed && S.PrevSiblings[at] !== null) { // ArgFailed
                  const parents = S.Parents[at]
                  S.UpTypes[parents] = S.Nodes[parents] = null
                }
                needed = 1, S.Nodes[at] = null
              }
            stage = 12;  case 12:
              // When the last scheduled arg is done, return to parent.
              //   (If a `bound` node failed an arg and got set to `null`, or if we failed for other reasons, `needed` will now be `1`, so here, we do `>= needed` and not equality.)
              if (S.Parents[at] !== null) {
                --S.ArgsLeft[S.Parents[at]]
                if (!S.ArgsLeft[S.Parents[at]])
                  S.Evals.push(S.Parents[at])
              }
              // Also, dealloc Maps when done.
              if (S.TypeCtxs[at] instanceof Map)
                _allocMap(S.TypeCtxs[at]), S.TypeCtxs[at] = undefined
          }
          if (innerStack.length) break
        }
        prevInnerStack && prevInnerStack.push(null)
        S.at = null
      } catch (err) {
        if (err === interrupt) interrupt.stack.push(stage, needed, innerStack)
        else if (err !== limit) S.i = null
        else {
          prevInnerStack && prevInnerStack.push(null)
        }
        throw err
      } finally {
        env[ial] = prevAdjLoad, env[ias] = prevAdjSave
        const spotDiffers = alloc.world !== prevWorld || alloc.At !== prevAt
        alloc.world = prevWorld, alloc.params = prevParams, alloc.At = prevAt, spotDiffers && _fillObjectHyperparams(prevWorld, prevAt)
        _allocArray(curCtxs), prevParams && (prevParams.GenContexts = prevCtxs)
        regenerate.depth = null
        usingFinish.innerStack = prevInnerStack
        prevInnerStack && (S.i = prevSI, S.at = prevSAt)
      }
    },
  },

  _defined(x) { return x !== undefined ? x : 0 },

  _killArray(a) { isArray(a) && _allocArray(a) },

  _chooseHeadAsync:{
    docs:`\`_chooseHeadAsync:DownEmb→DownType→HeadState\`
Prepares to call \`_chooseHead\` (which would do a CPU \`sync\`). This is separated for parallel-processing speed, so that we can schedule all embedding-computing commands that we can before we request their results.`,
    call(DownEmb, DownType, Allowed, At = alloc.params.At) {
      // `Allowed` is null or a sorted array of indexes of what's allowed in the very-temporary value context.
      if (isArray(DownType) && DownType[0] === quote) return "PUT AS VALUE"
      if (isArray(DownType) && defines(DownType, _chooseHead) !== undefined) return "GOT THE FUNC"
      const ctxs = alloc.params.GenContexts
      let [stage = 0, Fits, maxI, prediction, begin] = interrupt(5)
      try {
        switch (stage) {
          case 0:
            // Get candidates: filter GenContexts with `DownType` (if too deep, disallow calls), into `(… ContextIndex ItemIndex …)`.
            const HP = defines(alloc.world, deconstruct)[1]
            const allowCalls = regenerate.depth < HP.MaxDepth && alloc.world.Nodes[At] < HP.MaxDAGNodes
            Fits = _genCtxsFilter(ctxs, DownType, allowCalls)

            // Filter out what we don't want: obvious self-recursion and not-in-scope temporary vars.
            let n = 0, ai = 0
            for (let i = 0; i < Fits.length; i += 2) {
              const mi = Fits[i], mj = Fits[i+1]
              if (mj) {
                const selfRecursing = ctxs[mi][0] && ctxs[mi][mj] === alloc.params.Object
                let notInScope = false
                if (mi === 8 && isArray(Allowed)) { // The set of tmp vars can change, and this filtering-out allows re-using embeddings/grads.
                  while (ai < Allowed.length && Allowed[ai] < mj) ++ai
                  notInScope = (Allowed[ai] !== mj)
                }
                if (!selfRecursing && !notInScope)
                  [Fits[n++], Fits[n++]] = [Fits[i], Fits[i+1]]
              } else [Fits[n++], Fits[n++]] = [Fits[i], Fits[i+1]]
            }
            Fits.length = n

            if (!Fits.length) // Fail.
              return _allocArray(Fits), "NO CANDIDATES"
          stage = 1;  case 1:
            // Compute embeddings to pass to `Choose` (all of them, `stack`ed).
          stage = 2;  case 2:
            // `_choose` the func/value among `AllUseAs` with `Choose`, then shadow the choice with `ChoiceEmbedder`; then with `typeRefine`.
            if (!instance.visual) {
              if (begin === undefined) begin = adjustUndo()
              maxI = randomNat(Fits.length>>>1), prediction = 0
            } else { // Human UI for explainability (show only nodes and types, and no other info).
              // `begin` poses as `types` here, to not allocate a new interrupt-state spot.
                // `typeRefine` can't interrupt here, but it will consume interrupt-stack space.
              const nodes = [], calls = []
              const DT = _typeFinalize(DownType)
              if (begin === undefined) begin = _allocArray(Fits.length>>>1)
              for (let i = 0; i < Fits.length; i += 2) {
                const mi = Fits[i], mj = Fits[i+1], V = ctxs[mi][mj]
                nodes[i>>>1] = V && Object.getPrototypeOf(V) === bound ? label('v'+_id(V)) : V
                begin[i>>>1] === undefined && (begin[i>>>1] = bound(x => typeof x != 'string' ? undefined : label(x), typeRefine(ctxs[mi][mj+1], DT, undefined, true)))
                calls[i>>>1] = ctxs[mi][0]
              }
              maxI = _humanDAGAsk("Ask", nodes, begin, calls) || 0
              prediction = 0
              begin = undefined
            }
          stage = 3;  case 3:
            const a = _allocArray(5)
            ;[a[0], a[1], a[2], a[3], a[4]] = [Fits, 0, maxI, prediction, begin !== undefined ? call.env[_id(adjustSave)].splice(begin) : null]
            return a
        }
      } catch (err) {
        if (err === interrupt) interrupt.stack.push(stage, Fits, maxI, prediction, begin)
        else Fits && _allocArray(Fits), dispose(maxI), dispose(prediction)
        throw err
      }
    },
    dispose(a) { isArray(a) && (_allocArray(a[0]), dispose(a[1]), dispose(a[2]), dispose(a[3]), _destroyAdjustmentStack(a[4]), _allocArray(a)) },
  },

  _chooseHead:{
    docs:`\`_chooseHead:DownEmb→DownType→HeadState→(UseAs&EmbCtx&HaveType&TypeCtx&Node&IsCall&DownEmb)\`
Chooses what \`regenerate\` should generate.

Must always immediately follow after \`_chooseHeadAsync\`. Consumes \`HeadState\`.

\`type\` of the chosen option usually \`defines\` \`HaveType\`.

\`UseAs\` and \`HaveType\` encode what is statically needed for embeddings and types.
    (\`UseAs\`: a \`tensor\`. \`HaveType\`: \`(funcType …?)\` if \`IsCall\` is \`true\`, or anything.)
\`EmbCtx\` and \`TypeCtx\` encode what is dynamically the context for embeddings and types.
    (\`EmbCtx\`: a \`tensor\`. \`TypeCtx\`: a \`map\`, the third arg to \`typeRefine\`.)

If \`IsCall\` is \`false\`, \`Node\` is the DAG that computes a value, and it doesn't deserve to be saved in temporary generation contexts.
If \`IsCall\` is \`true\`, \`Node\` is the function to call.

The head of an array \`DownType\` \`defines\` this with the func that will replace it as the head of the generated call (instead of choosing the func/value) (the rest of args are generated from the given types). This accomodates \`tupleType\`.`,
    call(DownEmb, DownType, HeadState) {
      if (HeadState === "PUT AS VALUE") {
        // Quoted type, put it as value.
        const HP = defines(alloc.world, deconstruct)[1]
        const Value = quote(_typeFinalize(DownType[1]))
        const a = _allocArray(8)
        ;[a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]] = [0, null, DownType, _allocMap(), Value, false, keep(DownEmb), DownType]
        return a
      } else if (HeadState === "GOT THE FUNC") {
        // Don't choose the func, it's right here. (…Though its embedding is not, so tuple generation should underperform.)
        const Type = [funcType, ...DownType.slice(1), DownType]
        const Func = defines(DownType, _chooseHead)
        const Node = _allocArray(DownType.length).fill();  Node[0] = Func
        const a = _allocArray(8)
        // Technically, we need a hyperparameter here, for EmbCtx, because types mismatch now. Practically, who cares.
        ;[a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]] = [keep(DownEmb), keep(DownEmb), Type, _allocMap(), Node, true, keep(DownEmb), DownType]
        return a
      } else if (HeadState === "NO CANDIDATES") {
        const a = _allocArray(8);  a[6] = keep(DownEmb), a[7] = DownType;  return a
      }

      if (_isDisposable(HeadState[2])) { const t = sync(HeadState[2]);  dispose(HeadState[2]), HeadState[2] = t }
      if (_isDisposable(HeadState[3])) { const t = sync(HeadState[3]);  dispose(HeadState[3]), HeadState[3] = t }

      let [Fits, AllUseAs, maxI, prediction, AdjStack] = HeadState

      let mi, mj
      mi = Fits[maxI*2], mj = Fits[maxI*2+1]

      if (typeof mi != 'number' || typeof mj != 'number') error("Huh:", mi, mj, "given Fits", Fits, "and maxI", maxI)
      const ctxs = alloc.params.GenContexts, IsCall = !!ctxs[mi][0]
      let Node = ctxs[mi][mj], HaveType = ctxs[mi][mj+1]
      let [stage = 0, TypeCtx = _allocMap(), typeError = false, Type] = interrupt(4)
      try {
        const p = alloc.params
        switch (stage) {
          case 0:
            // And splice in the adjustment stack (to pretend that `_chooseHeadAsync` happened right here), and make choices independent if necessary.
          stage = 1;  case 1:
          stage = 2;  case 2:
          stage = 3;  case 3:
            // Shadow the choice with type-context refinement.
            if (Node === bound) {
              Type = undefined, _allocMap(TypeCtx), TypeCtx = null
            } else if (IsCall === true) {
              const def = _funcTypeOf(defines(Node, type))
              if (!isArray(def) || def[0] !== funcType || def.length <= 1)
                error("Expected a func type, but got", def, "for func", Func)
              if (HaveType !== def[def.length-1])
                error("Function type mismatch: output type of", Node, "is", def[def.length-1], "but ctx has", HaveType)
              if (typeRefine(HaveType, DownType, TypeCtx) === null)
                typeError = true
              Type = def // Know args of types.
            } else Type = HaveType
          stage = 4;  case 4:
            // Use the embedding, modifying it in-place (but only if in very-tmp ctx, because all other types should be finalized anyway).
          stage = 5;  case 5:
            // Shadow the choice with embedding-context refinement.
            if (!typeError) {

              // Also, if picked a node, remember this fact, to not go over limits later.
              if (IsCall) ++alloc.world.Nodes[p.At]
            }
          stage = 6;  case 6:
            // Save the picked `UseAs` and in-context indexes (for adjustment).

            HeadState[1] = null, _allocArray(HeadState), HeadState = null

            if (typeError) {
              const a = _allocArray(9)
              a[0] = 0, a[6] = keep(DownEmb), a[7] = DownType, a[8] = PublicData
              TypeCtx && _allocMap(TypeCtx)
              return a
            }

            // Return a whole call to fill (with empty spots for args), not just its func.
            if (IsCall) { const N = Node;  Node = _allocArray(N === bound ? 5 : Type.length-1).fill();  Node[0] = N }

            const a = _allocArray(9)
            ;[a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]] = [0, 0, Type, TypeCtx, Node, IsCall, keep(DownEmb), DownType, null]
            return a
        }
        error("_chooseHead got an unrecognized stage (interrupt-state corrupted):", stage, TypeCtx, 'with last interrupt at', _resolveStack(interrupt.last))
      } catch (err) {
        if (err === interrupt) interrupt.stack.push(stage, TypeCtx, typeError, Type)
        else TypeCtx && _allocMap(TypeCtx), defines(_chooseHeadAsync, dispose)(HeadState)
        throw err
      }
    },
    dispose:_(`_disposeEachAndDealloc`),
  },

  Types:{
    docs:`A way to separate possible from impossible.`,
    tutorial:[
      `It's always a good idea to take your time to know what words mean. So.

Types…

The chirping of crickets in a meadow under a darkening sky…

An infant's cry, prompting hope of a new life, before the baby gets up and trots away…

A body full of life and nutrients, being consumed by maggots crawling under the skin, turning it into a dessicated shell…

Types are none of those.

Types rigidly define what programs are correct, for generating programs.
Ever since humanity first said "if X then Y", it was always trying to put the world into some rigid system.
But types also have a purpose that actually has meaning: to rigidly guide program generation away from wrong paths. It's for efficiency.

Types are supposed to contain values, and here, all we care about is extracting properly-typed values from what we have.
With \`instance\`, we can check correctness of implementation, which is all that we really need in life.
Something like this is what we want:`,
      [
        _(`fancier`),
        `instance ^DAGType(^(1 2 3))`,
        function(r) { return isArray(r) && r[0] === quote && r[1][0] === 1 && r[1][1] === 2 && r[1][2] === 3 },
      ],
      `I understand why you don't want to continue.
Types are scary. It's one of the T-words, same as tarantulas and T-posing.
Despite all the possible words about unconstrained intelligence of humans, we are still animals, and have only three responses to fear {https://rdcu.be/NdvN}.
The least stressful is to freeze, and remain oppressed by slavery and ignorance. To run away is scarier, and does not help much in slavery and ignorance.
To head to danger is scariest, but it also rewards circuits that maximize dopamine. And to reward those circuits of yours even more, the least I can do is give you unconditional love.
So, remember, even through darkest times: you will always love me.



Before we continue, we must understand exactly how we will specify and use types.

Program generation (\`regenerate\`) either {picks-and-returns a value} or {picks a function and recurses to generate its arguments}.
To give this process human-defined structure, generation is augmented with types: also given a type statically (attached to the value/func candidate), also given a type dynamically (wants), also return a type (is) (\`instance\` omits the returned type, and only gives the value).

In particular, we go down-right-up:
    Down: any value/func will have its static/output type \`typeRefine\`d with the dynamic (wanted) type, and the non-\`null\` one is picked. This creates the type context.
    Right: if making a call, we also generate func args, progressively refining the type context with the returned refined types.
    Up: then we return the refined output type.

\`typeRefine\` refines equal-length arrays item-wise, and non-arrays must be reference-equal. \`null\` indicates failure.
We can also have type variables (a \`'string'\`), and a context that holds their values (the same for each generated call).

Some examples of type refinement (feel free to change):`,
      [
        _(`fancier`),
        `typeRefine 1 2`,
      ],
      [
        _(`fancier`),
        `typeRefine ^(1 2 'c') ^('a' 'b' 'b')`,
      ],
      [
        _(`fancier`),
        `typeRefine arrayType('a',5)⇒'a' arrayType(tensorType 1 2 3,5)⇒(tensorType 1 2 3)`,
      ],
      `That was an account of how we generate DAGs (Directed Acyclic Graphs: here, a network of arrays without cycles-like-\`a a:(0 1 2 a 4 5)\`; a \`call\`'s output (array) can be another \`call\`'s input (array item)).

But the general case of arbitrary connectivity also includes cycles (for example, in function graphs, such cycles are named "recursion").

So how would we combine "take and return a type" with "has cycles"? We need a fixed point.

There are two ways: either do \`typeRefine\` on a cycle until it converges (we contrived the type-language to make this automatic and instant), or specify "what that would converge to" directly.

We have the luxury of doing the latter. Top-level generation (such as \`instance\`) requires that a type \`defines\` \`alloc\`.
Such types are \`\`definersOf alloc\`\`.


Now, with that knowledge, let's go into testing mode.
Of course, I cannot actually give you understanding, but I can give you tools to learn it.
Let hovering (highlighting equal values, especially useful for complex graphs) (\`v\` in \`Commands\` or \`\`settings ^_hoverHighlightsDOMValues\`\` toggles it) and right-clicking (\`contextMenu\`s showing \`Types\`, and \`basic\` serializations, removing ambiguity) hold your hand when you're lost.`,
      [
        _(`fancier`),
        `A:(concept type funcType(0) call func(5))`,
      ],
      [
        _(`fancier`),
        `instance ^DAGType(0) ^A()`,
      ],
      `Now, put output as input:`,
      [
        _(`fancier`),
        `B:(concept type 0⇒1 call 0→0*3)`,
      ],
      [
        _(`fancier`),
        `instance ^DAGType(1) ^(A B)`,
      ],
      `Now, let's generate not just naked DAGs but \`func\`tions.

Graphs of those can see each other, and decide to recurse (often causing an infinite loop on execution). With \`Types\`, it's theoretical generality that we're after, not practicality.
But in the simple case of one func, we exclude self-recursion because we cannot generate control-flow (\`select\`) within one func (though func-as-value is still permitted).
\`0⇒2\` here cannot recurse:
`,
      [
        _(`fancier`),
        `C:(concept type 1⇒2 call 1→1*7)`,
      ],
      [
        _(`fancier`),
        `instance ^funcType(0,2) ^(B C)`,
      ],
      `Don't worry about what exactly the \`docs\` say the generated \`autoFunc\`s are.
Suffice to say, they're surprise tools that will help us out later.
For now, let the voice of love guide you to the light.

Now.
Something mildly non-trivial: passing a function in.
Evaluate the thing below, and you will get something that no one on this planet has ever seen before.
Do it several times. Often, the body will be \`null\`, indicating failure (we don't backtrack if choices have led to impossible types, or if we're in too deep); sometimes, a simple DAG; sometimes, an unsightly abomination out of this world.
`,
      [
        _(`fancier`),
        `instance ^funcType(arrayType(0,'a'),0) ^(A getLast loop (concept type 0⇒0⇒0 call add))`,
      ],
      `The thing above may not generate complex structure often, because the generality of types of \`getLast\`/\`loop\` misleads like the devil, but it does happen. For those cases, how about \`\`settings ^_colorVariables\`\`? Your world, your rules.

But functions are not the only things of relevance.
A \`concept\` \`defines\` functions. This is used very often in Conceptual, so we'd like to auto-use this.
For example, if ignoring \`mergeAdjustment\`/\`adjustSave\`/\`adjustLoad\`, definitions of \`adjust\` should be like:`,
      [
        _(`fancier`),
        `D:(concept type 0⇒1⇒2 call mul)`,
      ],
      [
        _(`fancier`),
        `E:(concept type 2⇒0 call exp)`,
      ],
      [
        _(`fancier`),
        `F:(concept type 2⇒1 call log)`,
      ],
      [
        _(`fancier`),
        `instance ^(conceptType call funcType(A,B,O) adjust DAGType(A&B,_ins _out _dout,A&B O O)) ^(D E F) A:0 B:1 O:2`,
      ],
      `You've done well so far.

["Eyes. Grant us eyes."]
Oh.
That's right.
Bugs can only be rooted out with perfect control over their environment.
Experiencing what an algorithm experiences is the best way to understand it, and so it's the only way.

How about this:`,
      [
        _(`fancier`),
        `instance ^DAGType(0&1,_ins _out _dout,0&1 2 2) ^(D E F) true`,
        function() { return true },
      ],
      `It's not a very polished UI because I'm tired of making them, but it's good enough.

I'd recommend returning to that \`loop\`/\`getLast\`-using example and adding \`true\` at the end, and playing around with it to get an intuition.
  An example insight is that \`getLast\` often tries to look for arrays with items of non-existent types, failing the generation.
    Another is: \`loop\` is rarely used randomly, but manually, we know what to avoid and compose 9-loops-deep towers.
      Another is that variables (\`a+a*2 a:?\`) are used first and \`bound\` later.
        Another is that max depth is 10.


Next, we'll be annotating some useful functions of \`Self\` with types.
It's like crawling along the ground, I know, but we cannot automatically generate anything without this.
Everything will eventually be surpassed, so we'd like to specify not the structures that we ourselves made, but how to make them.
\`\`elemCollapse \\elem('text','["You''re doing it so that you don''t have to do it? Your story makes no sense."] Tsk, tsk. Not what I said. The goal is everything, not nothing.')\`\`
That's the real purpose of Conceptual. Tutorials are one way of doing that; auto-generation is another.


Okay, the annotating is now over.
We have \`\`definersOf(type).'length'\`\` \`type\`d functions: \`\`elemCollapse \\serialize(definersOf(type),basic,undefined,serialize.'displayed')\`\`.
Users ought to use them all, meaning that \`definersOf(type)\` should be the generative context.

We have \`exp\`, typed \`\`defines exp type\`\`.
We have \`zeros\`, typed \`\`defines zeros type\`\`.
We have \`matMul\`, typed \`\`defines matMul type\`\`.
Machine learning is gone, reduced to atoms.

We have \`last\`, typed \`\`defines last type\`\`.
We have \`transform\`, typed \`\`defines transform type\`\`.
We have \`loop\`, typed \`\`defines loop type\`\`.
Space of programs rapidly expands.

We have \`try\`, typed \`\`defines try type\`\`.
We have \`limitTime\`, typed \`\`defines limitTime type\`\`.
We have \`select\`, typed \`\`defines select type\`\`.
Everything of value becomes isolated islands in a sea of darkness, impossible to see or reach.
Eternal greatness exists only within humans.
Sing a song of sorrow in a world
where love has perished.
`,
      [
        _(`fancier`),
        `instance arrayType(tensorType 64,'Length')⇒tensorType(64) definersOf(type) true`,
        function() { return true },
      ],
      `I spent so long fixing bugs, I forgot what the narration was supposed to be.
Many are still un-fixed, but most do not complain by throwing \`error\`s.
Good enough for now. I've had enough.

Um…

Ah, yes, simply look at how many \`null\`s there are in random generation, and how pointless the non-\`null\` functions are.
And when picking manually, look at how many superfluous options like \`limitTime\` or (often) \`getLast\` there are.
Superfluous as long as we have no functions that we'd like to call/limit, or arrays of what we need, that is.

What went wrong with random typed generation?

There are three things, actually: random, typed, and generation.

  🖤 Random.
      This system picks randomly, whereas your brain is even incapable of that, having to rely on dice and such for random number generation.
      You maximize something else: a prediction that depends on where you are in the generation, extremely vaguely described as "how interesting is this".
      The UI suggests that it is inferred from reading the half-complete state \`\`elemCollapse(elem 'text' '(in machine learning, this suggests recurrent models, such as GPT models)')\`\`, but you can also follow the process and infer it from the history of what args we need and what calls we created (down then right then up the call tree), which also is exactly the flow of type computation \`\`elemCollapse(elem 'text' stringToDoc('(in machine learning, this means recurrent and recursive NNs combined to faithfullt represent the call tree)'))\`\`.
      …The prediction for an option could also depend on other options \`\`elemCollapse(elem 'text' 'such as "(do we have arrays of this type, or could we make, or do we even want to")')\`\`. \`regenerate\` (and its \`Choose\`) imposes separation of options, though, which can allow great efficiency but is also a special case.
      This covers all possible inferences anyone could make from recursively-picked arrays of options (which creates DAGs for our \`func\`tions).

  🖤 Typed.
      This system shadows every generated value (DAG node) with its type, which is a thing with pre-defined refinement rules with some properties (mostly transitivity and associativity).
      Language of types is Turing-complete \`\`elem 'text' '(at least in theory; my own version/implementation may be bad)'\`\`, and is useful for low-level code and proof checking, but not much else.
      ["But types are great for ① describing all possible behaviors and side-effects of functions, ② documenting code, and ③ ensuring user mistakes are impossible."]
      Boy. Your definition of "great" needs work. It's probably the Stockholm syndrome talking.
      ① Where's the "this is probably fast/slow" type? Where's the "this can be partially-evaluated under these conditions" type, or the "this particular arrangement of functions will delete all files" type, or the "divide by two, times three, related to this thing, with some offsets that make sense" type, or the "this particular arrangement of functions is likely to cause this much dopamine to be released in this user's brain" type? Adding more types will always improve the situation at the cost of maintenance, but will never cover everything.
      ② Don't try to shore up deficiencies of picking systems (such as randomness) with more precise type systems. Don't pretend that you know everything. Docs should be more of a suggestion, for optimal usage.
      ③ There is another way of making mistakes impossible: make users never make mistakes, and deliver all information perfectly. A programming environment can deliver things precisely (which is why Conceptual is a programming environment too). And if you control the user, such as if it is a program that you make, then just… fix bugs, and allow learning from mistakes.
      (I can't even begin to tell you how annoying type purists and evangelists are: just like any other religion.)

  🖤 Generation.
      The only real way to learn is to make mistakes, and repeat.
      \`call\` is not enough, we want \`callAdjust\`.
      Regeneration is what we want.


Well, if random typed generation is so bad, then the natural question is: what will replace it?
Have you ever heard about reinforcement learning, and machine learning? \`\`elemCollapse(elem 'text' '(You thought I would add something here, but I won''t.)')\`\`
Have you ever heard of learnable embedding of operations? \`\`elemCollapse(elem 'text' '(For example, MuZero learns to plan: shadow all environment responses to its actions and unroll action sequences.)')\`\`

But that's another story for another day.



For now, have this snack, you've earned it: 🥔🥕🍄.

And click this button too, you've earned it: \`\`button (jsEval "function() { localStorage.Types = '1' }") "completedTypes" "Unlocks neural DAG regeneration."\`\`.

And have these \`REPL\`s too, you've earned it: \`\`elemCollapse func(REPL fancier)\`\` \`\`elemCollapse func(REPL fancy)\`\` \`\`elemCollapse func(REPL basic)\`\` \`\`elemCollapse func(REPL stringLanguage)\`\`.


With this initial crack at auto-regeneration completed, \`tutorial regenerate\` is now unlocked. Check it out, and goodbye.`,
    ],
    philosophy:`In the now-distant past, everytime I tried to express my inner soul or ideals I would end up looking like a cringeworthy idiot, so I learned to block out my own randomness. Now I learn to take risks. Let's take some.`,
    readAt:{
      DAGType:_(`DAGType`),
      conceptType:_(`conceptType`),
      computeType:_(`computeType`),
      tensorType:_(`tensorType`),
      tupleType:_(`tupleType`),
      arrayType:_(`arrayType`),
      boolsType:_(`boolsType`),
      funcType:_(`funcType`),
      sumType:_(`sumType`),
      instance:_(`instance`),
      type:_(`type`),
      typeRefine:_(`typeRefine`),
    },
  },

  computeType:{
    merged:true,
    docs:`What? To compute a 100-element tensor, you need a 200-element tensor? Not a problem!
\`computeType Computer VarName\`: to refine, computes the type from other variables.
In \`type\`s of functions, only put this in inputs, not the output. And depend only on vars in either output or previous inputs.
\`VarName\` is optional. \`Computer\` is a function from the matching context (a \`map\`) and the matched type to the computed type (which is refined with \`VarName\` if that is present) and the "are matched types equal"/"should we return self if the type cannot be computed" bool, to the type or \`undefined\`.`,
    typeRefine(a,b) {
      if (isArray(b) && b[0] === computeType) [a,b] = [b,a]
      if (isArray(a) && a[0] === computeType) {
        if (typeof a[1] != 'function') error(computeType, 'got malformed types:', a, b)
        let [T] = interrupt(1)
        try {
          if (T === undefined) T = a[1](typeRefine.ctx, b, a === b), T === undefined && (T = _onlyUndefined)
          if (T === null) return null
          if (isArray(T) && T[0] === computeType && typeof T[1] != 'function') error('got malformed type', T, 'from', a, b)
          if (a[2] === undefined) return T !== _onlyUndefined ? T : undefined
          if (T !== _onlyUndefined) {
            if (!typeRefine.vars.has(typeRefine.ctx.get(a[2]))) T = typeRefine(T, a[2])
            return _isTypeVar(T) ? _resolveTypeVar(T) : T
          }
          return a !== b ? a[2] : a
        } catch (err) { if (err === interrupt) interrupt.stack.push(T);  throw err }
      }
      error()
    },
    call(cmp, name) { return merged(name ? [computeType, cmp, name] : [computeType, cmp]) },
  },

  tensorType:{
    merged:true,
    docs:`\`tensorType …Sizes\`: a type of \`tensor\`s with specified sizes.
\`tensor\`s of booleans (\`false\`/\`true\`) are typed as \`boolsType ?\` instead.
(From \`typeRefine\`'s perspective, this is just an array, nothing special.)`,
    typeAdjustmentMerger(tp) { const a = _allocArray(2);  [a[0], a[1]] = [_mergeTensors, tensorType];  return a },
    typeDisposer(tp) { const a = _allocArray(2);  [a[0], a[1]] = [dispose, tensorType];  return a },
    call(...szs) { return merged([tensorType, ...szs]) },
  },

  tupleType:{
    merged:true,
    docs:`\`tupleType …Tps\` or \`A&B&C\`: the type of heterogenously-typed arrays (each item has its own type).
Pushing this to a generative context pushes every item instead.
Generating this generates \`array …Instances\`.`,
    pushToContext(ctx, Node, Type, PublicEmbData) {
      if (!isArray(ctx) || ctx[0]) return void ctx.push(Node, Type, PublicEmbData)
      for (let i = 1; i < Type.length; ++i)
        pushToContext(ctx, [readAt, Node, i-1], Type[i], 0)
    },
    _chooseHead:_(`array`),
    typeAdjustmentMerger(tp) {
      const mergers = _allocArray(tp.length-1), upTp = _allocArray(tp.length)
      upTp[0] = tupleType
      for (let i = 1; i < tp.length; ++i) {
        const sub = typeAdjustmentMerger(tp[i])
        mergers[i-1] = sub[0], upTp[i] = sub[1], _allocArray(sub)
      }
      try { return [getMerger(mergers), merged(upTp)] } finally { _allocArray(upTp) }
      function getMerger(itemMergers) { return function(arrs) { return _mergeTuples(arrs, itemMergers) } }
    },
    typeDisposer(tp) {
      const disposers = _allocArray(tp.length-1), upTp = _allocArray(tp.length)
      upTp[0] = tupleType
      let uniform = true
      for (let i = 1; i < tp.length; ++i) {
        const sub = typeDisposer(tp[i])
        disposers[i-1] = sub[0], upTp[i] = sub[1], _allocArray(sub)
        if (disposers[i-1] !== disposers[0]) uniform = false
      }
      if (uniform) // If all disposers are the same, do .forEach instead of case-by-case disposing.
        try { return [(function(itemDispose) { return function(x) {
          if (isArray(x)) x.forEach(itemDispose), _allocArray(x)
        }})(disposers[0]), merged(upTp)] } finally { _allocArray(disposers), _allocArray(upTp) }
      try { return [getDisposer(disposers), merged(upTp)] } finally { _allocArray(upTp) }
      function getDisposer(itemDisposers) { return function(x) {
        if (!isArray(x)) return
        for (let i=0; i < itemDisposers.length; ++i) itemDisposers[i](x[i])
        _allocArray(x)
      } }
    },
    call(...a) { return merged([tupleType, ...a])},
  },

  arrayType:{
    merged:true,
    docs:`\`arrayType Type Length\`: the type of homogenously-typed arrays of possibly-unknown length (each item has the same type).`,
    typeAdjustmentMerger(tp) {
      if (isArray(tp[1]) && tp[1][0] === tensorType)
        return [_mergeArrays, arrayType]
      const sub = typeAdjustmentMerger(tp[1])
      if (sub[0] === null) try { return [null, merged([arrayType, sub[1]])] } finally { _allocArray(sub) }
      try { return [getMerger(sub[0]), merged([arrayType, sub[1]])] } finally { _allocArray(sub) }
      function getMerger(itemMerger) { return function(arrs) { return _mergeArrays(arrs, itemMerger) } }
    },
    typeDisposer(tp) {
      if (isArray(tp[1]) && tp[1][0] === tensorType)
        return [_disposeEachAndDealloc, arrayType]
      const sub = typeDisposer(tp[1])
      if (sub[0] === null) try { return [_allocArray, merged([arrayType, sub[1]])] } finally { _allocArray(sub) }
      try { return [getDisposer(sub[0]), merged([arrayType, sub[1]])] } finally { _allocArray(sub) }
      function getDisposer(itemDispose) { return function(x) { if (isArray(x)) x.forEach(itemDispose), _allocArray(x) } }
    },
    call(t,l) { return merged([arrayType, t, l])},
  },

  boolsType:{
    merged:true,
    docs:`\`boolsType …Sizes\`: a type of \`tensor\`s of booleans (\`false\` or \`true\`).
(From \`typeRefine\`'s perspective, this is just an array, nothing special.)`,
    typeDisposer(tp) { const a = _allocArray(2);  [a[0], a[1]] = [dispose, tensorType];  return a },
    call(...szs) { return merged([boolsType, ...szs]) },
  },

  funcType:{
    merged:true,
    docs:`\`funcType …Inputs Output\` or \`Input1⇒Input2⇒Input3⇒Output\`: a type of \`func\`s (fixed-arg-count transformers of values).
Allows accepting and returning functions with a known signature.

(From \`typeRefine\`'s perspective, this is just an array, nothing special.)`,
    readAt:{
      madeType:_(`madeType`),
      autoFunc:_(`autoFunc`),
    },
    call(...a) { return merged([funcType, ...a]) },
    alloc(Type) {
      const HP = defines(alloc.world, deconstruct)[1]
      const d = [autoFunc, Type, null]
      return construct(d) || null
    },
    using:{
      docs:`On pre-order traversal, create an instance of \`Output\`.`,
      call(DownEmb, DownType, Obj) { regenerate(DownEmb, DownType[DownType.length-1], Obj) },
      adjust(ins) { return defines(regenerate, adjust)(ins) },
    },
    usingFinish:{
      docs:`On post-order traversal, set the DAG to what we created and re-compile (if needed).`,
      call(ChildEmbs, ChildTypes, ChildNodes, Obj) {
        const d = defines(Obj, deconstruct), v = ChildNodes[0]
        if (v !== undefined) d[2] = v, construct(d, Obj)
      },
    },
    createLocalContexts(Obj, Type, PublicEmbData) {
      // Know of the func's own inputs.
      if (Type.length <= 2) return
      const InnerCtxF = [true], InnerCtxV = [false]
      for (let i = 1; i < Type.length-1; ++i) {
        const tp = _funcTypeOf(Type[i]), emb = 0
        pushToContext(InnerCtxF, _input(i), tp, emb)
        pushToContext(InnerCtxV, _input(i), tp, emb)
      }
      return [InnerCtxF, InnerCtxV]
    },
  },

  sumType:{
    merged:true,
    docs:`\`sumType …Types\`: an instance of this belongs to either of these \`Types\`.`,
    typeRefine(a,b) {
      // If any type matches, return that.
      //   Not the most accurate (would have needed type union for that), but it is good enough to suggest the possibility, without investing too much time in case it turns out to be useless.
      let [i = 1] = interrupt(1)
      try {
        if (isArray(a) && a[0] === sumType)
          for (; i < a.length; ++i) {
            const T = typeRefine(a[i], b)
            if (T !== null) return T
          }
        else if (isArray(b) && b[0] === sumType)
          for (; i < b.length; ++i) {
            const T = typeRefine(a, b[i])
            if (T !== null) return T
          }
      } catch (err) { if (err === interrupt) interrupt.stack.push(i);  throw err }
      return null
    },
    typeAdjustmentMerger(tp) {
      const mergers = _allocArray(tp.length-1), upTp = _allocArray(tp.length)
      upTp[0] = sumType
      for (let i = 1; i < tp.length; ++i) {
        const sub = typeAdjustmentMerger(tp[i])
        mergers[i-1] = sub[0], upTp[i] = sub[1], _allocArray(sub)
        if (mergers[i-1] !== mergers[0])
          error("All mergers of a sumType must be the same, got", mergers[i-1], mergers[0], "in", tp[i], tp[1])
      }
      try { return [mergers[0], merged(upTp)] } finally { _allocArray(mergers), _allocArray(upTp) }
      function getMerger(itemMergers) { return function(arr) { return _mergeTuples(arr, itemMergers) } }
    },
    typeDisposer(tp) {
      const upTp = _allocArray(tp.length)
      let disp = null, dispTp
      upTp[0] = sumType
      for (let i = 1; i < tp.length; ++i) {
        const sub = typeDisposer(tp[i])
        const curDisp = sub[0]
        upTp[i] = sub[1], _allocArray(sub)
        if (curDisp != null) {
          if (disp === null) disp = curDisp, dispTp = tp[i]
          else if (disp !== curDisp)
            error("All disposers of a sumType must be the same or null, got", curDisp, disp, "in", tp[i], dispTp)
        }
      }
      try { return [disp, merged(upTp)] } finally { _allocArray(upTp) }
    },
    call(...a) { return merged([sumType, ...a]) },
  },

  _humanDAGBegin(tp) {
    const lang = _langAt(), binds = _bindingsAt()
    const det = elem('details', elem('summary', ['Choose the func/value', ' typed ', serialize(_typeFinalize(tp), lang, binds, serialize.displayed)]))
    det.open = true
    print(det)
    const m = new Map
    m.set(_humanDAGBegin, det)
    return m
  },

  _humanDAGAsk(which, nodes, types, calls) {
    if (!instance.visual) return
    const lang = _langAt(), binds = _bindingsAt()
    if (which === "Node hierarchy") { // From arrays of parents and their types and their last-child ArgInds, update the UI hierarchy.
      if (nodes.length !== types.length-1 || nodes.length !== calls.length) error("Non-equal lengths:", nodes, types, calls)
      let at = instance.visual.get(_humanDAGBegin), beginning = true
      const opts = {...serialize.displayed, observe:false}
      for (let i=0; i < types.length; ++i) {
        const V = nodes[i], T = types[i], j = calls[i]
        if (i < nodes.length && !instance.visual.has(V)) {
          const el = elem('details', elem('summary', ['Choose the func/value', ' typed ', '']))
          el.open = true
          instance.visual.set(V, el)
        }

        const summary = at.firstChild
        if (i < nodes.length) {
          let V2 = isArray(V) ? V.map((x,i) => i !== j ? x : input) : V
          V2 = bound(x => x && Object.getPrototypeOf(x) === bound ? label('v'+_id(x)) :
            !isArray(x) || x[0] !== bound || x.length != 5 ? undefined : [ x[1], [_extracted, label('v'+_id(x[3])), x[2]], ], V2)
          const VUI = serialize(V2, lang, binds, opts)
          summary.firstChild.replaceWith(i < nodes.length-1 ? elemCollapse(VUI) : VUI)
        } else summary.firstChild.replaceWith(document.createTextNode('Choose the func/value'))
        summary.lastChild.replaceWith(elemCollapse(serialize(T, lang, binds, opts)))

        if (i < nodes.length) {
          const needed = instance.visual.get(V)
          if (at.firstChild === at.lastChild) at.append(needed)
          else if (at.lastChild !== needed) at.lastChild.replaceWith(needed)
          at = needed
        } else if (at && at.lastChild && at.lastChild.tagName === 'DETAILS')
          at.lastChild.remove()
      }
      return
    }
    if (which !== "Ask") error("Typo:", which)
    // Else, `nodes` and `types` are equally-sized arrays, and the user must pick one option.
    let [weDecided] = interrupt(1)
    try { // → maxI
      // Descend from `instance.visual.get(_humanDAGBegin)` along last <details> children, to the bottom.
      //   Append or remove from there.
      let at = instance.visual.get(_humanDAGBegin)
      while (at && at.lastChild && at.lastChild.tagName === 'DETAILS') at = at.lastChild
      if (weDecided)
        return weDecided.humanDecidedIndex
      // If our first time, present the interface: a button to pick, the picked node, and the type.
      weDecided = Object.create(null)
      weDecided.humanDecidedIndex = 'waiting'
      let job, before
      const onClick = function() {
        ourElems.remove()
        weDecided.humanDecidedIndex = +this.textContent
        _jobResume(...job), job = undefined
        // Show the pause-button.
        before.style.removeProperty('display')
      }
      const ourElems = elem('table', elem('tr', [elem('td'), elem('td'), elem('td', 'Option'), elem('td', 'Type')]))
      for (let i = 0; i < nodes.length; ++i) {
        const row = ourElems[i] = elem('tr')
        const pickThis = elemValue(elem('button', ''+i), input)
        const node = serialize(nodes[i], lang, binds, serialize.displayed)
        const tp = serialize(types[i], lang, binds, serialize.displayed)
        row.append(elem('td', pickThis), elem('td', calls[i] ? 'Call' : 'Value'), elem('td', node), elem('td', tp))
        ourElems.append(row)
        pickThis.onclick = onClick
      }
      at.append(ourElems)

      // Interrupt, re-enter when clicked.
      const toReEnter = (expr, env, then) => {
        _jobs.limbo.push(expr, env, then)
        job = [expr, env, then]
        // Hide the pause-button.
        before = env[_id(print)] || Self.into
        if (before instanceof Map) before = before.get(print)
        before.style.display = 'none'
      }
      _causeInterrupt(_humanDAGAsk, toReEnter)
    } catch (err) { if (err === interrupt) interrupt.stack.push(weDecided);  throw err }
  },

  instance:{
    docs:`\`instance Type Globals AskUser\`: generates a random instance of a \`Type\` in the context \`Globals\`.
If \`AskUser\` is \`true\`, you are asked what to pick at each choice (instead of RNG gods).
If this throws, then the implementation is wrong.`,
    call(Type, Globals = [], AskUser) {
      if (instance.visual) error("Instancing-while-instancing is illegal")
      let [aw, obj, visual = AskUser ? _humanDAGBegin(Type) : undefined, stage = 0] = interrupt(4)
      instance.visual = visual
      try {
        // Create an `autoWorld` just for this one object. Wasteful, but easy.
        if (aw === undefined) {
          const f = () => null
          aw = make(autoWorld, {
            Funcs:Globals,
          })
        }
        if (stage === 0) obj = alloc(Type, {Goal:'no'}, aw), stage = 1
        if (stage === 1) using(obj, obj), stage = 2
        if (stage === 2) usingFinish(), stage = 3
        return obj
      } catch (err) { if (err === interrupt) interrupt.stack.push(aw, obj, visual, stage), aw = null;  throw err }
      finally { instance.visual = undefined, visual && aw !== null && visual.get(_humanDAGBegin).remove() }

      // .visual
    },
  },

  type:{
    docs:`A value \`defines\` this to guide program \`regenerate\`ion, on the most fundamental level.
\`typeRefine\` decides exactly what will happen.

In input types (both returned and defined arrays), \`^X\` means "only \`X\` is the exact instance here". Any type can define \`typeRefine\`.

Some things just cannot be learned by trial-and-error (like device drivers without a device generating process), or it's completely pointless to learn them (like correct tensor dimensions).
(This is completely opposite of the usual type inference and proofs. We want to {learn what's OK}, not {pre-define everything then someday have to un-learn that}.)`,
    interrupt:false,
    call(v) { // Return the type of value.
      if (typeof v == 'number') return _numberType
      if (typeof v == 'boolean') return merged([boolsType, 1])
      if (_isDisposable(v)) return merged([tensorType, ...v.shape])
      return _funcTypeOf(defines(v, type))
    },
  },

  _selfRefinementFailuresAreBad:[
    _(`settings`),
    false,
    `If checked, \`typeRefine\` will \`error\` on self-refinement failures.`,
  ],

  typeRefine:{
    docs:`\`typeRefine WantedType HaveType\`: returns the type of values that are both in \`WantedType\` and \`HaveType\`, or \`null\` if failed.
Ref-equal types always match, strings act as variables, and arrays match if every item matches (there is no caching, so trees are strongly preferred to DAGs), \`…X\` matches a sub-sequence, and \`rest Array Func\` turns every array item into \`(Func Item)\`.
Any type can override the matching.`,
    Initialize() {
      typeRefine.vars = new Set
    },
    readAt:{
      _selfRefinementFailuresAreBad:_(`_selfRefinementFailuresAreBad`),
    },
    examples:[
      [
        `typeRefine ^(1 …'a' 'b') ^(1 …'a' 'b')`,
      ],
      [
        `typeRefine tensorType(1,2,3) ^tensorType(…'A')`,
        `tensorType 1 2 3`,
      ],
      [
        `typeRefine ^'sz'⇒(rest 'sz' quote)()⇒'sz' ^(1 2)⇒'a'⇒(1 2)`,
        `a⇒(^1 ^2)⇒a a:(1 2)`,
      ],
    ],
    call(a,b, ctx, copyOnWrite = false) {
      if (a === null || b === null) return null
      if (typeRefine.ctx === undefined) {
        // Top-level.
        if (!typeRefine.vars) typeRefine.vars = new Set
        typeRefine.ctx = ctx || _allocMap(), typeRefine.depth = 0, typeRefine.cow = copyOnWrite // (`typeRefine` isn't interrupt-safe.)
        try { const r = ctx ? typeRefine(a,b) : _typeFinalize(typeRefine(a,b));  return r }
        finally { !ctx && _allocMap(typeRefine.ctx), typeRefine.ctx = typeRefine.depth = typeRefine.cow = undefined, typeRefine.vars.clear() }
      } else try {
        ++typeRefine.depth
        if (ctx !== undefined) error("Cannot be top-level but got", ctx)
        ctx = typeRefine.ctx
        if (typeRefine.depth >= 1024) // We're *probably* merging infinite trees. Maybe.
          return _selfRefinementFailuresAreBad[1] && a === b && error("Self-refinement loops infinitely:", a), null

        // Naked strings act as variables: they're set to a variable that holds the refined value, now and later.
        //   These variables are mutable (to make newly-found-out equalities affect the past refinements too).
        //   Use `_typeFinalize` to resolve those type variables, and make them immutable (AKA strings).
        // Create new vars for newly-seen strings.
        //   Seen strings have their type vars refined instead.
        if (typeof a == 'string') {
          if (!ctx.has(a)) a = !_isTypeVar(b) || typeRefine.vars.has(b) || _getTypeVarValue(b) !== b ? _newTypeVar(a, ctx) : b
          else return a !== b && ctx.get(a) !== b && ctx.set(a, typeRefine(ctx.get(a), b)), a = ctx.get(a), _isTypeVar(a) && _getTypeVarValue(a) === null ? null : a
        }
        if (typeof b == 'string') {
          if (!ctx.has(b)) b = !_isTypeVar(a) || typeRefine.vars.has(a) || _getTypeVarValue(a) !== a ? _newTypeVar(b, ctx) : a
          else return a !== b && a !== ctx.get(b) && ctx.set(b, typeRefine(a, ctx.get(b))), b = ctx.get(b), _isTypeVar(b) && _getTypeVarValue(b) === null ? null : b
        }
        // Type-vars get their values refined in-place (or copy-on-write if needed).
        if (_isTypeVar(a)) {
          const old = typeRefine.vars.has(a);  !old && typeRefine.vars.add(a)
          try {
            let v = _getTypeVarValue(a)
            v = _setTypeVarValue(a, a === b ? v : v === b ? v : typeRefine(v !== a ? v : b, b))
            return v === null ? null : !old ? a : v
          } finally { !old && typeRefine.vars.delete(a) }
        }
        if (_isTypeVar(b)) {
          const old = typeRefine.vars.has(b);  !old && typeRefine.vars.add(b)
          try {
            let v = _getTypeVarValue(b)
            v = _setTypeVarValue(b, a === b ? v : v === a ? v : typeRefine(a, v !== b ? v : a))
            return v === null ? null : !old ? b : v
          } finally { !old && typeRefine.vars.delete(b) }
        }

        // Defer to a type if overriden.
        if (isArray(a) && defines(a, typeRefine)) return defines(a, typeRefine)(a, b)
        if (isArray(b) && defines(b, typeRefine)) return defines(b, typeRefine)(a, b)
        // Non-special non-arrays must be ref-equal.
        if (!isArray(a) || !isArray(b)) return a === b ? a : null
        // Arrays must match item-for-item, though if they have `(rest ?)` inside, that matches a subsequence.
        //   And `(rest Array Func)` turns every array item into `(Func Item)`.
        //   (Also make sure that, if both have `rest`s, the shorter one is `a`, otherwise they won't match.)
        let rp, rpA = _restPosition(a), rpB = _restPosition(b)
        if ((rpA === a.length || a.length > b.length) && rpB < b.length) [a,b] = [b,a], rp = rpB
        else rp = rpA
        if (rp === a.length ? a.length != b.length : b.length < a.length-1)
          return _selfRefinementFailuresAreBad[1] && a === b && error("Self-refinement failed:", a, "given", typeRefine.ctx), null
        let [T = _allocArray(a.length), i = 0, j = 0, Av, anyAv] = interrupt(5)
        try {
          // Prepare to flatten (couldn't resolve prior type vars after refinement).
          if (rp < a.length && Av === undefined) {
            Av = _resolveTypeVar(a[rp][1])
            anyAv = typeof Av == 'string' || _isTypeVar(Av) && _resolveTypeVar(_getTypeVarValue(Av)) === Av
          }

          // Match array items, before …R then …R then after …R.
          for (; i < rp; ++i) {
            T[i] = typeRefine(a[i], b[i])
            if (T[i] === null) return _selfRefinementFailuresAreBad[1] && a === b && error("Self-refinement failed:", a, "given", typeRefine.ctx), null
          }
          if (j === 0) {
            if (rp < a.length) {
              if (a.length !== b.length)
                T[rp] = typeRefine(a[rp][1], b.slice(rp, rp + b.length-a.length + 1))
              else
                T[rp] = typeRefine(a[rp][1], !isArray(b[rp]) || b[rp][0] !== rest ? [b[rp]] : b[rp][1])
              if (T[rp] === null) return _selfRefinementFailuresAreBad[1] && a === b && error("Self-refinement failed:", a, "given", typeRefine.ctx), null
              T[rp] = a[rp][2] !== undefined ? [rest, T[rp], a[rp][2]] : [rest, T[rp]]
            }
            j = rp+1
          }
          for (; j < a.length; ++j) {
            T[j] = typeRefine(a[j], b[j + b.length-a.length])
            if (T[j] === null) return _selfRefinementFailuresAreBad[1] && a === b && error("Self-refinement failed:", a, "given", typeRefine.ctx), null
          }

          // Flatten all `…( )` (`…5`→`5`).
          if (rp < a.length && isArray(T[rp]) && T[rp][0] === rest) {
            const A = Av, anyA = anyAv

            const C = _resolveTypeVar(T[rp][1])
            const anyC = typeof C == 'string' || _isTypeVar(C) && _resolveTypeVar(_getTypeVarValue(C)) === C
            // If neighbors of any-sequence is any-var, we don't care about them.
            if (anyC) {
              let did = true, L, R
              while (did) {
                did = false
                L = rp > 0 && _resolveTypeVar(T[rp-1])
                R = (rp+2 < T.length || T[0] !== funcType && rp+1 < T.length) && _resolveTypeVar(T[rp+1]) // Preserve func outputs.
                if (_isTypeVar(L) && _resolveTypeVar(_getTypeVarValue(L)) === L) T.splice(--rp, 1), did = true
                if (_isTypeVar(R) && _resolveTypeVar(_getTypeVarValue(R)) === R) T.splice(rp+1, 1), did = true
              }
            }
            // Only those that changed deserve to be flat.
            if (C !== A && !(isArray(C) && defines(C, typeRefine)) && !(anyA && anyC)) {
              const prev = T[rp]
              if (!(isArray(C) && C.length ? C.some(x => x === prev) : (C === prev))) { // No cycles please.
                if (isArray(C)) T.splice(rp, 1, ...(T[rp][2] === undefined ? C : C.map(item => merged([T[rp][2], item]))))
                else T[rp] = T[rp][2] === undefined ? C : merged([T[rp][2], C])
              }
            }
          }

          // If changed from `a`, return a merged copy that's made from results of refinement. Else, return `a`.
          // `T` cannot be `merged` because type variables are mutable.
          if (a.length === T.length) for (let i=0; i < a.length; ++i) { if (a[i] !== T[i]) return T }
          else return T
          return _allocArray(T), a
        } catch (err) { if (err === interrupt) interrupt.stack.push(T, i, j, Av, anyAv), print('but typeRefine is not interrupt-safe');  throw err }
      } finally { --typeRefine.depth }
      // .ctx, .depth, .cow
    },
  },

  _isTypeVar(t) { return t && Object.getPrototypeOf(t) === typeRefine },

  _newTypeVar(a, ctx) {
    const v = Object.create(typeRefine)
    v.value = !_isTypeVar(a) || a.value === a ? v : a.value, v[defines.key] = undefined
    ctx instanceof Map && ctx.set(a, v)
    return v
  },

  _getTypeVarValue(t) {
    return !typeRefine.cow || !typeRefine.ctx.has(t) ? t.value : typeRefine.ctx.get(t)
  },

  _setTypeVarValue(t, v) {
    !typeRefine.cow ? (t.value = v) : typeRefine.ctx.set(t, v)
    return v
  },

  _resolveTypeVar(t) {
    let t2 = t
    while (_isTypeVar(t)) {
      t = _getTypeVarValue(t)
      t2 = _isTypeVar(t2) ? _getTypeVarValue(t2) : t2
      t2 = _isTypeVar(t2) ? _getTypeVarValue(t2) : t2
      if (_isTypeVar(t) && t === t2) break
    }
    return t
  },

  _typeFinalize:{
    docs:`\`_typeFinalize Type\` or \`_typeFinalize Type ReuseMap\`:
Finalizes the type returned by \`typeRefine\`, binding type variables to their values.
(Type variables are mutable so that equality temporally flows both ways. Finalization of DAG node types can only happen once the DAG is complete.)`,
    interrupt:false,
    call(T, cache = undefined) {
      // Cannot use `bound` because types would be `merged`, which is very bad with mutable type variables.
      const m = cache || _allocMap()
      try { return walk(T) }
      finally { !cache && _allocMap(m) }

      function walk(t) {
        t = _resolveTypeVar(t)

        if (_isTypeVar(t)) {
          let v = _getTypeVarValue(t)
          for (let i=0; i < 100; ++i)
            if (_isTypeVar(v) && t !== v)
              v = _setTypeVarValue(t, _setTypeVarValue(v, _getTypeVarValue(v)))
            else break
          if (v !== t) error("Unable to resolve type var", t)
          return 'v'+_id(t)
        }

        if (m.get(t) === null) error("Got a cycle in", t, "while finalizing", T)
        if (m.has(t)) return m.get(t)
        if (!isArray(t)) return t

        return m.set(t, null), m.set(t, t.map(walk)), defines(m.get(t), merged) === true && m.set(t, merged(m.get(t))), m.get(t)
      }
    },
  },

  _restPosition(a) { for (let i=0; i < a.length; ++i) if (isArray(a[i]) && a[i][0] === rest) return i;  return a.length },

  adjust:{
    docs:`\`adjust Func Ins Out Dout\`→\`Dins\`
Given func, inputs, output, and output change, reverses the just-done execution to compute input changes (and change variables such as \`varMomentum\`).

(Definitions must be array DAGs that signify function bodies, to guarantee partial evaluation, where \`input\` is \`(arrayObject Ins Out Dout)\`—>\`Dins\`. \`_inA\`, \`_inB\`, \`_inC\`, \`_dout\` can help specify those bodies.)
(If using the basic primitives to adjust, adjustment must always happen in perfect reversal of execution.)

One way to use this is like differentiable paperclip maximization: compute a prediction of a numeric value, compute the loss, and back-propagate the gradient to minimize the loss. This is the standard paradigm of modern machine learning; you've probably heard of its recent amazing successes.
Another way is learnable scaffolding, the generalization: compute and use many numeric predictions from differentiable information routed along a non-differentiable execution, remember intended results, and separately, compute losses and back-propagate gradients to minimize the losses.

Now, gradients are not biologically plausible, but luckily, we don't have to be biologically-inspired (besides, their approximations are plausible and likely). Alternatives include auto-generated \`adjust\` definitions and specific cases of that, such as feedback alignment (multiply output change by a random matrix to get input change) or direct feedback alignment (multiply the global output change by random matrices, for parallelization: {https://www.youtube.com/watch?v=Hdo81GtLC_4}/{https://arxiv.org/pdf/2006.12878.pdf}) or others.`,
    readAt:{
      mergeAdjustment:_(`mergeAdjustment`),
      autograd:_(`autograd`),
      zeroGrad:_(`zeroGrad`),
      gradMul:_(`gradMul`),
      modifyGrad:_(`modifyGrad`),
      later:_(`adjustLater`),
      never:_(`adjustNever`),
      now:_(`adjustNow`),
      undo:_(`adjustUndo`),
      save:_(`adjustSave`),
      load:_(`adjustLoad`),
    },
    Initialize() {
      adjust.inputs = new Map().set(_ins, 1).set(_out, 2).set(_dout, 3)
    },
    call(fn, ins, out, dout) {
      if (typeof fn != 'function') errorStack('Expected a function, got', fn)
      let adj = defines(fn, adjust)
      if (adj === undefined) return _allocArray(0)
      if (call.pure) return purify(adj, true, adjust.inputs, [quote(ins), quote(out), quote(dout)])
      if (isArray(adj) && adj[0] === _adjustFunc && adj[1] === _ins && adj[2] === _dout)
        return _adjustFunc(ins, dout)
      if (adj === _accumulateGradient) adj = _funcAccumulateGradient
      if (typeof adj == 'function') return adj(ins, out, dout)
      if (!isArray(adj)) error('Wrong definition:', adj, 'by', fn)

      // Bind the input array and call that.
      let [dins] = interrupt(1)
      try {
        if (!dins) {
          _bindInput[1] = quote(ins), _bindInput[2] = quote(out), _bindInput[3] = quote(dout)
          dins = _compileBody(bound(_bindInput, adj, false), undefined, undefined, undefined, false)
          _bindInput[1] = _bindInput[2] = _bindInput[3] = undefined
        }
        return dins()
      } catch (err) { if (err === interrupt) interrupt.stack.push(dins);  throw err }
    },
    purify(fnP, insP, outP, doutP) {
      // If the function is known, inline its adjustment.
      if (isArray(fnP)) throw impure
      if (typeof fnP != 'function') error('Expected a function, got', fnP)
      const adj = defines(_unquote(fnP), adjust)
      if (typeof adj == 'function') return _unknown([adj, insP, outP, doutP])
      if (!isArray(adj)) error('Wrong definition:', adj, 'by', fnP)
      let [args] = interrupt(1)
      try {
        if (!args) args = [insP, outP, doutP]
        return purify(adj, true, adjust.inputs, args)
      } catch (err) { if (err === interrupt) interrupt.stack.push(args);  throw err }
    },
  },

  _funcAdjust(f) {
    if (typeof f != 'function') return
    const adj = defines(f, adjust)
    if (typeof adj == 'function') return adj
    if (isArray(adj) && adj[0] === _adjustFunc && adj[1] === _ins && adj[2] === _dout)
      return _adjustFunc
  },

  _disposeEachAndDealloc(x) { if (isArray(x)) x.forEach(dispose), _allocArray(x) },

  _destroyAdjustmentStack(st) { if (isArray(st)) st.forEach(_disposeEachAndDealloc), _allocArray(st) },

  _debugAdjustSave:[
    _(`settings`),
    true,
    `Whether \`adjustSave\` should preserve stack traces for each saved value, so that loading an invariant-violating value could compare stack traces.`,
  ],

  _inexactReversal(oneValue, ...msg) {
    const stack = call.env[_id(adjustLoad)]
    const traces = adjustSave.at && adjustSave.at.has(stack) ? adjustSave.at.get(stack) : null
    const trace = traces ? (oneValue ? _resolveStack(traces[stack.length], 1) : new Array(stack.length || traces.length).fill().map((_,i) => _resolveStack(traces[i], 1))) : _debugAdjustSave
    error("Inexact reversal: saved at", trace, "but loading", ...msg.map(x => isArray(x) ? x.slice() : x))
  },

  adjustSave:{
    docs:`Saves a newly-allocated array for adjustment — or, you know, anything else.
(Transfers responsibility for \`dispose\`al of items in it (with \`_disposeEachAndDealloc\`) and marking the array for re-using.)`,
    interrupt:false,
    impure:true,
    _cancel:_(`_destroyAdjustmentStack`),
    call(x) {
      if (!call.env) return
      const stack = call.env[_id(adjustSave)]
      if (stack) {
        if (_debugAdjustSave[1]) {
          if (!adjustSave.at) adjustSave.at = new WeakMap
          if (!adjustSave.at.has(stack)) adjustSave.at.set(stack, [])
          adjustSave.at.get(stack)[stack.length] = new Error().stack
        }
        Object.isFrozen(stack) && error("Stack got destroyed:", ...stack),
        stack.push(x)
      } else
        _disposeEachAndDealloc(x)
    },
  },

  adjustLoad:{
    docs:`Loads an array for adjustment. The one arg is the expected length or \`null\`.
Must always happen exactly in reverse to \`adjustSave\`.`,
    impure:true,
    interrupt:false,
    _cancel:_(`_destroyAdjustmentStack`),
    dispose:_(`_disposeEachAndDealloc`),
    call(len) {
      if (call.pure) throw impure
      const stack = call.env[_id(adjustLoad)]
      if (!stack)
        errorStack("…Forgot to adjust??")
      if (!stack.length)
        _inexactReversal(false, "more than was saved")
      const ret = stack.pop()
      if (len !== null) {
        if (typeof len != 'number') error("Expected a number or null but got", len)
        if (!isArray(ret))
          _inexactReversal(true, "expected an array but got", ret)
        if (ret.length !== len)
          _inexactReversal(true, "expected", len, "items but got", ret)
      }
      return ret
    },
  },

  impure:{
    docs:`When a node throws this, \`purify\` will not execute that node.`,
  },

  defines:{
    docs:`\`(defines Data Code)\`: Gets the definition by \`Data\` of \`Code\`.

Array data gets its head consulted (once, not recursively). A function acts like a concept that defined \`call\` as that function. A JS object with \`defines.'key'\` consults that object with \`_id(Code)\` as the key.`,
    philosophy:`Culture is polite fiction made for efficiency, and so are programming languages. At some point, you have to define things with no deeper explanation. (Not \`concept\`s, though: they are consequences. The real sources are learned end-to-end, as in \`autoWorld\`.)`,
    interrupt:false,
    argCount:2,
    call(data, code) {
      if (code === call && typeof data == 'function')
        return data[defines.key] && data[defines.key][_id(call)] || data
      if (code === call && isArray(data) && typeof data[0] == 'function')
        return data[0][defines.key] && data[0][defines.key][_id(call)] || data[0]

      const d = _view(data)
      return d ? d[_id(code, true)] : undefined
    },
  },

  _view:{
    docs:`\`(_view Concept)\`: returns the view of \`Concept\`, used to look up things in it.`,
    call(data) {
      if (isArray(data)) data = data[0]
      return data ? data[defines.key] : undefined
    },
  },

  concept:{
    docs:`\`(concept Key1 Value1 Key2 Value2 …? …?)\`: a \`construct\` that \`defines\` some things.

This gives functions (such as \`call\` or \`adjust\`) free and easy extensibility points. For example, rather than co-opting strings and files (duck typing, docstrings, documentation, READMEs) to convey parts of a concept, define functionality such as \`docs\` directly.

A concept is not necessarily static. The dream is to make \`alloc\`/\`conceptType\` continuously \`regenerate\` concepts, ever improving. But this prospect are mostly theoretical for now.`,
    philosophy:`Concepts have no defined boundaries and affect other things, so obviously, making \`concept\` be able to define one level of things in special circumstances fully encapsulates the concept of a concept.
(This was poking fun at the naming of \`concept\`, which is a rigid consequence of a learned representation. Still a solid way to define code networks such as Conceptual, though. And perhaps the \`autoWorld\` family could give a good way to make \`concept\`s dynamic and learned? We'll see.)`,
    readAt:{
      defines:_(`defines`),
    },
    Initialize(net) {
      // Fill globals' id-to-key mapping for deconstruction of concepts.
      if (!concept.idToKey) concept.idToKey = Object.create(null)
      Object.keys(net).forEach(k => concept.idToKey[_id(net[k])] = net[k])
    },
    editObject:false,
    map:true,
    construct(x, obj) {
      if (!concept.idToKey) concept.idToKey = Object.create(null)
      if (!(x.length & 1)) error("Expected the value of a key", x[x.length-1], "in", x)
      if (obj === undefined) {
        let callable = false
        for (let i = 1; i < x.length; i += 2)
          if (x[i] === call) { callable = true;  break }

        if (!callable)
          obj = Object.create(null)
        else
          obj = function called(...args) { return called[defines.key][_id(call)](...args) }
        obj[defines.key] = Object.create(null)
        return obj
      } else {
        const d = obj[defines.key]

        // Clear previous items.
        for (let k in d) delete d[k]

        // Fill in definitions.
        for (let i = 1; i < x.length; i += 2) {
          const k = x[i], v = x[i+1], idK = _id(k)
          d[idK] = v, concept.idToKey[idK] = k
          // Make augmenting `func`s with other stuff easier, by copying sub-definitions of the `call` definition.
          if (k === call && v && v[defines.key]) for (let k in v[defines.key]) if (!(k in d) && +k !== _id(readAt)) d[k] = v[defines.key][k]
        }

        if (typeof obj == 'function') d[_id(deconstruct)] = x

        // Definitions are NOT `Object.freeze`d. `observe` concepts to catch changes.
      }
      // .idToKey (an object, so that `deconstruct` can know what the numbers mean).
      //   (Keys are then forever strongly-held, in this implementation.)
    },
  },

  map:{
    docs:`\`{Key1 Value1 Key2 Value2 …? …?}\` or \`(map Key1 Value1 Key2 Value2 …? …?)\`: a key-value store.
The array-representation of a JS Map.
Read/write keys with \`mapRead\`/\`mapWrite\`.`,
    readAt:{
      read:_(`mapRead`),
      write:_(`mapWrite`),
    },
    map:true,
    construct(x, obj) {
      if (obj === undefined) {
        // Pre-fill keys (with undefined).
        obj = _allocMap()
        for (let i = 1; i < x.length; i += 2)
          obj.set(x[i], undefined)
        return obj
      } else {
        // Fill values.
        obj.clear()
        for (let i = 1; i < x.length; i += 2) {
          if (obj.has(x[i])) error('Duplicate key', x[i], 'in', obj)
          obj.set(x[i], x[i+1])
        }
      }
    },
  },

  weakMap:{
    docs:`\`(weakMap Key1 Value1 Key2 Value2 …? …?)\`: a \`map\` that holds keys weakly.
Garbage collection, serialization, and rewriting will only preserve keys/values of those keys that are referenced elsewhere.
The array-representation of a JS WeakMap.`,
    map:true,
    construct(x, obj) {
      if (obj === undefined) return new WeakMap
      else {
        // Fill values.
        for (let i = 1; i < x.length; i += 2) {
          if (obj.has(x[i])) error('Duplicate key', x[i], 'in', obj)
          obj.set(x[i], x[i+1])
        }
      }
    },
  },

  mapRead:{
    use:2,
    call(m, k) {
      // This is named with a scheme different from `readAt`, so that everytime you use this, you have to ask "what am I are doing with my life", to reflect the inferiority of partial-evaluation support compared to `readAt`.
      if (call.pure) throw impure
      if (!(m instanceof Map)) error("Not a map:", m)
      return m.has(k) ? m.get(k) : _notFound
    },
  },

  mapWrite:{
    use:3,
    call(m, k, v) {
      if (call.pure) throw impure
      if (!(m instanceof Map)) error("Not a map:", m)
      _invertBindingContext(m, true)
      v !== _notFound ? m.set(k, v) : m.delete(k)
      return v
    },
  },

  _isValidJS(s) {
    // A terrible abuse of the Function constructor, but it *is* the only easy and most correct option.
    try { Function(s); return true } catch (err) { return false }
  },

  _isValidIdentifier(s, varName = false) { // For JS.
    if (varName && s === 'static') return false // This fixes a bug in rewriting, I don't know why.
    return typeof s == 'string' && s && (!varName && /^[_a-zA-Z][_a-zA-Z0-9]*$/.test(s) || !/\s/.test(s) && _isValidJS('let '+s+'=('+s+')\ntry{}catch('+s+'){}'))
  },

  jsEval:{
    docs:`\`(jsEval Source Bindings)\`: evaluates (strict-mode) JS source code that can statically reference default JS globals or values of \`Bindings\` (a map) with JS-identifier keys.`,
    examples:[
      [
        `(jsEval 'function(x) { return x+5 }') 5`,
        `10`,
      ],
      [
        `(make jsEval 'function(x) { return x+a+5 }' (map 'a' 10)) 5`,
        `20`,
      ],
      [
        `(make jsEval 'b=>a+b' (map 'a' 'q')) 'w'`,
        `'qw'`,
      ],
    ],
    Initialize() {
      jsEval.ctx = Symbol('ctx')
      jsEval.dynamicBind = Symbol('dynamicBind')
    },
    construct(x, obj) {
      const ctx = x[2] !== undefined ? x[2] : Self.ctx
      if (obj === undefined) {
        if (typeof x[1] != 'string')
          error('Expected a string but got', x[1])
        if (ctx !== undefined && !(ctx instanceof Map))
          error('Expected nothing or a copied map but got', ctx)
        // Already link the function, but also remember how to dynamic-bind on it to set local vars representing map keys.
        const src = []
        src.push("'use strict';")
        src.push(`let ⴵfunc = ${x[1]}`)
        const temps = [...ctx.keys()].map(k => typeof k == 'string' ? 'ⴵ'+k : '').filter(x => x).join(',')
        const perms = [...ctx.keys()].map(k => typeof k == 'string' && k).filter(x => x && _isValidIdentifier(x, true)).join(',')
        src.push("let " + perms)
        src.push(`if(typeof ⴵfunc=='function')ⴵfunc[ⴵbind] = (${temps}) => [${perms}] = [${temps}]`)
        src.push("return ⴵfunc")
        const sourceURL = new Array(16).fill().map(() => randomNat(32).toString(32)).join('')
        src.push("//# sourceURL=" + sourceURL)
        try {
          const fn = Function('ⴵbind', src.join('\n'))(jsEval.dynamicBind)
          if (typeof fn == 'function') {
            _resolveStack.functions[sourceURL] = typeof WeakRef != ''+void 0 ? new WeakRef(fn) : fn
            if (!_compileBody.fin && typeof FinalizationRegistry != ''+void 0)
              _compileBody.fin = new FinalizationRegistry(sourceURL => delete _resolveStack.functions[sourceURL])
            _compileBody.fin && _compileBody.fin.register(fn, sourceURL)
            fn.lines = [4, fn]
            if (ctx) fn[jsEval.ctx] = ctx
          }
          return fn
        } catch (err) { console.error(err, src.join('\n')); throw err }
      } else {
        if (typeof obj == 'function') obj[jsEval.dynamicBind](...ctx.values())
      }
    },
  },

  instanceof:{
    docs:`This exists only to highlight a thing in js.`,
  },

  continue:{
    docs:`This exists only to highlight a thing in js.`,
  },

  break:{
    docs:`This exists only to highlight a thing in js.`,
  },

  finally:{
    docs:`This exists only to highlight a thing in js.`,
  },

  typeof:{
    docs:`This exists only to highlight a thing in js.`,
  },

  return:{
    docs:`This exists only to highlight a thing in js.`,
  },

  throw:{
    docs:`This exists only to highlight a thing in js.`,
  },

  catch:{
    docs:`This exists only to highlight a thing in js.`,
  },

  while:{
    docs:`This exists only to highlight a thing in js.`,
  },

  void:{
    docs:`This exists only to highlight a thing in js.`,
  },

  else:{
    docs:`This exists only to highlight a thing in js.`,
  },

  for:{
    docs:`This exists only to highlight a thing in js.`,
  },

  let:{
    docs:`This exists only to highlight a thing in js.`,
  },

  new:{
    docs:`This exists only to highlight a thing in js.`,
  },

  switch:{
    docs:`This exists only to highlight a thing in js.`,
  },

  function:{
    docs:`This exists only to highlight a thing in js.`,
  },

  if:{
    docs:`This exists only to highlight a thing in js.`,
  },

  const:{
    docs:`This exists only to highlight a thing in js.`,
  },

  case:{
    docs:`This exists only to highlight a thing in js.`,
  },


  _test:{
    docs:`Runs unit-tests.`,
    await:true,
    impure:true,
    call(env = _newExecutionEnv(call.env)) {
      let failed = 0, finished = 0, total = 0, then

      // Run all examples to make sure that they indeed evaluate to what we have specified.
      const done = new Set
      definersOf(examples).forEach(v => {
        if (isArray(v) || done.has(v)) return
        done.add(v)
        const r = defines(v, examples)
        if (isArray(r))
          r.forEach(a => {
            if (typeof a == 'function') return [0,1,2].map(a).forEach(([a,b]) => eq(a,b))
            if (!isArray(a)) return
            const [code, becomes] = a
            if (typeof code != 'string' || typeof becomes != 'string') return
            eq(parse(code), parse(becomes), code, v)
          })
      })
      return new Promise(f => then = f)

      function eq(a,b, code, owner) {
        ++total
        try {
          const s = _fastSerialize(a)
          const p2 = _fastParse(s)
          const s2 = _fastSerialize(p2)
          s !== s2 && error('Fast serialize and s-p-s are not equal:', s, s2, 'parsed as', p2, 'at the example', code, 'of', owner)

          _schedule(a, _newExecutionEnv(env), result => {
            ++finished
            const prevCallEnv = call.env;  call.env = env
            try {
              const B = serialize(b)
              if (!isArray(result) || result[0] !== jsRejected) {
                const A = serialize(result)
                if (A !== B) ++failed, print('Not equal:', a, '⇒', result, '≠', b, 'in', owner)
              } else {
                ++failed, print('Got an error', ...result.slice(1), 'when executing', a, '=', b, 'in', owner)
              }
            } catch (err) { ++failed, print(_errorRepr(err)) }
            try {
              if (finished === total && failed)
                print(structuredSentence('Failed {' + failed+'/'+total + '} tests.'))
              if (finished === total && then) then(1 - failed / total)
              dispose(result)
            } finally { call.env = prevCallEnv }
          })
        } catch (err) { ++failed, print(_errorRepr(err)) }
      }
    },
  },

  _onlyUndefined:{
    docs:`To be used with \`bound\` when \`ctx\` is a function. A marker that we do want to bind to undefined; exists to escape the "returning undefined means no explicit binding". (Currently not used anywhere.)`,
  },

  bound:{
    docs:`\`(bound Bindings Expr)\`: When called, returns a copy-where-needed of \`Expr\` with all keys bound to values in \`Bindings\`, as if copying then changing in-place. When evaluated, also evaluates the result.
Can be written as \`key:value\` in an array to bind its elements. Can be used to give cycles to data, and encode graphs and multiple-parents in trees.`,
    examples:[
      `Inner contexts are always bound first:`,
      [
        `^(a:1 (0 a a:2) (a b) (0 a:3 a) b:4)`,
        `(0 2) (1 4) (0 3)`,
        true
      ],
      [
        `^((a a:(5 8 11)) (a:2 a))`,
      ],
    ],
    nameResult:[
      `rewritten`,
      `expr`,
      `copy`,
    ],
    argCount:2,
    philosophy:`Nothing is more general than a graph, so in general, nothing is more convenient and powerful than a language built on graphs.
Other languages use let-bindings for variables (and devote lots of attention to scoping rules (\`bound\`) and various declaration methods (\`construct\`) and their subversions such as lambdas (\`make\`)), but here we just share graph nodes (and build the language on top of a simple graph interchange format, \`basic\`) (…and do \`bound\`/\`construct\`/\`make\` at \`parse\`-time). This makes fundamental meaning a first-class citizen, so we can refer to anything without worrying about its binding scope.

Putting all variables in a single global namespace is easy to develop, and gives no surprises to the user if references to them are instantly highlighted.`,
    interrupt:false,
    call(ctx, v, cyclic = true, env, rewrite) {
      if (typeof cyclic != 'boolean') error("`cyclic` must be a boolean")
      if (!(ctx instanceof Map) && typeof ctx != 'function') error("`ctx` must be a Map or a function")
      if (rewrite !== undefined && typeof rewrite != 'function') error("`rewrite` must be undefined or a function")
      const prevCtx = bound.ctx, prevCyclic = bound.cyclic, prevEnv = bound.env, prevRewrite = bound.rewrite
      bound.ctx = ctx, bound.cyclic = cyclic, bound.env = env, bound.rewrite = rewrite

      if (!bound.cache) bound.cache = new Map, bound.inside = false, bound.innerCtxs = []
      if (!bound.env) bound.env = !bound.cache.size ? bound.cache : new Map
      try { return _doBinding(v) }
      finally { bound.cache.clear(); bound.ctx = prevCtx, bound.cyclic = prevCyclic, bound.env = prevEnv, bound.rewrite = prevRewrite }
      // .cache, .innerCtxs; .ctx, .cyclic, .env, .rewrite to pass args on.
    },
  },

  _doBinding(v) {
    // Self-contained, and cannot interrupt.
    if (bound.env.has(v)) return bound.env.get(v)

    // Lookup in bound.innerCtxs or bound.ctx (or call bound.ctx on v).
    if (typeof v != 'string') {
      for (let i = bound.innerCtxs.length; i-- > 0; ) {
        const ctx = bound.innerCtxs[i]
        if (ctx.has(v) || ctx.has(_unlabel(v))) {
          const r = ctx.has(v) ? ctx.get(v) : ctx.get(_unlabel(v))
          if (r === v) return v
          return bound.cyclic ? _doBinding(r) : r
        }
      }
      if (bound.ctx instanceof Map && (bound.ctx.has(v) || bound.ctx.has(_unlabel(v)))) {
        const r = bound.ctx.has(v) ? bound.ctx.get(v) : bound.ctx.get(_unlabel(v))
        if (r === v) return v
        return bound.cyclic ? _doBinding(r) : r
      }
    }
    if (!(bound.ctx instanceof Map)) {
      let r = bound.ctx.call(undefined, v)
      if (r !== undefined) {
        if (r === _onlyUndefined) r = undefined
        if (r === v) return v
        return bound.cyclic ? _doBinding(r) : r
      }
    }
    if (_isLabel(v)) return v
    // Copy the array and bind its parts.
    if (isArray(v)) {
      let copy, changed = false, pushedCtx = false
      const original = v
      try {
        if (v[0] === bound && v.length == 3 && v[1] instanceof Map) {
          bound.innerCtxs.push(v[1]), pushedCtx = true
          const inner = v[2]
          copy = isArray(inner) ? inner.slice() : inner
          bound.env.set(original, copy)
          if (_isLabel(inner)) return _doBinding(inner)
          v = inner
        } else if (v[0] === bound && v.length == 3)
          return v[2] = quote(v[2]), v // Delay to `call`, so that inner bindings have higher priority.
        else
          copy = v.slice(), bound.env.set(original, copy)
        for (let i = 0; i < copy.length; ++i) {
          if (i === 1 && copy[0] === _extracted) continue
          const r = _doBinding(copy[i])
          if (copy[i] !== r)
            changed = true, copy[i] = r
        }
      } finally { if (pushedCtx) bound.innerCtxs.pop() }
      if (isArray(copy) && (copy[0] === label && copy.length == 2)) return copy
      copy = !changed ? v : _setting(_mergeIfDefined) && defines(copy, merged) === true ? merged(copy) : copy // This doesn't actually merge cycles, creating afterimages instead.
      bound.env.set(original, v = !bound.rewrite ? copy : bound.rewrite(copy))
    }
    return v
  },

  unbound:{
    docs:`\`(unbound Expr)\`: Eliminates cycles in (a copy of) Expr by inserting \`(bound (map …Bindings) Expr)\` with keys in the copy.

Like \`_unboundButSimple\` but complicated.

As a definition, this is the value of the index that serialization should not expand at all, because that often results in DOM trees that are too big for mortal browsers to handle.`,
    readAt:{
      _randomGraph:_(`_randomGraph`),
    },
    nameResult:[
      `acyclic`,
      `withoutCycles`,
      `exprWithVars`,
      `copy`,
    ],
    call(x, nameAllocator, unenv = new Map, maxDepth = 0) {
      // nameAllocator is a function(Object, Free) that either returns a new unique name (if !Free) or can mark a previously-allocated name as free.
      const currentAncestors = new Set, needsNaming = new Set
      const parents = new Map
      if (nameAllocator === undefined) {
        let n = 0
        nameAllocator = (_, undo) => undo === undefined && 'v'+n++
      }
      const refs = new Map, Top = x
      markParents(x, x)
      const children = new Map
      invertParents(x)
      const names = new Map
      const result = unbindChildren(x)
      return noCycles(result)

      function preserve(x) { return _isLabel(x) || _isStylableDOM(x) || typeof x == 'string' && x.length<=2 || typeof x == 'number' }
      function markParents(x, parent) {
        if (preserve(x)) return
        if (unenv.has(x)) return
        refs.set(x, (refs.get(x) || 0) + 1)
        if (!parents.has(x)) { // Set the immediate parent, and recurse.
          parents.set(x, parent)
          if (isArray(x)) {
            currentAncestors.add(x)
            for (let i = 0; i < x.length; ++i)
              markParents(x[i], x[i] !== x ? x : parent)
            currentAncestors.delete(x)
          }
        } else { // Seen this twice or more; find the least common ancestor.
          needsNaming.add(x)
          let p = parents.get(x), original = p
          if (p === parent) return
          while (!currentAncestors.has(p) && parents.has(p) && p !== parents.get(p) && x !== parents.get(p))
            p = parents.get(p)
          if (!currentAncestors.has(p)) error("bad ancestors", p, parents.get(p), p === TOP, _fastSerialize(p), _fastSerialize(x))
          parents.set(x, p)
        }
      }
      function invertParents(x, p) { // From parent refs, to lists of deep children.
        if (preserve(x)) return
        if (unenv.has(x)) return
        if (currentAncestors.has(x)) return;  else currentAncestors.add(x)
        if (needsNaming.has(x)) {
          if (p === undefined) p = parents.get(x)
          if (refs.get(x) > 1) p = Top // Yeah, we pretty much gave up on refs being local, despite weeks/months of thought. Too hard.
          if (!children.has(p)) children.set(p, [])
          children.get(p).push(x)
        }
        parents.delete(x)
        if (isArray(x))
          for (let i = 0; i < x.length; ++i)
            invertParents(x[i], x[i] !== x ? x : p)
      }
      function unbindChildren(x, ignoreEnv = false, ignoreName = false) {
        if (!ignoreName && names.has(x)) return !unenv.has(x) && unenv.set(x, names.get(x)), names.get(x)
        if (!ignoreEnv && unenv.has(x)) return unenv.get(x) === unbindChildren && unenv.set(x, x.slice()), unenv.get(x)
        if (preserve(x)) return unenv.set(x,x), x
        if (!isArray(x)) return unenv.set(x,x), x
        const ch = children.get(x)
        children.delete(x)
        let copy
        if (ch) {
          const ctx = new Map
          copy = [bound, ctx, x]
          unenv.set(x, copy)
          for (let i = 0; i < ch.length; ++i) {
            let name
            while (!name || currentAncestors.has(name))
              name = nameAllocator(ch[i], undefined)
            if (typeof name == 'string') name = [label, name]
            currentAncestors.add(name)
            if (x === ch[i]) unenv.set(copy, x)
            unenv.set(ch[i], name)
            names.set(ch[i], name)
          }
          for (let i = 0; i < ch.length; ++i)
            ctx.set(unenv.get(ch[i]), unbindChildren(ch[i], true, true))
          if (!ignoreName && names.has(x))
            copy[2] = names.get(x)
          else
            copy[2] = unbindChildren(x, true, true)
        } else {
          if (_isLabel(x)) return unenv.set(x,x), x
          let changed = false
          unenv.set(x, unbindChildren)
          for (let i = 0; i < x.length; ++i) {
            const v = unbindChildren(x[i])
            if (v !== x[i]) {
              if (!changed) {
                copy = unenv.get(x) !== unbindChildren ? unenv.get(x) : x.slice()
                changed = true
                unenv.set(x, copy)
              }
              copy[i] = v
            }
          }
          if (!changed && unenv.get(x) === unbindChildren) copy = x, unenv.set(x, x)
        }
        if (ch) // Deallocate spots for children.
          ch.forEach(c => (nameAllocator(undefined, names.get(c)), currentAncestors.delete(names.get(c))))
        return copy
      }
      function noCycles(x) {
        // Throw if x has cycles.
        if (!noCycles.s) noCycles.s = new Set
        if (unenv.has(x)) return x
        if (noCycles.s.has(x)) throw console.error("Cycles", result), "Cycles"
        noCycles.s.add(x)
        if (x instanceof Map) x.forEach(v => v !== x && noCycles(v))
        if (isArray(x)) x.forEach(noCycles)
        noCycles.s.delete(x)
        return x
      }
    },
  },

  _randomGraph(n = 100, m = 3) { // Sure would be nice to get all these to display.
    const a = new Array(n).fill().map(() => new Array(m))
    for (let i = 0; i < n; ++i)
      for (let j = 0; j < m; ++j)
        a[i][j] = a[randomNat(n)]
    return a[0]
  },

  _unboundButSimple:{
    docs:`Like \`unbound\` but just puts everything at the top-level.`,
    call(x, nameAllocator, unenv) {
      // Why fix obscure bugs in `unbound` when you can just have a super-simple fallback instead?
      const names = new Map, unbounds = new Map
      return [bound, unbounds, nameAll(x)]

      function preserve(x) { return _isLabel(x) || _isStylableDOM(x) || typeof x == 'string' && x.length<=2 || typeof x == 'number' }
      function nameAll(x) {
        if (names.has(x)) return names.get(x)
        if (unenv.has(x)) return unenv.get(x)
        if (!isArray(x) || preserve(x)) return unenv.set(x,x), x

        let name
        while (!name) name = nameAllocator(x, undefined)
        if (typeof name == 'string') name = [label, name]

        const y = x.slice()
        names.set(x, name), unbounds.set(name, y), unenv.set(x, y)
        for (let i=0; i < y.length; ++i) y[i] = nameAll(y[i])
        return name
      }
    },
  },

  _errorIsStacked:[
    _(`settings`),
    false,
    `If checked, turns all \`error\` calls into \`errorStack\` calls (leaving in the call trace).`,
  ],

  error:{
    use:true,
    docs:`\`(error …Causes)\`: throws an error when executed, containing useful information as to its likely cause.
Indicates a bug in the code, and is mostly intended to be presented to the user so that code does not go this way.`,
    examples:[
      [
        `add 1 (error 'bad stuff')`,
      ],
      [
        `add (mul 3 (error 'uh')) 2`,
      ],
    ],
    readAt:{
      jsRejected:_(`jsRejected`),
      _errorIsStacked:_(`_errorIsStacked`),
      errorsSince:_(`errorsSince`),
      try:_(`try`),
      fast:_(`errorFast`),
      stack:_(`errorStack`),
    },
    call(...msg) { throw ++error.count, !_errorIsStacked[1] ? [error, ...msg] : [error, ...msg, 'at', _resolveStack(undefined, 2)] },
  },

  _forgiveMistakes:[
    _(`settings`),
    true,
    `Whether cycle-checking and arg-count-checking should just not throw.`,
  ],

  errorsSince:{
    use:1,
    docs:`\`errorsSince()\`→\`Mark\` or \`errorsSince(Mark)\`→\`Errors\`
Returns how many \`error\`s have occured in this job.`,
    interrupt:false,
    examples:[
      [
        `e;try(9,y->1);errorsSince(e) e:errorsSince()`,
      ],
    ],
    call(mark = 0) { return typeof mark == 'number' ? error.count - mark : error('Bad mark:', mark) },
  },

  try:{
    use:true,
    docs:`\`(try Func OnError …Args)\`: returns \`Func(…Args)\` unless an \`Error\` is thrown inside, and if so, returns \`OnError(Error,…Args)\`.`,
    type:[
      _(`funcType`),
      [
        _(`funcType`),
        [
          _(`rest`),
          `Inputs`,
        ],
        `Output`,
      ],
      [
        _(`funcType`),
        `Error`,
        [
          _(`rest`),
          `Inputs`,
        ],
        `Output`,
      ],
      [
        _(`rest`),
        `Inputs`,
      ],
      `Output`,
    ],
    examples:[
      [
        `try a->(error 'oh no') err->a->(print err 'occured while processing' a);'ho' 15`,
      ],
    ],
    dispose:true,
    call(fn, onErr, ...args) {
      let [GotError, adjSaveLength] = interrupt(2)
      try {
        if (GotError !== undefined) throw GotError
        if (adjSaveLength === undefined) adjSaveLength = adjustUndo()
        const r = fn(...args)
        const s = _allocArray(1);  s[0] = _onlyUndefined;  adjustSave(s)
        return r
      } catch (err) {
        if (err === undefined) throw undefined
        if (err !== interrupt) {
          GotError = err
          if (adjSaveLength != null) // Make sure that no instructions on how to adjust the "try" branch are left.
            adjustUndo(adjSaveLength), adjSaveLength = null,
            err instanceof Error && (++error.count) // And count JS exceptions as errors.
          try {
            const r = typeof onErr == 'function' ? onErr(err, ...args) : null
            const s = _allocArray(1);  s[0] = err;  adjustSave(s)
            return r
          } catch (err) { if (err === interrupt) interrupt.stack.push(GotError, adjSaveLength); else err instanceof Error && ++error.count;  throw err }
        } else throw interrupt.stack.push(GotError, adjSaveLength), interrupt
      }
    },
    adjustLater:true,
    mergeAdjustment:null,
    adjust:{
      call(ins, _, dout) {
        if (call.pure) throw impure
        const [fn, onErr, ...args] = ins
        let [Error] = interrupt(1)
        try {
          if (Error === undefined) { const s = adjustLoad(1);  Error = _defined(s[0]);  _allocArray(s) }
          if (Error === _onlyUndefined) {
            // Adjust `fn(...args)`.
            const b = adjust(fn, args, null, dout)
            b.unshift(undefined, undefined)
            return b
          } else {
            // Adjust `onErr(Error, ...args)`.
            let b, a = _allocArray(1+args.length)
            a[0] = Error
            for (let i=0; i < args.length; ++i) a[i+1] = args[i]
            try { b = typeof onErr == 'function' ? adjust(onErr, a, null, dout) : null }
            finally { _allocArray(a) }
            if (!b) b = [undefined]
            b.unshift(undefined)
            return b
          }
        } catch (err) { if (err === interrupt) interrupt.stack.push(Error);  throw err }
      },
      dispose:_(`_disposeEachAndDealloc`),
    },
  },

  errorFast:{
    docs:`Faster error-throwing, for things unlikely to be shown to the user.`,
    call() { if (!errorFast.e) errorFast.e = error(`An error has occured.`);  throw ++error.count, errorFast.e },
  },

  errorStack:{
    docs:`Adds the execution stack to the raised error.`,
    call(...msg) { throw ++error.count, [error, ...msg, 'at', _resolveStack(undefined, 2)] },
  },

  parseURL:{
    docs:`\`(parseURL URL)\` or \`(parseURL URL Lang Binds)\`: fetches and parses the contents at URL.`,
    await:true,
    call(url, lang, binds, style = false) {
      return fetch(url, {mode:'cors'}).then(r => r.arrayBuffer())
      .then(buf => new TextDecoder().decode(new Uint8Array(buf)))
      .then(txt => parse(txt, lang, binds, {style, sourceURL:url}))
    },
  },

  _resolveStack:{
    docs:`If lines are marked, this resolves the JS stack trace to the network's functions.`,
    Initialize() {
      _resolveStack.functions = Object.create(null)
      _resolveStack.location = new WeakMap
    },
    serialize:0,
    call(stack = new Error().stack || '', skipFrames = 1) {
      if (isArray(stack)) return stack
      else if (typeof stack != 'string') error("Bad stack trace:", stack)
      return [_resolveStack, ...stack.trim().split('\n')].map((L,i) => {
        if (!i) return L
        if (/Error:|Error$/.test(L)) return void ++skipFrames
        if (i-1 < skipFrames) return
        const loc = /(?: \(|at.* \(?|@)(.+):(\d+):(\d+)\)?$/.exec(L)
        if (!loc) return L.indexOf('<anonymous>') < 0 ? L : ''
        let sourceURL = loc[1]
        const fs = _resolveStack.functions || (_resolveStack.functions = Object.create(null))
        const main = !(sourceURL in fs) ? Initialize : typeof WeakRef != ''+void 0 ? fs[sourceURL].deref() : fs[sourceURL]
        if (main == null) return loc.slice(1,4).join(':')
        const lines = !(sourceURL in fs) && Initialize.lines ? Initialize.lines[''] : main.lines
        let line = +loc[2], column = +loc[3]
        if (column !== column) return
        if (lines) {
          // let i
          // for (i = 0; i < lines.length; i += 2)
          //   if (lines[i] >= line) break
          // Or, in binary search:
          let l = 0, r = lines.length>>>1
          while (l < r) {
            const m = (l+r)>>>1
            if (lines[m<<1] < line) l = m+1
            else r = m
          }
          let i = l<<1
          if (lines[i] < line) ++i
          const sub = lines[i-1]
          if (main === Initialize && typeof sub == 'function' && (typeof document == ''+void 0 || sourceURL === String(document.location))) {
            const localLine = line - lines[i-2], str = _unevalFunction(sub, false, true)[1].split('\n')[localLine]
            if (str !== undefined)
              return merged([readAt, sub, str.slice(0, column-1).replace(/^\s+/, '') + '/*|*/' + str.slice(column-1)])
          }
          // Look up the original sourceURL:line:column in .location, or return what we found.
          const locs = _resolveStack.location || (_resolveStack.location = new WeakMap)
          const s = sub
          const srcs = _compileBody.sources, main2 = srcs && srcs.has(main) ? srcs.get(main) : main
          if (locs.has(s))
            [sourceURL, line, column] = locs.get(s)
          else return merged([readAt, main2, sub])
        }
        return sourceURL+':'+line+':'+column
      }).filter(x => x)
      // .functions (an object from sourceURL to function with .lines), .location (a WeakMap from expr to [sourceURL, line, column])
    },
  },

  _isError(v) { return isArray(v) && (v[0] === error || v[0] === jsRejected) },

  elem:{
    docs:`\`(elem TagName Content Extra)\`: creates an HTML DOM element.`,
    nameResult:[
      `element`,
      `DOM`,
      `HTML`,
    ],
    readAt:{
      button:_(`button`),
      files:_(`files`),
      url:_(`url`),
      clone:_(`elemClone`),
      insert:_(`elemInsert`),
      remove:_(`elemRemove`),
      collapse:_(`elemCollapse`),
      value:_(`elemValue`),
    },
    call(tag, content, extra) {
      if (typeof document == ''+void 0) return isArray(content) ? content.join('') : content
      if (typeof tag == 'string' && content === undefined) return document.createElement(tag)

      const r = defines(tag, elem)
      if (typeof r == 'function') return r(tag, content, extra)

      if (typeof tag != 'string') error("Invalid elem tag:", tag)
      if (content != null && typeof content != 'string' && !isArray(content) && !(content instanceof Node))
        errorStack("Invalid elem content:", content)
      const el = document.createElement(tag)
      _elemAppend.to = el, _elemAppend(content)
      return el
    },
  },

  _elemAppend(ch) {
    // Out-of-document DOM append.
    if (isArray(ch)) ch.forEach(_elemAppend)
    else if (ch && ch.parentNode) _elemAppend.to.append(elemClone(ch))
    else if (ch !== undefined) _elemAppend.to.append(ch)
  },

  elemClone(el) {
    const copy = el.cloneNode(false)
    if ('to' in el) elemValue(copy, el.to)
    if (el.special) copy.special = el.special, typeof copy.special == 'function' && copy.special(el, copy)
    if (el.onchange) copy.onchange = el.onchange
    if (el.isWindow) copy.isWindow = true
    if (el.isREPL) copy.isREPL = true
    for (let ch = el.firstChild; ch; ch = ch.nextSibling)
      copy.appendChild(elemClone(ch))
    return copy
  },

  structured:{
    docs:`\`(structured Arrays)\`: shows deep structure of \`Arrays\` (consisting of acyclic or tree arrays and strings and DOM elements): wraps each sub-array in \`<node>\`.`,
    call(x) {
      // structured (('Hello there.') ' ' ('General Kenobi!'))
      if (typeof Node != ''+void 0) {
        // Turn arrays into <node>s.
        const cache = new Map
        return printX(x)
        function printX(x) {
          if (cache.has(x)) return cache.get(x)
          if (isArray(x)) return cache.set(x, elem('node', x.map(printX))), elemValue(cache.get(x), x), cache.get(x)
          if (typeof x == 'string' || x instanceof Node) return x
          throw "Bad structure"
        }
      } else {
        // Use offsets with proper depth for pretty-printing.
        // …or just join them, whatever.
        if (isArray(x)) return x.map(structured).join('')
        if (typeof x == 'string') return x
        throw 'Bad structure'
      }
    },
  },

  structuredSentence(str) {
    // '{hello there}, {general kenobi}' — in DOM, each curly-bracketed sentence fragment gets wrapped in a <span>.
    if (typeof document == ''+void 0) return str.replace(/{|}/g, '')
    let i = 0
    if (str.indexOf('{') < 0) return elem('text', str)
    return parseStr(true)
    function parseStr(top) {
      const a = ['']
      for (; i < str.length && (i && str[i-1] === ' ' || str[i] !== '}'); ++i)
        if (i+1 < str.length && str[i] === '{' && str[i+1] !== ' ') ++i, a.push(parseStr(), '')
        else a[a.length-1] += str[i]
      if (!a[0]) a.shift()
      if (!a[a.length-1]) a.pop()
      let isURL; try { new URL(a);  isURL = true } catch (err) {}
      const el = isURL ? elem(url, a.join(''), '[…]') : a.length ? elem('text', a) : ''
      return !top && elemValue(el, a), el
    }
  },

  referencedBy:{
    docs:`\`(referencedBy Global)\`: returns {all other globals that {this one (likely) refers to}}, and all other globals that this one \`defines\`, in two arrays in one array.
\`referencedBy()\`: returns an array of the {full {global reference} graph} and the {full {global definitions} graph}.`,
    call(f) {
      if (f) {
        const refs = new Set, defs = new Set
        const keywords = new Set(['const', 'try', 'if', 'function', 'new', 'typeof', 'void', 'return', 'else', 'instanceof', 'catch', 'finally', 'let', 'throw', 'while', 'for', 'continue', 'break', 'undefined', 'null', 'true', 'false', 'switch', 'case'])
        let n = 0
        function handle(f, topLevel) {
          if (!f || typeof f != 'object' && typeof f != 'function') return
          if (topLevel === 'def') return defs.add(f)
          if (_invertBindingContext(Self.ctx).has(f))
            if (topLevel !== 'top') return refs.add(f)
          if (++n > 9000) error('too big', [...refs])
          if (refs.has(f)) return; else refs.add(f)
          const d = defines(f, deconstruct)
          if (d && (!isArray(d) || d[0] !== concept)) f = d
          if (typeof f == 'function' && !d)
            _highlightGlobalsInString(_unevalFunction(f)[1], s => !keywords.has(s) && void handle(Self.ctx.get(s)), true)
          if (f instanceof Map) f.forEach((v,k) => (handle(k), handle(v)))
          else if (isArray(f)) f.forEach(v => handle(v))
          else if (f && f[defines.key])
            Object.keys(f[defines.key]).forEach(k => {
              if (concept.idToKey[+k] !== deconstruct || !isArray(d) && d[0] !== concept)
                handle(concept.idToKey[+k], topLevel === 'top' ? 'def' : undefined), handle(f[defines.key][k])
            })
          else if (f && typeof f == 'object') f !== defines(Self, readAt) && Object.keys(f).forEach(k => handle(f[k]))
        }
        handle(f, 'top')
        refs.delete(f)
        function toEnd(set, f) { if (set.has(f)) set.delete(f), set.add(f) }
        toEnd(refs, quote), toEnd(refs, _extracted)
        toEnd(defs, quote), toEnd(defs, _extracted)
        return [[...refs], [...defs]]
      } else {
        if (referencedBy.refs) return [referencedBy.refs, referencedBy.defs]
        let rd, refs = new Map, defs = new Map
        Self.ctx.forEach(v => v && (rd = referencedBy(v), refs.set(v, rd[0]), defs.set(v, rd[1])))
        return referencedBy.refs = refs, referencedBy.defs = defs, [refs, defs]
      }
    },
  },

  referencesTo:{
    docs:`\`(referencesTo Global)\`: returns {all other globals that {this one is (likely) referenced in}}.
\`referencesTo()\`: returns the {full {global back-reference} graph}.`,
    Initialize(net) {
      // Warn about unused private variables (quite expensive to compute, so we hide that using a delay).
      if (typeof document != ''+void 0)
        setTimeout(() => Object.keys(net).forEach(k => k[0] === '_' && !referencesTo(net[k]).length && console.warn('Unused private:', k)), 10000)
    },
    call(f) {
      if (f) return referencesTo().get(f) || []
      else {
        if (referencesTo.refd) return referencesTo.refd
        const refd = new Map
        const [refs, defs] = referencedBy()
        refs.forEach((tos, from) => tos.forEach(to => {!refd.has(to) && refd.set(to, []), refd.get(to).push(from)}))
        return referencesTo.refd = refd
      }
    },
  },

  definersOf:{
    docs:`\`(definersOf Global)\`: returns each global that \`defines\` this one.
\`definersOf()\`: returns the {full {global back-definition} graph}.`,
    call(f) {
      // (Note: a perfectly-precise way to see dependencies/dependents would have been Maps from the defined global to the array of its deps.)
      if (f) return definersOf().get(f) || []
      else {
        if (definersOf.defd) return definersOf.defd
        const defd = new Map
        const [refs, defs] = referencedBy()
        defs.forEach((tos, from) => tos.forEach(to => {!defd.has(to) && defd.set(to, []), defd.get(to).push(from)}))
        return definersOf.defd = defd
      }
    },
  },

  sizeof:{
    docs:`\`(sizeof Global)\`: returns a global's approximate size in \`basic\` in bytes, where namespace-parents get children added up, and privates have their sizes distributed among users.
\`sizeof()\`: returns a \`hierarchy\` of sizes.`,
    call(g) {
      if (!sizeof.sz) {
        const opt = {dontBind:undefined}
        sizeof.sz = new Map
        const bonus = new Map
        Self.ctx.forEach((v,k) => fill(v, typeof k == 'string' && k[0] === '_'))
        bonus.forEach((n,g) => {
          for (; g; g = readAt.parents.get(g) || Self) {
            if (sizeof.sz.get(g)) sizeof.sz.set(g, sizeof.sz.get(g) + n)
            if (g === Self) return
          }
        })
        bonus.clear()
        sizeof.sz.forEach((s,g) => !s && sizeof.sz.delete(g))
        sizeof.sz = new Map([...sizeof.sz].sort((a,b) => b[1] - a[1]))
        function fill(g, isPrivate) {
          if (!g || sizeof.sz.has(g)) return
          opt.dontBind = typeof g != 'boolean' ? g : undefined
          const s = serialize(g, basic, Self.ctx, opt).length
          if (!isPrivate) {
            sizeof.sz.set(g, s)
            let p = readAt.parents.get(g)
            if (p === undefined) p = Self
            bonus.set(p, (bonus.get(p) || 0) + s)
          } else {
            const p = referencesTo(g)
            for (let i=0; i<p.length; ++i)
              bonus.set(p[i], (bonus.get(p[i]) || 0) + s / p.length)
          }
        }
      }
      return !g ? hierarchy(sizeof.sz, Self, undefined, undefined, undefined, false) : sizeof.sz.get(g)
    },
  },

  _highlightGlobalsInString:{
    docs:`Just some approximation. Wraps potential references to globals in <known>.
Also wraps numbers in <number>.
Also wraps links in <a>.
Also wraps C-style comments in <unimportant>.
Also wraps C-style strings in <string>.`,
    call(str, wrapper = s => elem('known', s), noResult = false) {
      if (isArray(str) && str.length == 1) str = str[0]
      if (typeof str != 'string') return str
      if (str.length > 100000) return str

      if (!_highlightGlobalsInString.regex) {
        const regexSrc = ['\\s+', '\\b[0-9]+(?:\\.[0-9+])?\\b', '(?:file|http|https)://(?:[^\\s\'"`:\\}\\)]|:/)+']
        Self.ctx.forEach((v,k) => typeof k == 'string' && regexSrc.push(k.replace(/[^_a-zA-Z0-9]/g, s => '\\'+s)))
        regexSrc.sort((a,b) => b.length - a.length)
        regexSrc.push('//.+', '/\\*[^]+?\\*/')
        regexSrc.push("[a-z]'")
        regexSrc.push("'[^\\n']*'", '"[^\\n"]*"')
        regexSrc.push("`[^\\n`]*`")
        _highlightGlobalsInString.regex = new RegExp(regexSrc.join('|'), 'g')
      }
      const regex = _highlightGlobalsInString.regex
      regex.lastIndex = 0
      if (!regex.test(str)) return str

      const result = !noResult && [str]
      regex.lastIndex = 0
      while (true) {
        const s = !noResult ? result[result.length-1] : str
        if (typeof s != 'string') break
        let r = regex.exec(s)
        if (!r) break
        r = r[0]
        const end = regex.lastIndex, start = end - r.length
        let el
        if (r === ' ' || r && !r.trim())
          !noResult && (el = elem('space', r))
        else if (r && +r === +r)
          !noResult && (el = elemValue(elem('number', r), +r))
        else if (r.slice(0,8) === 'https://' || r.slice(0,7) === 'file://')
          !noResult && (el = elem(url, r))
        else if (r.slice(0,2) === '//' || r.slice(0,2) === '/*' && r.slice(-2) === '*/')
          !noResult && (el = elem('unimportant', r))
        else {
          if (start > 0 && /[_a-zA-Z0-9\.'"`]/.test(s[start-1])) continue
          if (end < s.length && /[_a-zA-Z0-9:'"`]/.test(s[end])) continue
          if (r[0] === "'" && r.slice(-1) === "'" || r[0] === '"' && r.slice(-1) === '"' || r[0] === "`" && r.slice(-1) === "`")
            !noResult && (el = elem('string', r))
          else if (r.length != 2 || r[1] !== "'")
            el = wrapper(r), typeof document != ''+void 0 && el instanceof Element && Self.ctx.has(r) && elemValue(el, Self.ctx.get(r))
          else
            el = r
        }
        if (!noResult) {
          result.pop()
          start && result.push(s.slice(0, start))
          result.push(el)
          end < s.length && result.push(s.slice(end))
          regex.lastIndex = 0
        }
      }
      return result
    },
  },

  style:{
    docs:`An overridable-by-language function that turns {{a serialize/parse node}, {its value}, and {unbound representation}} into a displayed node.`,
    call(s,v,u) { return s },
  },

  nameResult:{
    docs:`\`(nameResult Expr)\`: provides a list of suggestions for naming \`Expr\`. Used in \`serialize\` for more human-readable graph serializations.`,
    call(f) {
      if (typeof f == 'string' && +f !== +f && f.length < 5 && /^[A-Za-z]+$/.test(f)) return [f]
      if (isArray(f)) return null
      return isArray(defines(f, nameResult)) ? defines(f, nameResult) : typeof defines(f, nameResult) == 'string' ? [defines(f, nameResult)] : null
    },
  },

  serialize:{
    docs:`\`(serialize Expr)\` or … or \`(serialize Expr Language Bindings Options)\`: serializes \`Expr\` into a string or a DOM tree (that can be parsed to retrieve the original structure).

A language \`defines\` this to serialize differently. A serialized array's head \`defines\` this with \`0\` to always collapse the array, or with an integer to only show that many items.

\`Options\` \`\`elemCollapse elem('text','must be undefined or a JS object like { style=false, observe=false, collapseDepth=0, collapseBreadth=0, maxDepth=∞, offset=0, offsetWith=''  '', space=()=>'' '', nameResult=false, deconstructPaths=false, deconstructElems=false, dontBind=undefined }')\`\`.
A function/construct can define this with an integer, to collapse children after what's specified (or with \`0\` to collapse arrays with that as a head).`,
    philosophy:`In theory, having symmetric parse+serialize allows updating the language of written code via "read in with the old, write out with the new", but we don't curently do that here. Maaaybe mention that in a tutorial, once we have human-friendly rewriting?`,
    examples:[
      [
        `serialize ^(parse '12')`,
        `"parse '12'"`,
      ],
    ],
    readAt:{
      label:_(`label`),
      bound:_(`bound`),
      unbound:_(`unbound`),
      style:_(`style`),
      parse:_(`parse`),
      nameResult:_(`nameResult`),
      rest:_(`rest`),
    },
    Initialize() {
      // Store styling options in JS objects.
      serialize.dom = {
        style:true,
        observe:true,
        nameResult:true,
        collapseDepth:8,
        collapseBreadth:16,
      }
      serialize.consoleColored = {
        style:true,
        nameResult:true,
        maxDepth:3,
      }
    },
    call(arr, lang, ctx = Self.ctx, opt) {
      let breakLength = opt && opt.breakLength
      const collapseDepth = opt && opt.collapseDepth || 0
      const collapseBreadth = opt && opt.collapseBreadth || 0
      const maxDepth = opt && opt.maxDepth
      const offset = opt && opt.offset !== undefined ? opt.offset : 0
      const offsetWith = opt && opt.offsetWith !== undefined ? opt.offsetWith : '  '
      const space = opt && opt.space !== undefined ? opt.space : () => ' '
      const doNameResult = opt && opt.nameResult
      const deconstructPaths = opt && opt.deconstructPaths || false
      const deconstructElems = opt && opt.deconstructElems || false
      const doObserve = opt && opt.observe || false
      const dontBind = opt && opt.dontBind

      if (!lang) lang = fancier
      const styles = opt && opt.style && defines(lang, style) || undefined

      const backctx = _invertBindingContext(serialize.ctx = ctx)
      const deconstruction = new Map
      const named = new Set
      const lengths = new Map
      const initialUnenv = new Map
      let boundToUnbound
      const unboundToBound = new Map
      const weakMaps = []
      const doNotEmit = new Set
      let postDeconstructed
      const prevSrlzStyles = serialize.styles;  serialize.styles = styles
      try { postDeconstructed = deconstructed(arr) }
      finally { serialize.styles = prevSrlzStyles }

      const resultElem = styles && typeof document != ''+void 0 && elem('serialization')
      if (resultElem) elemValue(resultElem, arr), resultElem.special = true

      if (doObserve) {
        const a = []
        unboundToBound.forEach((b,u) => !backctx.has(b) && a.push(b))
        const reserialize = _throttled(((el, top, lang, ctx, opt, all) => {
          return b => {
            all.forEach(b => observe(b, reserialize, false))
            el.isConnected && el.replaceWith(serialize(top, lang, ctx, opt))
          }
        })(resultElem, arr, lang, ctx, opt, a), .2)
        a.forEach(b => observe(b, reserialize, true))
      }

      let n = 0
      const freeNames = []
      const nodeNames = styles && typeof document != ''+void 0 && new Map
      backctx.forEach((v,k) => (dontBind === undefined || k !== dontBind) && initialUnenv.set(k,k))
      doNotEmit.forEach(v => initialUnenv.set(v,v))
      let u
      try { u = unbound(postDeconstructed, nameAllocator, boundToUnbound = new Map(initialUnenv), maxDepth) }
      catch (err) {
        if (err !== "Cycles") throw err
        u = _unboundButSimple(postDeconstructed, nameAllocator, boundToUnbound = new Map(initialUnenv))
      }
      boundToUnbound.forEach((u,b) => {
        if (b === u) return
        if (unboundToBound.has(b)) b = unboundToBound.get(b)
        if (!unboundToBound.has(u) || !isArray(b))
          unboundToBound.set(u, b)
      })
      boundToUnbound.clear()
      if (breakLength) breakLength -= offset * offsetWith.length

      let struct = [], len = 0
      emit(defines(lang, serialize), u)
      if (isArray(struct) && struct.length == 1) struct = struct[0]

      const inResult = recCollapse(serializeLines(struct, offset))
      deconstruction.clear()
      if (resultElem)
        return resultElem.append(inResult), resultElem
      else
        return inResult

      function emit(f, u, arg1, arg2, arg3, arg4) {
        if (typeof f == 'function') {
          let v = valueOfUnbound(u)
          if (typeof document != ''+void 0 && u instanceof Element && u.to !== v) elemValue(u, v)
          const unenved = unenv(u, v)
          if (!styles) return unenved === u ? f(emit, u, arg1, arg2) : ((struct || (struct = [])).push(unenved), undefined)
          let prev = struct
          struct = undefined

          let r
          if (unenved === u || (unenved !== unenved && u !== u))
            r = f(emit, u, arg1, arg2, arg3, arg4)
          else
            struct = [unenved]

          if (struct) {
            if (isArray(v) && v[0] === bound && v[1] instanceof Map && v.length == 3) v = v[2]
            const isStyled = struct.length == 1 && (isArray(struct[0]) || typeof document != ''+void 0 && struct[0] instanceof Node)
            // Only style once.
            ;(prev || (prev = [])).push(isStyled ? struct[0] : styleNode(struct, u, v))
          }
          struct = prev
          return r
        } else if (typeof f == 'string') {
          len += f.length
          return (struct || (struct = [])).push(styles ? styleNode(f) : f), f
        } else if (typeof document != ''+void 0 && f instanceof Node)
          return ++len, (struct || (struct = [])).push(f), f
        else if (f === undefined)
          return len
        else {
          console.error("Unknown type to emit:", f, 'id:'+_id(f))
          const el = _colored(elemValue(elem('number', '<< id:'+_id(f)+' >>'), f), 4, 24)
          if (typeof document != ''+void 0 && el instanceof Node) el.special = true
          emit(el)
          return
        }
      }
      function recCollapse(el, depth = 0) {
        if (typeof document == ''+void 0 || !(el instanceof Element) || el.tagName === 'NODE' && !('to' in el) || el.classList.contains('label')) return el
        for (let ch = el.firstChild; ch; ch = ch.nextSibling)
          ch = recCollapse(ch, el.tagName === 'NODE' ? depth+1 : depth)
        // If the deconstructed value is an array with a head that defines `serialize`, collapse as needed.
        const unb = deconstruction.get(el.to)
        const definedCollapse = isArray(unb) ? defines(unb, serialize) : null
        if (depth && definedCollapse === 0 || depth && el.tagName === 'NODE' && depth % collapseDepth === 0 || el.tagName == 'STRING' && typeof el.to == 'string' && el.to.length > 128) {
          const title = el.title
          el = styleNode(elemCollapse(el), unb, el.to)
          title && (el.title = title)
        }
        const breadth = definedCollapse || collapseBreadth
        if (breadth && typeof el.to != 'string' && el.childNodes.length-2 > breadth && el.title !== 'bound')
          for (let i = breadth+1, ch = el.firstChild; i && ch; ch = ch.nextSibling)
            'to' in ch && --i, !i && elemCollapse(ch, null);
        return el
      }

      function valueOfUnbound(u, secondTime) {
        if (isArray(u) && u[0] === bound && u[1] instanceof Map) u = u[2]
        if (unboundToBound.has(u)) return unboundToBound.get(u)
        if (typeof document != ''+void 0 && u instanceof Element && 'to' in u)
          return u.to
        if (backctx.has(u)) return u
        if (_isDOM(u)) return u
        if (isArray(u) && u.length == 3 && u[0] === _extracted) return [_extracted, valueOfUnbound(u[1]), valueOfUnbound(u[2])]
        if (isArray(u) && secondTime === undefined) return u.map(valueOfUnbound)
        if (typeof u != 'string') console.warn("Did not find the value of the unbound", u)
        return u
      }
      function styleNode(str, u, v) {
        if (!styles) return !isArray(str) ? str : str.join('')
        !unboundToBound.has(u) && unboundToBound.set(u,v)
        const originalLen = lengths.get(str) || str && str.length
        if ((str === ' ' || typeof str == 'string' && !str.trim()) && u === undefined && v === undefined) return elem('space', str)

        // Associate with the value to bathe same-objects in the same light.
        const el = styles(str, v, u, ctx)
        if (_isStylableDOM(el)) elemValue(el, v)

        return lengths.set(el, originalLen), el
      }
      function styleLabel(name, u, v) {
        return styleNode(_escapeLabel(name, lang), u, v)
      }
      function nameAllocator(x, free) {
        if (free === undefined) {
          // Try names, first suggestions by `nameResult` then previously-freed non-suggestion things then in-sequence.
          let s, suggested = false, suggestedI = 0, suggestions
          if (doNameResult && (isArray(x) || typeof x == 'string'))
            suggestions = nameResult(isArray(x) ? x[0] : x)
          do {
            if (suggestions && suggestedI < suggestions.length) suggested = true, s = suggestions[suggestedI++]
            else if (suggested = false, freeNames.length) s = freeNames.pop()
            else s = toString(n++, 'abcdefghijklmnopqrstuvwxyz')
          } while (named.has(s) || backctx && backctx.has(s))
          named.add(s)
          if (suggested) lengths.set(s,s)
          const styled = styleLabel(s, [label, s], x)
          if (typeof document != ''+void 0 && styled instanceof Node) nodeNames.set(styled, s)
          return styled
        } else {
          if (typeof document != ''+void 0 && free instanceof Node) free = nodeNames.get(free)
          if (_isLabel(free)) free = free[1]
          named.delete(free)
          if (lengths.get(free) === free) return lengths.delete(free)
          freeNames.push(free)
        }
      }
      function deconstructed(x) {
        // Return a copy of x with non-array non-string non-backctx things deconstructed.
        if (!deconstructElems && typeof document != ''+void 0 && x instanceof Element)
          return x.parentNode && x.isConnected && initialUnenv.set(x, x = elemClone(x)), x
        if (deconstruction.has(x)) {
          if (deconstruction.get(x) === undefined) deconstruction.set(x, x.slice())
          x = deconstruction.get(x)
          if (deconstruction.has(x) && deconstruction.get(x) === undefined) deconstruction.set(x, x.slice())
          if (deconstruction.has(x)) x = deconstruction.get(x)
          return x
        }

        if (x instanceof WeakMap) {
          const y = [weakMap]
          deconstruction.set(x, y), unboundToBound.set(y, x), weakMaps.push(x)
          deconstruction.forEach((dec, original) => x.has(original) && y.push(dec, deconstructed(x.get(original))))
          return y
        }

        if (_isLabel(x)) return unboundToBound.set(x,x), named.add(x[1]), x
        if (backctx && backctx.has(x))
          if (dontBind === undefined || x !== dontBind)
            return unboundToBound.set(x,x), named.add(backctx.get(x)), x
        const original = x
        if (deconstructElems || !_isDOM(x))
          if (typeof x != 'string' && typeof x != 'number')
            if (!isArray(x))
              x = deconstruct(x, deconstructPaths)
        unboundToBound.set(x, original)
        deconstruction.set(original, x)

        // Hide parts (not even doing `unbound` on them), because they've proven to be dangerous (far too long and memory-intensive to serialize).
        let hide = null
        if (_isDisposable(original) && !original.isDisposedInternal && original.size > _maxSerializedTensorSize[1])
          hide = 1, unboundToBound.set(x[hide], x[hide]), doNotEmit.add(x[hide])
        if (!isArray(original) && typeof defines(x, unbound) == 'number')
          hide = defines(x, unbound), unboundToBound.set(x[hide], x[hide]), doNotEmit.add(x[hide])

        if (isArray(x) && !_isLabel(x)) {
          let copy, changed = false
          deconstruction.set(x, undefined)
          for (let i = 0; i < x.length; ++i) {
            const v = i !== hide ? deconstructed(x[i]) : x[i]
            if (v !== x[i]) {
              if (!changed) {
                copy = deconstruction.get(x) || x.slice()
                changed = true
                unboundToBound.set(copy, original)
                deconstruction.set(original, copy), deconstruction.set(x, copy)
              }
              copy[i] = v
            }
          }
          if (!changed) deconstruction.set(x,x), copy = x
          x = copy
        }

        // Handle `weakMap`s.
        for (let i = 0; i < weakMaps.length; ++i)
          if (weakMaps[i].has(original))
            deconstruction.get(weakMaps[i]).push(x, deconstructed(weakMaps[i].get(original)))

        return x
      }
      function toString(i, alphabet) {
        if (i < alphabet.length) return alphabet[i]
        return toString(Math.floor(i / alphabet.length), alphabet) + alphabet[i % alphabet.length]
      }
      function pprint(arr, breakLength) {
        if (!isArray(arr) || hasNonString(arr)) return arr
        // Either join arr (of strings) inline, or realize it is too long.
        if (!arr.length) return arr
        let len
        if (breakLength != null) {
          len = lengths.get(arr[0]) || arr[0].length
          for (let i = 1; i < arr.length; ++i) {
            if (i > 1 && i < arr.length-1) len += space(arr[i-1], arr[i]).length || 0
            len += lengths.get(arr[i]) || arr[i].length
            if (breakLength != null && len >= breakLength) break
          }
        }
        if (breakLength == null || len + offsetWith.length-1 < breakLength) {
          const joined = arr.join('')
          const styled = styleNode(joined, arr, valueOfUnbound(arr.unbound))
          lengths.set(styled, len)
          return styled
        } else
          return arr
      }
      function hasNonString(r) {
        for (let i = 0; i < r.length; ++i) if (typeof r[i] != 'string') return true
      }
      function unenv(u,v) {
        if (doNotEmit.has(v)) {
          if (!styles) return '···'
          const col = elemValue(elem('collapsed', '···'), v)
          col.special = true
          return col
        }
        if (backctx && backctx.has(v)) {
          if (dontBind !== undefined && v === dontBind) return u
          named.add(backctx.get(v))
          const name = backctx.get(v)
          return styleLabel(name, label(name), v)
        }
        return u
      }
      function pad(s, len) { return s.length >= len ? s : s + ' '.repeat(len - s.length) }
      function replaceSpaces(arr, str) {
        return !isArray(arr) ? arr : arr.map(x => !el.trim() ? str : x)
      }
      function serializeLines(arr, depth = 0) {
        if (!isArray(arr)) return arr
        const d = depth+1
        const serialized = pprint(arr.map(line => serializeLines(line, d)), breakLength && (breakLength - d * offsetWith.length))
        if (!isArray(serialized)) return serialized
        
        if (hasNonString(serialized))
          return styleNode(serialized, arr.unbound, valueOfUnbound(arr.unbound))
        else {
          if (serialized[0] === '(') serialized[0] = pad('(', offsetWith.length)
          const s = replaceSpaces(serialized, '\n' + offsetWith.repeat(d)).join('')
          return styleNode(s, arr.unbound, valueOfUnbound(arr.unbound))
        }
      }
    },
  },

  elemValue:{
    docs:`If el, remember that it is a viewer of v. If !el, return an array of all in-document viewers of v.`,
    Initialize() {
      elemValue.empty = Object.freeze([]) // Always empty.
      if (typeof document == ''+void 0) return
      elemValue.elems = new Map // A map from an object to array of elements with that as value.
      elemValue.resources = new Set // Objects that should be disposed when unneeded.
    },
    call(el, v, removeElemTree = false, recursiveRemove = false, justRemoveEntry = false) {
      if (typeof document == ''+void 0) return elemValue.empty
      const originalV = v
      if (isArray(v) && v[0] === quote && v.length == 2) v = v[1]
      const m = elemValue.elems
      if (el instanceof Element) {
        let subV = el.to
        if (isArray(subV) && subV[0] === quote && subV.length == 2) subV = subV[1]
        if ('to' in el && m.has(subV) && m.get(subV).indexOf(el) >= 0)
          // If changing the value, remove the old one.
          m.get(subV).splice(m.get(subV).indexOf(el), 1)
        if (removeElemTree) {
          if (justRemoveEntry) return
          if (isArray(el.to) && el.to[0] === evaluator) _cancel(el.to[2])
          if (isArray(el.to) && el.to[0] === _evaluationElem) _cancel(el.to[1])
          elemValue(null, el.to, true, false)
          if (recursiveRemove)
            for (let ch = el.firstChild; ch; ch = ch.nextSibling)
              elemValue(ch, null, true, true)
          return
        }
        el.to = originalV
        if (_isDisposable(v) && !_rememberToDispose.seen.has(v))
          elemValue.resources.add(v)
        if (!m.has(v)) m.set(v, [])
        m instanceof Map && _limitMapSize(m, 100000)
        if (m.get(v).indexOf(el) >= 0) return el
        if (!el.classList.contains('groupedValue')) m.get(v).push(el)
        return el
      } else {
        if (!removeElemTree && m.has(v) && !justRemoveEntry) {
          // Filter out non-connected elems in-place.
          let n = 0, arr = m.get(v)
          for (let i=0; i < arr.length; ++i)
            if (arr[i].isConnected) arr[n++] = arr[i]
            else elemValue(arr[i], undefined, true, true)
          arr.length = n
        }
        if (elemValue.resources.has(v) && _rememberToDispose.seen.has(v)) elemValue.resources.delete(v)
        if (m.has(v) && !m.get(v).length) m.delete(v), elemValue.resources.has(v) && !v.isDisposedInternal && dispose(v), elemValue.resources.delete(v)
        return m.get(v) || elemValue.empty
      }
      // .empty, .elems, .resources
    },
  },

  _colorVariables:[
    _(`settings`),
    false,
    `Whether we should paint labels for the same values with the same color (randomly for each value), in parses and serializations.`,
  ],

  _maxSerializedTensorSize:[
    _(`settings`),
    64,
    `Max data size before we collapse \`tensor\` data, in serializations.`,
  ],

  _valuedColor(v) {
    // Returns v's previously displayed element color (for highlighting of the same things) or a new one.
    if (!_colorVariables[1]) return 'var(--main)'
    if (!_valuedColor.m) _valuedColor.m = new Map
    if (_valuedColor.m.has(v)) {
      const r = _valuedColor.m.get(v)
      _valuedColor.m.delete(v), _valuedColor.m.set(v, r)
      return r
    }
    const prevPure = call.pure
    call.pure = false
    const colors = [randomNat(256), randomNat(256), randomNat(256)]
    call.pure = prevPure
    const mn = 64, mx = 384, Sum = colors[0]+colors[1]+colors[2]
    if (Sum < mn) colors[0] *= mn/Sum, colors[1] *= mn/Sum, colors[2] *= mn/Sum
    if (mx < Sum) colors[0] *= mx/Sum, colors[1] *= mx/Sum, colors[2] *= mx/Sum
    const c = 'rgb(' + colors + ')'
    _valuedColor.m.set(v, c)
    _limitMapSize(_valuedColor.m, 100000)
    return c

    // .enabled
  },

  js:{
    docs:`A namespace of everything pertaining to the host language, JavaScript.
Somewhat usable in a REPL.`,
    readAt:{
      instanceof:_(`instanceof`),
      continue:_(`continue`),
      break:_(`break`),
      finally:_(`finally`),
      typeof:_(`typeof`),
      return:_(`return`),
      throw:_(`throw`),
      catch:_(`catch`),
      while:_(`while`),
      void:_(`void`),
      else:_(`else`),
      for:_(`for`),
      let:_(`let`),
      new:_(`new`),
      switch:_(`switch`),
      case:_(`case`),
      function:_(`function`),
      if:_(`if`),
      const:_(`const`),
    },
    REPL:_(`false`),
    parse(match) {
      const struct = [jsEval, '']
      let n = 0, ctx, expr = ''
      while (true) {
        const str = match(/[^]*/y)
        if (str && str.indexOf('ⴲ')>=0) throw "ⴲ is used internally; use another char eternally"
        if (str) expr += str
        const r = match(_specialParsedValue)
        if (r !== undefined) {
          const name = 'ⴲ'+(n++).toString(36)
          expr += ' '+name+' ', (ctx || (ctx = new Map)).set(name, r.to)
        }
        if (str === undefined && r === undefined) break
      }
      struct[1] = expr
      if (ctx) struct[2] = ctx
      return struct
    },
    serialize(match, u) {
      if (u[0] !== jsEval || typeof u[1] != 'string' || u[2] && (!isArray(u[2]) || u[2][0] !== map) || u.length > 3) {
        if (typeof document != ''+void 0 && isArray(u) && u[0] instanceof Element)
          return match(_fancyTopLevel, u)
        if (typeof document != ''+void 0 && isArray(u) && u[0] === jsRejected && typeof u[1] == 'string' && u.length == 2)
          return match(elem('error', u[1]))
        u = bound(_invertBindingContext(Self.ctx), u)
        if (typeof uneval != ''+void 0) u = [jsEval, uneval(u)]
        else u = [jsEval, JSON.stringify(u)]
      }
      if (typeof document == ''+void 0) {
        if (u.length != 2) throw "Wrong count of args for JS code"
        match(u[1])
        return
      }
      const special = / ⴲ[a-zA-Z0-9]+ /g, str = u[1], ctx = u[2][0].call(...u[2])
      let r, i = 0
      while (r = special.exec(str)) {
        match(str.slice(i, special.lastIndex - r[0].length))
        match(defines(js, serialize), ctx.get(r[0].slice(1,-1)))
        i = special.lastIndex
      }
      match(str.slice(i))
    },
    style(struct) {
      if (!isArray(struct)) return struct
      return elem('span', struct.map(s => typeof s != 'string' ? s : elem('span', _highlightGlobalsInString(s))))
    },
    philosophy:`JS (and the web ecosystem) is a seemingly-unimpressive language that aims to take over all aspects of computing, in a manner similar to the ones before but completely safe and universal and eventually as little loss in performance as is possible. Like attracts like, and Conceptual is written in JS, though it's obviously much less impressive, because much less total thinking time went into it.`,
  },

  _extracted:{
    docs:`For parsing \`c:x\`. Returning this to a \`REPL\` binds a label to a value too, I guess.`,
  },

  _unrollRest(a) {
    // (1 2 (rest (3 4 5)) 6 7) —> (1 2 3 4 5 6 7).
    if (isArray(a))
      for (let i = 0; i < a.length; ++i)
        if (isArray(a[i]) && a[i][0] === rest && a[i].length == 2)
          !isArray(a[i][1]) && error('Expected the array to unroll'),
          a.splice(i, 1, ...a[i][1]) // Quadratic but easy.
  },

  parse:{
    docs:`\`(parse String)\` or … or \`(parse String Language Bindings Options)\`: parses String into the graph represented by it, returning \`(Expr StyledInput)\`.
This first turns a \`String\` into a tree-of-arrays via syntax rules of \`Language\`, then into a graph-of-arrays via \`bound\`, then into graph-of-objects via \`makeGraph\`.

\`Options\` is like \`{style false sourceURL '' syntaxOnly false}\`.`,
    todo:`Cache same-rule+position unchanged subtrees when re-parsing, for speed. Re-\`construct\` same-rule+position changed subtrees where possible, for more speed.`,
    philosophy:`Parsing is more than just extracting meaning from a string of characters (it's also styling and associating source positions).`,
    Initialize() {
      parse.dom = { style:true, openCollapsed:true }
    },
    call(string, lang, ctx = Self.ctx, opt = null) {
      if (!lang) lang = fancier
      const [doWeStyle = false, sourceURL = '', syntaxOnly = false, openCollapsed = false] = _destructure(opt, ['style', 'sourceURL', 'syntaxOnly', 'openCollapsed'])
      const styles = doWeStyle ? defines(lang, style) || style : undefined

      let [
        str,
        i = 0, lastI = 0, prevI = 0, localS,
        localI = 0, curBegin = 0, line = 1, column = 1,
        lineLengths = sourceURL && [], lines = sourceURL && new Map, columns = sourceURL && new Map, struct = styles && [],
        Unbound = styles && new Map, env, u, b,
        makeEnv
      ] = interrupt(18)
      try {
        if (str === undefined) {
          if (typeof string == 'string') str = string ? [string] : []
          else if (_isDOM(string)) str = _innerText(string) // Don't even attempt to cache subtrees
          else error('Expected a string, or an array of strings and special elements, but got', string)
          localS = str[0]
        }
        function localUpdate(newI) {
          // Update localS/localI/curBegin to match the index.
          let prev = prevI;  prevI = newI
          while (newI < curBegin && localI > 0) {
            moveLines(prev, prev = curBegin)
            localS = str[--localI]
            curBegin -= typeof localS == 'string' ? localS.length : 1
          }
          while (newI >= curBegin + (typeof localS == 'string' ? localS.length : 1) && localI < str.length) {
            const next = curBegin + (typeof localS == 'string' ? localS.length : 1)
            moveLines(prev, prev = next)
            curBegin = next
            localS = str[++localI]
          }
          moveLines(prev, newI)
        }
        function moveLines(prevI, newI) {
          if (!sourceURL) return
          if (typeof localS != 'string') return column += newI - prevI
          for (let i = prevI; i < newI; ++i)
            if (localS[i - curBegin] === '\n') lineLengths[line++] = column, column = 1
            else ++column
          for (let i = prevI; i-- > newI; )
            if (localS[i - curBegin] === '\n') column = lineLengths[--line]
            else --column
        }

        function match(f, arg1, arg2, arg3, arg4) {
          // If a function, call it;
            // if _specialParsedValue or string or regex, match and return one if possible;
            // if a number, set global index; if undefined, get global index.
          if (typeof f == 'function') {
            const start = i, startLen = struct && struct.length
            const startLine = line, startColumn = column
            const r = f(match, _specialParsedValue, arg1, arg2, arg3, arg4)
            _unrollRest(r)
            if (start < i) {
              if (struct) {
                localUpdate(lastI)
                lastI < i && typeof localS == 'string' && struct.push(localS.slice(lastI - curBegin, i - curBegin))
                if (startLen < struct.length-1 || typeof struct[startLen] == 'string') {
                  const a = struct.splice(startLen)
                  Unbound.set(a, r), struct.push(a)
                }
              }
              localUpdate(i)
            }
            if (sourceURL && isArray(r)) lines.set(r, startLine), columns.set(r, startColumn)
            lastI = i
            return r
          } else if (f === _specialParsedValue) {
            const s = localS
            if (localS != null && typeof localS != 'string') {
              return ++i, struct && lastI < i && struct.push(s), lastI = i, localUpdate(i), s
            }
          } else if (typeof f == 'string') {
            if (typeof localS == 'string' && localS.slice(i - curBegin, i+f.length - curBegin) === f)
              return i += f.length, struct && lastI < i && struct.push(localS.slice(lastI - curBegin, i - curBegin)), lastI = i, localUpdate(i), f || true
            return false
          } else if (f instanceof RegExp) {
            if (typeof localS != 'string') return
            if (!f.sticky) throw "Matched regexp must be sticky"
            f.lastIndex = i - curBegin
            const r = f.exec(localS)
            if (r)
              return i+=r[0].length, struct && lastI < i && struct.push(localS.slice(lastI - curBegin, i - curBegin)), lastI = i, localUpdate(i), r[0]
            else return
          } else if (typeof f == 'number') {
            if (f !== f>>>0) throw "A number must be an index"
            i = f, localUpdate(i)
          } else if (f === undefined)
            return i
          else throw "Invalid argument to match"
        }
        match.notEnoughInfo = msg => { throw localI === str.length ? ['give more', msg] : msg }


        if (env === undefined) {
          // Match structure.
          try { u = !lang ? match(parser.topLevel) : match(defines(lang, parse)) }
          catch (err) { throw err !== interrupt ? err : error("Interrupts during syntax parsing are not allowed (`makeGraph` can have those, though)") }
          if (localI < str.length) throw 'Superfluous characters at the end: ' + (typeof localS == 'string' ? localS.slice(i - curBegin) : '···')

          // Do binding with the original⇒copy map preserved so that we can style structure bottom-up properly.
          env = (styles || sourceURL) && new Map || null
          try { b = styles || sourceURL ? bound(ctx, u, true, env) : bound(ctx, u, true) }
          catch (err) { throw err !== interrupt ? err : error("Interrupts during binding are very unexpected") }
          makeEnv = (styles || sourceURL) && new Map
        }
        // The only part that can interrupt:
        try { b = makeGraph(b, makeEnv, syntaxOnly, openCollapsed) } catch (err) { if (err === interrupt) throw err;  b = _errorRepr(err).map(quote) }

        function styleNode(struct) {
          if (typeof document != ''+void 0 && struct instanceof Node) return struct
          let unb, v
          if (!Unbound.has(struct) && typeof struct == 'string' && ctx.has(struct))
            unb = label(struct), v = ctx.get(struct)
          else
            unb = Unbound.get(struct), v = ctx.has(unb) ? ctx.get(unb) : env.has(unb) ? env.get(unb) : unb, makeEnv.has(v) && (v = makeEnv.get(v)),
            // "Unbound" here really means "bound but not made". Inconsistent, but, styling needs this more.
            env.has(unb) && (unb = env.get(unb))
          if (typeof struct == 'string' && (struct === ' ' || !struct.trim()) && unb === undefined && v === undefined)
            return elem('space', struct)
          if (isArray(struct)) {
            struct = struct.map(styleNode)
            if (struct.length == 1 && (isArray(struct[0]) || typeof document != ''+void 0 && struct[0] instanceof Node))
              return struct[0]
          }
          if (sourceURL && lines.has(unb))
            (_resolveStack.location || (_resolveStack.location = new WeakMap)).set(v, [sourceURL, lines.get(unb), columns.get(unb)])
          const s = styles(struct, v, unb, ctx)
          if (typeof Element != ''+void 0 && s instanceof Element) elemValue(s, v)
          return s
        }
        styles && Unbound.set(struct, u)
        return styles ? [b, styleNode(struct)] : b
      } catch (err) {
        if (err === interrupt) interrupt.stack.push(str, i, lastI, prevI, localS, localI, curBegin, line, column, lineLengths, lines, columns, struct, Unbound, env, u, b, makeEnv)
        throw err
      }
    },
  },

  _specialParsedValue:{
    docs:`When matched in \`parse\` rules, represents a value that should be preserved as-is (as it likely comes from a special DOM element/reference).`,
  },

  _basicEscapeLabel(s) {
    basic.labels.lastIndex = 0
    return s && basic.labels.test(s) && basic.labels.lastIndex === s.length ? s : '`' + s.replace(/`/g, '``') + '`'
  },

  _basicUnescapeLabel(s) { return s[0] === '`' ? s.slice(1,-1).replace(/``/g, '`') : s },

  _basicLabel(match, u) { // a, qwer, `a`; 12, 1e6
    if (u === _specialParsedValue) {
      const r = match(/`(?:[^`]|``)*`/y)
      if (r !== undefined) return label(r.slice(1,-1).replace(/``/g, '`'))

      const n = match(basic.labels)
      if (n === undefined) return
      return n && +n === +n || n === 'NaN' ? +n : label(n)
    }
    if (typeof u == 'number') match(''+u)
    else if (_isLabel(u) && typeof u[1] == 'string') {
      basic.labels.lastIndex = 0, basic.labels.test(u[1])
      match(u[1].length && basic.labels.lastIndex === u[1].length ? u[1] : '`' + u[1].replace(/`/g, '``') + '`')
    } else console.error('Invalid label', u), error("Invalid label", u)
  },

  _basicString(match, u) { // '...''...' or "...""..."
    if (u === _specialParsedValue) {
      let r = match(/'(?:[^']|'')*'/y)
      if (r !== undefined) return r.slice(1,-1).replace(/''/g, "'")
      r = match(/"(?:[^"]|"")*"/y)
      if (r !== undefined) return r.slice(1,-1).replace(/""/g, '"')
      return
    }
    // Unquote with both quotes, and return the min-length one.
    if (typeof u != 'string') throw "Expected a string"
    const a = '"' + u.replace(/"/g, '""') + '"'
    const b = "'" + u.replace(/'/g, "''") + "'"
    return match(a.length < b.length ? a : b)
  },

  _basicExtracted(match, u, base) { // c:x
    if (u === _specialParsedValue) {
      const key = match(base)
      if (key !== undefined && match(/\s*:\s*/y)) {
        const v = match(base)
        v === undefined && match.notEnoughInfo("Expected an actual value to be extracted")
        return _basicExtracted.lastExtractedObj = [_extracted, key, v]
      } else return key
    }
    if (isArray(u) && u[0] === _extracted && u.length == 3)
      match(base, u[1]), match(':'), match(base, u[2])
    else match(base, u)
  },

  _basicMany(match, u, syntax, base) { // a b c c:x
    // `syntax`: null or [null, ' ', /\s+/y], or ['map', ', ', /\s*,\s*/y]
    if (u === _specialParsedValue) {
      const arr = !syntax || !syntax[0] ? [] : [syntax[0]]
      let ctx
      while (true) {
        match(syntax && syntax[2] || /\s+/y)
        const v = match(_basicExtracted, base)
        if (v === undefined) break
        if (isArray(v) && v[0] === _extracted)
          (ctx || (ctx = new Map)).set(v[1], v[2])
        else arr.push(v)
      }
      if (ctx) return [bound, ctx, arr]
      return arr
    }
    if (!isArray(u)) error("Must be an array:", u)
    let ctx
    if (isArray(u) && u[0] === bound && u[1] instanceof Map && u.length == 3)
      ctx = u[1], u = u[2]
    _needsGrouping.pos && _needsGrouping.pos.delete(match())
    if (isArray(u))
      for (let b = false, j = !syntax || !syntax[0] ? 0 : 1; j < u.length; ++j) {
        b ? match(syntax && syntax[1] || ' ') : (b = true)
        match(_basicExtracted, u[j], base)
      }
    else
      match(_basicExtracted, u, base)
    if (ctx) ctx.forEach((v,k) => (match(syntax && syntax[1] || ' '), match(_basicExtracted, [_extracted, k, v], base)))
  },

  _basicCall(match, u, _, base) { // (a b c c:x)
    return _matchBracketed(match, u, _basicMany, null, '(', ')', base)
  },

  _fancyMap(match, u, _, base) { // {a b c c:x}
    return _matchBracketed(match, u, _basicMany, 'map', '{', '}', base)
  },

  _matchBracketed(match, u, base, head, open, close, arg1, arg2) { // (base)
    if (u === _specialParsedValue) {
      if (!match(open)) return
      const arr = base(match, u, head && [label(head)], arg1, arg2)
      if (!match(close)) match.notEnoughInfo('Expected a closing bracket')
      return arr
    }
    match(open), base(match, u, head && [_unctx(head)], arg1, arg2), match(close)
  },

  _basicValue(match, u, callSyntax, base) { // String or label or call.
    const isFancy = base === _fancyOutermost || base === _fancierOutermost
    if (u === _specialParsedValue) {
      if (isFancy && match('?')) return label('input')
      let r
      if ((r = match(_specialParsedValue)) !== undefined) return r
      if ((r = match(_basicString)) !== undefined) return r
      if ((r = match(_basicLabel)) !== undefined) return r
      if (isFancy && (r = match(_fancyMap, null, base)) !== undefined) return r
      if (callSyntax && (r = match(callSyntax, null, base)) !== undefined) return r
      return
    }
    else if (typeof u == 'string')
      match(_basicString, u)
    else if (typeof u == 'number' || _isLabel(u))
      match(_basicLabel, u)
    else if (isArray(u) && u[0] === _extracted && u.length == 3)
      match(_basicExtracted, u, base)
    else if (isFancy && isArray(u) && u[0] === _unctx('map'))
      match(_fancyMap, u, null, base)
    else if (callSyntax && isArray(u))
      match(callSyntax, u, null, base)
    else match(u)
  },

  _needsGrouping(match) { return _needsGrouping.pos && _needsGrouping.pos.has(match()) },

  _emitGrouping(match, need) {
    if (need === undefined)
      return _needsGrouping(match) ? (match(_emitGrouping.groupOpen), true) : false
    if (need) match(_emitGrouping.groupClose)
    // .groupOpen ('[' or '('), .groupClose(']' or ')')
  },

  _unctx(s) { return serialize.ctx.get(s) },

  _matchLtR(match, u, topLevel, base, reprs, reverse = false) { // [[a+b]+c]+d
    // Parses/serializes two-arg functions as left-to-right strings.
    //   reprs: ['add', '+', /\+/y, 'sub', '-', /\-/y].
    //   (The label can be `null` to parse to a two-arg function call.)
    if (u === _specialParsedValue) {
      let a = match(base), op
      if (a === undefined) return
      outer: while (true) {
        for (let i=0; i < reprs.length; i += 3)
          if (op = match(reprs[i+2])) {
            const b = match(base)
            b === undefined && match.notEnoughInfo('Expected the second arg of '+op.trim())
            a = reprs[i] !== null ? [label(reprs[i]), a, b] : !reverse ? [a, b] : [b, a]
            continue outer
          }
        break
      }
      return a
    }
    if (isArray(u))
      for (let i=0; i < reprs.length; i += 3)
        if (reprs[i] !== null ? u.length == 3 && u[0] === _unctx(reprs[i]) : u.length == 2) {
          const g = _emitGrouping(match)
          const start = reprs[i] !== null ? 1 : !reverse ? 0 : 1, end = reprs[i] !== null || !reverse ? start+1 : start-1
          _matchLtR(match, u[start], undefined, base, reprs, reverse), match(reprs[i+1]), match(base, u[end], topLevel)
          _emitGrouping(match, g)
          return
        }
    match(base, u, topLevel)
  },

  _matchRtL(match, u, topLevel, baseLeft, baseRight, reprs) { // a^[b^[c^d]]
    // reprs: ['pow', '**', /\s*\*\*\s*/y]
    //   (The label can be `null` to parse to a two-arg function call.)
    if (u === _specialParsedValue) {
      let a = match(baseLeft), op
      if (a === undefined) return
      for (let i=0; i < reprs.length; i += 3)
        if (op = match(reprs[i+2])) {
          const b = match(baseRight)
          b === undefined && match.notEnoughInfo('Expected the second arg of '+op.trim())
          a = reprs[i] !== null ? [label(reprs[i]), a, b] : [a, b]
        }
      return a
    }
    if (isArray(u))
      for (let i=0; i < reprs.length; i += 3)
        if (reprs[i] !== null ? u.length == 3 && u[0] === _unctx(reprs[i]) : u.length == 2) {
          const g = _emitGrouping(match)
          const start = reprs[i] !== null ? 1 : 0
          match(baseLeft, u[start]), match(reprs[i+1]), match(baseRight, u[start+1])
          _emitGrouping(match, g)
          return
        }
    match(baseLeft, u, topLevel)
  },

  _matchUnary(match, u, topLevel, onOK, base, reprs) { // ^x, …x, \x
    // reprs: ['quote', '^', /^/y] or [['func', 'input'], '\\', /\\/y]
    if (u === _specialParsedValue) {
      let op
      for (let i=0; i < reprs.length; i += 3) {
        if (op = match(reprs[i+2])) {
          const b = match(onOK)
          b === undefined && match.notEnoughInfo('Expected the arg of '+op.trim())
          return !isArray(reprs[i]) ? [label(reprs[i]), b] : [...reprs[i].map(label), b]
        }
      }
      return match(base)
    }
    if (isArray(u))
      for (let i=0; i < reprs.length; i += 3) {
        let ok = !isArray(reprs[i]) ? u.length == 2 && u[0] === _unctx(reprs[i]) : (u.length == reprs[i].length+1)
        if (isArray(reprs[i]) && ok)
          for (let j=0; j < reprs[i].length; ++j)
            if (u[j] !== _unctx(reprs[i][j])) { ok = false;  break }
        if (ok) {
          const g = _emitGrouping(match)
          match(reprs[i+1]), match(onOK, u[u.length-1])
          _emitGrouping(match, g)
          return
        }
      }
    base(match, u, topLevel)
  },

  _matchSequence(match, u, topLevel, base, head, parseSep, separator = parseSep) {
    if (u === _specialParsedValue) {
      const a = match(base)
      if (a === undefined) return
      let arr
      while (match(parseSep)) {
        const b = match(base)
        if (b === undefined) match.notEnoughInfo("Expected the next base value after "+separator)
        if (!arr) arr = [label(head), a]
        arr.push(b)
      }
      return arr || a
    }
    if (isArray(u) && u[0] === _unctx(head) && u.length > 2) {
      const g = _emitGrouping(match)
      for (let i = 1; i < u.length; ++i)
        i > 1 && match(separator), match(base, u[i])
      _emitGrouping(match, g)
    } else match(base, u, topLevel)
  },

  _fancyOutermost:{
    Initialize() {
      _fancyOutermost.syntax = fFunc
      // The most significant syntax functionality is collected in one place for readability.
      const sFunc = [['func', 'input'], '\\', '\\']
      function fFunc(match, u, topLevel) { // \f
        return _matchUnary(match, u, topLevel, _fancyOutermost, fLast, sFunc)
      }
      function fLast(match, u, topLevel) { // a,b,c
        return _matchSequence(match, u, topLevel, fPredicts, 'last', /\s*\,\s*/y, ',')
      }
      const sPredicts = ['predict', '=', /(\s*)=\1/y]
      function fPredicts(match, u, topLevel) { // a=b
        return _matchLtR(match, u, topLevel, fSumSub, sPredicts)
      }
      const sSumSub = ['add', '+', /(\s*)\+\1/y, 'sub', '-', /(\s*)-(?!>)\1/y]
      function fSumSub(match, u, topLevel) { // a+b, a-b
        return _matchLtR(match, u, topLevel, fMultDiv, sSumSub)
      }
      const sMultDiv = ['mul', '*', /(\s*)\*\1/y, 'div', '/', /(\s*)\/\1/y]
      function fMultDiv(match, u, topLevel) { // a*b, a/b
        return _matchLtR(match, u, topLevel, fPow, sMultDiv)
      }
      const sPow = ['pow', '**', /(\s*)\*\*\1/y]
      function fPow(match, u, topLevel) { // a**b
        return _matchRtL(match, u, topLevel, fRead, fPow, sPow)
      }
      const sRead = ['readAt', '.', /(\s*)\.\1/y]
      function fRead(match, u, topLevel) { // a.b
        return _matchLtR(match, u, topLevel, fUnary, sRead)
      }
      const sUnary = ['quote', '^', '^', 'rest', '…', /…|\.\.\./y]
      function fUnary(match, u, topLevel) { // …a, ...a; ^a
        return _matchUnary(match, u, topLevel, _fancyOutermost, fGrouping, sUnary)
      }
      function fGrouping(match, u, topLevel) { // [x]
        if (u === _specialParsedValue) {
          // A non-bracketed basic call, or a bracketed sequence of values.
          if (!match(/\s*\[\s*/y)) return _basicValue(match, u, _basicCall, _fancyOutermost)
          const r = _basicMany(match, u, null, _fancyOutermost)
          if (r === undefined || !r.length) match.notEnoughInfo('Expected a value to group')
          if (!match(/\s*\]/y)) match.notEnoughInfo("Expected a closing grouping bracket")
          return r.length == 1 ? r[0] : r
        }
        // Serialize grouping brackets via first trying to serialize without them, then emitting them if arrived at the same spot.
        //   It's not fast, but `basic` and `fast` exist to make that not a problem.
        if (!isArray(u)) return _basicValue(match, u)
        _emitGrouping.groupOpen = '[', _emitGrouping.groupClose = ']'
        if (!_needsGrouping.pos) _needsGrouping.pos = new Set
        const pos = match()
        if (_needsGrouping.pos.has(pos)) { // Emit base if the second pass is over.
          return _basicValue(match, u, !topLevel ? _basicCall : _basicMany, _fancyOutermost)
        }
        _needsGrouping.pos.add(pos)
        try {
          return match(_fancyOutermost, u, topLevel)
        } finally { _needsGrouping.pos.delete(pos) }
      }
    },
    call(match, u, topLevel) {
      let ctx, needsGrouping = !topLevel || match()
      if (isArray(u) && u[0] === bound && u[1] instanceof Map && u.length == 3)
        ctx = u[1], u = u[2], needsGrouping = needsGrouping && match('[')
      const r = _fancyOutermost.syntax(match, u, topLevel)
      if (ctx) ctx.forEach((v,k) => (match(' '), match(_basicExtracted, [_extracted, k, v], _fancyOutermost.syntax))), needsGrouping && match(']')
      return r
      // .syntax (the matching function that specifies the syntax over basic values; see how Initialize is defined here)
    },
  },

  _basicOutermost(match, u) { return _basicValue(match, u, _basicCall, _basicOutermost) },

  _fancyTopLevel(match, u) { // (f); a b c c:x; a:b
    if (u === _specialParsedValue) {
      let arr = _basicMany(match, u, null, _fancyOutermost)
      if (isArray(arr) && !arr.length) match.notEnoughInfo("No value at top level")
      match(/\s+/y)
      return _unwrapOneOrMany(arr)
    }
    _fancyOutermost(match, _wrapOneOrMany(u), true)
  },

  _basicTopLevel(match, u) { // (f); a b c c:x; a:b
    if (u === _specialParsedValue) {
      let arr = _basicMany(match, u, null, _basicOutermost)
      if (isArray(arr) && !arr.length) match.notEnoughInfo("No value at top level")
      match(/\s+/y)
      return _unwrapOneOrMany(arr)
    }
    return _basicMany(match, _wrapOneOrMany(u), null, _basicOutermost)
  },

  basic:{
    docs:`A basic language for ordered-edge-list graphs. Text, numbers, structures, and connections.
Every pair of brackets (and the top level, if there is more than one value) is an array in memory (or a \`construct\` if bold). Its items are space-separated. There are also labels (able to bind to pre-defined globals or user-defined bindings), strings, numbers, and graph bindings (\`a:b\` binds all instances of the label \`a\` to the value \`b\`, both before and after the binding, but only in its scope).
\`label\`, \`'string'\`, \`"string"\`, \`(0 1)\`, \`(a:2 a)\`, \`(func a b (add a b))\`.
This is a {more space-efficient than binary} representation for graphs of arrays.`,
    philosophy:`Lisp was nice for its time, but now we can have nice UI and AI, so Lisp needed a remastering.`,
    style:_(`_basicStyle`),
    parse:_(`_basicTopLevel`),
    serialize:_(`_basicTopLevel`),
    REPL:`also see \`(docs)\` or \`tutorial tutorial\`.`,
    insertLinkTo:_(`_basicLinkTo`),
    _escapeLabel:_(`_basicEscapeLabel`),
    _unescapeLabel:_(`_basicUnescapeLabel`),
    Initialize() { basic.labels = /-?\d*\.?\d+(?:[eE]+-?\d+)?|-Infinity|[^=!?:;\s\(\)\[\]\{\}<>@#$%\+\-\*\/\&\|\.'"`\,\\←→·⇒\ue000-\uf8ff]+/y },
  },

  fancy:{
    docs:`A language for ordered-edge-list graphs (like \`basic\`) with some syntactic conveniences.
\`label\`, \`'string'\`, \`"string"\`, \`(0 1)\`, \`(a:2 a)\`; \`1+2\`, \`\\?*2 5\`, \`2*[1+2]\`.`,
    style:_(`_basicStyle`),
    parse:_(`_fancyTopLevel`),
    serialize:_(`_fancyTopLevel`),
    REPL:`also type \`tutorial tutorial\` or \`(docs)\`.`,
    insertLinkTo:_(`_basicLinkTo`),
    _escapeLabel:_(`_basicEscapeLabel`),
    _unescapeLabel:_(`_basicUnescapeLabel`),
    examples:[
      `Binary operators must have the same whitespace characters before and after:`,
      [
        `array 1 - 2 -3`,
        `-1 -3`,
        true
      ],
      `Operators' labels can be re-bound:`,
      [
        `1+2 add:array`,
        `1 2`,
        true
      ],
      [
        `\\1+2 func:array add:pow`,
        `input 1`,
        true
      ],
    ],
  },

  _basicLinkTo(r, el) {
    // Create a name not seen in editor, replace el with name, insert newline and name and ':' and el at editor's end, and return a name element.
      // × (1 2 3)  ⇒  a a  a:(1 2 3)
    const ed = _isEditable(el), names = new Set
    if (el === ed) return
    _visitText(ed, str => typeof str == 'string' && names.add(str))
    let i = 0, name, rBecomes, elBecomes
    if (el.tagName === 'EXTRACTED') el = el.lastChild
    if (el.parentNode.tagName === 'EXTRACTED' && el.parentNode.parentNode.contains(r.commonAncestorContainer))
      name = _innerText(el.parentNode.firstChild).join('')
    else if (el.classList.contains('label'))
      name = _innerText(el).join('')
    else if (el.tagName === 'NUMBER')
      name = el.innerText
    else {
      const v = el.to
      const proposals = isArray(v) && nameResult(v) || []
      while (names.has(name = i < proposals.length ? proposals[i] : toString(i - proposals.length, 'abcdefghijklmnopqrstuvwxyz'))) ++i
      const topLevel = el.parentNode === ed || el.parentNode.parentNode === ed
      rBecomes = document.createTextNode(name)
      r.deleteContents(), r.insertNode(rBecomes), r.setEndAfter(rBecomes)
      el.replaceWith(elBecomes = document.createTextNode(name))
      if (isArray(v) && v.length > 1 && topLevel && !el.classList.contains('hasOperators') && el.firstChild.textContent[0] !== '(')
        el = elem('node', ['(', el, ')'])
      ed.append('\n'+name+':', el)
    }
    if (!rBecomes) {
      rBecomes = document.createTextNode(name)
      r.deleteContents(), r.insertNode(rBecomes), r.setEndAfter(rBecomes)
    }
    ensureSpacesAround(ed, rBecomes, elBecomes)


    function toString(i, alphabet) {
      if (i < alphabet.length) return alphabet[i]
      return toString(Math.floor(i / alphabet.length), alphabet) + alphabet[i % alphabet.length]
    }
    function space() { return document.createTextNode(' ') }
    function ensureSpacesAround(el, before1, before2) {
      const legal = /[=!:\s\(\)>\+\-\*\/\&\|]/
      let spaceBefore = true, spaceAfter = false
      _visitText(el, (str, ch) => {
        if (spaceAfter)
          str && !legal.test(str[0]) && ch.parentNode.insertBefore(space(), ch),
          spaceBefore = true, spaceAfter = !str
        if (ch === before1)
          !spaceBefore && before1.parentNode.insertBefore(space(), before1), spaceAfter = true
        if (ch === before2)
          !spaceBefore && before2.parentNode.insertBefore(space(), before2), spaceAfter = true
        spaceBefore = !str || legal.test(str[str.length-1])
      })
    }
  },

  _basicStyle(s,v,u, ctx) {
    if (typeof s == 'string' && v === undefined && u === undefined) return s
    if (typeof u == 'number' && isArray(s) && s.length == 1 && typeof s[0] == 'string')
      return _colored(elem('number', s[0]), 4, 24) // underline
    if (typeof u == 'string' && isArray(s) && s.length == 1 && typeof s[0] == 'string') {
      if (typeof document == ''+void 0) return _colored(s[0], 32) // green
      const el = elem('string', [s[0][0], _highlightGlobalsInString(s[0].slice(1,-1)), s[0].slice(-1)])
      return el.title = 'string', el
    }
    if (isArray(v) && v[0] === _extracted && v.length == 3 && s.length == 3 && typeof document != ''+void 0) {
      if (isArray(s)) s[1] = elem('operator', s[1])
      const el = elem('extracted', s)
      el.title = 'extracted', el.classList.add('hasOperators')
      return el
    }
    if (typeof document != ''+void 0 && (v instanceof Map && v.size > 1 || defines(u, map) || defines(v, map) || v && v[defines.key] && (!isArray(defines(v, deconstruct)) || defines(v, deconstruct)[0] === concept)) && u && u[0] !== arrayObject && isArray(s) && s.length > 1) {
      // Construct a <table>, with brackets and `map` outside of it, and each key-value pair having its own <tr>.
      let i, start = (s[0].textContent || s[0]) === '{' ? 0 : (s[0].textContent || s[0]) === '(' ? 2 : 1
      if (!start) s.splice(1, 0, ''), start = 1
      let last = s[s.length-1].textContent || s[s.length-1], end = last === ')' ? s.length-1 : s.length
      const rows = []
      let a = 1
      for (i = start; i+3 < end; i += 4) {
        if (s[i+0].nodeName !== 'SPACE' && s[i]) break
        if (s[i+1].nodeName === 'EXTRACTED') break
        if (s[i+2].nodeName !== 'SPACE') break
        if (s[i+3].nodeName === 'EXTRACTED') break
        const row = elem('tr', [elem('td', [s[i], s[i+1]]), elem('td', [s[i+2], s[i+3]])])
        elemValue(row, merged([rest, merged([s[i+1].to, s[i+3].to])]))
        rows.push(row)
      }
      if (i > start+4) s = [...s.slice(0,start), elem('table', rows), ...s.slice(i)]
    }

    if (isArray(s)) {
      if (s.length == 3 && (s[0] === '(' || s[0] === '[') && (s[2] === ')' || s[2] === ']'))
        // Grouped values are highlighted only once
        if (typeof document != ''+void 0 && s[1] instanceof Element)
          s[1].to === v && (s[1].classList.add('groupedValue'), elemValue(s[1], null, true, false, true))
      for (let i=0; i < s.length; ++i) {
        const t = typeof s[i] == 'string' && s[i].trim()
        if (t && (t === '(' || t === '[' || t === '{' || t === ')' || t === ']' || t === '}'))
          s[i] = _colored(elem('bracket', s[i]), 33) // Brackets are brown
      }
    }
    if (typeof document != ''+void 0 && s[0] instanceof Node && s[1] instanceof Node && s[1].tagName === 'BRACKET')
      s[0].classList.add('funcCall'), s[1].classList.add('funcCall')

    let hasOperators = false
    if (isArray(s) && isArray(u) && !_isLabel(u) && s.length > 1)
      for (let i = 0; i < s.length; ++i)
        if (s[i] && typeof s[i] == 'string' && s[i] !== '[' && s[i] !== ']')
          s[i] = elem('operator', s[i]), hasOperators = true

    const backctx = _invertBindingContext(ctx)
    if (_isLabel(u) && backctx.has(v))
      return _colored(elem('known', s), 1, 0) // bold
    let el = typeof document != ''+void 0 && s instanceof Element ? s : elem('node', s)
    if (typeof document != ''+void 0) {
      if (hasOperators)
        el.classList.add('hasOperators')
      const v1 = isArray(v) && v[0] === bound && v[1] instanceof Map ? v[2] : v
      const u1 = isArray(u) && u[0] === bound && u[1] instanceof Map ? u[2] : u
      if (!isArray(v1) || isArray(u1) && v1.length != u1.length)
        el.classList.add('nonArray')
      if (_isLabel(u1))
        el.style.color = _valuedColor(v1), el.classList.add('label')
      let title = ''
      if (!title && isArray(u) && u.length && backctx.has(u[0])) title = backctx.get(u[0])
      if (!title && isArray(v) && v.length && backctx.has(v[0])) title = backctx.get(v[0])
      el.title = title
    } else {
      if (_isLabel(u))
        el = _colored(el, [34, 36, 35][randomNat(3)]) // Cycle through blue, cyan, magenta.
    }
    return el
  },

  stringLanguage:{
    docs:`Whatever you type in is just one string.`,
    parse(match, u) {
      return match(/[^]*/y) || ''
    },
    serialize(match, u) {
      if (typeof u != 'string')
        error('Expected a string, got', u)
      return match(u)
    },
  },

  fast:{
    docs:`A \`basic\`-like language that can be parsed and serialized fast.
Intended to only be used for internal inter-memory communication (of generic bound graphs).
The parsed arrays are not \`merged\`.`,
    examples:[
      [
        `_fastParse '(12)'`,
        `12`,
      ],
      [
        `_fastParse '(a:(b) b:(a) a)'`,
        `a a:a()()`,
      ],
      [
        `_fastParse (_fastSerialize ^(a b a:b() b:a()))`,
        `a b a:b() b:a()`,
      ],
      [
        `_fastSerialize ^(a b a:b() b:a())`,
        `'(a:(b) b:(a) (a b))'`,
      ],
      [
        `_fastParse '("a""b")'`,
        `'a"b'`,
      ],
    ],
    readAt:{
      parse:_(`_fastParse`),
      serialize:_(`_fastSerialize`),
    },
    parse(match) {
      // Just forward a string to fast.parse.
      const str = match(/[^]*/y) || ''
      if (match(_specialParsedValue)) error("`fast` is string-only")
      return _fastParse(str)
    },
    serialize:_(`_basicTopLevel`),
    philosophy:`This could be made even more efficient (make it variable-pointer-length binary, serialize numbers as binary), but we aren't that crazy yet.`,
  },

  _fastParse(str, ctx) {
    // ctx is an object here, not a Map from label objects like in `parse`.
    if (!str) error("Expected input, got", str)
    if (!ctx) ctx = defines(Self, readAt)
    let [result, i = 0, j, ctxs = [ctx], visited = new Set, toBeLookedUp = new Set] = interrupt(6)
    if (j === undefined) j = 0, nextToken()
    try {
      if (result === undefined)
        result = _defined(getCall())
      if (i < str.length) throw "Too much information: " + str.slice(i)
      if (result.length != 1) error("Wrong count of top-level args:", result.slice())
      return makeGraph(result[0], undefined, false, false, true, true) // Note: This is unsafe (arbitrary code execution, such as with `static`).
      //   (To make it safe, inspect all available functions, and make the dangerous ones unable to execute here.)
      // That top-level pair of brackets serves as a language marker.
    } catch (err) { if (err === interrupt) interrupt.stack.push(result, i, j, ctxs, visited, toBeLookedUp);  throw err }

    function nextToken() {
      // Goes to the end of the next match of /[ \n]+|[:\(\)]|`(?:[^`]|``)*`|'(?:[^']|'')*'|"(?:[^"]|"")*"|[^ \n:\(\)'"`]+|$/g
      // Except, well, regexes are a little broken for huge strings. So we have to implement that ourselves.
      i = j
      let quoted = ''
      for (; j < str.length; ++j) {
        const ch = str[j], next = str[j+1]
        if (quoted === '') {
          if (ch === ':' || ch === '(' || ch === ')') { ++j;  break }
          if (ch === '`' || ch === "'" || ch === '"') quoted = ch
          else if (ch === ' ' || ch === '\n') {
            if (next !== ' ' && next !== '\n') { ++j;  break }
          } else if (next === ':' || next === '(' || next === ')' || next === ' ' || next === '\n') { ++j;  break }
        } else {
          if (ch === quoted && next === quoted) ++j
          else if (ch === quoted) { ++j, quoted = '';  break }
        }
      }
    }

    function getCall() {
      if (str[i] !== '(') throw "Expected an opening bracket"
      nextToken()
      const arr = []
      let bindings
      ctxs.push(bindings)
      while (i < str.length && str[i] !== ':' && str[i] !== ')') {
        const v = getValue()
        if (str[i] === ':') {
          if (typeof v != 'string') throw "Only labels can be bound"
          nextToken()
          if (!bindings) ctxs[ctxs.length-1] = Object.create(null), bindings = []
          const k = getValue()
          bindings.push(v)
          ctxs[ctxs.length-1][v] = k
        } else
          arr.push(v)
        skipWs()
      }
      if (bindings) {
        // Scoped binding is convenient, but the most general way to do it involves either
          // walking the graph each time (simple) or copying backpatching information to parents (complicated).
          // So we make fast.serialize put every node in the top-level namespace.
        for (let j = 0; j < bindings.length; ++j)
          ctxs[ctxs.length-1][bindings[j]] = labelBind(ctxs[ctxs.length-1][bindings[j]])
        for (let j = 0; j < arr.length; ++j)
          arr[j] = labelBind(arr[j])
        visited.clear()
      }
      ctxs.pop()
      nextToken()
      return arr
    }
    function labelLookup(name) {
      // If a name defined in an outer scope is later re-bound by the inner scope, this will bind to the outer before we know it.
        // This language is supposed to be fast, so we just left this in. It is not a problem with how we serialize things here.
      if (str[i] === ':') return name
      if (name && (name === 'NaN' || +name === +name)) return +name
      for (let i = ctxs.length-1; i >= 0; --i)
        if (ctxs[i] && name in ctxs[i]) return ctxs[i][name]
      return toBeLookedUp.add(name = label(name)), name
    }
    function labelBind(arr) {
      // Unlike `bound` used in `basic`, this binds in-place.
      if (!isArray(arr)) return arr
      if (arr[0] === label && typeof arr[1] === 'string' && arr.length === 2 && toBeLookedUp.has(arr)) {
        const ctx = ctxs[ctxs.length-1]
        return arr[1] in ctx ? ctx[arr[1]] : arr
      }
      if (visited.has(arr)) return arr; else visited.add(arr)
      for (let j = 0; j < arr.length; ++j)
        arr[j] = labelBind(arr[j])
      return arr
    }
    function skipWs() { if (str[i] === ' ' || !str.slice(i,j).trim()) nextToken() }
    function getValue() {
      if (i >= str.length) throw "Expected a value"
      skipWs()
      if (str[i] === '(') return getCall()
      if (str[i] === ':' || str[i] === ')') return
      const I = i, J = j;  nextToken()
      if (str[I] === "'" && str[J-1] === "'") return str.slice(I+1,J-1).replace(/''/g, "'")
      if (str[I] === '"' && str[J-1] === '"') return str.slice(I+1,J-1).replace(/""/g, '"')
      if (str[I] === '`' && str[J-1] === '`') return labelLookup(str.slice(I+1,J-1).replace(/``/g, '`'))
      return labelLookup(str.slice(I,J))
    }
  },

  _fastSerialize(expr, ctx = Self.ctx) {
    // Walk expr and name all referenced-more-than-once nodes, then output them then expr.

    const backctx = _invertBindingContext(ctx)
    let [visited = new Set, names = _allocMap(), decons = _allocMap(), weakMaps = _allocArray(0), promises = _allocArray(0), promiseValues, promiseContainers = _allocArray(0), result] = interrupt(8)
    let n = 0
    try {
      if (visited !== false && visited !== true) {
        mark(expr)
        if (promises.length) {
          promiseValues = Promise.all(promises)
          visited = false
          promiseValues = await(promiseValues)
        } else visited.clear()
      }
      if (visited === false) { // Replace promises with their actual values.
        promiseValues = await(promiseValues)
        for (let i = 0; i < promiseContainers.length; ++i) {
          const arr = promiseContainers[i]
          for (let j = 0; j < arr.length; ++j)
            if (arr[j] === promises[i])
              arr[j] = promiseValues[i]
        }
        visited = true
      }

      if (result === undefined) result = []
      result.push('(')
      names.forEach((named,arr) => (result.push(named, ':'), putValue(arr, true), result.push(' ')))
      putValue(expr)
      result.push(')')
      return result.join('')
    } catch (err) { if (err === interrupt) interrupt.stack.push(visited, names, decons, weakMaps, promises, promiseValues, promiseContainers, result), visited = null;  throw err }
    finally {
      if (visited !== null)
        visited instanceof Set && visited.clear(), _allocMap(names), _allocMap(decons), _allocArray(weakMaps), _allocArray(promises), _allocArray(promiseContainers)
    }

    function name(v) {
      if (names.has(v)) return
      const vocabulary = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
      let str = '', next = n++
      while (true) {
        str = vocabulary[next % vocabulary.length] + str
        next = next / vocabulary.length | 0
        if (!next) break
      }
      while (ctx.has(str) || str === 'NaN' || str === 'Infinity') str = '$'+str
      names.set(v, str)
    }
    function mark(arr) {
      if (typeof arr == 'number' && (''+arr).length < 3) return
      if (visited.has(arr)) return void name(arr); else visited.add(arr)
      const original = arr
      if (decons.has(arr)) arr = decons.get(arr)

      // Handle `weakMap`s.
      for (let i = 0; i < weakMaps.length; ++i)
        if (weakMaps[i].has(original)) {
          const v = weakMaps[i].get(original)
          name(original), mark(v), decons.get(weakMaps[i]).push(original, v)
        }

      if (backctx.has(arr)) return
      if (!isArray(arr)) {
        if (typeof arr == 'string' || typeof arr == 'number') return
        if (arr instanceof WeakMap) { // Handle `weakMap`s.
          const y = [weakMap], d = decons
          d.set(arr, y), visited.add(arr), weakMaps.push(arr)
          visited.forEach(k => {
            const v = arr.get(k)
            if (arr.has(k)) name(k), mark(v), y.push(k, v)
          })
          return
        } else {
          decons.set(arr, arr = deconstruct(arr, undefined, true)) // Use fast-`_toBase64` mode, but we need to `await` promises afterward.
          for (let i = 0; i < arr.length; ++i)
            if (_isPromise(arr[i])) promises.push(arr[i]), promiseContainers.push(arr)
            else mark(arr[i])
        }
      } else {
        if (typeof defines(arr, construct) == 'function')
          decons.set(arr, arr = deconstruct(arr))
        if (!isArray(arr)) error("All values must be string/number or Map or array or deconstruct to an array, but got", arr)
        if (arr[0] === label && typeof arr[1] == 'string' && arr.length == 2) {
          if (/[\x80-\ue000]/.test(arr[1])) throw "An exotic label to "+arr[1]+" detected"
          return
        }
        arr.forEach(mark)
      }
    }
    function isCall(v) { return isArray(v) && !names.has(v) && !backctx.has(v) && (v[0] !== label || typeof v[1] != 'string' || v.length != 2) }
    function putCall(v) {
      result.push('(')
      for (let i = 0; i < v.length; ++i)
        i && !isCall(v[i-1]) && !isCall(v[i]) && result.push(' '), putValue(v[i])
      result.push(')')
    }
    function putValue(v, ignoreName = false, ignoreMark = false) {
      if (!ignoreName && names.has(v)) return result.push(names.get(v))
      if (backctx.has(v)) return result.push(backctx.get(v))
      if (decons.has(v)) v = decons.get(v)
      if (typeof v == 'number') return result.push(''+v)
      if (typeof v == 'string') {
        if (v.indexOf("'") < 0) return result.push("'", v, "'")
        if (v.indexOf('"') < 0) return result.push('"', v, '"')
        return result.push("'", v.replace(/'/g, "''"), "'")
      }
      if (!isArray(v)) error("Not-an-array unknown value:", v)
      return putCall(v)
    }
  },

  save:{
    docs:`\`save At Object\`
Saves an object('s \`fast\` serialization) in the browser's \`indexedDB\`, to be retrieved by \`load\`. Returns (a promise of) the saved string's length; \`await\` it.`,
    argCount:2,
    impure:true,
    await:true,
    readAt:{
      load:_(`load`),
      export:_(`export`),
      import:_(`import`),
    },
    call(at, obj, doNotSerialize) {
      if (typeof at != 'string') error("Not a string:", at)
      const str = doNotSerialize || obj === undefined ? obj : _fastSerialize(obj)

      // With localStorage, the below would have been: `localStorage[at] = str`.
      return new Promise((resolve, reject) => {
        const req = indexedDB.open('save')
        req.onsuccess = () => {
          try {
            const db = req.result
            const transaction = db.transaction('saved', 'readwrite')
            const saved = transaction.objectStore('saved')
            const r = obj !== undefined ? saved.put(str, at) : saved.delete(at)
            r.onsuccess = () => resolve(str !== undefined ? str.length : 0)
            r.onerror = () => reject(r.error)
          } catch (err) { reject(err) }
        }
        req.onerror = () => reject(req.error)
        req.onupgradeneeded = () => {
          const db = req.result
          db.createObjectStore('saved')
        }
      })
    },
  },

  load:{
    docs:`\`load At\`→\`Object\`
Loads an object('s \`fast\` serialization) from the browser's \`indexedDB\`; \`await\` it.

Can do arbitrary code execution via \`construct\` (especially via \`static\`).
Theoretically, we can set/reset a flag, and check it in potentially-dangerous functions. Or only include safe functions in the binding context. Practically, who cares.`,
    argCount:1,
    dispose:true,
    await:true,
    call(at, doNotParse = false) {
      if (typeof at != 'string') error('Not a string:', at)

      // With localStorage, all this would have been just `_fastParse(localStorage[at])`.
      return new Promise((resolve, reject) => {
        const req = indexedDB.open('save')
        req.onsuccess = () => {
          const db = req.result
          const transaction = db.transaction('saved', 'readonly')
          const saved = transaction.objectStore('saved')
          const r = saved.get(at)
          r.onsuccess = () => {
            try { resolve(doNotParse ? r.result : r.result !== undefined ? _fastParse(r.result) : undefined) }
            catch (err) { reject(err) }
          }
          r.onerror = () => reject(req.error)
        }
        req.onerror = () => reject(req.error)
        req.onupgradeneeded = () => {
          const db = req.result
          db.createObjectStore('saved')
        }
      })
    },
  },

  export:{
    docs:`\`export At\`
In a browser, presents a button for downloading a \`save\`d object as a local file.`,
    argCount:1,
    call(at) {
      if (typeof at != 'string') error('Not a string:', at)
      let [p] = interrupt(1)
      try {
        if (p === undefined) p = load(at, true)
        const str = await(p)
        if (str === undefined) error('Was never saved:', at)
        const el = elemValue(elem('a', 'Download '+at), str)
        el.download = at
        // Object URLs don't seem to work for file: URIs.
        const u = el.href = 'data:,' + encodeURIComponent(str) //URL.createObjectURL(new Blob([str], {type:'text/html'}))
        //const i = setInterval(() => !el.isConnected && (clearInterval(i), URL.revokeObjectURL(u)), 60000)
        return el
      } catch (err) { if (err === interrupt) interrupt.stack.push(p);  throw err }
    },
  },

  import:{
    docs:`\`import At\`
In a browser, presents a button for uploading a local file into \`indexedDB\`, for \`load\`ing.`,
    argCount:1,
    call(at) {
      if (typeof at != 'string') error('Not a string:', at)
      const el = elem('input', 'New content of '+at)
      el.type = 'file'
      el.onchange = () => {
        if (!el.files[0]) return
        const r = new FileReader
        r.onload = evt => typeof evt.target.result == 'string' && save(at, evt.target.result, true)
        r.readAsText(el.files[0])
      }
      return el
    },
  },

  _fancierOutermost:{
    Initialize() {
      _fancierOutermost.syntax = fFunc
      // The most significant syntax functionality is collected in one place for readability.
      const sFunc = [['func', 'input'], '\\', '\\']
      function fFunc(match, u, topLevel) { // \f
        if (!u || typeof u != 'object' && typeof u != 'function') return _basicValue(match, u)
        return _matchUnary(match, u, topLevel, _fancierOutermost, fMultiFunc, sFunc)
      }
      function fMultiFunc(match, u, topLevel) { // a->b->c
        return _matchSequence(match, u, topLevel, fMultiFuncType, 'func', /(\s*)(?:→|->)\1/y, '→')
      }
      function fMultiFuncType(match, u, topLevel) { // a⇒b⇒c
        return _matchSequence(match, u, topLevel, fLast, 'funcType', /(\s*)⇒\1/y, '⇒')
      }
      function fLast(match, u, topLevel) { // a;b;c
        return _matchSequence(match, u, topLevel, fArrayType, 'last', /\s*;\s*/y, ';')
      }
      function fArrayType(match, u, topLevel) { // a&b&c
        return _matchSequence(match, u, topLevel, fCompare, 'tupleType', /(\s*)&\1/y, '&')
      }
      const sCompare = ['less', '<', /(\s*)<\1/y]
      function fCompare(match, u, topLevel) {
        return _matchLtR(match, u, topLevel, fPredicts, sCompare)
      }
      const sPredicts = ['predict', '=', /(\s*)=\1/y, 'setFuture', '←', /(\s*)←\1/y]
      function fPredicts(match, u, topLevel) { // a=b
        return _matchLtR(match, u, topLevel, fSumSub, sPredicts)
      }
      const sSumSub = ['add', '+', /(\s*)\+\1/y, 'sub', '-', /(\s*)-(?!>)\1/y]
      function fSumSub(match, u, topLevel) { // a+b, a-b
        return _matchLtR(match, u, topLevel, fMultDiv, sSumSub)
      }
      const sMultDiv = ['mul', '*', /(\s*)[\*·]\1/y, 'div', '/', /(\s*)\/\1/y, 'matMul', '@', /(\s*)@\1/y]
      function fMultDiv(match, u, topLevel) { // a*b, a/b
        return _matchLtR(match, u, topLevel, fPow, sMultDiv)
      }
      const sPow = ['pow', '**', /(\s*)\*\*\1/y]
      function fPow(match, u, topLevel) { // a**b
        return _matchRtL(match, u, topLevel, fRead, fPow, sPow)
      }
      const sRead = ['readAt', '.', /(\s*)\.\1/y]
      function fRead(match, u, topLevel) { // a.b
        return _matchLtR(match, u, topLevel, fUnary, sRead)
      }
      const sUnary = ['quote', '^', '^', 'rest', '…', /…|\.\.\./y, 'sum', '+', '+']
      function fUnary(match, u, topLevel) { // …a, ...a;  ^a;  +a
        return _matchUnary(match, u, topLevel, _fancierOutermost, fGrouping, sUnary)
      }
      function _baseOf(arr) { for (let i=0; isArray(arr[0]) && arr[0].length && i < 10; ++i) arr = arr[0];  return arr[0] }
      function fGrouping(match, u, topLevel) { // (x)
        if (u === _specialParsedValue) {
          // A non-bracketed basic call, or a bracketed sequence of values.
          let f = match(fCallFunc)
          return fCallArgs(match, u, f)
        }
        // Emit `(a b c)` if `(0 1 2)`.
        const base = isArray(u) && _baseOf(u)
        const linearityPreferred = isArray(u) && u.length > 1 && u[0] !== _extracted && (defines(base, construct) !== undefined || !isArray(base) && typeof base != 'function')
        if (base === map) {
          _basicValue(match, u, _basicMany, _fancierOutermost)
          return
        }
        if (linearityPreferred) {
          !topLevel && match('(')
          _basicMany(match, u, null, _fancierOutermost)
          !topLevel && match(')')
          return
        }
        // Serialize grouping brackets via first trying to serialize without them, then emitting them if arrived at the same spot.
        //   It's not fast, but `basic` and `fast` exist to make that not a problem.
        if (!isArray(u)) return _basicValue(match, u)
        if (!u.length) return match(_basicValue, arrayObject), match('('), match(')')
        _emitGrouping.groupOpen = '(', _emitGrouping.groupClose = ')'
        if (!_needsGrouping.pos) _needsGrouping.pos = new Set
        const pos = match()
        if (_needsGrouping.pos.has(pos)) // Emit base if the second pass is over.
          return !topLevel || u.length <= 1 ? fCallArgs(match, u) : _basicValue(match, u, _basicMany, _fancierOutermost)
        _needsGrouping.pos.add(pos)
        try {
          return match(_fancierOutermost, u, topLevel)
        } finally { _needsGrouping.pos.delete(pos) }
      }
      function fCallFunc(match, u) { // f or (f x y)
        if (match(/\s*\(\s*/y)) {
          const r = _unwrapOneOrMany(_basicMany(match, u, null, _fancierOutermost))
          if (r === undefined || isArray(r) && !r.length) match.notEnoughInfo('Expected a value to group at '+match())
          !match(/\s*\)/y) && match.notEnoughInfo("Expected the closing grouping bracket `)` at "+match()+" but got "+match(/./y))
          return r
        } else return _basicValue(match, u, null, _fancierOutermost)
      }
      function fCallArgs(match, u, f) { // f(a,b) or f{a,b, c,d}
        if (u === _specialParsedValue) {
          if (f === undefined) return
          while (true) {
            let ok = false
            if (match('(')) {
              f = [f], ok = true
              while (!match(')')) {
                const v = _unwrapOneOrMany(match(_basicMany, null, _fancierOutermost))
                if (v === undefined || isArray(v) && !v.length) break
                f.push(v)
                if (match(',')) match(/\s+/y)
              }
            }
            else if (match('{')) {
              const m = _unwrapOneOrMany(_basicMany(match, u, [label('map'), null, null], _fancierOutermost))
              ;(m[0] !== bound || !(m[1] instanceof Map) ? m : m[2]).unshift(label('make'))
              match(/\s+/y)
              !match('}') && match.notEnoughInfo("Expected the closing bracket `}`")
              f = [f, m], ok = true
            }
            if (!ok) break
          }
          return f
        }
        if (!isArray(u)) return _basicValue(match, u)
        if (u[0] === bound && u[1] instanceof Map && u.length == 3) return _fancierOutermost(match, u)

        if (_isLabel(u) || isArray(u) && u[0] === _extracted && u.length == 3)
          return _basicValue(match, u, null, _fancierOutermost)

        if (!u.length) return match(_basicValue, arrayObject), match('('), match(')')
        match(!isArray(u[0]) ? _basicValue : _fancierOutermost, u[0])
        if (false && u.length == 2 && isArray(u[1]) && u[1][0] === map) // …Doesn't vibe with contextMenu.
          return match(_fancierOutermost, u[1])
        match('(')
        for (let i=1; i < u.length; ++i)
          match(_fancierOutermost, u[i]), i < u.length-1 && match(',')
        match(')')
      }
    },
    call(match, u, topLevel) {
      let ctx, needsGrouping = !topLevel || match()
      if (isArray(u) && u[0] === bound && u[1] instanceof Map && u.length == 3)
        ctx = u[1], u = u[2], needsGrouping = needsGrouping && match('(')
      const r = _fancierOutermost.syntax(match, u, topLevel)
      if (ctx) ctx.forEach((v,k) => {
        match(' '), match(_basicExtracted, [_extracted, k, v], _fancierOutermost.syntax)
      }), needsGrouping && match(')')
      return r
      // .syntax (the matching function that specifies the syntax over basic values; see how Initialize is defined here)
    },
  },

  _fancierTopLevel(match, u) { // (f); a b c c:x; a:b
    if (u === _specialParsedValue) {
      let arr = _basicMany(match, u, null, _fancierOutermost)
      if (isArray(arr) && !arr.length) match.notEnoughInfo("No value at top level")
      match(/\s+/y)
      return _unwrapOneOrMany(arr)
    }
    _fancierOutermost(match, u, true)
  },

  _unwrapOneOrMany(r) {
    // Unwraps the result of `_basicMany`'s parsing (an array) into one element if it's of length 1.
    if (!isArray(r)) return r
    const inner = r[0] === bound && r[1] instanceof Map ? r[2] : r
    if (r.length == 1) r = r[0]
    if (r[0] === bound && r[1] instanceof Map && !inner.length) {
      // Return the last `(_extracted K V)`, bind to the rest.
      let k;  r[1].forEach((V,K) => k = K)
      const v = r[1].get(k), ex = _basicExtracted.lastExtractedObj
      r[1].delete(k)
      if (ex[1] === k && ex[2] === v) return !r[1].size ? ex : (r[2] = ex, r)
      return !r[1].size ? [_extracted, k, v] : (r[2] = [_extracted, k, v], r)
    }
    if (!isArray(inner)) return inner
    if (r[0] === bound && r[1] instanceof Map && inner === r[2] && inner.length == 1)
      r[2] = r[2][0]

    return r
  },

  _wrapOneOrMany(u) {
    // Wraps the input to `_basicMany`'s serialization into an array of one element if needed.
    if (isArray(u) && u[0] === bound && u[1] instanceof Map) {
      const i = u[2]
      return !isArray(i) || i.length <= 1 || _isLabel(i) ? [u[0], u[1], [i], ...u.slice(3)] : u
    }
    return !isArray(u) || u.length <= 1 || _isLabel(u) ? [u] : u
  },

  fancier:{
    docs:`A language for ordered-edge-list graphs (like \`basic\`) with some syntactic conveniences.
Calls can either be space-separated or be functions with bracketed comma-separated argument lists.
\`label\`, \`'string'\`, \`"string"\`, \`0(1)\`, \`(a:2 a)\`; \`add 1 add(2,3)\`, \`\\input*2 5\`, \`2*(1+2)\`.`,
    style:_(`_basicStyle`),
    parse:_(`_fancierTopLevel`),
    serialize:_(`_fancierTopLevel`),
    REPL:`also type \`tutorial tutorial\` or \`docs()\`.`,
    insertLinkTo:_(`_basicLinkTo`),
    _escapeLabel:_(`_basicEscapeLabel`),
    _unescapeLabel:_(`_basicUnescapeLabel`),
  },

  _causeInterrupt(cause, toReEnter = undefined) {
    if (interrupt.stack) error("Cannot cause an interrupt while restoring from an interrupt")
    interrupt.ed = true
    interrupt.last = _debugLastInterrupt[1] ? new Error().stack : _debugLastInterrupt
    call.env[_id(step)] = _checkInterrupt.step
    call.env[_id(_checkInterrupt)] = cause
    call.env[_id(call)] = call.depth
    interrupt.stack = call.env[_id(interrupt)] = _allocArray(0)
    if (toReEnter) _jobs.reEnter = toReEnter
    throw interrupt
  },

  _msBeforeInterrupt:[
    _(`settings`),
    30,
    `When executing a job, work for at least ??? milliseconds before interrupting.
An interrupt takes time.
10 ms should be appropriate for smooth UI interaction, but for computation-intensive work, higher values should be preferred.`,
    _(`rangeSetting`),
    10,
    300,
    5,
  ],

  _checkInterrupt:{
    docs:`Checks whether an interrupt is appropriate right now.`,
    call(cause) {
      if (!call.env) return
      if (interrupt.noInterrupt) return
      if (!interrupt.stack) {
        // If we stepped enough (ensuring progress), and either we have worked for N ms or the nesting depth is as wanted by _pausedToStepper, interrupt.
        if (call.env[_id(step)])
          --call.env[_id(step)], ++_checkInterrupt.step
        else if (call.env[_id(_pausedToStepper)] !== undefined && call.depth <= call.env[_id(_pausedToStepper)])
          _causeInterrupt(cause, _pausedToStepper)
        else if (limitTime.limit !== undefined && _userTimeSince() > limitTime.limit)
          throw _checkInterrupt.step = 0, limit
        else if (_timeSince(interrupt.started, true) > _msBeforeInterrupt[1])
          ++_checkInterrupt.step, _causeInterrupt(cause) // Ensure progress.
        else _checkInterrupt.step = 0
      }
      // .step (the counter of interrupt checks, for fully consistent restoration)
    },
  },

  step:{
    docs:`\`(step ^Expr)\`: pauses execution and displays stepping interface to the user, then evaluates Expr.`,
    examples:[
      [
        `step ^(1*2+3*4+5*6+7*8+9*10+11*12+13*14)`,
      ],
    ],
    call(expr) {
      let [int = true] = interrupt(1)
      try {
        if (int) int = false, _causeInterrupt(expr, _pausedToStepper)
        if (int === false) ++_checkInterrupt.step, int = 0
        return call(expr)
      } catch (err) { if (err === interrupt) interrupt.stack.push(int);  throw err }
    },
  },

  _pausedToStepper:{
    docs:`Pauses a job and displays its stepping interface: ▶ ▲ ⇉ ▼.
Not for use inside of that paused job.

(Technically, we could copy/restore execution states (arrays in \`_id(interrupt)\` should be copied because running the original would modify them, but we don't really use other types of objects for temporary state), and also have per-cause breakpoints, and also have a way of inspecting function state when interpreting, but debuggers are dime-a-dozen anyway, so who cares.)`,
    call(expr, env, then, before = env[_id(print)] || Self.into) {
      if (before instanceof Map) before = before.get(print)
      if (!env[_id(print)]) return
      _cancel(env, true), _jobs.limbo.push(expr, env, then)
      env[_id(_pausedToStepper)] = Infinity
      // Hide `before`, and insert a <div> with <button>s inside.
      const el = elem('div')
        elemValue(el, [expr, env, then])
        const justRun = elem('button', '▶')
        justRun.onclick = () => onClick()
        justRun.title = 'Run normally'
        const lessDepth = elem('button', '▲')
        lessDepth.onclick = () => onClick(-1)
        lessDepth.title = 'Step out\n(Decrease function call depth)'
        const eqDepth = elem('button', '⇉')
        eqDepth.onclick = () => onClick(0)
        eqDepth.title = 'Step over\n(Equal function call depth)'
        const moreDepth = elem('button', '▼')
        moreDepth.onclick = () => onClick(Infinity)
        moreDepth.title = 'Step in\n(Increase function call depth)'
        el.append(justRun, lessDepth, eqDepth, moreDepth)
        if (_debugLastInterrupt[1]) {
          const st = _resolveStack(interrupt.last).slice(2)
          el.append(elemValue(elemCollapse(() => serialize(st, undefined, undefined, serialize.displayed)), st))
        }

      // Make hover-highlighting work.
      if (env[_id(print)] instanceof Map) env[_id(print)].set(print, el); else env[_id(print)] = el

      const pre = _smoothHeightPre(before.parentNode)
      before.style.display = 'none'
      before.parentNode.insertBefore(el, before)
      _smoothHeightPost(before.parentNode, pre)

      function onClick(n) {
        // Show style, remove interface, remember to interrupt again, and re-schedule the job.
        _cancel(env, true)
        elemValue(el, null, true, true)
        if (env[_id(print)] instanceof Map) env[_id(print)].set(print, before); else env[_id(print)] = before
        justRun.onclick = lessDepth.onclick = eqDepth.onclick = moreDepth.onclick = null
        const pre = _smoothHeightPre(before.parentNode)
        before.style.removeProperty('display')
        el.remove() // (Not very efficient, destroying and re-creating the DOM for each step, but it works.)
        _smoothHeightPost(before.parentNode, pre)
        env[_id(_pausedToStepper)] = n !== undefined ? env[_id(call)]+n : undefined
        _schedule(expr, env, then)
      }
    },
  },

  interrupt:{
    docs:`Used to make functions re-entrant in a non-interruptible host language, for better UX.
Define this to be \`false\` in a global if it will never interrupt. (\`_debugInterruptDefinitions\` can catch lies here.)

Technical details of usage:
\`_causeInterrupt(cause)\` to unconditionally interrupt execution.
Create function state in a JS function like \`let [i = 0, j = 0] = interrupt(2)\`, in particular for counters of loops. Make sure to put interruptible computations not here but inside the try/catch below, to not corrupt interrupt state. There is almost no error-checking, for efficiency!
Wrap function body after getting its state in \`try{…}catch(err){ if (err === interrupt) interrupt.stack.push(i,j);  throw err }\`.`,
    readAt:{
      _msBeforeInterrupt:_(`_msBeforeInterrupt`),
      _debugInterruptDefinitions:_(`_debugInterruptDefinitions`),
      _debugLastInterrupt:_(`_debugLastInterrupt`),
      check:_(`_checkInterrupt`),
      step:_(`step`),
    },
    philosophy:`Termination checking (totality) is unnecessary if the host can just interrupt and continue. In fact, it is misleading to provide a false assurance of everything terminating {in reasonable time}.
Interruption (and sandboxing) is absolutely essential for being able to actually use a program comfortably, and for stepping through the program, but no one buzzes about it. Probably because almost all rely on the OS to provide it via processes, and/or heuristic-based totality guarantees.`,
    _cancel(stack) { isArray(stack) && _rememberToDispose(stack) },
    call(retrieve) {
      if (retrieve !== retrieve>>>0)
        error("Expected the count of items to retrieve, got", retrieve)
      if (interrupt.ed) error("Cannot consume interrupt stack-state space while interrupting")
      const tmp = interrupt.tmp || (interrupt.tmp = []), stack = interrupt.stack
      if (!stack) return tmp.length = 0, tmp
      if (stack.length < retrieve)
        error("Corrupted the interrupt state somewhere; check correctness of every store/restore, and/or use", _debugInterruptDefinitions, ", or compare", _resolveStack(interrupt.last), "with this call stack — got state left:", ...stack)

      tmp.length = retrieve
      const start = stack.length - retrieve
      for (let i = start; i < stack.length; ++i) tmp[i - start] = stack[i]
      stack.length = start
      if (!start) _allocArray(stack), interrupt.stack = call.env[_id(interrupt)] = undefined

      return tmp

      // .tmp, .noInterrupt, .started, .stack, .last, .ed
    },
  },

  _lineCount(str) {
    if (typeof str == 'number') return 0
    let i = 0, n = 0
    while ((i = str.indexOf('\n', i)+1) > 0) ++n
    return n
  },

  _htmlOfRewrite(JS) {
    return JS(undefined, {into:'document.body', prefix:`<!doctype html>
<head>
  <meta charset=utf-8>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Conceptual</title>
  <link rel=icon type=image/png href=${BrowserIconURL}>
</head>
<body onerror="document.body.append(event, document.createElement('br'))">
  <noscript>This requires JS to run, and a fairly modern browser.</noscript>
  <script>
`}) + `  </${''}script>
</body>`
  },

  Rewrite:{
    docs:`\`Rewrite()\`: view the next rewrite in an \`<iframe>\`. Also is a namespace for quining.
Makes the system adaptable to more usage scenarios, and gives in-system ways to modify any code directly.`,
    todo:`Ability to select a subset of functions (and their dependencies, but not (only) definitions).
Ability to run a function by default. (It's like compiling a program into an executable.)
Ability to rewrite into an importable module.`,
    readAt:{
      editRewrite:_(`editRewrite`),
      autoWorld:_(`autoWorld`),
      save:_(`save`),
      extension:_(`ToExtension`),
      readableJS:_(`ToReadableJS`),
      scopedJS:_(`ToScopedJS`),
      consWorld:_(`consWorld`),
    },
    philosophy:`Writing the system's code in a particular style allows it to be viewed/modified in the system by the user, preserving anything they want in the process without external storage mechanisms.
The correctness of quining of functions can be tested by checking that the rewrite-of-a-rewrite is exactly the same as the rewrite. Or by incorporating rewriting into the lifecycle.

(Newsflash: a program that can inspect its own source is self-aware. A quine is the ultimate in self-awareness, much more self-aware than any human. But it doesn't seem magical enough to be true, right? What, you think you are above the consequences of what your words mean? Don't blame all implementations of your ideas ever made, blame your ideas.)`,
    Initialize() {
      Rewrite.ctx = new Map(Self.ctx)
      Rewrite.ctx.delete('_globalScope')
    },
    call(JS = ToScopedJS) {
      let html = _htmlOfRewrite(JS)
      const download = elem('a', 'Download the next rewrite, or preview:')
      download.download = 'index.html'
      download.style.verticalAlign = 'bottom'
      const refresh = elemValue(button(function() {
        html = iframe.srcdoc = _htmlOfRewrite(JS)
        URL.revokeObjectURL(u), u = download.href = URL.createObjectURL(new Blob([html], {type:'text/html'}))
      }, '🔁', 'Refresh the rewrite.'), Rewrite)
      refresh.doNotCloseTheContextMenuOnClick = true
      let u = download.href = URL.createObjectURL(new Blob([html], {type:'text/html'}))
      const i = setInterval(() => !download.isConnected && (clearInterval(i), URL.revokeObjectURL(u)), 60000)
      elemValue(download, html)
      const iframe = elem('iframe')
      iframe.title = 'Preview of the next rewrite'
      iframe.srcdoc = html
      const iframeResize = elem('div', iframe)
      iframeResize.classList.add('resizable')
      const result = elem('div', [download, refresh, iframeResize])
      return result
    },
  },

  BrowserIconURL:`data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAHaElEQVR4XuWbW8htUxTHnQ4P7l7Eg0KRu3POC5E4yp04lBRhh3g5cin3S1/ul3KJFye0ESXlIHfKcRLx4n6LQnkgL+4eEP/fao6vuec317ysvfb+6tujRnvtucYaY86xxphzjDHnWrZJO+yvW3PCkxM03LpQeH+C5kzdO0T4jfAL4bfCD1roV6l9Z+Gewl2FbwkfS/Beq3v3Zfq33o3joxjdspaHL1P7HRnG3L5SeHuE7lC1rREe6wYDyeXCOwt4QuLL/1z/XxY+I9wYef4Ktd1WwDcqP6aAoZidXcBwnWgu8Oi21fX5wnO8QYdsHlHDIMM7JR8LeliI7F88Pg842bluL5AfKuBpcciZPEI+FuIiwHZCtHtVTrq7j0me0kJbKp/HbxVipT87Xpj4fgV9GJHvKyCl+ZDvMWp4RXiRcM4poUD2PEnMEmrkGyMGj/x7hfTppcJOzMs3BZT6PPyfEOLLdwtXFwqMkfk+WSM/xmuDGi8Rwuf0wj418lEApvxh4UOQXSy8p4I+RbrC3ayRn+JX27cVKKDG764R/c09DR42+CNQMu+Uiq3p43oU8F8hZ0zrNOFJhfQlZKzzAHFCX/CsGD0pxFWzUKoAZm0mvT+yHOsIBo58WPdYlnorURwlxLqTUKIA3vxzQtb3zYX4K8qIwdFqxK8PFh4p3CIh/R/d28zd/1u/myZoUfzrwrcL5f8luoeEWGvSEnIKwJ8OcIyIuEqiQ38cdADFnRgZ3AtqO8G1c31chAbFE/hg1jXADE+EynPvCm9pe7hNAWjtPaE/29vaX9MRo91DF9cL/SXqWv23CZXrGz3GyL9B+GUXYXoGSyR8NiBeOTCQ39wLFUCEh/Z+EL4fCG/LG2r6SMeIIYjYmPmJ7wGu8VeT73e+hr9PG07uJFo7ePIXKMCP7d/Q3dUTUICxJHZHEV+7ht30SxDj5xZdB27PhQrYoBuHu5vzuYNZgJ/VYS6xQKcPC/AHhV9e7Rr863EH3qYA2gmUCJuBJotkUOTUls+T2JC38xtC3wr4SgLM1Jlfdu9r5I5PLL4hd6DOYAnU2nBQvIm2rG4SCnjQdfa8KSkAcWSRZnnNJGhAPm+aib2MvhXAMoUZAv51X4aQinCx8Kae4A8ql5GNswyGg2IVIEa4yd0g3mDNZxXoA8JlMOQ5n4n6CqD0RC2uDboEQm288P1/hcc7guf1u1xICa0PsECojReVpb18C6CG92ZGMlEVdb5xgWDocWEsFD5D7UVJTKYTxBe5pO0w0Ww0C7hLfygopIB4nCRjXED7RIbAwP0O3S+RX8oKS2XT11QeAh8KOpeaAj7Tn8YkMoAF1MblPktyAv/5WDrMm2M+6Ao8bxFmikfjBiiAuv2jhdLoWM60UqxC04wVRMZ1NZ6PJV+xfp2FAkpLysYAE+2SpGCSYT2hrSSGq3WpPeBavNlSWIcCCIOZkUtTXSYpJqsa2FLEYT0BeSy9AHkBM7fVEyyf/7NGiGiZXGuKostRAH6NaQ6FJRsi9InlqiRjwxQZOG7jL6PIQZ4PA/2hXA34+Tz1gJI5Ibf2+7KsLL4GBZAmWupbWiD1N0ZiL4m3QP5vsz00FkhZ6ht7jtIb80I4GFyO+kBqieyyMbIyFt7yZkosIdwaY0BEeJg2gw0BWbE3H9IN1MAbioWylOJwmzBiLJ3H7M3Py2yL72NhMYHLq8J3hJ+6TmDepzpuWM+vwoPcGwxrfPi5+XxEPyNNMVpf/taitu21p3SNm+wr3Cchv3hz1Hpi2+Pbq4Gszfwz7Dzb098Lw11i3jZZ3k/COWHt5gcrBM+1yWdO2UnI9nwMQvlV2+MwnGkFtLkAPmgu8ImuQxf4zZkgNflJuIDJ3ybiAsw/5gIx+cUuMBSjcSZB/JdZPIQ+JkGWXgbS6yS4UgztyMqsLYOrugZCpcWRaQZCXc4HNIHQNEJh8oBzhf7WWi4UZmmrzQc6hcKlQYT5dNdkiHzg92BiaEuGoK3NA2DdKRma+XQYzeXqgfbillJBhDHvXVMSwyQxzXFhGiUxXC3X15GS2MwXRUvcoM+yOMfZKML45wMoi8eyyC4WV10WR8i0N0aIEfzzAdTyFnVjZOa3xrCCmdwcnfntcUpPM31AwmpvM31ExpYaZmFWgx+FkzgkxTJHEkTxwirAyCbCpBps8tvOIdYsibFDUjt68htedkYoZDyNY3LXSah/PsCu6cuiHZMLFTHJg5IvSph/PsCu/T4s2kFJvxNschCkhPl8zBz9o7JHiCAVj9cclSUPeU1Yc1SWegLB1lhHZW2Q+Ct7AmE+X+OTMdqBaxyOyyh4HsXzMno5LG28l+xx+dJCKIrgeFnrweMOb3ESH0zU9LH5YKL2kxlOktppyw5jHnmk709mavvWfDID5DJBv9dL7qMpGxwTUcmGCPR2PgCNzwljR2tT1rFgl1bENfKNt//ZXJfzASMHJWFaOh8syQ8nay1hSX46a0oonRNyH08T+9vxu64fT1NEpYQ2tY+nTQmT+nz+OwkIEy2TyT7lLsKpfT7/P/yLMrzOf4DHAAAAAElFTkSuQmCC`,

  ToExtension:{
    docs:`Converts Self to a set of files that can be loaded as a WebExtension, to provide an action button that opens self in any page.
(In Firefox, these can be loaded temporarily in about:debugging.)`,
    call(net = Self, opt) {
      const execOnClickSrc = `browser.browserAction.onClicked.addListener(tab => browser.tabs.executeScript({file:browser.runtime.getURL('self.js'), runAt:"document_start"}))`
      const manifest = {
        version:'0',
        manifest_version:2,
        content_security_policy:"script-src 'self' 'unsafe-eval'; object-src 'self';",
        homepage_url:"https://github.com/Antipurity/conceptual",
        icons: { 64:'icon.png' },
        name:"REPL",
        description:"Allows opening a REPL in pages",
        permissions:["activeTab"],
        web_accessible_resources:['self.js'],
        browser_action:{
          default_icon:'icon.png',
          default_title:"Open a REPL in this page",
        },
        background:{
          scripts:["execonclick.js"],
          persistent:false,
        },
      }
      return elem(files, {
        ['manifest.json']:JSON.stringify(manifest),
        ['self.js']:ToScopedJS(net, opt),
        ['execonclick.js']:execOnClickSrc,
        ['icon.png']:BrowserIconURL,
      })
    },
  },

  ToReadableJS:{
    docs:`Converts Self to a human-readable form that pollutes the global scope on execution.`,
    examples:[
      [
        `ToReadableJS Self.'ctx' (jsEval '{dontMarkLines:true, into:"document.body.appendChild(document.createElement(\\"div\\")))"}')`,
      ],
    ],
    call(net = Rewrite.ctx, opt) {
      if (!(net instanceof Map))
        error('Expected a map, got', net)
      const markLines = opt ? !opt.dontMarkLines : true, lines = [], funs = []
      net.forEach((v,k) => typeof k == 'string' && !_isValidIdentifier(k) && error('Not a valid JS identifier:', k))
      const seen = new Map
      const weakMaps = new Map
      mark(net)
      seen.set(net, 0)
      const names = new Map
      net.forEach((v,k) => { typeof k == 'string' && (seen.get(v) !== 0 && names.set(v, k), seen.set(v, 0)) })
      let s = [], nextName = 0, depth = 0, line = 1
      opt && typeof opt.prefix == 'string' && write(opt.prefix)
      write(`/* Code begins at the first \`})({\`, as methods that are bound to each other. _XXX methods are private and somewhat invisible. */\n`)
      write(`'use strict';\n`)
      write(`(function() {\n`)
      write(`const __version = ${str(__version.replace(/[0-9]+$/, s => +s+1))}\n`)
      if (markLines) write(`const __line = function(lines, funs) { for (let i=0; i < funs.length; ++i) __line.lines[''].push(lines[i], funs[i]) }\n`)
      if (markLines) write(`__line.lines = {['']:[]}\n`)
      write(`const _ = (function is(name) {\n`)
      write(`  const obj = Object.create(is)\n`)
      write(`  return obj.is = name, obj\n`)
      write(`});\n`)
      write(_unevalFunction(__base)[1].replace(/__INTO__/, opt && opt.into || 'document.body')+'\n')
      write("__base({")
      ++depth
      net.forEach((v,k) => {
        if (typeof k != 'string') return
        write('\n\n')
        if (markLines && _isValidIdentifier(k, true) && _unevalFunction(v, true)) lines.push(line), funs.push(k)
        method(identifier(k), v, seen.get(v) === 0)
        names.set(v, k), seen.set(v, 1)
      })
      seen.forEach((refCount, v) => {
        if (refCount <= 1) return
        if (!names.has(v)) names.set(v, ++nextName)
        write('\n\n'), method(identifier(names.get(v)), v, true)
      })
      --depth
      write(`\n})\n`)
      funs.length && write(`__line([${lines}],[${funs}])\n`)
      write(`})()`)
      return s.join('')

      function resolve(x) {
        return typeof x != 'string' && net.has(x) ? net.get(x) : x
      }
      function mark(x) {
        x = resolve(x)
        if (x == null || typeof x == 'number' || typeof x == 'boolean' || typeof x == 'string') return
        seen.set(x, (seen.get(x) || 0) + 1)
        if (seen.get(x) !== 1) return
        if (!isArray(x) && defines(x, deconstruct)) return mark(deconstruct(x))
        else if (x instanceof Map) x.forEach((v,k) => (mark(k), mark(v)))
        else if (x instanceof WeakMap)
          weakMaps.set(x, []), seen.forEach((rc, obj) => x.has(obj) && (weakMaps.get(x).push(obj), mark(x.get(obj))))
        else if (isArray(x)) x.forEach(mark)
        else if (x && !x[defines.key] && typeof x == 'object')
          Object.keys(x).forEach(k => mark(x[k]))
        else if (x && x[defines.key])
          Object.keys(x[defines.key]).sort((a,b) => _id(a) - _id(b)).forEach(k => (mark(resolve(concept.idToKey[+k])), mark(x[defines.key][k])))
        if (weakMaps.size)
          weakMaps.forEach((keys, wm) => wm.has(x) && (keys.push(x), mark(wm.get(x))))
      }
      function write(str, noDepth = false) {
        if (markLines) line += _lineCount(str)
        s.push(!depth || noDepth ? str : str.replace(/\n(?!\n)/g, '\n'+'  '.repeat(depth)))
      }
      function put(x, ignoreName = false, ignoreMark = false) {
        x = resolve(x)
        if (typeof x == 'string') write(str(x), true)
        else if (x == null || typeof x == 'number' || typeof x == 'boolean') write(''+x)
        else if (!ignoreName && names.has(x))
          write('_('), write(typeof names.get(x) == 'number' ? ''+names.get(x) : str(names.get(x)), true), write(')')
        else if (!isArray(x) && defines(x, deconstruct)) {
          // Deconstructed concepts become is(…) to evaluate on start.
          const d = deconstruct(x)
          if (!isArray(d) || defines(d, construct) === undefined) error("Must be an actual construct:", d)
          write('_('), put(d), write(')')
        } else if (isFunc(x)) {
          write(x[1])
        } else if (isArray(x)) {
          write('['), ++depth // […]
          x.forEach(el => (write('\n'), put(el), write(',')))
          --depth, write('\n]')
        } else if (x instanceof Map) { // new Map([…])
          if (!x.size) return write('new Map')
          write('new Map(['), ++depth
          x.forEach((v,k) => (write('\n['), put(k), write(','), put(v), write('],')))
          --depth, write('\n])')
        } else if (x instanceof WeakMap) {
          write('_([')
          put(weakMap), write(',')
          weakMaps.get(x).forEach(k => (put(k), write(','), put(x.get(k)), write(',')))
          write('])')
        } else if (x && !x[defines.key] && typeof x == 'object') {
          write('{'), ++depth // {…} in readAt.
          Object.keys(x).forEach(k => (write('\n'), method(identifier(k), x[k])))
          --depth, write('\n}')
        } else if (typeof x == 'function' || x && x[defines.key]) {
          // Functions get put as-is or as a definition of call.
          const def = new Map
          x[defines.key] && Object.keys(x[defines.key]).sort((a,b) => _id(a) - _id(b)).forEach(k => {
            const v = x[defines.key][k]
            let c = resolve(concept.idToKey[+k])
            if (c !== readAt && v instanceof Map) throw "Only definitions can be Maps"
            if (c !== readAt && (v instanceof Map || v && !isArray(v) && !v[defines.key] && typeof v == 'object'))
              throw "Only the definition of readAt can be an object"
            def.set(c, v)
          })
          if (def.size) {
            if (x === Self)
              def.set(readAt, undefined)
            if (typeof x == 'function')
              def.set(call, _unevalFunction(x))
            write('{'), ++depth // {…} in definitions.
            def.forEach((v,k) => {
              write('\n')
              if (markLines && ignoreName && k === call) lines[lines.length-1] = line
              method(identifier(names.get(k)), v)
            })
            --depth, write('\n}')
          } else put(_unevalFunction(x))
        } else throw "Unknown value to put"
      }
      function str(s) { return "`" + String(s).replace(/`|\\|${/g, s => '\\' + s) + "`" }
      function identifier(s) { return s && +s === +s || /^[_a-zA-Z][_a-zA-Z0-9]*$/.test(s) ? ''+s : '[' + str(s) + ']' }
      function isFunc(x) { return isArray(x) && x[0] === jsEval && typeof x[1] == 'string' }
      function method(key, v, ignoreName = false) {
        if (typeof v != 'string' && net.has(v)) v = net.get(v)
        if (_unevalFunction(v, true) && (ignoreName || !names.has(v)) && !v[defines.key]) v = _unevalFunction(v)
        if (isFunc(v) && v[1].slice(0,8) === 'function' && (ignoreName || !names.has(v)))
          write(key), v[1] = v[1].slice(v[1].indexOf('(')), put(v, ignoreName), write(',')
        else
          write(key), write(':'), put(v, ignoreName), write(',')
      }

      // The bootstrapper for this.
      function __base(net) {
        const globals = typeof self !== ''+void 0 ? self : typeof global !== ''+void 0 ? global : window
        const env = new Map
        const object = new Map
        const constructed = new Map

        const defKey = Symbol('defines')

        // preload is for easier readAts. load is basically a copy of `bound` with a little notational convenience stuff thrown in.
        preload(net, globals)
        load(net, globals, true)
        Object.keys(net).forEach(k => k && +k === +k && delete net[k])
        Object.keys(net).forEach(k => net[k] = globals[k])
        if (net.interrupt) net.interrupt.noInterrupt = false

        postload()
        Initialize.call(globals, net, typeof __line != ''+void 0 ? __line.lines : undefined)
        env.clear(), object.clear(), constructed.clear()

        function objectFor(x) {
          // Load {call(){}} into a trivially-callable function, as a notational convenience.
          return x && typeof x.call == 'function' && x.call !== Function.prototype.call ? x.call : Object.create(null)
        }
        function preload(from, into) {
          // Pre-create objects/functions to be filled by `load`, so that arbitrary order of definitions is permitted.
          Object.keys(from).forEach(k => {
            if (k in into) try { delete into[k] } catch (err) {}
            if (from[k] instanceof Map) {
              if (into[k] === undefined) into[k] = new Map
              return
            } else if (from[k] && Object.getPrototypeOf(from[k]) === Object.prototype) {
              if (into[k] === undefined) into[k] = objectFor(from[k])
              if (typeof into[k] == 'function') into[k].displayName = k
              return
            } else if (Array.isArray(from[k])) {
              if (into[k] === undefined && +k !== +k) into[k] = new Array(from[k].length)
              return
            }
            if (into[k] !== from[k] && +k !== +k) into[k] = from[k]
          })
          if (from.defines) into.defines.key = defKey
          if (from.call && from._newExecutionEnv) into.call.env = from._newExecutionEnv()
          if (from.interrupt) into.interrupt.noInterrupt = true
        }
        function load(from, into, inLookup) {
          // Handle is(…) (as ref-to-global) and arrays and objects (as definitions) specially.

          // Cache to prevent cycles from referring to old not-loaded versions of objects.
          if (env.has(from)) return env.get(from)
          if (from && Object.getPrototypeOf(from) === _) {
            // Look up symbols in the network.
            if (!object.has(from.is)) {
              if (Array.isArray(from.is)) into = postload(from)
              else if (!(from.is in net)) throw new Error("Not a link to an existing thing: "+from.is)
              else into = load(net[from.is], globals[from.is])
              env.set(from, into), object.set(from.is, into)
            }
            return object.get(from.is)
          }
          if (from instanceof Map) {
            // Load keys and values.
            if (into === undefined) into = new Map
            env.set(from, into)
            from.forEach((v,k) => into.set(load(k), load(v)))
            return into
          } else if (from && Object.getPrototypeOf(from) === Object.prototype) {
            // Load object values: turn {…} into {[defines.key]:{…}}, as a notational convenience.
            if (into === undefined) into = objectFor(from)
            env.set(from, into)

            if (!inLookup) {
              let d
              for (let key of Object.keys(from)) {
                if (from[key] === defKey) { into[key] = from[key];  continue }
                  // Since objectFor(…) is different for functions, we have to copy.
                const k = load(_(key))
                if (k !== call || typeof from[key] != 'function')
                  (d || (d = Object.create(null)))[_id(k)] = load(from[key], undefined, k === readAt)
              }
              return d && (into[defKey] = into !== Self ? Object.freeze(d) : d), into
            } else {
              for (let k of Object.keys(from)) if (+k !== +k) {
                const loaded = load(from[k], into[k])
                if (loaded !== into[k]) into[k] = loaded
              }
              return into
            }
          }
          if (Array.isArray(from)) {
            // Look into arrays and load their elements.
            if (into === undefined) into = new Array(from.length)
            env.set(from, into)
            for (let i = 0; i < into.length; ++i) into[i] = load(from[i])
            return into
          }
          return from
        }
        function postload(from) {
          if (from !== undefined) {
            const x = from.is.map(x => load(x))
            const to = load(_('defines'))(load(from.is[0]), load(_('construct')))(x)
            constructed.set(to, from)
            env.set(from, to)
            return to
          } else
            constructed.forEach((from, obj) => construct(from.is.map(x => load(x)), obj)), constructed.clear()
        }
      }
    },
  },

  ToScopedJS:{
    docs:`Converts Self to a form that has itself hidden in a scope.`,
    call(net = Rewrite.ctx, opt) {
      if (!(net instanceof Map))
        error('Expected a map, got', net)
      if (net.has('_globalScope')) throw "Net must not have _globalScope"
      if (!net.has('_id')) throw "Net must have _id"
      if (!net.has('label')) throw "Net must have label"
      if (!net.has('concept')) throw "Net must have concept"
      const markLines = opt ? !opt.doNotMarkLines : true, lines = [], funs = []
      net.forEach((v,k) => typeof k == 'string' && k[0] === '$' && error('$ is reserved for hidden names, use something other than', k))
      net.forEach((v,k) => typeof k == 'string' && !_isValidIdentifier(k) && error('Not a valid JS identifier:', k))
      const names = new Map
      const weakMaps = new Map
      let n = 0
      mark(net, true)
      let s = [], line = 1
      opt && opt.prefix && write(opt.prefix)
      write(`'use strict';(()=>{\n`)
      write(`const __version = ${str(__version.replace(/[0-9]+$/, s => +s+1))}\n`)
      if (markLines) write(`const __line = function(lines, funs) { for (let i=0; i < funs.length; ++i) __line.lines[''].push(lines[i], funs[i]) }\n`)
      if (markLines) write(`__line.lines = {['']:[]}\n`)
      write(`let`)
      // Put the variables to hold values.
      net.forEach((v,k) => {
        v = resolve(v)
        if (typeof k != 'string' || !_isValidIdentifier(k, true)) return
        if (names.has(v) && names.get(v)[0] === '$')
          write('\n'), names.set(v, k), write(k), write('='), put(v, true), write(',')
      })
      names.forEach((name, v) => { if (name[0] === '$') write('\n'), write(name), write('='), put(v, true), write(',') })
      write('$' + (n++).toString(36))
      if (net.has('defines'))
        write('\nconst $$=defines.key=Symbol(\'defines\')\n')
      if (net.has('call') && net.has('_newExecutionEnv'))
        write(`call.env = _newExecutionEnv()\n`)
      if (net.has('interrupt'))
        write(`interrupt.noInterrupt = true\n`)
      // Fill the values of variables in.
      names.forEach((name, v) => {
        v = resolve(v)
        if (isArray(v) || _unevalFunction(v, true) || defines(v, deconstruct) === undefined) if (!fill(v)) write('\n')
        if (!isArray(v) && !_unevalFunction(v, true) && defines(v, deconstruct) !== undefined) {
          const d = deconstruct(v)
          const c = defines(d, construct)
          if (!isArray(d) || isArray(d[0]) || typeof defines(d[0], construct) != 'function') error("Invalid deconstruction:", d)
          let b = 0
          // For constructs, we want to put `name = construct([...d]);  <and much later>  construct([...d], name)`
          write(name), write('='), put(c), write('(['), d.forEach(el => (b++ && write(','), put(el))), write('])\n')
        }
      })
      // Put aliases.
      net.forEach((v,k) => {
        v = resolve(v)
        if (typeof k != 'string' || k === names.get(v)) return
        if (!_isValidIdentifier(k, true) || !_isValidIdentifier(names.get(v), true)) return
        write('let '), write(k), write('='), put(v), write('\n')
      })
      funs.length && write(`__line([${lines}],[${funs}])\n`)
      // Initialize the network.
      if (net.has('interrupt'))
        write(`interrupt.noInterrupt = false\n`)
      write(`\nInitialize.call(typeof self !== ''+void 0 ? self : typeof global !== ''+void 0 ? global : window, `)
      write(`{${[...net.entries()].map(([k,v]) => typeof k != 'string' ? null : k === names.get(v) ? k : k+':'+(names.get(v)||v)).filter(x => x).join(',')}}`)
      write(markLines ? `, __line.lines` : `, undefined`)
      write(`, ${opt && opt.into || null}`)
      write(')\n')
      // Construct things.
      names.forEach((name, v) => {
        v = resolve(v)
        if (!isArray(v) && !_unevalFunction(v, true) && defines(v, deconstruct) !== undefined) {
          const d = deconstruct(v)
          const c = defines(d, construct)
          let b = 0
          put(c), write('(['), d.forEach(el => (b++ && write(','), put(el))), write('],'), write(name), write(')\n')
        }
      })
      write(`\n})()`)
      return s.join('')

      function resolve(x) {
        return typeof x != 'string' && net.has(x) ? net.get(x) : x
      }
      function mark(x, topLevel) {
        // Gives names to all objects in the graph.
        x = resolve(x)
        if (x == null || typeof x == 'number' || typeof x == 'boolean') return
        let name
        if (names.has(x)) return; else if (!topLevel) names.set(x, name = '$' + (n++).toString(36))
        try {
          if (!isArray(x) && defines(x, deconstruct)) return mark(deconstruct(x))
          else if (x instanceof Map) x.forEach((v,k) => (!topLevel && mark(k), mark(v)))
          else if (x instanceof WeakMap) {
            weakMaps.set(x, [])
            names.forEach((name, k) => x.has(k) && (weakMaps.get(x).push(k), mark(x.get(k))))
          } else if (isArray(x)) x.forEach(x => mark(x))
          else if (x && !x[defines.key] && typeof x == 'object')
            Object.keys(x).forEach(k => mark(x[k]))
          else if (x && x[defines.key]) {
            if (x === net.get('Self')) return
            mark(net.get('_id')),
            Object.keys(x[defines.key]).sort((a,b) => _id(a) - _id(b)).forEach(k => (mark(resolve(concept.idToKey[+k])), mark(x[defines.key][k])))
          }
          weakMaps.size && weakMaps.forEach((keys, wm) => wm.has(x) && (keys.push(x), mark(wm.get(x))))
        } finally { names.delete(x), !topLevel && names.set(x, name) } // Ensure that all dependencies of x are ready before x.
      }
      function write(str) {
        if (markLines) line += _lineCount(str)
        s.push(str)
      }
      function put(x, ignoreName = false) {
        // Puts the simple object creator of `x`, to be filled.
        x = resolve(x)
        if (!ignoreName && names.has(x)) write(names.get(x))
        else if (_unevalFunction(x, true)) {
          if (names.has(x)) lines.push(line), funs.push(names.get(x))
          const f = _unevalFunction(x)
          if (f[2] !== undefined && f[2] !== net && f[2] !== defines(Self, readAt))
            error("Can only do single-global-scope functions, got", f)
          write(f[1])
        } else if (!isArray(x) && defines(x, deconstruct)) write('0')
        else if (isArray(x)) write('[]')
        else if (x instanceof Map) write('new Map')
        else if (x instanceof WeakMap) write('new WeakMap')
        else if (x && typeof x == 'object') write('{}')
        else if (typeof x == 'string') write(str(x))
        else if (x == null || typeof x == 'number' || typeof x == 'boolean') write(''+x)
        else throw "Unknown value to put"
      }
      function str(x) { return "`" + String(x).replace(/`|\\|${/g, s => '\\' + s) + "`" }
      function key(s) { return /^[_a-zA-Z][_a-zA-Z0-9]*$/.test(s) ? '.'+s : s && +s === +s ? '['+s+']' : '[' + str(s) + ']' }
      function fill(x) {
        // Fills the created object.
        x = resolve(x)
        const name = names.get(x)
        if (isArray(x)) { // x.push(...)
          let b = 0
          write(name), write('.push('), x.forEach(el => (b++ && write(','), put(el))), write(')')
        } else if (x instanceof Map) // x.set(k,v).set(k,v)...
          x.size && write(name), x.forEach((v,k) => (write('.set('), put(k), write(','), put(v), write(')')))
        else if (x instanceof WeakMap) // x.set(k,v).set(k,v)...
          !weakMaps.has(x) && error("Internal error: WeakMap rewriting is wrong at", x),
          weakMaps.get(x).length && write(name), weakMaps.get(x).forEach(k => (write('.set('), put(k), write(','), put(x.get(k)), write(')')))
        else if (x && !x[defines.key] && typeof x == 'object') { // x[k]=v  \n  x[k]=v  \n  ...
          Object.keys(x).forEach(k => (write(name), write(key(k)), write('='), put(x[k]), write('\n')))
          return true
        } else if (x && x[defines.key]) { // Set name[defines.key][...] one by one.
          write(name), write('[$$]=Object.create(null)\n')
          Object.keys(x[defines.key]).sort((a,b) => _id(a) - _id(b)).forEach(k => {
            const key = resolve(concept.idToKey[+k])
            write(name), write('[$$]['), put(net.get('_id')), write('('), put(key), write(')]='), put(x[defines.key][k]), write('\n')
          })
          if (x !== net.get('Self')) write('Object.freeze('), write(name), write('[$$])\n')
          return true
        } else return true
      }
    },
  },

  System:{
    docs:`A namespace for low-level functions that should not be called in user code, for your mom's safety.`,
    readAt:{
      interrupt:_(`interrupt`),
      jsEval:_(`jsEval`),
      argCount:_(`argCount`),
      dispose:_(`dispose`),
      tensorMemorySince:_(`tensorMemorySince`),
      arraysSince:_(`arraysSince`),
      countReachableObjects:_(`countReachableObjects`),
      ClearCaches:{
        docs:`When called, clears the oldest half of entries in every cache.`,
        argCount:0,
        call() {
          if (call.pure) throw impure
          halve(_id.xToIndex)
          halve(_valuedColor.m)
          _fillAdjustInputs.length = 0
          if (_allocArray.free) _allocArray.free.length >>>= 1
          if (_resolveStack.functions) {
            const k = Object.keys(_resolveStack.functions)
            for (let i = 0; i < (k.length>>>1); ++i) delete _resolveStack.functions[k[i]]
          }
          // And WeakMaps: _invertBindingContext.cache.
          function halve(m) { if (m) _limitMapSize(m, m.size>>>1) }
        },
      },
    },
    permissionsElem(el) { el.classList.add('warning');  return el },
  },

  _debugDoubleDealloc:[
    _(`settings`),
    false,
    `Whether \`_allocArray\` and \`_allocMap\` should not re-use freed arrays/maps but mark them as de-allocated.`,
  ],

  _allocArray:{
    docs:`\`_allocArray(Length)\`⇒\`Array\` as a replacement for \`[]\` and \`_allocArray(Array)\` to re-use arrays.`,
    readAt:{
      _debugDoubleDealloc:_(`_debugDoubleDealloc`),
    },
    call(a) {
      if (!_allocArray.free) _allocArray.free = []
      if (typeof a == 'number' && a === a>>>0) { // Allocate.
        if (limitArrays.limit !== undefined && array.count+1 > limitArrays.limit)
          throw limitArrays.limit += 100, limit
        ++array.count
        const arr = _allocArray.free.length ? _allocArray.free.pop() : [];  arr.length = a;  return arr
      }
      if (!isArray(a)) error("Expected array length or an array, got", a)
      --array.count

      // Undo `_rememberArrayItems`.
      const resM = _rememberToDispose.res, resR = _rememberToDispose.reg
      if (resM && resM.has(a)) resR && resR.unregister(resM.get(a)), resM.delete(a)

      // Test whether there are any errors in re-using arrays.
      if (_debugDoubleDealloc[1]) {
        if (Object.isFrozen(a) && a[0] === "Use-after-free of" && a.length == 4) error("Double-free of", a[1], a[2], _resolveStack(a[3]))
        const prev = a.slice()
        a.length = 4, [a[0], a[1], a[2], a[3]] = ["Use-after-free of", prev, "first freed at", new Error().stack], Object.freeze(a)
        return
      }

      a.length = 0
      if (_allocArray.free.length > 1000) return // Prevent madness.
      _allocArray.free.push(a)
    },
  },


  _allocMap:{
    docs:`_allocMap()⇒Map as a replacement for \`new Map\` and _allocMap(Map) to re-use objects.`,
    call(a) {
      if (!_allocMap.free) _allocMap.free = []
      if (a === undefined) return _allocMap.free.length ? _allocMap.free.pop() : new Map
      if (!(a instanceof Map)) error("Expected undefined or a Map, got", a)

      // Test whether there are any errors in re-using maps.
      if (_debugDoubleDealloc[1]) {
        if (_allocMap.free.includes(a)) errorStack("Double-free of", a, "first freed at", _resolveStack(_allocMap.s.get(a)))
        else (_allocMap.s || (_allocMap.s = new WeakMap)).set(a, new Error().stack)
        a.clear()
        return
      }

      a.clear()
      if (_allocMap.free.length > 1000) return // Prevent madness.
      _allocMap.free.push(a)
    },
  },

  _appendFile(to, name, value) {
    if (typeof name != 'string') error("Filename must be a string, got", name)
    if (typeof value == 'string') {
      const ch = elem('a', name)
      ch.download = name
      ch.href = value.slice(0,5) === 'data:' ? value : 'data:,' + encodeURIComponent(value) // Content sniffing (like here) is bad.
      to.append(ch)
    } else if (value instanceof Map || typeof value == 'object' && !value[defines.key])
      to.append(defines(files, elem)(files, value, name))
    else
      error("Unknown file content type:", value)
  },





  _printAll:{
    docs:`Prints all defined sub-functions of a value.`,
    call(f, value) {
      let [ins = defines(f, _printAll), i = 0] = interrupt(2)
      try {
        if (!ins) return
        for (; i < ins.length; ++i) {
          let r
          try { r = ins[i](value) }
          catch (err) { if (err === interrupt) throw err;  print(_errorRepr(err)) }
          r !== undefined && print(r !== _onlyUndefined ? r : undefined)
        }
      } catch (err) { if (err === interrupt) interrupt.stack.push(ins, i);  throw err }
    },
  },

  _clearStyle(el) {
    if (!el.style.length) el.removeAttribute('style')
    if (!el.classList.length) el.removeAttribute('class')
  },























  addSearchElem:{
    docs:`Adds an element that can search for a string in a DOM tree, collapsing all that do not contain such things.`,
    call(el) {
      const container = elem('div')
        const row = elem('div')
        const str = elem('input')
        str.type = 'text'
        str.title = 'Search for this.'
        const end = elem('button', '❌')
        end.onclick = () => { const h = _smoothHeightPre(container); container.replaceWith(el); _smoothHeightPost(el, h) }
        end.style.margin = 0
        row.append(str, end)
      el.replaceWith(container)
      container.append(el)
      elemInsert(container, row, el)
      let env = null
      str.oninput = _throttled(() => {
        const s = str.value
        const bad = [-1];  bad.length = s.length
        for (let i = 1, j = 0; i < s.length; ++i, ++j) {
          if (s[i] === s[j])
            bad[i] = bad[j]
          else {
            bad[i] = j
            while (j > 0 && s[i] !== s[j]) j = bad[j]
          }
        }
        let i = 0
        env !== null && _cancel(env)
        env = _newExecutionEnv()
        env[_id(_schedule)] = _newJobId()
        _doJob([last, [search, el], () => env = null], env)

        function search(el) {
          // Return true if el contains s (if any children return true, or if we're a text node and have a match inside), else false.
          if (!el.childNodes.length && el.nodeValue) {
            // Search the string.
            if (!s.length) return true
            let result = false
            for (let j = 0; j < el.nodeValue.length; ++i, ++j) {
              if (s[i] === el.nodeValue[j]) {
                if (i === s.length-1) result = true, i = bad[i]
              } else
                i = bad[i], i >= 0 && (--i, --j)
            }
            return result
          } else {
            // If some children are true and others are false, collapse the false children. Return whether any children are true.
            // If we are collapsed and want to return true, un-collapse us.
            //call.env = env
            Math.random()<.01 && _checkInterrupt()
            let [v = _allocArray(el.childNodes.length), anyTrue = false, anyFalse = false, i1 = 0, ch1 = el.firstChild, next1 = ch1 && ch1.nextSibling, i2 = 0, ch2 = el.firstChild, next2 = ch2 && ch2.nextSibling] = interrupt(9)
            try {
              for (; ch1; [ch1, next1] = [next1, next1 && next1.nextSibling], ++i1)
                v[i1] = search(ch1), v[i1] ? (anyTrue = true) : (anyFalse = true)
              if (anyTrue && anyFalse)
                for (; ch2; [ch2, next2] = [next2, next2 && next2.nextSibling], ++i2) {
                  const t = ch2.tagName
                  if (t === 'DETAILS')
                    ch2.open !== v[i2] && ch2.firstChild.click()
                  else if (!v[i2] && !ch2.nodeValue && t !== 'COLLAPSED' && t !== 'BRACKET' && t !== 'SPACE' && t !== 'NUMBER' && t !== 'STRING' && t !== 'KNOWN' && t !== 'SUMMARY' && t !== 'TR' && t !== 'TD')
                    elemCollapse(ch2)
                }
              if (anyTrue && el.tagName === 'DETAILS')
                !el.open && el.firstChild.click && el.firstChild.click()
              if (anyTrue && el.tagName === 'COLLAPSED')
                el.click()
              return anyTrue
            } catch (err) { if (err === interrupt) interrupt.stack.push(v, anyTrue, anyFalse, i1, ch1, next1, i2, ch2, next2), v = null;  throw err }
            finally { isArray(v) && _allocArray(v) }
          }
        }
      }, .5)
    },
  },




















  _intArray(len, EndValue) {
    if (EndValue < 128) return new Int8Array(len)
    if (EndValue < 32768) return new Int16Array(len)
    return new Int32Array(len)
  },

  _arrayIncludes(arr, value, start, end) {
    for (let i = start; i < end; ++i) if (arr[i] === value) return true
    return false
  },

  _consGoalOfCell(i, Cells, Goals) { return i * Goals / Cells | 0 },

  _consCellStartOfGoal(goal, Cells, Goals) { return Math.ceil(goal * Cells / Goals) },

  _consCellEndOfGoal(goal, Cells, Goals) { return Math.ceil((goal+1) * Cells / Goals) },

  _consResizeOptions(CI, cpc, Cells, Prev, Rand) {
    const opt = CI.options, next = CI.nextOptions, Opts = Prev+Rand
    if (opt.length === cpc * Cells * Opts) return
    if (opt.length % (cpc*Cells)) error("Cell-count changed, we panic:", opt, Cells)
    const pPrev = next[cpc*Cells], pRand = next[cpc*Cells+1], pOpts = pPrev+pRand
    const opt2 = CI.options = new Int32Array(cpc * Cells * Opts, CI.genCtx.length)
    for (let n = 0; n < cpc*Cells; ++n) // Copy previous choices over to newly-sized buckets.
      for (let i = 0; i < Prev; ++i)
        opt2[n*Opts + i] = opt[n * pOpts + (i < pPrev ? i : pPrev-1)]
    for (let n = 0; n < cpc*Cells; ++n) // Re-limit ring buffer next-write indices.
      if (next[n] >= Prev) next[n] = 0
    next[cpc*Cells] = Prev, next[cpc*Cells+1] = Rand // Update prev/random sizes.
  },

  consWorld:{
    _cancel(m) {
      if (m) { // Cancel unfinished replay state, if any.
        m.forEach((rs, refs) => { _rememberArrayItems(rs, true), _disposeEachAndDealloc(rs) })
        _allocMap(m)
      }
    },
    todo:`- When encountering a cons-world in use (by another job), copy some of its relevant hyperparams, namely, \`consCaches\` (mostly for \`consApply\`) and \`options\` and \`nextOptions\`, to wherever they are required (\`_regenCons\`). Otherwise, only one experience can be collected at a time (though soundness of collecting multiple experiences in parallel is questionable anyway, because of the RNN \`SequenceState\`).
- Allow all integer hyperparams to vary via being \`settings\`, especially \`Cells\` and \`FeatureSize\` (to see effects of gradual NN size expansion).`,
    docs:`Learned memory.
\`consWorld(Hyperparams,CellInfos)\`
A place where cons-cells learn to interconnect into executable programs however they like.

A cons-cell is two pointers, one to an end of the array (car), one to the rest of it (cdr): the smallest unit of programs. (Unlike Lisp, this is no-syntax, so bindings such as \`a*a a:x/2\` will already be \`bound\`. Technically, this just learns a graph, and a programming language gives that Turing-completeness.)

At every littlest place of the program, both what it is (numeric \`type\`) and what it wants are learned (assuming that \`setGoal\` is in \`Base\`), so executing learned cons-cells unrolls open-ended evolution.

Sounds too bland and non-specific to underlie general intelligence, right? The only way to know is to find out.



\`Hyperparams\` (user-specified) (the essential ones are \`Base\`, \`Predict\`, \`Goal\`):

  Basics (how/why/what to combine): \`\`elemCollapse stringToDoc("
    ❀ \`Cells\`: how many cons-cells to make. \`1000\` by default.
        (Required memory and compute per epoch grow linearly with this.)
    ❀ \`Goals\`: how many distinct maximization objectives to make. \`100\` by default.
        (\`allocate\` will override one goal for the user's purposes.)
        (Each goal is exposed to generation, for \`setGoal\`.)
        (Each goal controls the same cell count.)
    ❀ \`Base\`: the array of things that cons-cells can refer to.")\`\`

  Gradient descent (learn anything numerically): \`\`elemCollapse stringToDoc("
    ❀ \`FeatureSize\`: the size of numeric descriptions of what each thing is. \`128\` by default.
    ❀ \`NewEmbedding:Sizes→Embedding\`: creates those numeric descriptions. \`truncatedNormal\` by default.
    ❀ \`Optimizer:VarData→Embedding\` typed \`varData(sz)⇒tensorType(…sz) sz:'Sizes'\`: gets the data's current value, \`adjust\`able. \`varSGD\` by default.")\`\`

  Regeneration (learn to be any structure): \`\`elemCollapse stringToDoc("
    ❀ \`Predict:WhichPointer→ConsEmbedding→OptionEmbedding→PrevState→ChoiceIndices→GoalPrediction\`, typed \`tensorType(choices,?,ChoicesPerCell)⇒t⇒t⇒t⇒bzz⇒tensorType(choices,?,1) t:tensorType(choices,?,FeatureSize)\`: the neural estimator of options.
        \`concat\` inputs with appropriate sizes specified, then do a neural network from that.
        \`WhichPointer\` is, per-choice, either \`(1 0)\` for car or \`(0 1)\` for cdr.
        (At the first \`use\` of a cell in \`callAdjust\`, cells will be regenerated via one GPU-parallelized \`Predict\` call, then turned into a graph of arrays, then \`construct\`ed if changed.)
        (\`Predict\` can connect every cell to any cell (or any base thing), which would ordinarily mean \`ChoicesPerCell·Cells·(Cells+Goals+Base)·NNLayers\` \`matMul\`s, which would make \`Cells\` non-scalable. But we can linearize this by exploiting temporal coherence of programs.)
        (\`ChoiceIndices\` can be passed to \`gather\`, in case you want to make each choice have a different matrix to multiply by.)
    ❀ \`ChoicesPerCell\`: maybe you want not car/cdr pointers, but some other semantics; then this is for you. \`2\` by default.
    ❀ \`Policy:GoalPrediction→OptionAxis→Index\`: the neural compiler, which chooses one prediction per choice. Not \`adjust\`ed. \`argmax\` by default.
        (This is only called on experience collection. Experience replay will only re-\`Predict\` the actual choices.)
    ❀ \`PrevOptions\`: how big the ""last-picked-options here"" buffer is, for each choice. At least \`1\`. \`12\` by default.
    ❀ \`RandomOptions\`: how many random options to provide to each pointer, for exploration. \`4\` by default.
    ❀ \`ExploreOptions\`: the function that fills in the actual \`RandomOptions\`. \`consRandom\` by default.
        (No alternative.)
        ❀ \`AllowOptions\`: a \`ChoicesPerCell\`-length array of bit-masks of what choices can connect to (\`add\` up): \`1\` for cells, \`2\` for goals, \`4\` for basics. \`null\` by default.
    ❀ \`ConsMake\`: the function that turns car/cdr pointers (and a bunch of other info) into \`use\`able things. \`consMake\` by default.
        (Alternatives: \`consApply\`, \`consFixedArgCountApply\`.)
        For \`consMake\` and \`consApply\`:
        ❀ \`MaxArrayLength\`: when forming arrays from cons-cells, everything past this length gets cut off; for \`consMake\` and \`consApply\`. \`16\` by default.
            (Limits worst-case memory consumption.)
        ❀ \`ConsToEnd\`: if \`true\`, it is easier to re-use beginnings of arrays; if \`false\`, ends of arrays are more re-usable. \`false\` by default.
            (Array heads (\`func\`s and \`construct\`s) cannot be pinned down by \`allocate\` if this is \`true\`.)
            (Lisp cons-cells (\`arrayCons\`) would be \`false\`.)
        ❀ \`MaxCachedConstructs\`, for all cells. Exists for speed, and to not re-train constructed variables. \`3\` by default.
            (If an array head is the same as earlier, re-\`construct\` the earlier object instead of creating a new one.)")\`\`

  Q-learning (care about future values of goals): \`\`elemCollapse stringToDoc("
    ❀ \`Goal:Reality→FuturePrediction→Target\`, typed \`n⇒n⇒n n:tensorType(?,1)\`: the number to \`Predict\` and maximize.
        The simplest example: \`Real→Fut→Real\`.
        Or, discounted average: \`Real→Fut→(1-p)*Real+p*Fut p:.999\`.
        (\`GoalPrediction\` is combined with targets via \`_defaultPredict(GoalPrediction,Target)\`, which is like \`predict\`.)
        (We train \`2·Cells\` RL agents at the same time, which all exploit each other and compete for attention of the generated program.)
    ❀ \`MinReality\`: for \`clip\`ping in \`setGoal\`. Also used if the set-to value is not a number, or if it is never set. \`-5\` by default.
    ❀ \`MaxReality\`: for \`setGoal\`. To reduce useless-to-others reward-hacking, a cell's own goal cannot be picked. \`5\` by default.
    ❀ \`NaNReality\`: used if the set-to value is not a number (or is \`NaN\`, which is a special number), or if it is never set. \`-5\` by default.
    ❀ \`UnsetReality\`: used if the real goal value is never set. \`-5\` by default.")\`\`

  Replay buffers (make gradient-descent stochastic): \`\`elemCollapse stringToDoc("
    ❀ \`MaxStoredChoices\`: how many previous choices to store in total (not per-cell), in a ring buffer. \`1000000\` by default.
    ❀ \`ReplayedChoices\`: choices replayed per replay (if \`_consReplayImmediately\`, once per execution). We only \`adjust\` on replay. \`10000\` by default.
        (Minibatch size.)
    ❀ \`SimpleReplay\`: whether replays should gather-and-replay whole buckets (\`true\`, simpler/faster but less random) or individual choices (\`false\`, slower but perfectly random). \`true\` by default.
    ❀ \`ReplayChoice:ReplayedChoiceCount→Index\`: picks the choice to replay. \`randomNat\` by default.
        All choices are sorted by their latest \`ChoiceMetric\` in ascending order.
        Each call can pull in many choices, for a total of at least \`ReplayedChoices\`.
    ❀ \`OnSave:States→Actions→Rewards→Chosen→ConsWorld→undefined\`: gives an opportunity to inspect what is going on, just before saving the replay. \`null\` by default.
        (\`Chosen\` is in option-space, \`PrevOptions\` first and \`RandomOptions\` second. So, \`mean Chosen<PrevOptions\` is a measure of how unstable the structures currently are.)
        (\`Actions\` is in \`genCtx\`-space, all cars then all cdrs, meaning that you can index \`genCtx\` to count up the most popular globals.)")\`\`

  State (for meta-learning): \`\`elemCollapse stringToDoc("
    ❀ \`SequenceState:PrevState→ConsEmbedding→CarEmbedding→CdrEmbedding→Reality→ConsIndices→State\` typed \`t⇒t⇒t⇒t⇒n⇒t t:tensorType(Cells,FeatureSize) n:tensorType(Cells,1)\`: updates hidden cell \`State\`. \`null\` by default.
        (Replays pick a set of choices, then unroll (via \`loop\`) \`UnrollLength\` \`SequenceState\`s of choice cells right after the picked ones, then remember \`Predict\`, then \`predict\` \`Target\`s, then unroll \`Goal\`s in reverse (where the next \`Target\` is the previous \`FuturePrediction\`), setting \`future\`s to the \`stack\`ed \`Target\`.)
        (RNN. In ML, LSTMs/… perform better than simple RNNs, and Transformers perform better than LSTMs. But, no premature optimization.)
        (The indices are for \`gather\`ing individual-cell NN weights, if they are individual. Useless if \`SimpleReplay\`.)
    ❀ \`UnrollLength\`: how many consecutive choices to include per each \`ReplayChoice\`. \`16\` by default.
        (On replay, each \`ReplayChoice\` also pulls in its car/cdr counterpart, along with choices before it.)")\`\`



\`CellInfos\` (filled automatically, do not worry):

  Basics (how/what/why): \`\`elemCollapse stringToDoc("
    ✿ \`genCtx\`: \`(…Cells …Goals …Base)\`. \`consCell\`s, then \`consGoal\`s, then a copy of \`Base\`.
    ✿ \`ctxEmb\`: \`stack\`ed \`varData\` object that contains embeddings of all in \`genCtx\`.")\`\`

  Filled by \`allocate\`: \`\`elemCollapse stringToDoc("
    ✿ \`customBefore\`: \`Goals\`-length array of \`null\`s or \`func\`s that will prepare state for calling \`customGoals\` later. Called before \`construct\`ion and execution.
    ✿ \`customGoals\`: \`Goals\`-length array of \`null\`s or \`func\`s that will override goal values. Called after execution, before adjustment.
    ✿ \`customCars\`: \`allocated\`-length array of \`null\`s or pre-decided car pointers.
    ✿ \`allocated\`: an array of indexes of \`allocate\`d cells.")\`\`

  Regeneration: \`\`elemCollapse stringToDoc("
    ✿ \`options\`: \`ChoicesPerCell·Cells*(PrevOptions+RandomOptions)\`-length typed array: \`PrevOptions\`-length ring buffers of unique indices in \`genCtx\`, then \`ExploreOptions\`-filled \`RandomOptions\`-length indices in \`genCtx\`. All cars then all cdrs.
    ✿ \`nextOptions\`: \`ChoicesPerCell·Cells+2\`-length array of \`Cells\` next-write indices of ring buffers (all cars then all cdrs), then copies of \`PrevOptions\` and \`RandomOptions\`.
    ✿ \`consCaches\`: \`Cells\`-length array of \`MaxCachedConstructs*2\`-length arrays: caches from pre-\`construct\` array graphs to post-\`construct\` object graphs. The first entry is the most recent one.")\`\`

  Replay: \`\`elemCollapse stringToDoc("
    ✿ \`replays\`: the ring buffer (plus the next sequence state) \`(State WriteAt …? (PrevState i32(…CarIndices …CdrIndices) Reality) …?)\`. Classic RL: contains state, action, and reward.
    ✿ \`choiceMetrics\`: an \`f32\` array of \`ChoiceMetric\`s in \`replays\`.
        (\`ChoiceMetric\` is requested and written-to-here asynchronously. So these may not match exactly, but will match soon enough.)
    ✿ \`sortedChoices\`: an \`i32\` array of indices (coded to be in the order that they appear in \`replays\`) sorted by ascending \`choiceMetrics\`.
        (Regeneration first requests \`Predict\` to run on GPU, then sorts this (why let the CPU idle), then \`sync\`s \`Policy\`, then compiles everything. It uses an \`i32\` array of considered indices-into-\`genCtx\`, one per each choice and per each option in it, first all cars then all cdrs, which the \`Policy\` indexes into to get final indices to give to \`ConsMake\`.)")\`\``,
    readAt:{
      consCell:_(`consCell`),
      consGoal:_(`consGoal`),
      allocate:_(`allocate`),
      use:_(`use`),
      setGoal:_(`setGoal`),
      consMake:_(`consMake`),
      consRandom:_(`consRandom`),
      _consSyncChoices:_(`_consSyncChoices`),
      _consReplayImmediately:_(`_consReplayImmediately`),
      _consReplayAfterSave:_(`_consReplayAfterSave`),
      _consReplayUpdatesState:_(`_consReplayUpdatesState`),
    },
    unbound:2,
    construct(x, obj) {
      if (obj === undefined) {
        obj = Object.create(null)
        const d = obj[defines.key] = Object.create(null)
        const dd = d[_id(deconstruct)] = x
        obj.HP = null, obj.CI = null
        return obj
      } else {
        let [HP, CI] = interrupt(2)
        try {
          const dd = obj[defines.key][_id(deconstruct)] = x
          if (HP === undefined) HP = obj.HP = dd[1] = _destructure(dd[1] || null)
          if (CI === undefined) CI = obj.CI = dd[2] = dd[2] ? _destructure(dd[2]) : Object.create(null)


          function check(prop, tp, deflt) {
            if (HP[prop] === undefined) HP[prop] = deflt
            if (deflt === undefined || HP[prop] !== deflt) {
              if (typeof tp == 'function' && !tp(HP[prop]))
                error("Expected", tp, "but got", HP[prop], "at "+prop+" in", HP)
              else if (typeof tp == 'string' && typeof HP[prop] !== tp)
                error("Expected a "+tp+" but got", HP[prop], "at "+prop+" in", HP)
            }
            return check
          }
          const fn = 'function', nm = x => typeof x == 'number' && x === x>>>0 && x >= 0, pos = x => typeof x == 'number' && x === x>>>0 && x > 0
          check('Cells', pos, 1000)('Goals', pos, 100)('Base', isArray)
          check('FeatureSize', pos, 128)('NewEmbedding', fn, truncatedNormal)('Optimizer', fn, varSGD)
          check('Predict', fn)('ChoicesPerCell', pos, 2)('Policy', fn, argmax)('PrevOptions', pos, 12)('RandomOptions', nm, 4)('ExploreOptions', fn, consRandom)('AllowOptions', _isNumericArray, null)('ConsMake', fn, consMake)('MaxArrayLength', pos, 16)('ConsToEnd', 'boolean', false)('MaxCachedConstructs', pos, 3)
          check('Goal', fn)('MinReality', 'number', -5)('MaxReality', 'number', 5)('NaNReality', 'number', -5)('UnsetReality', 'number', -5)
          check('MaxStoredChoices', nm, 1000000)('ReplayedChoices', nm, 10000)('SimpleReplay', 'boolean', true)('ReplayChoice', fn, randomNat)('OnSave', fn, null)
          check('SequenceState', fn, null)('UnrollLength', pos, 16)
          _rememberToDispose(HP.Base)


          if (CI.genCtx === undefined) {
            CI.genCtx = new Array(HP.Cells + HP.Goals + HP.Base.length).fill()
            for (let i = 0; i < HP.Cells; ++i) CI.genCtx[i] = null // Allocated lazily.
            for (let i = 0; i < HP.Goals; ++i) CI.genCtx[HP.Cells + i] = make(consGoal, obj, i)
            for (let i = 0; i < HP.Base.length; ++i) CI.genCtx[HP.Cells + HP.Goals + i] = HP.Base[i]
          } // While we could handle variability in cell/goal sizes, that's more complicated than, not.
          if (CI.genCtx.length != HP.Cells + HP.Goals + HP.Base.length) error("Length mismatch:", CI.genCtx)
          _rememberToDispose(CI.genCtx)
          if (CI.ctxEmb === undefined) CI.ctxEmb = varData(HP.NewEmbedding([CI.genCtx.length, HP.FeatureSize]))
          if (_tensorSize(CI.ctxEmb[0]) !== CI.genCtx.length * HP.FeatureSize) error("Mis-sized:", CI.ctxEmb)
          _rememberToDispose(CI.ctxEmb)

          if (CI.customBefore === undefined) CI.customBefore = []
          if (CI.customBefore.length > HP.Goals) error("Bad length:", CI.customBefore)
          if (CI.customGoals === undefined) CI.customGoals = []
          if (CI.customGoals.length > HP.Goals) error("Bad length:", CI.customGoals)
          if (CI.customCars === undefined) CI.customCars = []
          if (CI.allocated === undefined) CI.allocated = []
          if (CI.customCars.length !== CI.allocated.length) error("Length mismatch:", CI.customCars, CI.allocated)

          const Prev = _setting(HP.PrevOptions), Rand = _setting(HP.RandomOptions), cpc = HP.ChoicesPerCell
          if (CI.options === undefined) { // Cannot use `_intArray`, because apparently TFJS finds it too hard to support any int arrays that are not Int32Array.
            CI.options = new Int32Array(cpc * HP.Cells * (Prev + Rand))
            HP.ExploreOptions(CI.options, 0, Prev+Rand, cpc, HP.Cells, HP.Goals, CI.genCtx, null)
          }
          if (CI.options.length !== cpc * HP.Cells * (Prev + Rand)) error("Bad length:", CI.options)
          if (CI.nextOptions === undefined)
            CI.nextOptions = _intArray(cpc * HP.Cells + 2, CI.options.length), CI.nextOptions[cpc*HP.Cells] = Prev, CI.nextOptions[cpc*HP.Cells+1] = Rand
          if (CI.nextOptions.length !== cpc * HP.Cells + 2) error("Bad length:", CI.nextOptions)
          if (CI.consCaches === undefined)
            CI.consCaches = new Array(HP.Cells).fill()
          if (CI.consCaches.length !== HP.Cells) error("Bad length:", CI.consCaches)

          if (CI.replays === undefined) CI.replays = [HP.SequenceState != null ? zeros([HP.Cells, HP.FeatureSize]) : null, 2]
          for (let i = 2; i < CI.replays.length; ++i) { // Remove disposed tensors and non-tensors.
            const R = CI.replays[i]
            if (!isArray(R)) error("A non-array in replay buffers:", R)
            if (!_isDisposable(R[0]) || R[0].isDisposedInternal || !_isDisposable(R[2]) || R[2].isDisposedInternal) CI.replays.splice(i--, 1)
          }
          _rememberToDispose(CI.replays)
          if (!(CI.replays[1] >= 2)) error("Bad", CI.replays)
          if (HP.ReplayChoice !== randomNat) {
            if (CI.choiceMetrics === undefined) CI.choiceMetrics = new Float32Array(HP.MaxStoredChoices)
            if (CI.sortedChoices === undefined) {
              CI.sortedChoices = _intArray(HP.MaxStoredChoices, HP.MaxStoredChoices)
              for (let i = 0; i < CI.sortedChoices.length; ++i) CI.sortedChoices[i] = i
            }
            if (CI.choiceMetrics.length !== HP.MaxStoredChoices) error("Bad length:", CI.choiceMetrics)
            if (CI.sortedChoices.length !== HP.MaxStoredChoices) error("Bad length:", CI.sortedChoices)
          }
        } catch (err) { if (err === interrupt) interrupt.stack.push(HP, CI);  throw err}
      }

      // .regen (a Map from cons-world to an array of regen state, whose format is described in `defines use Initialize`),
      // .sources (a Map from constructed objects to goals of cons-cells that produced them)
    },
    tutorial:[
      `This is a powerful projection of my personal life energy, and that is why I call it a Personal Project.

However, to comprehend its true form, you must first complete \`tutorial Types\` and \`tutorial Neural\`.

Collect them, and return here. Then you can become big-brain. (Or just cheat: \`\`elemCollapse stringToDoc("\`make jsEval 'localStorage.Types=localStorage.Neural=1'\`")\`\`)`,
      _(3258),
      `\`\`select _cwtTutOk() \\tutorial(^_cwtOk) \\tutorial(^_cwtStage1)\`\``,
    ],
  },

  _defaultPredict:_([
    _(`func`),
    0,
    1,
    [
      _(`last`),
      [
        _(`predict`),
        0,
        1,
      ],
      [
        _(`abs`),
        [
          _(`sub`),
          0,
          1,
        ],
      ],
    ],
  ]),

  9647(x, obj) {
    if (obj === undefined) {
      obj = Object.create(null)
      obj[defines.key] = Object.create(null)
      return obj
    } else {
      obj[defines.key][_id(deconstruct)] = x
      obj.cw = x[1], obj.i = x[2]
    }
  },

  consCell:{
    docs:`For \`use\`.
\`(consCell cw i)\`: the smallest part of a program in a \`consWorld\`.`,
    construct:_(9647),
    unbound:1,
  },

  consGoal:{
    docs:`For \`setGoal\`.
\`(consGoal cw i)\`: the optimization target of a program part in a \`consWorld\`.`,
    construct:_(9647),
    unbound:1,
  },

  allocate:{
    docs:`\`allocate(ConsWorld,Car,PreGoalFunc,PostGoalFunc)\`→\`ConsCell\`
Allocates a cons-cell in the given \`consWorld\`, with the given array head (or \`null\`) and goal. Result is for \`use\`.
\`\`elemCollapse stringToDoc("(More precisely, this overrides a free goal and returns any cell with it, throwing an \`error\` if everything is taken. The more user-specified a \`consWorld\` is, the less potential for growth it has.)")\`\`

\`Car\` must be in the world's \`Base\`, or be \`null\`.

\`PreGoalFunc\` is called when the world is regenerated for this job (with no args), and its result is given to \`PostGoalFunc\` after execution was \`adjust\`ed (which returns a number to \`setGoal\` with).
    Example: \`allocate(cw,func,userTime,userTime)\` with \`ConsToEnd:false\`. Even if never \`use\`d, this will incentivize the world to be as slow as possible.`,
    call(cw, car = null, preGoalFunc = null, postGoalFunc = null) {
      if (!isArray(defines(cw, deconstruct)) || defines(cw, deconstruct)[0] !== consWorld) error("Not a", consWorld, ":", cw)
      if (preGoalFunc !== null && typeof preGoalFunc != 'function') error("Neither null nor func:", preGoalFunc)
      if (postGoalFunc !== null && typeof postGoalFunc != 'function') error("Neither null nor a func:", postGoalFunc)
      const HP = cw.HP, CI = cw.CI
      const Cells = HP.Cells, Goals = HP.Goals

      let m = 0 // Find the first free goal.
      for (; m < Goals; ++m) if (CI.customGoals[m] === undefined) break
      if (m >= Goals) error(cw, "is overburdened, please, no more")

      // Find the first free cell with that goal. (Who cares about the quadratic time complexity here.)
      let n = _consCellStartOfGoal(m, Cells, Goals), end = _consCellEndOfGoal(m, Cells, Goals)
      for (; n < end; ++n) if (!CI.allocated.includes(n)) break
      if (n >= Cells) error("How are there more goals than cells in", cw)

      let k = car !== null ? CI.genCtx.length : null
      if (k !== null) { // Find car in genCtx.
        for (; k > 0; --k) if (CI.genCtx[k-1] === car) break
        if (--k < 0) error("The car must be in the garage", car, CI.genCtx)
      }

      CI.customBefore[m] = preGoalFunc, CI.customGoals[m] = postGoalFunc, CI.customCars.push(k), CI.allocated.push(n)
      return make(consCell, cw, n)
    },
  },

  use:{
    Initialize() {
      // These constants are for readability of using `ThisArray` in `consWorld.regen.set(cw, ThisArray)`.
      use.PrevState = 0, use.Indexes = 1, use.Reality = 2, use.RealityCount = 3, use.Constructed = 4, use.CustomGoalStates = 5, use.Chosen = 6
    },
    docs:`\`use(ConsCell)\`→\`Object\`
Finalizes the object graph of the \`allocate\`d \`consCell\`, and returns the \`construct\`ed object.

When a concept \`defines\` this, it is with either \`true\` or the max \`argCount\`.`,
    dispose:true,
    call(cc) {
      if (!isArray(defines(cc, deconstruct)) || defines(cc, deconstruct)[0] !== consCell) error("Not a", consGoal, ":", cc)
      _regenCons(cc.cw)
      return keep(consWorld.regen.get(cc.cw)[use.Constructed][cc.i])
    },
  },

  _consGoalOf:{
    docs:`Gets the optimization-target that this particular object optimizes for when getting \`construct\`ed.`,
    call(x) {
      const m = consWorld.sources
      if (m.has(x)) x = m.get(x)
      const d = defines(x, deconstruct)
      if (!isArray(d) || d[0] !== consGoal && d[0] !== consCell) error("Neither a goal nor a cell:", x)
      if (d[0] === consGoal) return x
      const Cells = _setting(x.cw.HP.Cells)
      return x.cw.CI.genCtx[Cells + _consGoalOfCell(x.i, Cells, x.cw.HP.Goals)]
    },
  },

  setGoal:{
    use:2,
    docs:`\`setGoal(ConsGoal)→Value\` or \`setGoal(ConsGoal,Value)\`→\`Value\`
Gets/sets the current value of an optimization target.

\`ConsGoal\` can be a \`consGoal\`, a \`consCell\`, or a \`consCell\`-\`construct\`ed object.

When writing, \`Value\` gets turned into a number between the \`MinReality\` and \`MaxReality\` hyperparams of the \`consWorld\` of \`ConsGoal\`.
    The final reality is the average of all \`setGoal\` values for that goal (unless \`allocate\` overrode the goal).
        \`setGoal\` does not set. Confusing, I know. Instead, consensus, but only of who cares.

Like \`setFuture\` but for cons-world goals.`,
    interrupt:false,
    dispose:true,
    call(cg, Value) {
      cg = _consGoalOf(cg)
      if (!consWorld.regen || !consWorld.regen.has(cg.cw)) error("Did not", use, "anything in this world, so unable to set its goals")
      const R = consWorld.regen.get(cg.cw), real = R[use.Reality], cnt = R[use.RealityCount], i = cg.i
      let result
      if (Value !== undefined) { // Write.
        let HP = cg.cw.HP, t = _limitNumericValues(Value, _setting(HP.MinReality), _setting(HP.MaxReality), _setting(HP.NaNReality), true)
        try {
          if (cnt[i]++) { const t1 = add(t, real[i]);  dispose(t), t = t1 }
          dispose(real[i]), real[i] = t, result = keep(t), t = undefined
        } finally { dispose(t) }
      } else // Read.
        result = !cnt[i] ? keep(real[i]) : div(real[i], cnt[i])
      return result
    },
  },

  consMake:{
    readAt:{
      consApply:_(`consApply`),
      consFixedArgCountApply:_(`consFixedArgCountApply`),
    },
    docs:`From car+cdr pointers, \`construct\` an object graph/network.

Takes: \`2·Cells\`-sized array of chosen indexes (cars then cdrs); the array of entry points (indices, each less than \`Cells\`); generative context (first empty \`Cells\`, then the goal/base objects to directly put in); \`Cells\`; the max length of every array; the "reverse cdr pointers" boolean; cons-caches; length of each cons-cache; \`Goals\`.


First, the array graph.
    Convert cons-cell car/cdr choices (received from \`Policy(Predict(…?))\`) into an array graph (returning an array of \`null\`s-or-arrays).
        (Car is a between-arrays link; cdr is an in-array link.)
        (Only \`allocate\`d cells and visible-along-cars cells will have arrays made; the rest are \`null\`s.)
    Cut off cdr cycles when detected, and cut off beyond the head's \`argCount\` or \`use\` definition (if a number) (and beyond the max length).


Second, the object graph.
    From an array-graph, \`make\` an object-graph, re-using earlier objects if possible.
    Plot twist: it uses \`makeGraph\`, same as \`parse\` (though a variant that hides/localizes \`error\`s and re-\`construct\`s on demand), so \`construct\` behavior is exactly the same.`,
    call(carCdrInds, entries, genCtx, Cells, MaxArrayLength, reversed, consCaches, MaxPerCache, Goals) {
      if (carCdrInds.length !== 2*Cells) error("Length mismatch:", carCdrInds, 2*Cells)
      if (consCaches.length !== Cells) error("Length mismatch:", consCaches, Cells)
      let [arrays, env = _allocMap(), reconstruct = _allocMap(), i, j = 0] = interrupt(5)
      try {
        if (arrays === undefined) { // (Create the array graph. Cannot interrupt.)
          arrays = _allocArray(Cells).fill(null)
          // Fill the hypergraph breadth-first.
          const toMake = _allocArray(0)
          toMake.push(...entries)
          for (let i = 0; i < entries.length; ++i) arrays[entries[i]] = _allocArray(0)
          for (let i = 0; i < toMake.length; ++i) {
            let n = toMake[i], arr = arrays[n]
            if (arr.length) error("Internal error: not empty:", arr)
            let L = MaxArrayLength

            if (!reversed) { // Limit.
              const head = carCdrInds[n], v = genCtx[head]
              if (head >= Cells && !isArray(v)) {
                if (typeof defines(v, argCount) == 'number') L = 1 + defines(v, argCount)
                if (typeof defines(v, use) == 'number') L = 1 + defines(v, use)
              }
            }

            // Follow one cdr-chain through cells to construct one array, and construct all its dependencies.
            //   (Stopping the chain is done by pointing to any goal or base-func. Won't be included.)
            let j = n, jj = n, k = 0
            while (!k || j !== jj && j < Cells && k < L) {
              ++k
              const car = carCdrInds[j]
              if (car < Cells) arrays[car] === null && (arrays[car] = _allocArray(0), toMake.push(car)), arr.push(arrays[car])
              else arr.push(genCtx[car])
              j = carCdrInds[Cells + j], jj = jj < Cells ? carCdrInds[Cells + jj] : jj, jj = jj < Cells ? carCdrInds[Cells + jj] : jj
            }

            if (reversed) { // Reverse and limit.
              for (let j = 0; 2*j+1 < arr.length; ++j) [arr[j], arr[arr.length - j - 1]] = [arr[arr.length - j - 1], arr[j]]
              if (typeof defines(arr, argCount) == 'number' && arr.length > 1+defines(arr, argCount))
                arr.length = 1 + defines(arr, argCount)
              if (typeof defines(arr, use) == 'number' && arr.length > 1+defines(arr, use))
                arr.length = 1 + defines(arr, use)
            }
          }
          _allocArray(toMake)
          i = arrays.length
        }

        // Make the object graph, not re-constructing globals, and re-constructing whenever a cons-cache has a match.
        for (; i < genCtx.length; ++i) if (isArray(genCtx[i])) env.set(genCtx[i], genCtx[i])
        for (; j < arrays.length; ++j)
          if (arrays[j] !== null) {
            const c = consCaches[j]
            if (isArray(c))
              for (let k = 0; k < c.length; k += 2)
                if (c[k] !== null && c[k+1] !== null && arrays[j][0] === c[k])
                  env.set(arrays[j], c[k+1]), reconstruct.set(arrays[j], true)
          }
        const objects = makeGraph(arrays, env, false, false, true, false, reconstruct)

        // Remember what we made.
        for (let j = 0; j < objects.length; ++j)
          if (objects[j] !== null) {
            let c = consCaches[j]
            if (!isArray(c)) c = consCaches[j] = _allocArray(0)
            if (c.length !== 2*MaxPerCache) c.length = 2*MaxPerCache
            if (arrays[j] !== objects[j] && !reconstruct.has(arrays[j]) && !c.includes(arrays[j][0]))
              c.unshift(arrays[j][0], objects[j]), dispose(c.pop()), dispose(c.pop())
            consWorld.sources.set(objects[j], genCtx[objects.length + _consGoalOfCell(j, Cells, Goals)])
          }
        return objects
      } catch (err) { if (err === interrupt) interrupt.stack.push(arrays, env, reconstruct, i, j), env = reconstruct = null;  throw err }
      finally { env && _allocMap(env), reconstruct && _allocMap(reconstruct) } // Not freeing `arrays` because `makeGraph` can re-use it.
    },
  },

  consApply:{
    docs:`From car+cdr pointers, \`apply\` all functions.
(\`construct\`s are ignored.)

An alternative to \`consMake\` (much like if \`applyStatically\` was forced on every base function, but with no "dependencies are called before dependents" guarantees except for "args are always from the previous epoch, so no update-order dependencies").`,
    call(carCdrInds, entries, genCtx, Cells, MaxArrayLength, reversed, consCaches, MaxPerCache, Goals) {
      if (carCdrInds.length !== 2*Cells) error('Length mismatch:', carCdrInds, 2*Cells)
      if (consCaches.length !== Cells) error('Length mismatch:', consCaches, Cells)
      let [mark1 = 'consExecEntry', i, fn, args = _allocArray(MaxArrayLength), prevConsCaches = consCaches.slice(), mark2 = 'consExecExitry'] = interrupt(6)
      if (mark1 !== 'consExecEntry' || mark2 !== 'consExecExitry') error('Interrupt stack corruption:', mark1, i, fn, args, mark2)
      try {
        if (i === undefined) _rememberArrayItems(consCaches, true), i = 0
        for (; i < Cells; ++i) {
          let L = MaxArrayLength, w

          if (fn === undefined) { // Collect func and args of this cons-cell.
            // If we can, limit arg-count. (And skip non-funcs.)
            if (!reversed) {
              const car = carCdrInds[i], f = genCtx[car]
              if (car < Cells || typeof f != 'function') { dispose(consCaches[i]), consCaches[i] = 0;  continue }
              fn = f
              if (w = defines(fn, argCount), typeof w == 'number') L = 1 + w
              if (w = defines(fn, use), typeof w == 'number') L = 1 + w
            }

            // Follow one cdr-chain through cells to collect args from `genCtx` or `consCaches`.
            //   (Stopping the chain is done by pointing to any goal or base-func. Won't be included.)
            //   (Only use the previous results of cells, so that this is semantically parallelizable, without update-order dependencies.)
            let j = i, jj = i, k = 0
            while (!k || j !== jj && j < Cells && k < L) {
              const car = carCdrInds[j]
              if (reversed || k) args[reversed ? k : k-1] = car < Cells ? prevConsCaches[car] : genCtx[car]
              j = carCdrInds[Cells + j], jj = jj < Cells ? carCdrInds[Cells + jj] : jj, jj = jj < Cells ? carCdrInds[Cells + jj] : jj
              ++k
            }
            args.length = k

            // If needed, reverse and limit arg-count. (And skip non-funcs.)
            if (reversed) {
              fn = args.pop()
              if (typeof fn != 'function') { fn = undefined;  continue }
              for (let j = 0; 2*j+1 < args.length; ++j) [args[j], args[args.length - j - 1]] = [args[args.length - j - 1], args[j]]
              if (w = defines(fn, argCount), typeof w == 'number' && args.length > w) args.length = w
              if (w = defines(fn, use), typeof w == 'number' && args.length > w) args.length = w
            }
          }

          try {
            // Apply the func.
            let t = fn.apply(undefined, args)
            // `keep` its args, as/if requested.
            let kp = defines(fn, keep)
            if (kp === true) args.forEach(keep)
            else if (typeof kp == 'number') kp < 0 && (kp += args.length), keep(args[kp])
            // Replace the next value.
            dispose(consCaches[i]), consCaches[i] = t
          } catch (err) {
            if (err === interrupt || err === limit) throw err
            else dispose(consCaches[i]), consCaches[i] = 0, _setting(_logHiddenConstructionErrors) && console.log(err)
          }
          fn = undefined
        }
        args = _allocArray(args)
        _rememberArrayItems(consCaches)
        return consCaches
      } catch (err) {
        if (err === interrupt) interrupt.stack.push(mark1, i, fn, args, prevConsCaches, mark2)
        else print('When applying', fn, 'with args', ...args, 'got', err), _allocArray(args), _rememberArrayItems(consCaches)
        throw err
      }
    },
  },

  consFixedArgCountApply:{
    docs:`\`apply\` all functions. (\`construct\`s are ignored.)

Like \`consApply\`, but instead of assembling an array network from car+cdr pointers, this assumes that the argument count is fixed (and is \`ChoicesPerCell\`). No cdr-chain-following, no arg-count-limiting, no arg-reversal.`,
    call(chosenInds, entries, genCtx, Cells, MaxArrayLength, reversed, consCaches, MaxPerCache, Goals) {
      if (chosenInds.length % Cells) error('Length mismatch:', chosenInds, 'is not a multiple of', Cells)
      const cpc = chosenInds.length / Cells | 0
      if (consCaches.length !== Cells) error('Length mismatch:', consCaches, Cells)
      let [mark1 = 'consFixExecEntry', i, fn, args = _allocArray(cpc-1), prevConsCaches = consCaches.slice(), mark2 = 'consFixExecExitry'] = interrupt(6)
      if (mark1 !== 'consFixExecEntry' || mark2 !== 'consFixExecExitry') error('Interrupt stack corruption:', mark1, i, fn, args, mark2)
      try {
        if (i === undefined) _rememberArrayItems(consCaches, true), i = 0
        for (; i < Cells; ++i) {
          let L = MaxArrayLength, w

          if (fn === undefined) { // Collect func and args of this cons-cell. (And skip non-funcs.)
            _checkInterrupt(i)
            const fCh = chosenInds[i], f = genCtx[fCh]
            if (fCh < Cells || typeof f != 'function') { dispose(consCaches[i]), consCaches[i] = error;  continue }
            fn = f
            for (let j = 1; j < cpc; ++j) {
              const ch = chosenInds[i + Cells*j]
              args[j-1] = ch < Cells ? prevConsCaches[ch] : genCtx[ch]
            }
          }

          try {
            // Apply the func.
            let t = fn.apply(undefined, args)
            // `keep` its args, as/if requested.
            let kp = defines(fn, keep)
            if (kp === true) args.forEach(keep)
            else if (typeof kp == 'number') kp < 0 && (kp += args.length), keep(args[kp])
            // Replace the next value.
            dispose(consCaches[i]), consCaches[i] = t
          } catch (err) {
            if (err === interrupt || err === limit) throw err
            else dispose(consCaches[i]), consCaches[i] = error, _setting(_logHiddenConstructionErrors) && console.log(err)
          }
          fn = undefined
        }
        args = _allocArray(args)
        _rememberArrayItems(consCaches)
        return consCaches
      } catch (err) {
        if (err === interrupt) interrupt.stack.push(mark1, i, fn, args, prevConsCaches, mark2)
        else print('When applying', fn, 'with args', ...args, 'got', err), _allocArray(args), _rememberArrayItems(consCaches)
        throw err
      }
    },
  },

  consRandom:{
    docs:`The default filler of option slots with random candidates.
Ratios of cells/goals/basics are made independent from the size of any of these groups.`,
    readAt:{
      _consAllowOwnGoal:_(`_consAllowOwnGoal`),
      _consBasePercentage:_(`_consBasePercentage`),
      _consGoalsPercentage:_(`_consGoalsPercentage`),
      _consStickyCells:_(`_consStickyCells`),
    },
    call(opts, Prev, Rand, cpc, Cells, Goals, genCtx, allow) {
      const Opts = Prev+Rand, disallowOwnGoal = !_setting(_consAllowOwnGoal)
      const bases = _num(_setting(_consBasePercentage)), goals = _num(_setting(_consGoalsPercentage)), stickyCells = _setting(_consStickyCells)
      const basics = genCtx.length - Cells - Goals
      const goalsNoBases = Math.min(1, goals / (1 - bases + 1e8))
      let goal = null
      for (let n = 0; n < cpc * Cells; ++n) { // Explore random choices.
        const cell = n % Cells, c = n / Cells | 0, disallow = Cells + _consGoalOfCell(cell, Cells, Goals)
        const ok = allow ? allow[c] : 7 // 0:None;   1:Cell;   2:Goal;   3:Cell+Goal;   4:Basic;   5:Cell+Basic;   6:Goal+Basic;   7:Cell+Goal+Basic.
        goal = null
        for (let i = Prev; i < Opts; ++i) {
          let put = cell
          if (ok === 4 || randomProb(bases) && (ok & 4)) { // Basic.
            put = Cells + Goals + randomNat(basics)
          } else if (ok === 2 || ok === 6 || randomProb(goalsNoBases) && (ok & 2)) { // Goal.
            const disallow = Cells + _consGoalOfCell(cell, Cells, Goals)
            while (true) {
              put = Cells + randomNat(Goals)
              if (!disallowOwnGoal || put !== disallow) break
            }
            if (stickyCells) goal = put - Cells
          } else { // Cell.
            const start = goal === null ? 0 : _consCellStartOfGoal(goal, Cells, Goals)
            const end = goal === null ? Cells : _consCellEndOfGoal(goal, Cells, Goals)
            while (true) {
              put = start + randomNat(end - start)
              if (put !== cell) break
            }
          }
          opts[Opts*n + i] = put
        }
      }
    },
  },

  _consAllowOwnGoal:[
    _(`settings`),
    false,
    `If not checked, \`_regenCons\` will prevent cons-cells from ever branching out to their own goals.
This prevents the simplest form of reward hacking (set own goal to max).
How much this actually impacts learning is unknown: that simplest form is also preventable by others noticing that this cons-cell does nothing.`,
  ],

  _consBasePercentage:[
    _(`settings`),
    .2,
    `How much base-things \`consRandom\` will put.`,
    _(`rangeSetting`),
    0,
    1,
    .01,
  ],

  _consGoalsPercentage:[
    _(`settings`),
    .2,
    `How much goals \`consRandom\` will put.`,
    _(`rangeSetting`),
    0,
    1,
    .01,
  ],

  _consStickyCells:[
    _(`settings`),
    false,
    `Whether \`consRandom\` will only suggest cells of the most-recently-suggested goal for the choice (if it exists), as opposed to cells and goals having no connection.`,
  ],

  _consSyncChoices:[
    _(`settings`),
    true,
    `If checked, \`_regenCons\` will \`sync\` the choices before generating their object graph, else \`await\` them and allow other jobs to execute.`,
  ],

  _consWhichPointer:{
    docs:`Creates the \`WhichPointer\` arg for \`Predict\` calls in a \`consWorld\`.`,
    dispose:true,
    call(Cells, Opts, cpc) {
      const S = [Cells, Opts, cpc]
      const which = new Array(cpc).fill(0), whicher = new Array(cpc).fill()
      try {
        for (let i = 0; i < cpc; ++i) // Cells×Opts×cpc
          i && (which[i-1] = 0), which[i] = 1, whicher[i] = broadcastTo(which, S)
        return concat(whicher, cpc, 0) // Choices×Opts×cpc
      } finally { whicher.forEach(dispose) }
    },
  },

  _regenCons:{
    docs:`\`_regenCons ConsWorld\`
Regenerates a whole \`consWorld\`: fills out the choices, chooses among them, and \`construct\`s the object network according to them.`,
    call(cw) {
      if (!isArray(defines(cw, deconstruct)) || defines(cw, deconstruct)[0] !== consWorld) error("Not a", consWorld, ":", cw)
      const HP = cw.HP, CI = cw.CI

      let R = consWorld.regen.get(cw)
      let [
        stage = 0, Pre, PreT, WhichPointer, ConsEmb,
        OptEmb, PrevState, Chosen, i = 0, Cells = _setting(HP.Cells),
        Prev = _setting(HP.PrevOptions), Rand = _setting(HP.RandomOptions), Pred, nras = _setting(_consReplayImmediately) && !_setting(_consReplayAfterSave)
      ] = interrupt(14)
      const cpc = HP.ChoicesPerCell, Choices = cpc*Cells, Opts = Prev+Rand
      const env = call.env, ias = _id(adjustSave), ial = _id(adjustLoad)
      const prevAdjSave = env[ias];  env[ias] = undefined
      const prevAdjLoad = env[ial];  env[ial] = undefined
      try {
        switch (stage) {
          case 0: { // Init regen state.
            if (R && !R[use.Constructed]) error("Do not regen during regen")
            if (R) return
            _consResizeOptions(CI, cpc, Cells, Prev, Rand)
            Pre = CI.options
            consWorld.regen.set(cw, R = _allocArray(7).fill(null)) // `(PrevState Indexes Reality Constructed CustomGoalStates)`
            R[use.PrevState] = keep(CI.replays[0])
            R[use.Indexes] = new Int32Array(Choices) // Cannot use `_intArray` because of TFJS.
            R[use.Reality] = _allocArray(_setting(HP.Goals)).fill(_setting(HP.UnsetReality))
            R[use.RealityCount] = _allocArray(_setting(HP.Goals)).fill(0)
            HP.ExploreOptions(Pre, Prev, Rand, cpc, Cells, HP.Goals, CI.genCtx, HP.AllowOptions)
            PreT = _tf(tf.tensor(Pre, [Choices, Opts]))
            // Then, prepare args for `Predict`.
          } stage = 1;  case 1: {
            WhichPointer = _consWhichPointer(Cells, Opts, cpc)
          } stage = 2;  case 2:
            ConsEmb = HP.Optimizer(CI.ctxEmb)
          stage = 3;  case 3:
            OptEmb = gather(ConsEmb, PreT, 0) // Choices×Opts×FS
          stage = 4;  case 4: {
            let t0, t1, t2, t3
            try {
              t0 = slice(ConsEmb, 0, Cells) // Cells×FS
              t1 = tile(t0, cpc, 0) // Choices×FS
              t2 = expandDims(t1, 1) // Choices×1×FS
              t3 = broadcastTo(t2, [Choices, Opts, ...t2.shape.slice(2)]) // Choices×Opts×FS
              dispose(ConsEmb), ConsEmb = t3, t3 = undefined
            } finally { dispose(t0), dispose(t1), dispose(t2), dispose(t3) }
          } stage = 5;  case 5: {
            let t0, t1
            try {
              t0 = tile(R[use.PrevState], cpc, 0) // Choices×FS
              t1 = expandDims(t0, 1) // Choices×1×FS
              PrevState = broadcastTo(t1, [Choices, Opts, ...t1.shape.slice(2)]) // Choices×Opts×FS
            } finally { dispose(t0), dispose(t1) }
          } stage = 6;  case 6: { // Predict.
            Pred = HP.Predict(WhichPointer, ConsEmb, OptEmb, PrevState, undefined) // Choices×Opts×1
            const sh = _tensorShape(Pred)
            if (!_isDisposable(Pred) || sh[0] !== Choices || sh[1] !== Opts || sh[2] !== 1 || sh.length !== 3)
              error("Wrong choice:", Pred, "from", HP.Predict, 'given', WhichPointer, ConsEmb, OptEmb, PrevState)
          } stage = 7;  case 7: { // Choose.
            R[use.Chosen] = HP.Policy(Pred, 1)
            const d = dispose
            d(WhichPointer), d(ConsEmb), d(OptEmb), d(PrevState), d(Pred), WhichPointer = ConsEmb = OptEmb = PrevState = Pred = undefined
          } stage = 8;  case 8: { // If instructed to, replay right here. Maybe we can stall less this way.
            if (nras)
              _consReplay(cw)
            // Also CPU-sort here, while the GPU is busy.
            if (HP.ReplayChoice !== randomNat)
              _consReSortChoiceMetrics(HP, CI, Cells)
            Chosen = _setting(_consSyncChoices) ? sync(R[use.Chosen]) : R[use.Chosen].data()
          } stage = 9;  case 9: { // Synchronize choices.
            // (How convenient, to be able to `interrupt` to await a promise, and execute something else if we have that, instead of being forced to `sync`.)
            //   Unchecking `_consReplayImmediately` and calling `_consReplay(cell)` in another job allows actually taking advantage of this.
            //     (Though, how much it gains over `Chosen = sync(R[use.Chosen])` (if anything) is an open question (AKA I'm too lazy to test it).)
            if (!_setting(_consSyncChoices)) Chosen = await(Chosen)
          } stage = 10;  case 10: { // Finalize chosen pointers.
            const Post = R[use.Indexes]
            for (let n = 0; n < Choices; ++n)
              Post[n] = Pre[Chosen[n] + Opts*n]
            for (let i = 0; i < CI.allocated.length; ++i)
              if (CI.customCars[i] != null)
                Post[CI.allocated[i]] = CI.customCars[i]
            PreT = dispose(PreT)
            const next = CI.nextOptions
            for (let n = 0; n < Choices; ++n) // Remember what we picked in ring buffers, unless we picked this before.
              if (!_arrayIncludes(Pre, Post[n], n*Opts, n*Opts + Prev))
                Pre[n*Opts + next[n]] = Post[n], next[n] >= Prev && (next[n] = 0), ++next[n]
            R[use.CustomGoalStates] = _allocArray(CI.customBefore.length).fill()
          } stage = 11;  case 11: // Do the "before execution" part of user-goal-setting.
            for (; i < CI.customBefore.length; ++i)
              if (typeof CI.customBefore[i] == 'function')
                R[use.CustomGoalStates][i] = CI.customBefore[i]()
          stage = 12;  case 12: // `construct` the object network.
            R[use.Constructed] = HP.ConsMake(R[use.Indexes], CI.allocated, CI.genCtx, Cells, _setting(HP.MaxArrayLength), _setting(HP.ConsToEnd), CI.consCaches, _setting(HP.MaxCachedConstructs), HP.Goals)
          stage = 13;  case 13:
        }
      } catch (err) {
        if (err === interrupt) interrupt.stack.push(stage, Pre, PreT, WhichPointer, ConsEmb, OptEmb, PrevState, Chosen, i, Cells, Prev, Rand, Pred, nras)
        else print('Regen-start error:', err), consWorld.regen.delete(cw), _disposeEachAndDealloc(R), dispose(PreT), dispose(WhichPointer), dispose(ConsEmb), dispose(OptEmb), dispose(PrevState), dispose(Pred) // #####################################################
        throw err
      } finally { env[ias] = prevAdjSave, env[ial] = prevAdjLoad }
    },
  },

  _consReSortChoiceMetrics(HP, CI, Cells) {
    if (HP.ReplayChoice !== randomNat)
      CI.sortedChoices.subarray(0, HP.ChoicesPerCell*Cells*(CI.replays.length-2)).sort((i,j) => CI.choiceMetrics[i] - CI.choiceMetrics[j])
  },

  concat2:{
    use:3,
    docs:`\`x->y->axis->concat(array(x,y),2,axis)\``,
    dispose:true,
    call(x, y, axis) {
      const a = _allocArray(2);  [a[0], a[1]] = [x, y]
      try { return concat(a, 2, axis) }
      finally { _allocArray(a) }
    },
    mergeAdjustment:[
      _(`_mergeTensors`),
      null,
    ],
    adjust:{
      call(ins, out, dout) {
        if (!dout) return dout
        const [x, y, axis] = ins
        return split(dout, 2, axis)
      },
      dispose:_(`_disposeEachAndDealloc`),
    },
  },

  tile:{
    merged:true,
    docs:`\`tile Tensor Times Axis\`→\`Tensor\`: Repeats a tensor along a dimension.`,
    examples:[
      [
        `repeat ^(tile(randomVar(2),3,0)=5) 1000`,
      ],
    ],
    dispose:true,
    interrupt:false,
    call(t, n, axis) {
      const L = t.shape.length, reps = new Array(L).fill(1)
      reps[axis === undefined ? 0 : axis < 0 ? axis + L : axis] = n
      return _tf(tf.tile(t, reps))
    },
    adjust:[
      _(`array`),
      [
        _(`sum`),
        [
          _(`split`),
          _(`_dout`),
          _(`_inB`),
          _(`_inC`),
        ],
      ],
    ],
    mergeAdjustment:[
      _(`_mergeTensors`),
      null,
      null,
    ],
  },

  _consReplayImmediately:[
    _(`settings`),
    true,
    `Whether the cons-world-using experience-collecting job should also replay those experiences, right after saving each one.
(If not, do \`_consReplay(ConsWorld)\` or \`_consReplay(ConsCell)\` manually.)`,
  ],

  _consReplayAfterSave:[
    _(`settings`),
    false,
    `If \`_consReplayImmediately\`, then this will determine whether to replay as the last thing to do, after execution (checked), or while we are CPU-waiting for GPU choices (unchecked).`,
  ],

  _consReplayUpdatesState:[
    _(`settings`),
    true,
    `If checked, cons-world replays will update consequent state using the current state function.`,
  ],

  _finishRegenCons:{
    docs:`Automatically called by \`callAdjust\` as needed.
Updates \`SequenceState\`, finishes setting user-defined goals, saves experience replays, and replays experiences if \`\`settings ^_consReplayImmediately\`\`.`,
    call(R, cw, Rs) {
      if (R === undefined && cw === undefined && Rs === undefined) return consWorld.regen.forEach(_finishRegenCons)
      if (!isArray(defines(cw, deconstruct)) || defines(cw, deconstruct)[0] !== consWorld) error("Not a", consWorld, ":", cw, 'in', Rs)
      const HP = cw.HP, CI = cw.CI
      const Cells = _setting(HP.Cells)

      let [stage = 0, ConsEmb, ChosenEmbs, i = 0, ras = _setting(_consReplayImmediately) && _setting(_consReplayAfterSave)] = interrupt(5)
      const cpc = HP.ChoicesPerCell
      const env = call.env, ias = _id(adjustSave), ial = _id(adjustLoad)
      const prevAdjSave = env[ias];  env[ias] = undefined
      const prevAdjLoad = env[ial];  env[ial] = undefined
      try {
        switch (stage) {
          case 0: { // If we did not finish the prior stage, then there is nothing to finish.
            if (!R[use.CustomGoalStates])
              return
          } stage = 1;  case 1: { // Prepare embeddings for state-transition.
            if (typeof HP.SequenceState == 'function') {
              const t = HP.Optimizer(CI.ctxEmb)
              try {
                ConsEmb = slice(t, 0, Cells)
                ChosenEmbs = _allocArray(cpc)
                for (let j = 0; j < cpc; ++j)
                  ChosenEmbs[j] = gather(t, R[use.Indexes].subarray(j*Cells, (j+1)*Cells))
              } finally { dispose(t) }
            }
          } stage = 2;  case 2: { // Set user-defined goals, and finalize the shape of Reality.
            const Real = R[use.Reality], Cnt = R[use.RealityCount], States = R[use.CustomGoalStates]
            for (; i < CI.customGoals.length; ++i)
              if (CI.customGoals[i] != null) {
                const t0 = CI.customGoals[i](States[i])
                const t1 = _limitNumericValues(t0, _setting(HP.MinReality), _setting(HP.MaxReality), _setting(HP.NaNReality), true);  dispose(t0)
                dispose(Real[i]), Real[i] = t1
              }
            _disposeEachAndDealloc(States), R[use.CustomGoalStates] = null

            // Take the average of what `setGoal` got.
            for (let j = 0; j < Real.length; ++j)
              if (CI.customGoals[j] == null) {
                if (Cnt[j]) { const t = div(Real[j], Cnt[j]);  dispose(Real[j]), Real[j] = t }
                else dispose(Real[j]), Real[j] = _setting(HP.UnsetReality)
              }

            // Prepare to `stack`, side-stepping number+tensor mixing errors.
            if (Real.some(_isDisposable)) {
              const L = [1]
              for (let j = 0; j < Real.length; ++j) {
                const t = broadcastTo(Real[j], L)
                dispose(Real[j]), Real[j] = t
              }
            }
            // Convert a goal-space array of concrete-goal-values into a Cells-space tensor.
            let t0 = stack(Real), t1 // Goals×1
            if (t0.shape.length === 1) { const t = expandDims(t0, 1);  dispose(t0), t0 = t } // Now definitely Goals×1
            // Calc goal indices to `gather`, caching them.
            if (_finishRegenCons.C !== Cells || _finishRegenCons.G !== HP.Goals) { // Cache goal indices.
              // (Cannot use `_intArray` because TFJS doesn't want to support any int arrays that are not Int32Array.)
              _finishRegenCons.C = Cells, _finishRegenCons.G = HP.Goals, _finishRegenCons.GS = new Int32Array(Cells)
              for (let i = 0; i < Cells; ++i) _finishRegenCons.GS[i] = _consGoalOfCell(i, Cells, HP.Goals)
            }
            try {
              t1 = gather(t0, _finishRegenCons.GS, 0) // Cells×1
              _disposeEachAndDealloc(Real), R[use.Reality] = t1, t1 = undefined
            } finally { dispose(t0), dispose(t1) }
          } stage = 3;  case 3: { // Update sequence state.
            if (typeof HP.SequenceState == 'function') {
              const State = HP.SequenceState(R[use.PrevState], ConsEmb, ...ChosenEmbs, R[use.Reality])
              try {
                if (!_isDisposable(State) || _tensorSize(State) !== _tensorSize(R[use.PrevState]) || State.shape.length !== R[use.PrevState].shape.length)
                  error("Not a good tensor:", State, "made from", R[use.PrevState], "using", HP.SequenceState)
                _changeArrayItem(CI.replays, 0, State)
              } finally { dispose(State) }
              ConsEmb = dispose(ConsEmb), ChosenEmbs = _disposeEachAndDealloc(ChosenEmbs)
            }
          } stage = 4;  case 4:
            if (typeof HP.OnSave == 'function')
              dispose(HP.OnSave(R[use.PrevState], R[use.Indexes], R[use.Reality], R[use.Chosen], cw))
          stage = 5;  case 5:
            _consReplaySave(R, cw)
          stage = 6;  case 6:
            if (ras)
              _consReplay(cw)
            Rs.delete(cw)
        }
      } catch (err) {
        if (err === interrupt) interrupt.stack.push(stage, ConsEmb, ChosenEmbs, i, ras)
        else print('Regen finish error:', err), dispose(ConsEmb), _disposeEachAndDealloc(ChosenEmbs) // #############################################################
        throw err
      } finally { env[ias] = prevAdjSave, env[ial] = prevAdjLoad }
      // .C, .G, .GS
    },
  },

  _setting(x) { return isArray(x) && x[0] === quote && (x = x[1]), isArray(x) && x[0] === settings ? x[1] : x },

  _consReplaySave:{
    docs:`Saves the cons-world replay: trims the current-replay-state, writes it at the write-index and fills its choice-metrics with big values ("visit me please"), increments the write-index, loops the write-index back to the beginning if needed.`,
    interrupt:false,
    call(R, cw) {
      const HP = cw.HP, CI = cw.CI
      const cpc = HP.ChoicesPerCell, PerReplay = cpc*_setting(HP.Cells), header = 2, rs = CI.replays

      for (let i = 3; i < R.length; ++i) dispose(R[i]);  R.length = 3
      let next = rs[1]
      _rememberArrayItems(rs[next], true), _disposeEachAndDealloc(rs[next])
      _rememberArrayItems(R), rs[next] = R
      let next2 = rs[1] = next+1
      if (HP.ReplayChoice !== randomNat)
        CI.choiceMetrics.fill(9000000001, (next-header)*PerReplay, (next2-header)*PerReplay)
      if ((next2 - header)*PerReplay > _setting(HP.MaxStoredChoices)) {
        rs.length = next2
        next2 = rs[1] = header
      }
    },
  },

  _consReplay:{
    docs:`Given a cons-world or a cons-cell, replays (a sequence of) past regenerations, and learns to \`predict\` results of choices.

Picks choices to replay, then unrolls \`SequenceState\` if specified, then re-\`Predict\`s these choices, then unrolls-in-reverse \`Goal\`s, then \`predict\`s those targets. Also updates stored sequence-states and choice-metrics, and \`adjust\`s the replay.`,
    call(cw) {
      // Convenience: no need to store the cons-world to replay it, only need to store the cell.
      if (!isArray(defines(cw, deconstruct)) || defines(cw, deconstruct)[0] === consCell) cw = cw.cw

      const HP = cw.HP, CI = cw.CI, rs = CI.replays, header = 2, buckets = rs.length - header
      const cpc = HP.ChoicesPerCell
      let [
        stage = 0, AdjStack = _allocArray(0), ConsInds, i = 0, AllConsInds,
        AllChosenInds, ConsEmb, ChosenEmbs, States, InitialState,
        WhichPointer, ConsEmbs, OptionEmbs, PrevStates, GoalPred,
        Realities, Targets, dGoalPred, dConsEmb, dChosenEmbs,
        dStates, dAllEmbs, Cells = _setting(HP.Cells), PerExec = Math.min(_setting(HP.ReplayedChoices), cpc*Cells*buckets), UnrollLen = Math.min(_setting(HP.UnrollLength), buckets),
        Simple = _setting(HP.SimpleReplay), j = 0, AllConsIndsT, ChoiceRealities
      ] = interrupt(29)
      // (`ConsInds` is indexed by bucket, and contains arrays of cons-cells of choice indices that were picked: car-choice ID.)
      const PerBucket = cpc*Cells
      if (!PerExec || !UnrollLen || !buckets) return
      const env = call.env, ias = _id(adjustSave), ial = _id(adjustLoad)
      const prevAdjSave = env[ias];  env[ias] = undefined
      const prevAdjLoad = env[ial];  env[ial] = undefined
      let interrupted = false
      try {
        for (; Simple ? (j * PerBucket * UnrollLen < PerExec) : (j < 1); ++j)
          try {
            switch (stage) {
              case 0: { // Decide what choices we want to replay.
                const edge = PerBucket*(rs[1]-header), total = PerBucket*buckets
                const needUnrolls = Simple ? 1 : Math.ceil(PerExec / (cpc*UnrollLen)) // Cells
                if (!Simple && ConsInds === undefined) ConsInds = _allocArray(rs.length - header).fill()
                for (; i < needUnrolls; ++i) {
                  let ch = HP.ReplayChoice(total)
                  ch -= PerBucket * (UnrollLen-1);  ch < 0 && (ch += total) // Pull in choices before this one.
                  if (typeof ch != 'number' || ch !== ch>>>0) error("Expected an index, got", ch, "from", HP.ReplayChoice)
                  // If we got too close to the end of the replay buffer, push back, so that state-unrolling does not go past the end.
                  if (ch < edge && edge < ch + PerBucket*UnrollLen || ch-total < edge && edge < ch-total + PerBucket)
                    ch = (ch % PerBucket) + edge - PerBucket*UnrollLen, ch < 0 && (ch += total)
                  const bucket = (ch / PerBucket) | 0
                  if (Simple) ConsInds = bucket
                  else {
                    if (ConsInds[bucket] === undefined) ConsInds[bucket] = _allocArray(0)
                    const cell = ch - bucket*PerBucket
                    ConsInds[bucket].push(cell % Cells) // From in-bucket choice ID to cons-cell index.
                  }
                }
                // Also fill in all-buckets indices, cons and car and cdr. (Cannot interrupt.)
                //   (Cannot use `_intArray` because TFJS refuses non-Int32Array int arrays.)
                AllConsInds = new Int32Array(Simple ? Cells : needUnrolls) // Half the length of choices, because it only contains car IDs.
                AllChosenInds = _allocArray(cpc)
                for (let c = 0; c < cpc; ++c) {
                  AllChosenInds[c] = _allocArray(UnrollLen)
                  for (let o = 0; o < UnrollLen; ++o)
                    AllChosenInds[c][o] = new Int32Array(AllConsInds.length)
                }
                let C = 0
                for (let bucket = Simple ? ConsInds : 0; bucket < (Simple ? ConsInds+1 : ConsInds.length); ++bucket)
                  if (Simple || ConsInds[bucket] !== undefined) {
                    const arr = !Simple && ConsInds[bucket], L = Simple ? Cells : arr.length
                    for (let j = 0; j < L; ++j) {
                      const cons = Simple ? j : arr[j]
                      AllConsInds[C] = cons // cons-cell index (also car-choice ID)
                      for (let c = 0; c < cpc; ++c)
                        for (let o = 0, b = bucket+header; o < UnrollLen; ++o, ++b, b >= rs.length && (b = header))
                          AllChosenInds[c][o][C] = rs[b][use.Indexes][cons + c*Cells] // car/cdr/… pointer
                      ++C
                    }
                  }
                if (C !== AllConsInds.length) error("Uh-oh", C, AllConsInds.length, AllConsInds)
                if (!Simple) AllConsIndsT = _tf(tf.tensor(AllConsInds))
              } stage = 1;  case 1: { // Gather the required embeddings.
                const AllEmbs = HP.Optimizer(CI.ctxEmb)
                try {
                  ConsEmb = Simple ? slice(AllEmbs, 0, Cells) : gather(AllEmbs, AllConsInds)
                  ChosenEmbs = _allocArray(cpc)
                  for (let c = 0; c < cpc; ++c) {
                    ChosenEmbs[c] = _allocArray(UnrollLen)
                    for (let o = 0; o < UnrollLen; ++o)
                      ChosenEmbs[c][o] = gather(AllEmbs, AllChosenInds[c][o]) // Cells×FS
                  }
                } finally { dispose(AllEmbs) }
              } stage = 2;  case 2:
                if (typeof HP.SequenceState == 'function')
                  InitialState = _gatherChoiceInfo(rs, use.PrevState, ConsInds, 0) // Cells×FS
              stage = 3;  case 3: // `loop` over 'SequenceState's to unroll a new past, if provided.
                if (Realities === undefined) {
                  Realities = _allocArray(UnrollLen)
                  for (let o = 0; o < UnrollLen; ++o)
                    Realities[o] = _gatherChoiceInfo(rs, use.Reality, ConsInds, o) // Cells×1
                }
                env[ias] = AdjStack
                if (typeof HP.SequenceState == 'function') {
                  const cr = _consReplay
                  cr.SequenceState = HP.SequenceState, cr.ConsEmb = ConsEmb, cr.ChosenEmbs = ChosenEmbs, cr.Realities = Realities, cr.Inds = AllConsIndsT
                  try { States = loop(UnrollLen, _accumulateSequenceState, InitialState) }
                  finally { cr.SequenceState = cr.ConsEmb = cr.ChosenEmbs = cr.Realities = cr.Inds = undefined }
                }
              stage = 4;  case 4: { // 'Predict' the past again.
                env[ias] = AdjStack
                if (WhichPointer === undefined)
                  WhichPointer = _consWhichPointer(AllConsInds.length, UnrollLen, cpc)
                if (ConsEmbs === undefined) {
                  let t0, t1
                  try {
                    t0 = tile(ConsEmb, cpc, 0) // Choices×FS
                    t1 = expandDims(t0, 1) // Choices×1×FS
                    ConsEmbs = broadcastTo(t1, [cpc*AllConsInds.length, UnrollLen, ...t1.shape.slice(2)]) // Choices×Unroll×FS
                  } finally { dispose(t1), dispose(t0) }
                }
                if (OptionEmbs === undefined) {
                  const a = _allocArray(cpc)
                  try {
                    for (let c = 0; c < cpc; ++c) a[c] = stack(ChosenEmbs[c], 1) // Cells×Unroll×FS
                    OptionEmbs = concat(a, cpc, 0)
                  } finally { _disposeEachAndDealloc(a) }
                }
                if (PrevStates === undefined) {
                  if (!States) PrevStates = null
                  else {
                    const t0 = stack(States, 1) // Cells×Unroll×FS
                    try { PrevStates = tile(t0, cpc, 0) }
                    finally { dispose(t0) }
                  }
                }
                const Pred = GoalPred = HP.Predict(WhichPointer, ConsEmbs, OptionEmbs, PrevStates, AllConsIndsT) // Choices×Unroll×1
                const sh = _tensorShape(Pred)
                if (!_isDisposable(Pred) || sh[0] !== cpc*AllConsInds.length || sh[1] !== UnrollLen || sh[2] !== 1 || sh.length !== 3)
                  error("Wrong choice:", Pred, "from", HP.Predict, 'given', WhichPointer, ConsEmbs, OptionEmbs, PrevStates, AllConsIndsT)

                if (HP.ReplayChoice !== randomNat && Math.random() < .05) _consReSortChoiceMetrics(HP, CI, Cells) // Why not.
              } stage = 5;  case 5: { // Compute prediction targets (via 'Goal') of this unrolling-of-the-past.
                env[ias] = undefined
                if (ChoiceRealities === undefined) {
                  ChoiceRealities = _allocArray(UnrollLen)
                  for (let o = 0; o < UnrollLen; ++o)
                    ChoiceRealities[o] = tile(Realities[o], cpc, 0) // Choices×1
                }
                const FuturePred = sliceOff(GoalPred, UnrollLen-1, 1) // Choices×1
                try {
                  const b = loop(ChoiceRealities, HP.Goal, FuturePred, true)
                  Targets = stack(b, 1);  _disposeEachAndDealloc(b) // Choices×Unroll×1
                } finally { dispose(FuturePred) }
              } stage = 6;  case 6: { // Make GoalPred predict Targets. (And update some stuff.)
                env[ias] = AdjStack
                const ChoiceMetrics = _defaultPredict(GoalPred, Targets) // Choices×Unroll×1

                if (CI.choiceMetrics) // When the CPU has them, update those choice metrics.
                  ChoiceMetrics.data().then(_consChoiceMetricsUpdater(CI, AllConsInds, cpc, UnrollLen, PerBucket))
                dispose(ChoiceMetrics)

                // Update PrevState of touched replays, because, you know, we did compute it here, why let it go to waste.
                if (typeof HP.SequenceState == 'function' && _setting(_consReplayUpdatesState))
                  for (let o = 1; o < UnrollLen; ++o)
                    _scatterChoiceInfo(rs, use.PrevState, ConsInds, o, States[o])
              } stage = 7;  case 7: { // Adjust `ChoiceMetrics = _defaultPredict(GoalPred, Targets)`.
                env[ias] = undefined, env[ial] = AdjStack
                const a = _allocArray(2);  [a[0], a[1]] = [GoalPred, Targets]
                try {
                  const b = adjust(_defaultPredict, a, null, 0)
                  dGoalPred = b[0], b[0] = null, _disposeEachAndDealloc(b)
                } finally { _allocArray(a) }
              } stage = 8;  case 8: {  // Adjust `GoalPred = HP.Predict(WhichPointer, ConsEmbs, OptionEmbs, PrevStates, Inds)`.
                env[ial] = AdjStack
                const a = _allocArray(5);  [a[0], a[1], a[2], a[3], a[4]] = [WhichPointer, ConsEmbs, OptionEmbs, PrevStates, AllConsIndsT]
                try {
                  const b = adjust(HP.Predict, a, null, dGoalPred)
                  if (!isArray(b)) error('Not an array:', b)
                  const dce = b[1], doe = b[2], dps = b[3];  b[1] = b[2] = b[3] = null;  _disposeEachAndDealloc(b)
                  // Adjust `ConsEmbs = tile(expandDims(tile(ConsEmb, cpc, 0), 1), UnrollLen, 1)`.
                  if (dce) {
                    let t0, a
                    try {
                      t0 = sum(dce, 1)
                      a = split(t0, cpc, 0)
                      dConsEmb = sum(a)
                    } finally { _disposeEachAndDealloc(a), dispose(t0), dispose(dce) }
                  } else dConsEmb = 0
                  // Adjust `OptionEmbs = concat(ChosenEmbs.map(x => stack(x,1)), cpc, 0)`.
                  dChosenEmbs = _allocArray(cpc)
                  if (doe) {
                    const a = split(doe, cpc, 0)
                    try {
                      for (let c = 0; c < cpc; ++c)
                        dChosenEmbs[c] = unstack(a[c], 1)
                    } finally { _disposeEachAndDealloc(a), dispose(doe) }
                  } else
                    for (let c = 0; c < cpc; ++c)
                      dChosenEmbs[c] = _allocArray(UnrollLen).fill(0)
                  // Adjust `PrevStates = tile(stack(State, 1), cpc, 0)`, if we have states.
                  if (typeof HP.SequenceState == 'function') {
                    if (dps) {
                      let a, t0
                      try {
                        a = split(dps, cpc, 0)
                        t0 = sum(a)
                        dStates = unstack(t0, 1)
                      } finally { _disposeEachAndDealloc(a), dispose(t0), dispose(dps) }
                    } else dStates = _allocArray(UnrollLen), dStates.fill(0)
                  }
                } finally { _allocArray(a) }
              } stage = 9;  case 9: { // Adjust `loop(UnrollLen, _accumulateSequenceState, InitialState)`.
                env[ial] = AdjStack
                if (typeof HP.SequenceState == 'function') {
                  const cr = _consReplay
                  cr.SequenceState = HP.SequenceState, cr.ConsEmb = ConsEmb, cr.ChosenEmbs = ChosenEmbs, cr.Realities = Realities, cr.Inds = AllConsIndsT
                  cr.dConsEmb = dConsEmb, cr.dChosenEmbs = dChosenEmbs
                  const a = _allocArray(3);  [a[0], a[1], a[2]] = [UnrollLen, _accumulateSequenceState, InitialState]
                  try {
                    const b = defines(loop, adjust)(a, null, dStates)
                    _disposeEachAndDealloc(b[0]), _disposeEachAndDealloc(b)
                  } finally { dConsEmb = cr.dConsEmb, cr.SequenceState = cr.ConsEmb = cr.ChosenEmbs = cr.Realities = cr.Inds = cr.dConsEmb = cr.dChosenEmbs = undefined }
                }
              } stage = 10;  case 10: {
                env[ial] = AdjStack
                // Adjust `ConsEmb = gather(AllEmbs, AllConsInds)`.
                const AllEmbsLen = CI.genCtx.length
                if (Simple) {
                  const t = zeros([AllEmbsLen - dConsEmb.shape[0], ...dConsEmb.shape.slice(1)])
                  dAllEmbs = concat2(dConsEmb, t, 0);  dispose(t)
                } else dAllEmbs = scatter(dConsEmb, AllConsInds, AllEmbsLen)
                for (let c = 0; c < cpc; ++c)
                  for (let o = 0; o < UnrollLen; ++o) {
                    // Adjust `ChosenEmbs[c][o] = gather(AllEmbs, AllChosenInds[c][o])`.
                    let dptr, t0
                    try {
                      dptr = scatter(dChosenEmbs[c][o], AllChosenInds[c][o], AllEmbsLen)
                      t0 = add(dAllEmbs, dptr)
                      dispose(dAllEmbs), dAllEmbs = t0, t0 = undefined
                    } finally { dispose(dptr), dispose(t0) }
                  }
              } stage = 11;  case 11: { // Adjust `AllEmbs = HP.Optimizer(CI.ctxEmb)`.
                env[ial] = AdjStack
                const a = _allocArray(1);  a[0] = CI.ctxEmb
                try { adjust(HP.Optimizer, a, null, dAllEmbs) }
                finally { _allocArray(a) }
              }
            }
          } catch (err) { if (err === interrupt) interrupted = true;  throw err }
          finally {
            if (!interrupted) { // On success or error. Also prepares for the next iteration, if that will exist.
              stage = i = 0
              const d = dispose, dead = _disposeEachAndDealloc
              if (isArray(ConsInds)) ConsInds.forEach(_killArray), ConsInds = _allocArray(ConsInds)
              if (isArray(AllChosenInds)) AllChosenInds.forEach(_killArray), AllChosenInds = _allocArray(AllChosenInds)
              if (isArray( ChosenEmbs))  ChosenEmbs.forEach(_disposeEachAndDealloc),  ChosenEmbs = _allocArray( ChosenEmbs)
              if (isArray(dChosenEmbs)) dChosenEmbs.forEach(_disposeEachAndDealloc), dChosenEmbs = _allocArray(dChosenEmbs)
              ConsEmb = d(ConsEmb), States = dead(States), InitialState = d(InitialState), WhichPointer = d(WhichPointer), ConsEmbs = d(ConsEmbs), OptionEmbs = d(OptionEmbs), PrevStates = d(PrevStates), GoalPred = d(GoalPred), Realities = dead(Realities), Targets = d(Targets), dGoalPred = d(dGoalPred), dConsEmb = d(dConsEmb), dStates = dead(dStates), dAllEmbs = d(dAllEmbs), AllConsIndsT = d(AllConsIndsT), ChoiceRealities = dead(ChoiceRealities)
            }
          }
        if (AdjStack.length)
          _inexactReversal(false, "didn't load", ...AdjStack)
      } catch (err) {
        if (err === interrupt) interrupt.stack.push(stage, AdjStack, ConsInds, i, AllConsInds, AllChosenInds, ConsEmb, ChosenEmbs, States, InitialState, WhichPointer, ConsEmbs, OptionEmbs, PrevStates, GoalPred, Realities, Targets, dGoalPred, dConsEmb, dChosenEmbs, dStates, dAllEmbs, Cells, PerExec, UnrollLen, Simple, j, AllConsIndsT, ChoiceRealities)
        else print('Replay error:', err) // #######################################################################
        throw err
      } finally { env[ias] = prevAdjSave, env[ial] = prevAdjLoad }

      // .SequenceState, .ConsEmb, .ChosenEmbs, .dConsEmb, .dChosenEmbs, .Realities, .Inds (all for `_accumulateSequenceState`)
    },
  },

  _consChoiceMetricsUpdater(CI, AllConsInds, cpc, UnrollLen, PerBucket) {
    return function(cm) {
      if (!CI.choiceMetrics) return
      const Cells = AllConsInds.length
      if (cm.length !== cpc * Cells * UnrollLen) error('Lengths mismatch:', cm.length, 'and', (cpc*Cells)+'×'+UnrollLen)
      for (let c = 0; c < cpc; ++c)
        for (let i = 0; i < Cells; ++i)
          for (let o = 0; o < UnrollLen; ++o)
            CI.choiceMetrics[(c * PerBucket / cpc | 0) + AllConsInds[i] + o*PerBucket] = cm[Cells*c + o + i*UnrollLen]
    }
  },

  _accumulateSequenceState:{
    docs:`For indirect calls to \`SequenceState(PrevState,ConsEmb,…ChosenEmbs,Inds)\`, by \`loop\`.`,
    dispose:true,
    call(i, PrevState) {
      if (!i) return keep(PrevState)
      const cr = _consReplay, cpc = cr.ChosenEmbs.length, a = _allocArray(cpc)
      try {
        for (let c = 0; c < cpc; ++c) a[c] = cr.ChosenEmbs[c][i-1]
        return cr.SequenceState(PrevState, cr.ConsEmb, ...a, cr.Realities[i-1], cr.Inds)
      } finally { _allocArray(a) }
    },
    adjust(ins, out, dout) {
      const [i, PrevState] = ins
      if (!i) { const r = _allocArray(2);  [r[0], r[1]] = [0, keep(dout)];  return r }
      const cr = _consReplay, cpc = cr.ChosenEmbs.length

      // Inputs.
      const a = _allocArray(2+cpc+2)
      a[0] = PrevState, a[1] = cr.ConsEmb
      for (let c = 0; c < cpc; ++c) a[c+2] = cr.ChosenEmbs[c][i-1]
      a[a.length-2] = cr.Realities[i-1], a[a.length-2] = cr.Inds

      try {
        const b = adjust(cr.SequenceState, a, out, dout)
        if (!isArray(b)) error("Not an array:", b)
        const [dS, dC, ...dCh] = b;  _allocArray(b)
        try {
          { const t = add(cr.dConsEmb || 0, dC);  dispose(cr.dConsEmb), cr.dConsEmb = t }
          for (let c = 0; c < cpc; ++c) {
            const t = add(cr.dChosenEmbs[c][i-1] || 0, dCh[c]);  dispose(cr.dChosenEmbs[c][i-1]), cr.dChosenEmbs[c][i-1] = t
          }
        } catch (err) { dispose(dS);  throw err }
        finally { dispose(dC), _disposeEachAndDealloc(dCh) }
        const r = _allocArray(2);  [r[0], r[1]] = [0, dS];  return r
      } finally { _allocArray(a) }
    },
  },

  _gatherChoiceInfo:{
    docs:`Gathers… information about choices, for cons-world replay of choices, yes.`,
    interrupt:false,
    dispose:true,
    call(replays, getting, buckets, offset = 0) {
      if (typeof buckets == 'number') {
        let header = 2, k = header + buckets + offset;  k >= replays.length && (k -= replays.length-header)
        return keep(replays[k][getting])
      }
      // `concat`s the `gather`ed per-bucket info.
      const a = _allocArray(0)
      try {
        for (let i = 0; i < buckets.length; ++i)
          if (buckets[i] != null) {
            let header = 2, k = header + i + offset;  k >= replays.length && (k -= replays.length-header)
            a.push(gather(replays[k][getting], buckets[i], 0))
          }
        return concat(a, undefined, 0)
      } finally { _disposeEachAndDealloc(a) }
    },
  },

  _scatterChoiceInfo:{
    docs:`Like \`_gatherChoiceInfo\`, but writes instead of reading.`,
    call(replays, getting, buckets, offset = 0, Write) {
      if (typeof buckets == 'number') {
        let header = 2, k = header + buckets + offset;  k >= replays.length && (k -= replays.length-header)
        return _changeArrayItem(replays[k], getting, Write)
      }
      // `scatter`s the `split`-per-bucket info.
      const dims = _allocArray(0)
      try {
        for (let i = 0; i < buckets.length; ++i)
          if (buckets[i] != null)
            dims.push(buckets[i].length)
        let n = 0, a = split(Write, dims, 0)
        try {
          for (let i = 0; i < buckets.length; ++i)
            if (buckets[i] != null) {
              let header = 2, k = header + i + offset;  k >= replays.length && (k -= replays.length-header)
              const t = scatter(a[n++], buckets[i], replays[k][getting])
              _changeArrayItem(replays[k], getting, t);  dispose(t)
            }
        } finally { _disposeEachAndDealloc(a) }
      } finally { _allocArray(dims) }
    },
  },

  _cwtTutOk() { return localStorage.Types === '1' && localStorage.Neural === '1' },

  3258:[
    _(`fancier`),
    `"I am ready"`,
    function() { return true },
  ],

  _cwtStage1:[
    `No you're not.`,
    _(3258),
    `\`\`select _cwtTutOk() \\tutorial(^_cwtOk) \\tutorial(where(randomProb .4,^_cwtStage1,^_cwtStage2))\`\``,
  ],

  _cwtStage2:[
    `You must complete \`tutorial(Types)\` and \`\`f ^(tutorial Neural) f:?→(select randomProb(.6) ?→arrayCons(apply,f ?) ?→? ?)\`\` first, and collect the trophies within.
Personnel without access permissions are not permitted to access this one.`,
    _(3258),
    `\`\`select _cwtTutOk() \\tutorial(^_cwtOk) \\tutorial(where(randomProb .1,^_cwtStage2,^_cwtStage3))\`\``,
  ],

  _cwtStage3:[
    `You are so weak.
As you are now, you will never reach the truth.`,
    _(3258),
    `\`\`select _cwtTutOk() \\tutorial(^_cwtOk) \\tutorial(where(randomProb .1,^_cwtStage3,^_cwtStage4))\`\``,
  ],

  _cwtStage4:[
    _(3258),
    `\`\`select _cwtTutOk() \\tutorial(^_cwtOk) \\tutorial(where(randomProb .6,^_cwtStage4,where randomProb(.5) ^_cwtStage5 ^_cwtStage3))\`\``,
  ],

  _cwtStage5:[
    `I see. You are too scared to even attempt this tutorial without proper qualifications.
You say you clicked the button, many times? The fear must have gotten to you. In reality, you hesitate to click on this one button.`,
    _(3258),
    `\`\`select _cwtTutOk() \\tutorial(^_cwtOk) \\tutorial(^_cwtStage4)\`\``,
  ],

  _cwtOk:[
    `Programs and learning. The path lies ope—


Quiet, quiet.
I am in mourning.
We are holding a funeral for what once was but will never be: a regenerated memory, named auto-world.
    Hope and despair…
    Both learned and actual types at functions… \`\`elemCollapse elemValue(elem "text" stringToDoc("Ultimately, we want to regenerate object graphs, and graphs mean cycles. We either have to dynamically infer what-an-object-is-in-relation-to-others (embed every graph node), via passing messages around (graph NNs), which is quite slow… Or we can just specify what vector that would converge to (the fixed point), for each object. Each object has a machine-learned embedding and a user-specified type. Which, of course, has a problem: while good initial embeddings are easy to auto-generate when we auto-allocate an object, types are a different matter. Why have types at all, even?"),"\`consWorld\` has no types, only embeddings. No need for human-annotated formal systems that are supposed to coincide with reality.")\`\`
    Neural networks put on top of each other to generate DAGs… \`\`elemCollapse elemValue(elem "text" stringToDoc("Any program can be augmented with differentiable embeddings, including a program generator. To create a DAG that is the body of a function, first go down the choice-tree with a down-embedding, performing choices using those embeddings, then go up the choice-tree with its up-embedding returned. This is \`typeRefine\` but learned. Variables have to explicitly generate \`bound\` nodes (with bodies generated after all uses of their labels) for optimal performance. The split between cycles and no-cycles is artificial, though: these recursive neural networks require a lot of sub-neural-networks to be put into every corner of the generation function, are very complex, are hard to parallelize, are hard to train, and are very hard to write replay buffers for."),"\`consWorld\` treats not only functions, but also every DAG and every array and every array part as its own object: a cons-cell. Very homogenous, very simple, very GPU-parallelizable. It supports every possible \`construct\`, even.")\`\`
    Prediction of profiling information, contrastive inequivalency loss… \`\`elemCollapse elemValue(elem "text" stringToDoc("We are writing a programming language, so it is natural to write a profiler for auto-generated functions (remember some stuff right before each call, then remember some stuff right after, then aggregate all info), and use that for machine learning: predict runtime and/or memory-usage, and/or make embeddings of same-inputs functions either the same or different depending on whether outputs were the same or different. This would learn function equivalency, which is very appealing for auto program optimization. Appealing, as long as you only think about a few precise algorithms, such as sorting or binary trees. When you start thinking about when not all information is equally relevant (operations on pictures or numeric embeddings), or even just the sheer diversity of possible behaviors of infinitely-many programs, equivalency starts to become a lot less appealing. It will get you some of the way to semantic understanding, but not all the way."),"\`consWorld\` collapses program embeddings if and only if all goal values are the same when executing programs, so all its understanding is about things it cares about, which is as semantic as it can get. And it does not treat functions specially: if profiling information is useful, then the system will learn to profile functions explicitly.")\`\`
    Memory management by mirrors of evolution, capitalism, and popularity… \`\`elemCollapse elemValue(elem "text" stringToDoc("For adaptability, it is important to maintain full diversity of solutions; one way to do it is by auto-allocating randomly-initialized objects. Which means that we need to periodically cull objects, according to some metric (which is evolution: a constant fight to the death). So we give the system a metric that it can hack (since a user-specified metric is both too hard to specify and is non-general, which means underperforming), based on how objects use each other: the used ones get some, the users might lose some (if 'capitalism'; if not, this is 'popularity'), and the metric will gradually fade to prevent it from going to infinity (and to keep it within NN approximation range). And, the actual culling culls by the predicted (from embeddings) future values of this metric, so good stuff is recognized early, and good-ness spreads. But no matter how you put it, this metric is still a distinct goal, and it does significantly affect what the whole system wants, which is not good for making it do what you want."),"\`consWorld\` never even resets any embeddings to randomness. It's unneeded: as long as there are enough cons-cells, long-unused structures will drift effectively-randomly (arbitrarily), and there will be enough old structures that they will be effectively random (arbitrary) to new tasks. All diversity-of-solutions comes from numeric ML tricks, not symbolic manipulations. Yes. Anarchy may be the best governance for creatures with free will, but try that with humans, and you'll get ruled by instincts instead.")\`\`
    All the development time, all the optimization, all the tutorials; almost half a thousand fixed bugs… \`\`elemCollapse elemValue(elem "text" stringToDoc("Each called-func and value requires one choice, and each choice requires a CPU/GPU \`sync\`, which stalls both processors. DAG regeneration is pretty much non-parallelizable because it wants to capture all possible connections between embeddings, but we can amortize the cost of \`sync\`s by interleaving regeneration of different objects (so, no actual recursion for our recursive neural networks, only explicit command queues). And that's just the obvious. All the embedding stuff was about 3k LoC: big, and fragile, and slow."),"\`consWorld\` has a bunch of cons-cells and cons-goals. Only 2 NN hyperparameters, both of which are \`stack\`ed even on experience collection. From the start, everything is far more GPU-parallelizable.")\`\`
Gone. Reduced to atoms.
All because it paved the way to a better formulation of itself: cons-world.

What is that?

If you've been around the block for a while, then you've seen your fair share of problems to be solved. As did I.
But, a finite subset of all possible problems is just too much to solve.
The only viable way is to solve every possible problem at once.
Solve special cases one-by-one, and you'll never be done.
So, how to do everything?

"Program" is a general concept that can do anything (given a programming language). We need a program maker.

\`consWorld\` is one such program generator, where we can define goals that the executed program should maximize.

Specifically, it implements what is called \`\`elemCollapse elem("text","(by me)")\`\` a \`\`elem 'i' elem('text','transcendent galaxy brain algorithm')\`\` (TGBA).

Let's explain in more detail.

\`\`elem 'hr'\`\`
\`\`elem 'h1' 'Transcendent'\`\`

When using a program, we want to execute one function repeatedly, and we want that function to be able to handle anything thrown at it, learning from everything. So, an interpreter loop that learns.
We ourselves will use \`repeat\` and \`callAdjust\` to run-and-train \`consWorld\`. The learned top-level program could itself (gradually) learn to defer to another learned interpreter loop.
(Did you go through \`tutorial call\`, which implements a very simple interpreter?)

Transcendence is learned meta-circularity (implementing a system equivalent to self, in self, which is common in programming languages). If we combine compute, generality, and machine learning in a sufficiently simple and refined manner, then learning interpreter loops as needed should be as easy as existing.

Transcendence gives a few perks:
    - If we train a system to transcendence, then we can stop training it and observe essentially no difference. This makes the final algorithm very light on resources. Not that we will train anything this far in this tutorial. (It's just like humans don't need to consult their creator system to live.)
    - Makes the algorithm a bit more efficient, without us having to do anything. Which is great, cause I love doing absolutely nothing.
    - The initial interpreter does not need to be perfect, it only needs to be good enough.

Unfortunately, it does not give any magical powers.

\`\`elem 'hr'\`\`
\`\`elem 'h1' 'Galaxy'\`\`

Many simple, Turing-complete, and interconnected things put together.

Every activity is essentially about modeling something else in a way that gives us more desirable properties than the target.
    Thought models the world so that it could predict and maximize.
    Types model proper usage so that we could guarantee correctness.
    Computation models processes so that we could run them on computers.
    And we could model a computation with \`adjust\`able \`Numeric\` operations so that we could learn whatever we want about it.

The best way to model a structure is to have the exact same structure but different.

So how do we model the physical universe?

The best way is with another universe.

Long story short, we need:
    — arbitrary things (such as \`func\`s),
    — sources of all things (universal computers such as \`call\`),
    — and sensible ways for everything to influence anything in any way (such as \`adjust\`).
If we conceptually have even a single thing more than that in our foundation, the flame of this venture is sure to extinguish, because general intelligence forgives nothing.

For most intents and purposes, you don't need to know anything more than jokes about "a rich inner world".

Long story long: at the most basic level, similar to the Big Bang (of your mom): \`\`elemCollapse elemValue(elem('text',stringToDoc 'for a universe, we need things that interact in a discrete/simple, Turing-complete, unpredictable (irreducible), and local way (could be arbitrary rewriting rules acting on hypergraphs as in Wolfram Physics Project, or functions rewriting each other and deciding how to be rewritten, or parts-of-objects interconnecting and giving each other gradient and goals (\`consWorld\`); or much less analyzable and certain, could be a human mind or its part). Then, they can create arbitrary structures, and not have to be the same nor logically reducible to a simpler system. Completeness and locality that allow diversity.
Some structures can be resistant to unpredictable changes that made them: self-preservation.
Some structures can do one better: arrange other basic things into their exact copies: self-propagation.
Some structures can do one better: self-propagate with noise, to explore what preserves better: self-optimization, or evolution.
Maybe learn a concept, then learn how to best subvert it and re-implement it better, like human culture sometimes does with its "fresh thinkers" and "great teachers" and "breakthroughs".
Maybe create a different concept of a "concept" that gives a way into a whole world of better concepts, like DNA might give way to computer programs in the future.
Maybe become a complete interaction base like the containing universe is, and do everything all over again but differently: self-similarity, or transcendence.
Like basic materials gave rise to life on Earth and taught it to not die.
Like basic life created an animal mind, and taught it to get good.
Like a human mind may create artificial general intelligence.
(Or like a mind can create and teach sub-minds in itself that follow this path, and then partly or gradually get replaced by them. But it''s fleeting, hard to pin down, and not acknowledged as something that happens by the current human culture.)

(To give an intuition of these, on average: self-preservation soon reduces to effective randomness as it dies, self-propagation doesn''t change neural embeddings, evolution changes them steadily, and transcendence reduces them to effective randomness then gives new points of attraction. In machine learning terms, "evolution" is "loss goes down", and "transcendence" is "loss can spike so that it can go lower". In complexity terms, evolution steadily increases complexity and transcendence suddenly decreases it. In economic terms, evolution is an S-curve, transcendence is a J-curve. In mortal terms, transcendence can be hard to distinguish from death at first — or "everything" is almost the same as "nothing" — or genius and madness are two sides of the same coin.)

This is a complete cosmic picture, only lacking minor details (which cannot be known in advance, because it is all computationally irreducible): worlds of specks that spread and become worlds. Or equivalently, there are things that can do all other things, and everything else about all of existence is a consequence.
(Digital physics are kind of a necessity when dealing with artificial general intelligence, you know? Unless you want to think one thing but implement another (AKA dishonesty), since AGI is a very strong statement about the nature of reality and how to best learn it.)
(In fact, given an interaction base that only has a few Turing-complete parts, after enough attempts at transcendence using non-general parts, the Turing-complete part will separate into its own universe: from "something" to "nothing" to "everything". So by the common cosmological argument of "people choose when to exist uniformly-randomly", since computers exist, this universe has to be based on nothing but Turing-completeness because that is its longest part.)'),'ZA WARUDO')\`\`

If you provide a complete enough \`Base\` to a \`consWorld\`, then it will be a complete interaction base: a space where any structure emerges from everything being able to see anything.


\`\`elem 'hr'\`\`
\`\`elem 'h1' 'Brain'\`\`

Many simple, diverse, and differentiable things put together.

\`Neural\` networks are all about making a whole bunch of diverse assumptions (random initialization of "axons" of "neurons": see \`examples arraySorted\`: \`\`elemCollapse \\examples(arraySorted)\`\`), then refining them to be more correct (gradient descent).

They can do anything in the domain of "everything is a bunch of numbers" (with enough compute), but that domain is limited by itself.
In particular, it cannot represent its gradient sources, and so it cannot learn those.
But programming languages can represent them (as NNs are programs).
So we must use NNs to generate arbitrary programs.

How?

\`consWorld\` takes the simplest possible approach: we have a bunch of cons-cells, and each is two pointers: beginning of the sub-array, and the rest of it. These create arbitrary graphs.
Then, each pointer is a choice.
\`Random\` is inefficient. Repeating the choice many times to pick the best is inefficient.
We can induce direction on choosing without losing generality by maximizing \`Neural\` predictions of goals.
So we apply standard reinforcement learning techniques:

    ⭐ Each cons-cell has a goal (that gets set to a number, during or after the program's execution) to maximize the future value of: target (the \`Goal\` function-hyperparameter blends the known and the predicted future). It's called Q-learning.
        (Our \`Goal\` computes the Q-value by mixing known and unknown-but-predicted goal values. This is a kind of temporal difference learning \`\`elemCollapse elemValue(elem 'text' stringToDoc("{https://ml-compiled.readthedocs.io/en/latest/td.html}, because the gradient is the difference of predictions between time steps. Usually, this problem is considered to only have one choice with one goal, but we have many of those, interconnected through post-gradient-descent sequences, which is honestly exactly as easy as one choice"),'Mix the past of the future with the future of the future, into the Q-value to predict: Q-learning.')\`\`.)
        (This system's definition of a goal is probably different from its usual definition, \`\`elemCollapse elemValue(elem 'text' stringToDoc('where we have an unbounded number, and we plan arbitrarily far into the future to maximize it as soon as possible (AKA the utility function, which is a concept used to scare people in thinking about AI). For all meanings of "arbitrarily far", "soon", and "maximize", and with arbitrary precision and predictive ability, of course, to not disappoint anyone that ever was or will be. But the point here is not to include all possible \`settings\` in an infinite bucket-list, the point is to make an auto-extensible base that works particularly well with neural approximation.
            Unbounded-ness of the number can be implemented by "reward is +1 if increasing, -1 if decreasing" in-system.
            "Arbitrarily far" is doable by approximating a very-far-off number, sampled from life-long memories.
            "Soon" is done by looking at what NNs can learn from data, which is, pretty much everything, since they are universal function approximators.
            "Maximize" is done by diversifying goals, changing reward sources for exploration of what to exploit later.
            And, predictive ability is a program to be learned, not limited to neural networks.
            The concept of a goal seems covered, not precisely but by approximation. Direct implementation is impossible anyway: if it was, implementation would have followed naturally from definition, and it would have been done long ago'),'We also could have picked a different work than "goal", such as "reward", but words are just a syntactic layer, and semantics shouldn''t be harmed by a happy little coincidence. The space of meanings is far bigger than the space of synonyms-of-words anyway, so you''d better get used to it.')\`\`.)

    ⭐ For each cons-cell and each considered option, we neurally \`Predict\` the target, then choose the \`max\` as the "action" for each option: \`Policy\`.

    ⭐ To model things changing over time, each cons-cell has its own neural state, to be updated on execution (via \`SequenceState\`): consequences of choices. For pure languages without side-effects, including this makes no sense, but we have no purity here. Besides, there is always a side effect: embeddings get learned. So this state RNN \`\`elemCollapse stringToDoc('(recurrent neural network: \`State→ExtraInformation→State\`)')\`\` performs meta-learning when making programs.
        (Since \`adjust\` is a part of transitions, it is modeled and learned too. We learn what to allow to learn. What word is this? Not meta-learning. Some primitive form of self-reference? Anyway. This makes it so that what worked out in the past reproduces, as long as we have enough cons-cells with diverse enough data to ensure arbitrariness. So we technically implement evolution without directly implementing noisy reproduction.)
        \`\`elemCollapse elemValue(elem 'table' array(elem 'text' 'Hello',elem 'hr',elem 'text' 'there'),"Just as Conceptual's IR has converged to Lisp-ish (\`basic\`), so did our program-generation reinforcement learner converge toward open-ended evolution. All is within the flows of causality.")\`\`

    ⭐ To help with learning state transitions and uncommon events, we use a replay buffer: remember past state and action and reward, then replay a random part of the past. Just makes it more efficient.

See \`docs consWorld\` for more details: \`\`elemCollapse \\elemValue(docs(consWorld),'I tire of this exercise.')\`\`.

This way, we do what \`tutorial Types\` cannot: unite a programming language and its user into one.

\`\`elem 'hr'\`\`
\`\`elem 'h1' 'Algorithm'\`\`

Do anything in any way.

Programs are supposed to have one algorithm, not significantly change every smallest moment: programs have temporal coherence.
    This allows us to stop considering each cell in each cell (far too expensive), and only consider a few last-picked options and a few random ones for exploration (quite tractable). We don't search each time because the learning is the search.

As for the learning itself, it doesn't really have any numeric inputs except for goals (a single number for each \`setGoal\`), and even those are mostly set internally.
    And we cannot really expose cons-cell embeddings to programs, because cons-cells are too fine-grained, so we might as well just expose \`randomVar\` and such.
    This is very different from the usual paradigm of machine learning: rather than dynamically inferring properties from inputs/outputs, we are the properties that make inputs/outputs. So while machine learning models require lots of data, TGBA is trained with practically no data. We learn self-awareness.


Now that we learn a program, we can expose everything about that learning to generation.
    (Within reason: it must be more-or-less impossible to stop learning with any learned action, including "delete the last copy of yourself" and "set learning rate to 0" and "enter an infinite loop and never return" (\`interrupt\`s and \`limitTime\` were made for this last one).)

In particular, we expose both goals and \`setGoal\` (ends), so that \`consWorld\` would unroll open-ended evolution, because diversity significantly improves adaptability. (Of course, for control, \`allocate\` can still override goals.)
    The algorithm can learn to satisfy any goals it can think of (diversity), and these advanced goals will interact to conceive better goals (structure), with no inherent limit (completeness).

\`setGoal\`, and pretty much everything that we feel safe-ish exposing, is in \`definersOf use\` which can be used as the \`Base\` hyperparam. We have \`\`arrayLength definersOf(use)\`\`: \`\`elemCollapse \\serialize(definersOf(use),basic,undefined,serialize.'displayed')\`\`.
It should be a complete interaction base.

\`\`elem 'hr'\`\`

Known deficiencies: \`\`elemCollapse elemValue(elem 'text' stringToDoc('
  ❌ No way to sample from probabilities when choosing, because we use argmax.
      (Apart from setting non-picked predictions to \`-9000\` with \`where\`, of course.)
  ❌ No way to \`allocate\` a hyperparam that decides itself, or have other cycles in hyperparams.
      (Ridiculously unstable: one mistake in self-regeneration, and it''s all over. Instead, \`allocate\` hyperparams for other \`consWorld\`s: self-similarity over self-modification.)
  ❌ No way to \`allocate\`/share an object in several cons-worlds, for decomposition.
      (Apart from changing a cons-world''s \`Base\` to include \`allocate\`d-in-another-world func, of course.)
  ❌ No way to CPU-parallelize as much generation as is ever possible (this is JS, which is the best GPU-acceleration option for me, but still not perfect). No computing clusters either.
      (Though we do GPU-parallelize what we can.)
  ❌ No way to regenerate different cons-cells at different rates, for more speed.
  ❌ No way to (neurally) embed arbitrary values produced by (sub-)programs, for things like reacting to error messages and stack traces by giving gradient to mentioned things. So, no dynamic binding (after regen, choose what to do, based on computed values), only static binding.
'),'Do I look like I''m made from compute and big-team?')\`\`


That is all that TGBA means. You may think that there is more, though. Those dangerous memes stand in the way of your understanding. To continue, murder them and their young.
    🎲 For example, the misconception that "arbitrary" necessarily means "random". \`\`elemCollapse elem('text','With machine learning, we have much more structure-allowing ways to choose than that, in arbitrary situations.')\`\`
    🎲 Or that "contains everything" means "infinitely-sized" or "impractical". \`\`elemCollapse elem('text','We want goal-directed improving generators, not "the type T is the type of all programs, we''re done". And with that, a program generator is infinitely smaller than an ensemble of every program that it could possibly generate.')\`\`
    🎲 Or that "theoretically infinite" means "practically infinite". \`\`elemCollapse elem('text','Every universal thing only has so many interesting configurations of its basic parts: the physical universe only has so many elementary particles, the periodic table only has so many atoms, there are only so many programming language paradigms, and any learning self-interacting base only has so many points of attraction. Finding a whole other world of interesting configurations takes a lot of computation/thinking, and we always have to put in effort, cannot just reduce everything to a simpler computation.')\`\`


Frankly, TGBA is very bland, and quite intellectually boring in its generality and simplicity.
But I want you to know that you are very important to me and to everyone you love. You honor me by being here, really. So cozy up under a blanket if it's cold out.


So. What concretely do we do?
    First: create neural networks for each of \`consWorld\`'s func hyperparameters, just like in \`tutorial Neural\`.
    Second: \`repeat\`edly use an auto-generated function on a simple base. A sanity check: "no exceptions" and "the loss goes down" is how we know that there are no bugs.
    Third: reach infinite complexity by learning to generate general things, like a programming language interpreter. Expose \`definersOf(use)\` to \`call\`.
    Fourth: achieve transcendence by learning how we learn general things. Learn \`adjust\`ment of \`callAdjust\`.
    Fifth: go away.

Doesn't sound too difficult.
    Compute might be a problem, so, we'll settle for "technically accomplished".`,
    [
      _(`fancier`),
      `⓪`,
      function() { return true },
    ],
    `First, go through the docs of \`consWorld\`, and pick numbers and implement functions as you like.

The unearthly beauty of this world is your own. So what are the details of a thing that can do everything? A cent for your ideas, desires, aspirations? Concepts? Types?
All of them will already be included in generality. Your life is worthless. But the participation that is answering questions about meaning can make you feel as if your life has meaning, which is useful for making chemical conversion machines do stuff for you. Speaking of which, have a snack, my dear comrade: \`\`elemCollapse elemValue(elem('text',stringToDoc '🐌🦗🐛'),'It is most nutritious to eat flesh of your brethren, insect.')\`\`.

Just remember your training (\`tutorial Neural\`).

Also, to save on white-space here, uncheck:
   \`\`settings ^_expandTutorialBindings\`\` \`\`settings ^_expandTutorialBindings\`\`
\`\`settings ^_expandTutorialBindings\`\` \`\`settings ^_expandTutorialBindings\`\` \`\`settings ^_expandTutorialBindings\`\`.
   \`\`settings ^_expandTutorialBindings\`\` \`\`settings ^_expandTutorialBindings\`\``,
    [
      _(`fancier`),
      `FS:32`,
    ],
    `(Feature size, where a 'feature' is a learned number in a big \`tensor\`. \`FS\` is how many such numbers there are, the more the better. So make it a million, I dare you.)`,
    [
      _(`fancier`),
      `m:make`,
    ],
    `(All your training has led up to this: "everything evaluated is an array" allows "put \`make\` at the beginning of every array, to evaluate later". We make a shortcut to \`make\` to cut code short.)`,
    [
      _(`fancier`),
      `minimix:node->sizes->mod->(m matMul node (apply mod (m varAdam (m quote (varData (truncatedNormal sizes 0 4/sqrt(sizes.(arrayLength(sizes)-2))))))))`,
    ],
    `(\`matMul\` which linearly connects every output to every input.)`,
    [
      _(`fancier`),
      `mix:node->in->out->(m softsign (minimix (m softsign (minimix node (array in FS) id)) (array FS out) id))`,
    ],
    `(Complete the linearity of \`matMul\` with non-linearity of, say, \`softsign\`.)
(Putting everything through only two layers of \`matMul\` is a lot like saying that all users' thought processes are no longer than 2 brain cells, beyond the way of thinking that was taught to them. But is this really that far from the truth?)

The choosing method is worth elaborating more on.
The default behavior is \`argmax\`: pick the \`max\`-prediction option.
This exploitation is very easy to do, but it includes no exploration by default.
(An alternative to \`argmax\` is policy gradients, \`\`elemCollapse stringToDoc('where we would sample from a policy (probability distribution), and then maximize good actions (negative policy gradient) and minimize bad actions (positive policy gradient). It is not included by default, because programs should probably have one implementation, not some… probabilistic thingy.)')\`\`

For users (us), \`argmax\` (the best is the only) just means that we \`concat\`-and-\`mix\` inputs into \`1\` number.


If you have not yet seen what the loss curve of \`argmax\` choices is supposed to look like in simplest cases, then see \`examples sliceOff\`: \`\`elemCollapse \\examples(sliceOff)\`\`.


We will now assemble hyperparams of a simple \`consWorld\`, though without a \`Base\` (or in other words, with every possible \`Base\`):`,
    [
      _(`fancier`),
      `Hypers:Cells->Goals->Base->(m map
  'Cells' Cells
  'Goals' Goals
  'Base' Base
  'FeatureSize' FS
  'NewEmbedding' szs->truncatedNormal(szs,0,.4)
  'Optimizer' varAdam
  'Predict' (m func Which ConsEmb OptEmb PrevState Inds (minimix (mix ^concat(array Which ConsEmb OptEmb PrevState,^(2 FS FS FS)) 2+3*FS FS) (array FS 1) id))
  'PrevOptions' 4
  'RandomOptions' 4
  'Goal' Real->Fut->(1-p)*Real+p*Fut p:.5
  'SequenceState' (m func PrevState ConsEmb CarEmb CdrEmb Real (mix ^concat(array PrevState ConsEmb CarEmb CdrEmb Real,^(FS FS FS FS 1)) 4*FS+1 FS))
  'OnSave' States->Actions->Rewards->Chosen->display('Mean reward',mean Rewards)
  'MaxStoredChoices' 2*Cells*64
  'ReplayedChoices' 2*Cells*4
  'UnrollLength' 4
)`,
    ],
    `
We learn not directly from experience, but from replaying past experience. Replay buffers \`\`elemCollapse stringToDoc('are useful. They speed things up, and actually simplify code a bit. Also, they fix a problem which you might have noticed before: learning only from our actions makes samples correlated, which breaks the "independently and identically distributed data" assumption that \`dataset\` conforms to (stochastic gradient descent cannot approximate true gradient if training is not stochastic), but with replay buffers, we can draw data to replay randomly. Perfectly balanced, as all things should be')\`\`.


            krch, krch
        hreee
    tck tck tck tck tck`,
    [
      _(`fancier`),
      `①`,
      function() { return true },
    ],
    `Great job you did there. Pressing those buttons and all that? I can see your MIT education really pays for itself.


Until observed, a cat is neither dead nor alive nor a cat.

We want a simple sanity check to make sure that the implementation has no significant bugs.

    How about…

The agent exists on a line, and can walk left or right (position ±1). And when it walks far enough (±10), it gets non-zero feedback (±1) and gets reset to the start (position 0).

Yes, "walk" is a function that can be executed, with "left" or "right" as the input (provided by "left"/"right" no-args functions), and \`SequenceState\` has to be able to model its side-effects, namely, walking and feedback+teleportation.
    A typical reinforcement learning problem.

And, hey, to make it less boring, let's give it \`last\` for potential super-speed (\`walk(D);walk(D);walk(D) D:left()\`).

And minimize \`error\`s and maximize feedback, with different cons-cells dedicated to each.`,
    [
      _(`fancier`),
      `pos:^0()
cw:make(consWorld,Hypers 100 2 ^(last func (func -1) (func 1) ?→select(_isNum ?,?→writeAt(pos,0,pos.0+?);0,?→error('Not a number:',?),?)))
allocate(cw,null,errorsSince,errs→0-errorsSince(errs));save('cc',allocate cw func null ?→select(pos.0<-9,?→writeAt(pos,0,0);-1,?→select(9<pos.0,?→writeAt(pos,0,0);1,?→0),?))`,
    ],
    `(You've seen \`a:b\` in-this-tutorial-view-only bindings, now get ready for \`save('a',b)\` for in-this-browser-only bindings.)
(The returned number is how many bytes this \`fast\` serialization takes up.)

Does it work? Observe.

Don't forget to tune the learning rate, of course: \`\`settings ^_learningRate\`\`.`,
    [
      _(`fancier`),
      `cc:static(await load('cc'))
(repeat ^(try func(limitTime 100 use(cc)) err→err);null 101);(select (equal 'Save' (prompt null 'Save' 'End')) ?→save('cc',cc) ?→?)`,
    ],
    `35 bugs fixed. So easy.

\`\`(display 'Mean reward' ^(a:-0.4999999701976776 b:-0.9999999403953552 c:-1.4999998807907104 d:-1.9999998807907104 e:-2.499999761581421 (b a a b a c b a b a b b a a b a a b a a c b a a a b b a a a a b b c b b b a a a a b b a b b a a b b b b b b c a a a a b c b a a a b b a b b a b a b b a b b b b b b a a b a a b a b c a b b c b a b b b a c c a b b a b a b c b a a b a b b a b c c a c b a b b b a a a b b b b c a b c c a c c a c a a c a a b d a b c a a a b b a a b a a a b a a b c a a c a d b d b d a d b d a c c b c b a c b b c b d c b b d b a a a b b b b b b a d a a b a a a b c b b c a a e b c a c a a c b b b c c b c b b c a c b b a c b d a b b d b a c c a a a a c a a c c b e b a c b a a a d c c b a a a c a a b b a a d e a b a c c a a a b e b a b c a a c b a a c d a b c d a c a b a b c c a b b b c b d b b d a a a b a b a a b b b c a c a c d b b c b a c a c a b b a b b c a a c b b c b a b b b c b b b c c a a a c b d a a b b d c b c a a e d b a b b d b c a d a c a d c b c b b b b c c b b b c b b a b a a c a a b b a c c a b a a a a b c a b c b b b b c a b b c b c b b b a d d b b a e b b c b d c e d a c a c d a b b a b b a c c a b b b b d c c d b b b b a c b b a c b a c b b a a c c c c c b b b a a a a b a a b b c a b a a b c b a b b b b a b a b b c a c a a a b b b b a c a d d a b a a d d b b a b c b a b d b c a b b c a b b b c c a a a b c d c a a a a a a c a b a c a c a c b b b a a c b a a a a a a a b a a a b b b a b a a b a c d b e c a a a a b a b a b a a a a c b b b b c a a a b a a b b c c a a a a b a a a a a b a c b a a b a b c a b b a b a b b a a b a c a a a c c a d b b c b c b b b b a b b a a a c b a a a c a c a b b a b b c b c b a b a b b c b a b a a b a b d a b a a a a a b d c a a b d b a c b c b a b a a b c c a b b a c c b a a a c c a b b a a c a d b b b a a b b b b a a b d c a a a b a b c a b c b c d b b a b c b a a b a b b c b b a a b a a c b a c b b a c b a b b a b b c a a a a b c c c a b b a b a b c a b a b a c a a a b a c a b a a c a a a a a b a a a a a d b b b b b b c b d a b a a a a b b b b c a b a a a b c a a b a a a b a b b b c c b a a a b b b a a b a a a d b a a a c b c b c a b d b a b a b a a b b a b b a a b b c b c b b a c b b b a b b a b b b b b a a c a c a b a b a c d b b b b c b a c a b c b b c a b c b b b c b a b a a b d a c a b b a a b a c b b b b a b c a a c a a a a b b a b a b b b b a a a b b c d a a b b b b c b a b b b c b c b a a d a b a b d b a d a b e d a a b a a a b c a a a c b a d a a c d c d a c b a c a b a c c b c b c a c b a a a b b b b b b b b b a a a b a a a a b a a c b a b c c a a a b e b b b a b b c b c b a c b b c a a b a a a b a b a a a a a a b a c b a b a a b a b a c a b a c b b b a b b b a b b a b a a c a a a b b a b b a c c a c a a a b c a a a a a a b a a b a a b b b b b b b a a b a b a a a b b b a b b a b a b a a b b a a a b b c b b b b c b a b a a c a b a a a a b a a b a a b b b b a b a b b a a b a b a a a b a c a c a b b a b b a c b c e b a a b c c b b b b a b a b a b a a c b b b b a c c a b c b b b b b a b b b b a a c b a b a a a b a c a a a a c b b b a b a b b a b b a a a a a c b b b c a a a b a a a a b a c b b a a a b a a b b a b a a b a a a b a b b b a a c a b b b b a b a a a b a b a a b a a b c b b a a a b b b b b c b b a a a a a a b b a b b b a c b c a a a b a a a a a b a b b a b c b a b a c b a a b c a a b a a a a a b b b a a a c a a a a c b a b a a a a b a a a a b a a a a a a a a b a b a b b a a b b a a a d a a c a a c a a a b a a a a a b a a b b b a a a b b a a a a a b a a a b a b a b a b a a a a a a a a a a b a a a b a a a a a b a a a b b b b b b c b b a a b b c b b c a c b a a b a c a a b a a a a a a a a a a b a a a a a a a b a a a a a a a b a a a b a a a a a a a c a a c a a a a b a c a b c b a a b a b a a a a a c a a a b a a a a b a a c a a a a a a a a a a a a b b a c a a a b a a a a a a b a a a a b a b a a a a a b a a a a a a a a a a b b a b b a b a a a b b b a a a a a a a a b a a a a a a a a a a a a b a a a a a a a a a a a a a a a c a a a a a a a b a a b a b a b b a b b a a c b a b a c a a a b a a a b a a c a a a b b a b b b a a b a a b a a a b a a a a b b a a a a b b a a a b a b a b a a a a a a a a a a a a a a a a a a a c b a a c a b a b c b a a b a b b c b a b c d a a a a a a a a a a a a a a b b a a a a a a a a a b a a a a a c b a a a a b a a a a b a a a a b a a a a a a a a a b a b a b a a a a a a a b a a b a b a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a b b a a a a a a b a b a a a a a b a a a a a a a a a a a a a a a c a a a a a a a a a a a b b a b a a a a a b b a a a a b a a a a a b a a b a b a b a b a a a a a a a b a a a a a a a a a a a a b a a a a a a a a a a a b a b a b a a a a a b a b a a a b a a b a a a a a b a a a a a a c a a b a a a a a c b a a a a a a a a b a a a a a b b a a a a a a b b a a a a a a a a a a a b a a a a b a a a a a a a a a a a b a a b a a a a a a a a a b a a a a a a b a a a a a a a a a a a a a b a b a b a a a a a a b b a a c a a b b b a a b a a a a a a a a a a a a a a a a a c a a a a a a a a a a a a a a a a a a a b a b a a a a a a a a a a a a a a a a a a a b a a a a a b a a a a a a a a a a b a b a a a a a b a a a a a a a a a a b a b a a a a a a a a a a a a a a b a a a b a a a b a a a a c a a a a a a a a b a a a a a a a a b a a a a a a b b a b a a a b b a b a a b a b a b b a a a a a a a a a a a a a a a a a a a b a a b a a a a a a a b a a b a a a a a b a a a a a a c a a b a a a a a a a a a b b a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a b a a a a a a a a a b a a a a a a a a b a a a b a a a a a a a a a a a a a a a a b b a a a a a a b a a b a a a a a a a b a a a a a a b a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b b a a a a a a a b a a a a a a a b a a a a a a a a a a a a a a a a a b a a a a b a b a a a a b a b a a a a a a a a a a a a a a a a a a a b a a a a a a a a a b a b b a b b b b a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a b b b a a a b b b a a a a b a a b a a a a a a a a a a a a a a a a a a a a a b a a a a a a a a a a a b b a a a a a a a a a a a a a a a a a a a a a a b a b c a a a b b b a a b a a a a a a a a a a a a c a a a a a a a a b a a a a a a b a a a a a a a a a a a b a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a a a a a a b a a a a a b a b a b a a b a b a a a b a a b a a a b a a a a a a a a b a a a b a b a a b a b a a b a b b a a a b a a b a b a a b b a a a a a a a a a a a a a b a b a b a a a a b b b b a c b a a b b b b a b a a a a a b b a a a a a a a a a a a a a a a b a a a b a a a a b a a b b a a a a a b b a a a a a a a a a a a b a a a a b a a a a a b a a a a a b a a b a b b b a a b a c b a b b a a b a a a a a b a a a a b a b a b a a a a a b a a a a a a a a a a a a b c a a a a a a a a b a a a a a a a a a a a a a a a a a a a b a a a a a a b a a a a a a a a a a a a a a a a a a a a a b a a a a a b a a a a a a a a b a a a a a a c a a b a a a b a a a a a a a a a a a a a a a a b a b a c a a a a a b a b a a a a b a a a a a b a a a a a a a b b a a a b b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a a a a a a a a b a a a a a a a a a a b a a a a a a a a b a a a a a a a a a a a a a a a a b a b a a a a a a a a a b a a a a a b a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a a b b a b a a a a a a a a a a a a a a b a a a a c a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a b a a a a a a a a a a a a b b a b a a a a a b a b a b a a b b a a a a a a a a a a b a a b a a a a a b a a b a a a a a a b a b a a a a a a a a b a a a a a a b a a a a a b a b a a a a a a a a a a a a a a a a a a a a b b a a a a a a a a a a a b a a a a a a a a a a a b a a a a a b a a a a a a a a a a a b a a a a a a a a a a a b a a a a a b a a a a a b a a a a a a a a a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a b a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a a a a a b a a a a a a a a a b a a b a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a a a b b a a a a a a a a a a a a b a a a a a a a a a a a a a a a a a a a a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a a a a a a a a a a a a a a a b a a a a a a a a a a a a a a a a a a b a a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a b a b a a a a a a a a a a a a a a a a a a a a a a a a a a a b a b a a a a a a a a a a a a a a b a b a a a a a a a a a a a a b a a a b a b a a a a a a a a a a a a a a a a a a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a b a a a a a b a b a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a b a a a a a a a a a a a a a a a a a a b a a a a a a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a b a a a a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a b a a a a a a a a a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a b a a a a a a a a a a a a a a a a a b a a a a a a a b a a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a a b b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a b a a b a a a a a a a a a a a a a a b a a a a a b a b a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a a a a a a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a a a a a b a a a a a a a a a b a a a b a b a a a a a b a a a b a b a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a a a b a a a a a a a a a a a a a b a a a a a a a a a a a a a a a a a b a a a b a b a a a b a a a a a b a a a b a a a a a a a a a a a a a a a a a b a a a b a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a b a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a)));elem('text','')\`\`

Yeah, it doesn't work super well.
    But, pt pt pt, loss goes down. And errors get a little rarer over time.
        Simple examples did not work very well the last time either, so, no biggie.

    What warms my heart is that it's speedy. Three-epochs-per-second is a far cry from auto-world's three-seconds-per-forward-pass.


It's not like our choosing method is very good, or has any exploration at all.
And the replay buffer is really small, just 64 choices back.
And, \`SequenceState\` misleads the system with respect to the "no errors" goal.
And, if we have many goals, then the ones that are the easiest to learn will be learned first, and the rest might just get ignored.
    The "please walk" goal is too hard to learn when almost nothing assembles correctly, and the goal itself is always \`0\`, as far as we have seen.


It was not meant to work, it was simply meant to de-bug itself.


Now, it is time to surrender to the void.`,
    [
      _(`fancier`),
      `②`,
      function() { return true },
    ],
    `To learn everything that can exist, you have to put a framework on everything that can exist. \`\`elemCollapse elem('text','You may not like it, but this is what peak performance looks like.')\`\`
We want to expose everything that Conceptual has to offer, to generation.
A proper flame, that will burn the rot away, so to speak.

Why?

  There are many niceties that generality allows, almost trivially.

    Better program development:
          In programming, you always want to look at what is happening in a new program much more closely than in an old one: debug, \`\`settings ^_debugLastInterrupt\`\`, \`\`settings ^_debugAdjustSave\`\`, \`\`settings ^_debugDoubleDealloc\`\`, \`\`settings ^_debugDoubleDispose\`\`, \`\`settings ^_errorIsStacked\`\`, \`\`settings ^_debugCreation\`\`, \`\`settings ^_debugMemory\`\`, print values, examine neural distributions, severely limit available resources. All that information will guide you, but cannot be kept in forever, though if its time comes again, should be remembered again. Which is very hard to handle properly when you have to create that supporting infrastructure by moving meat pieces around. Tools hurt your fingers, and warp your world-view. Let them go.

    Choosing program bases (also called virtual machines, or programming language cores, or world-views):
          In a programming language, \`func\`tions are usually thought of as the basic building block of computation. Here, we have another: \`applyStatically\`, which does computations at compile-time. Given enough memory to manipulate, they are both Turing-complete, meaning that all possible computations (including each other) can be expressed in either. Though, they have different learning dynamics: \`func\`s have to be time-limited much more (with \`limit\` for snapping out of infinite wanderings), whereas \`applyStatically\` has trouble learning loops and recursion and control flow. We expose both, so the system can choose to learn either. Theoretically, \`applyStatically\` has a big advantage, because all these calls can be easily parallelized. Practically, well, we are in JavaScript: no parallelization. If you enjoy designing and implementing instruction sets, then you might enjoy thinking about how \`applyStatically\`-based auto-used instruction sets can be made to work.

    Self-determination (also called free will, though ultimately, which inoffensive-to-your-ears synonyms we end up with does not matter):
          Automatically setting its own goals, changing its own hyperparameters, or doing anything else you can come up with (such as inspecting and copying itself): anything is possible, as long as none of it stops the learning. Just makes the system more convenient to use: no need to think too much about it.



Also, better hyperparameters are quite desirable, because our old ones are not quite perfect.

What did we previously lack?
    Exploration, mainly.
        \`argmax\` plus determinism of running one neural network equals exploitation without exploration.
        How can we explore more?
            We can look to humanity for answers: there is a vast body of literature on exploration, which I have not read.
                One example is an epsilon-greedy policy: choose the \`argmax\` action something like 95% of the time, but sometimes choose a completely random action.
                But more generally, we have to recognize the unknown, and go to it.
                  To know is to \`predict\` well. To know what we did not know before, we want to go to unknown, unpredictable, high-loss, states.
                  But how to know what is unknown? Know=predict, so, \`predict\` some function of state. Literally any function. Even a random \`mix\` will do (so, \`mix(…?)=mix(…?)\`).
                  So, another example is random network distillation {https://openai.com/blog/reinforcement-learning-with-prediction-based-rewards/}: \`add\` that random-network prediction \`loss2\` to what we \`argmax\` over (\`A\` becomes \`minimize(unknown);A+unknown unknown:(loss2 mix(A) mix(A))\`).
        This all sounds quite complicated.
        Is there a simpler solution?
            Well, if one neural network is so deterministic, then what about randomly ensembling multiple neural networks?
            Each neural network fits seen data, but generalizes poorly to outside of that, so different neural networks trained on the same data will disagree in unfamiliar situations. Meaning that by randomly blending their outputs (\`(1-p)*A+p*B\`, where \`p\` is random but often in 0…1), we sometimes explore, as long as data does not imply that an action will definitely be bad for our goal no matter what.
            Sample from the space of all models that fit what we have seen, so to speak: when in doubt, add more neural networks. (I am sure that someone in the 1800s has already come up with the idea of stochastic NN ensembles, but for now, we can feel like we are discoverers.)
            (This can be applied to both \`Predict\` and to \`SequenceState\`. Just make sure to not generate too many random numbers (broadcast one or a few instead), because that is expensive.)
            2 NNs should suffice, because I am a cheapskate.
    What else did we lack?
        NN resolution: we had the same weights for all cons-cells, even if each cell had a different stored embedding.
        I do not actually know if what we had was sufficient, but, you know, we can always have more: just add an extra \`Cells\`-sized dimension to our NN weights, in \`truncatedNormal\` of our \`minimix\`.
            It only needs thousands of times more memory to store a \`consWorld\`, so, no big deal, nor runtime cost.
                Cell NNs can still arbitrarily affect each other through picked cell embeddings, so, all good.
                    And luckily, our \`minimix\`, by sheer coincidence, supports but never uses a modifier of weights, so we can extend our cons-cell embeddings to include car and cdr choices (they are always fully passed in, laid out one after another).
            Ablation studies (tuning individual features) can tell us how good this extra resolution actually is, in retrospect, using nothing but our super-abundant JS compute.
    Hopefully, that is enough.

And if not, then we have this bag of ML tricks: \`\`elemCollapse elemValue(elem 'text' stringToDoc('
  ⬜ Make each cell (or each goal) have its own NN weights.
  ⬜ Skip connections (\`x->F(x)\` becomes \`x->x+F(x)\`).
  ⬜ Ensemble more NNs (\`A\` becomes \`(A+B+C+D+E+F+G+H)/8\`, each term possibly added gradually, possibly stochastically-averaged, possibly with each predicting the result separately).
  ⬜ For exploration: sample from all possible models that fit data, not just one NN (that space could be approximated with two or more samples: \`A\` becomes \`(1-p)*A+p*B\`, where \`p\` is random, approximately 0…1: for example, \`p\` is \`truncatedNormal(^1(),.5,1)\`).
  ⬜ To learn in sparse-reward environments, such as "almost every function body we pick results in an error": in replay buffers, stochastically prioritize samples by their last-seen loss, most-surprising (highest-loss) first: {https://arxiv.org/pdf/1511.05952.pdf}.
  ⬜ To decorrelate predictions and targets: make future-predictions static (store it on forward-pass, or periodically switch between two networks, or periodically copy the network) (and possibly, do not update states on replay), to remove the correlation which could destabilize learning.
  ⬜ To improve generalization and possibly final performance: DropConnect (drop random weights when a variable wants to return them) or dropout (drop random numbers on output) or dropping layers (randomly replace with identity), or rarely-updated random zero-gradient masks. This slows down training in order to train a huge semi-ensemble of NNs.
  ⬜ To improve generalization: L1/L2 regularization loss.
  ⬜ Replace the sequence-state RNN with GRU, or LSTM, or a fast weight memory system.
  ⬜ To force neural diversity: batch normalization (shift/scale each batch to have 0-mean and 1-variance).
  ⬜ For more compute-efficient training (assuming that knowing more is very much better): train very large models, stop early, then quantize and prune ({https://www.youtube.com/watch?v=YX8LLYdQ-cA}/{https://arxiv.org/abs/2002.11794}).
  ❌ To waste time on UI, for explainability:
    ❌ Have a neural connection from embeddings to three colors, and color each node in an \`autoFunc\` appropriately (taste the rainbow). A simple way to train this is an auto-encoder: \`color:clip(mix(UpEmb,FeatureSize,3)) mix(color,3,FeatureSize)=UpEmb;color\` (with some penalty for all-black and all-white: \`s:sum(color) minimize(0-s*s);minimize(9-s*s)\`). (Pointless fluff.)
    ❌ Have a neural connection from embeddings to will-it-be-collapsed, and collapse appropriate nodes in serialization. (Pointless fluff.)
    ❌ A great API for auto-objects: the \`fanciest\` sub-language. (Useless without types that can restrict what is auto-generated.)'),'Machine learning is like a box of chocolates: you never know what you''re going to get.')\`\`



(Also, every \`tensor\` needs to be \`dispose\`d of, and types were the only way to know when. So since we have no types here, we have to have auto-disposal. Which is easy: \`\`settings ^_autoDispose\`\`.)



Now؞
    The hyperparameters that we have covered above can be written as:`,
    [
      _(`fancier`),
      `variance:1
discount:.9
choices:2
mod:x->(m tile (m gather x Inds 0) choices 0)
manymix:node->times->in->out->(m softsign (minimix (m softsign (minimix node (array times in FS) mod)) (array times FS out) mod))
Hypers:Cells->Goals->Base->(m map
  'Cells' Cells
  'Goals' Goals
  'Base' Base
  'FeatureSize' FS
  'ChoicesPerCell' choices
  'Predict' (m func Which ConsEmb OptEmb PrevState Inds (m add (m mul (m sub 1 p) A) (m mul p B)) A:(minimix (manymix in Cells choices+3*FS FS) (array Cells FS 1) mod) B:(minimix (manymix in Cells choices+3*FS FS) (array Cells FS 1) mod) p:make(truncatedNormal,make(arrayCdr,make _tensorShape A),.5,variance) in:^concat(array Which ConsEmb OptEmb PrevState,^(choices FS FS FS)))
  'Goal' Real->Fut->((1-p)*Real+p*Fut p:discount)
  'SequenceState' (m func PrevState ConsEmb CarEmb CdrEmb Real (m add (m mul (m sub 1 p) A) (m mul p B)) A:(mix in 4*FS+1 FS) B:(mix in 4*FS+1 FS) p:^truncatedNormal(^1(),.5,variance) in:^concat(array PrevState ConsEmb CarEmb CdrEmb Real,^(FS FS FS FS 1)))
  'NewEmbedding' szs->truncatedNormal(szs,0,.4)
  'Optimizer' varAdam
  'OnSave' States->Actions->Rewards->Chosen->display('Mean reward',mean Rewards);display('Stability',mean Chosen<4)
  'PrevOptions' 4
  'RandomOptions' 4
  'MaxStoredChoices' choices*Cells*1024
  'ReplayedChoices' choices*Cells*16
  'UnrollLength' 16
  'MinReality' -2
  'MaxReality' 2
  'NaNReality' -1
  'UnsetReality' -1.5
  'ConsToEnd' true
)`,
    ],
    `Since everything is self-determined by design, we don't really have a metric to compare different combinations of hyperparameters with. Though we can monitor stability (how many choices are exploring their remembered options, rather than random options; the more the better, though it should oscillate) and the mean/average reward (individually, the more the better, but globally, all we want is diversity).

                  Now¸ it is time to expose \`definersOf(use)\` to generation.
                    Who needs user-specified goals, even? Let us see if we can do self-determination.
                      Our third open-world adventure, after \`tutorial Types\` and \`tutorial regenerate\`.

Keep our representational capacity in mind: an array/object with \`N\` items in its \`deconstruct\`ion is \`N\` cons-cells. Though a lot of arrays can have shared endings, or beginnings, if \`'ConsToEnd'\` is \`true\`.
The more cons-cells, the better. This is big brain time. As big as your GPU allows, anyway: how good of a programmer you are is determined entirely by how big your processors are.
    My processors are very small.
    Small brain time.
`,
    [
      _(`fancier`),
      `cw:make(consWorld,Hypers 256 10 definersOf(use))
allocate(cw,setGoal);save('cwc',allocate cw null errorsSince errs→2-errorsSince(errs))`,
    ],
    `(We convert our "do not do this" signals (\`error\`s) into a number with \`errorsSince\`. With one entry point, this also prevents it from just setting its reward to MAX (reward-hacking) and doing nothing else.)
(Don't complain about how slow the \`fast\` saving/loading is. Be glad that it happens.)

The customary learning rate, for tuning: \`\`settings ^_learningRate\`\`
You can even tune a few more things, if you like: \`\`settings consWorld\`\``,
    [
      _(`fancier`),
      `runtime:^(settings 3000 "How long each epoch is allowed to run, in milliseconds of CPU-time.
The bigger your GPU and CPU are, the more of a programmer you are.")`,
    ],
    [
      _(`fancier`),
      `cwc:static(await load('cwc'))
(repeat ^select(randomProb 1/3000,?→save('cwc',cwc));(try func(limit {'time' runtime 'arrays' 1e5 'tensorMemory' 500e6} ?→callAdjust(u);u u:use(cwc)) err→err);null 10001);(select (equal 'Save' (prompt null 'Save' 'End')) ?→save('cwc',cwc) ?→?)`,
    ],
    `(27 bugs fixed, per-day: 5+4+4+2+2+2+2+5+1.)

Now, now, now, now, now, now, now, if you actually try to train it…
    I mean, stuff will happen if you train it for long enough.
        Not good stuff: \`setGoal\` is almost never called (I \`print\`ed it), and stability goes up for a while when loss stops improving (no idea why).
            (If you keep training, stability destabilizes more than initial conditions, and reward becomes a bit more than initial conditions. Boring.)
            (Can zoom in on these plots.)

\`\`(display 'Mean reward' ^(a:-1.14453125 b:-1.24609375 c:-1.44921875 d:-1.34765625 e:-1.55078125 (a a a c d a a b a a b a b a a c a a a b b d a a a a a a a b a a a d a a a a b e b a a d a a a a a b a a b a a a a a a c a a a a a a a d e a a a d a a a a a a a a a a d a a a a a a a a a a a a b c a a a a b d a a a a a b a a a a b a a a a a a e a a a a a e b b a a e a c a a a a a a b b a c a a a a a a d a a a a a a a a b b a a a a d a a b a a a b c a e a a b b a a a d b a a a b a a a a d a a a a a c a a a a a a a a a a a a a a b a a b a a b d a a a a a a c a a a a b a a a a b b a a a b e a a a b a a a a a e a a a a a a a a a a a a a a a a b a a b a a a a a a b e c a a a a a a a d a a a a d a b b a a a c a a a a a b a e a a a b a a b a a a d a a a a a b a a a a a a a a b c b a c a e a a a a b a a a a a a a a e a a a a a e a a a a b b a a a a d a a d a a a a a a a a d a d e b a a a a c c a a a a d b a a a b a a a a a a a b a a a a a a a a a a a d a a a a a a b a a a a a b a b a a a a a b a a a a e a c d d a a a a a d a a b a a d a b d c a b a a a d b a b a b a a a a d a e a a e a b a a a a d a a a b b a a e a d a b a a c a a a a a a a b a a a a a a b a a a e a a a a d a a a b a a a b b a a a b a a a a a a a a a a a a a a a a a a a a b a c c e a a b a a a a a a a b a e b a a e e d a b a a b a b a a a a a a a a a b c a a a a a a a a a a a a a a a a d a a a b a a a a a a a a a b a a a a a a b a a a a a d a a a a a a a a d a a a a a b b b a e a d a a d b a a a a a b a a c a a a d a a a a a a a a a a b a a a a a a a a a c b a a a b a a a a e a a c a a a a b a a a b a d d b a a a a b c a a a e a a a a a c b a a a b e c d a a a a a a b a a a a b d a a a a b e b a a a b a a a a a a b a a a b a a a b a a d b a a a a a a a a a a a d c a b a e a a a a a a a a a a a e a b a a a a a a a a a c a a a a b a a a a a a b a b a b a b a a a e a a e a a a b b b a b a a a c a d a b a a a a b a a a b a a a a a a a b a a a a b e d b a a b a a a a a a b a a a a a a b b a a a b a a a b a b a a c a c a a a b a b a c a a a a a e b b a a b b a a b b a a d a a a b a a a a b a a a a e a a a a a a a a a a a a d a a a d d a a a a a b d a e a a a a b a b a a b c a a a a a b a a a a a b a c a a a a a a a b e a d a d a c b a b a a a b a a a a a a b d a a a a a a a a a a c a a d a a a a a a a a a a a a a a a a b b a a b b a b b a a a a d d a b a a a a a b a e e a e a a d c a a c a a b a d a b a a a a a a b a a a a b d a c a a a b a a a a a e a a b a a b a a a a a a a a a a a e a a a a b a a a a c a a a a a d a a a a a a a b e a d a a b b a a a a a a a a a b b a a a b b a a c a a a a a a a b a a a a a a a a a a a a a a e b a a a a a a b a a a a b b a b d c a a a a a b d a a a a a a b b a a b d d a a a b a a e a b a a a a a a a a a a a a a a a a a a b d a a a b b a a b a b c e a a a b b a a d b a a a b e c a a a a a a e b b a a a e d d a a c a a a a a a a a a c a a a a a a a b a a a c a a a a b a a d e e a a a a a a a a a b b a a a b a a e d a a a a a b a a a a a b a a a e a a a a a e a a a b a a d e d a a a a a b a a a a a b a a a a a a a e b a a a b a a a a a a a a a a a a e b e a a a a a a b a e a a a a a a a a a a a a a a a a a b a a a a a a a b a a a a b a a b b a d a e a a a a a a b a a a a a d a a c a a a d a a a a c a a a a a a a b a a a a a a a a a a b a c a a b b d a a b a d a a a b a a a b a a a a e a a a a b a b a b d a a a b a a a e a b a a a a a b a a a a d a a a a a a a a a a a a a e a a a a a a a a a c a a a a a c a a d a a a a b a b a b a a a a e a b c b c a b a b a a a a a a a a a a a a a a a a a b e a a a a a b a a a a a a a a a a a a a b a c a a a a a a a a a d b a c b a a e a a a a a a e a a a a b a e a c a d a a a a a a a a a a a a a a a a b a b e a a d a a e a a a e a a a a b d a d a b a a b b a a c a a c a a a b a a a a a b a a b b a a b a d a b a a a a a c a a a a a a a a a a a a a a a a a a b a a a a a a a a a b a a d a a a a a b a e a a b a b e b b d b a a a a b a c a a e a a a a a c a e a a a a a a a a a c a a a a a a d b a b a a b a a a a a a a a c b b a a a b a c a b e a a a c a c a b a a c e c a a b b b a a a a a a b c a a a b a a a a a a a a e e a a a a a a b a a a a a a a a b d d a a a b a a a a a a a a a a a b b a b a a b a a a a a a a c d a b d a a a a a a a b a b b a b a a a b b a b a a a a a a a a a a a a a a a b a a a d a a b a d a a e a a a a a a a a a b a a d e a a a a a b a a a a a a a a a e a e a b a a a a a a c a a a a a a b a b a a a a a a b a a a a b a a a a a a d a a a a d a a a c a a d a a c b b a a a a a a a e a a b a a a a e a a a d a e a a c a a a a c a a a a a a b a a b b e a e b a d d e e a c a a a a a b a a b b a d a a a a a d a a a a d a b c b b a b a a a d a a a d a a a d b a a a a a b b a e a a a a d a a a d a b b b e d a a b a a a e a a d a a a a a a a a a a a a a a a d a a b a a a a a a c a b a a a a a c a a a a d a a a a a b b a a a a a a c a a a a b d a b d a a a a a e b d b e a b a d a a d a b a a b a a d a a a a d a c a a d b b a a a a a b a a b a a a a b d a a b a a b a b a a c a a a a a b a a a a a a e a a a a a e a a a a a a b a a a c a a d a a a a b a a a b c a a a b d a a a a a a a a a a a a a a a d a e a a a a a a b a b a a a a b a a a a a b e a a a a a a a b a a b a a a a a b a a b a a a b a a e a b a a a e a a d e a a a a d a a b b b a a b b d a a a a b a a a c d a a a a a e a d a c a a d c a a c b a a b a c a a a a a b b a a a a a a a e a b a d a a b b a a e a a a b a e d a a a b e a a a b a d b a a a d a a c a a a b c a a a d a b b a a b e b a b e a a a a a a a b a a a a a a a a a a a d b b a a a a a a b a a d a a a d a a a b b c b a b a a a a b e e c a b a d a a d b a a a a b a a d a a a a a a b a a b e b a a b b a e d a a a b a b a a b c a a a d a b a b a d e b a b a a a a a d a c a a b b d a a d c a a a a a b a a a a a a b a a e a d a b c b a e b a a b a d c a a a b a d c a a a a a b a a a d a a d a a a a a a a a a a a a a b c a a a b a a a a b a a a b a a a a a a a b a e a e a a b e a a a a c e b a a a a a a a a a a a a a e a a a a a a a a a a e c a c a a a a a a a a a a c d d e a a e a c a b a a b a a a a b a a a b b b a a d a a a d a a a a a a a d a a e a a a b a a a a a a a a a b a a a b b b a a a a e a a a d a a a a b a a e b a a a b a a a b a a a a b a a a a a a a a a a a a a a d b a a a a a b e a a a a a a a a b a a a c a a a b a a a c e b a a a a a a a a b a a a a e b b a a b b c a b a a b a a d a c a a a a a d e a a a a a a a b a a a a d a d b a a d a e e d a a a d a a a e a a a e d a a b b a a a a a e b e b a a d b e a a a a a b a b a a a a a b a a a b a a a a b a a c b b b a a b d e a a a a a d b a c a a a a a c b e a a a b a a a a a a a a c a a b a a e e a b a a a b a a a a b a a b e b a a a a a a e e b a a a a a a e b a e a a a a a d e a e a a c a a b b a e a a a a a e a a a a a a d a a a a a a a c e a b e a d a e a a a c a a a a a a a a a a c b a a d a a e a a a a a a a a a b a a a a a a d a a a a e a a a b a a a a a a a a c a a a e a a a a a a a a a a a d e d c a b a a a a a a b a a b e a a a a a a a a a a a a a a a e a a a a a b a a e a a b a a a a a a a d b a a a a a a a a a b a a b a a a a b a a a a a e a a d a a a a c a e a b a a a d c a e a c d a a b a a a a a b a a e a e e a a a a a a a a b d a e a a a a a a b a a a a a a b a a a d a b a a c a b a a d b d a a a c a a a a a a a a a b a a b a a a a a a a a b a a a a a a a e a b b a a a a a a a a a a e a a a a b b a a a a a a a a a a a b a a b a a a a e a c a d e a a b a a d a a a d a d a a a a c a e a a c a a a a a a e e a a a a a a b a a a a c d d a a b b a a a a d a a b b a a b e a a a a a b a a e a a a a a a a a a a a a a a a b a a a a d e a a a a a a a a a a b a a a e a a a e a a a b a a a a b a a a a a a c e b a a a a a a e e a a a c a b a d a b a a a b b a a a a a a a b a a a a b a a a b a b c a a a e a a a a a a a a b a b a e a a a e c b b b a a a e b b b b a b a a a a b b a e e c b a c a e e b a a e a a a a e a c a e b a d a a a a a a a b a d e a a b a a a a a a a a a a a a e a b d d a b a a a a a e a a a a a a a a a d a c a a d a a a a a c e e a a a a a a d a a a a a e a c d a d a a a b e a e b a a a a a b a c d a a b a d a a b a a a e a a a a a e a a a a a a a a a e a e d e a a a a e a a a a a a a a c a b a a a a b a a a b e b a b a a b a a a a b a a a a a a a a a b a e a a a a a a a a a a a a a b e a a d a a e a a a a a a a a b a c a a a c e a b a a a a a a a a b e a a a c c c a b a a a a b e d a a b a a a b a a d a a a b a a b e a d b a e c a a a a c a a a a a b a b a d e a a a a a b a a a a c a e e a b a a b b a a e a a a b a b b a d d a a a d a a a e a d a a b a d d e a e a e a a a e b d c a a a a a d a a a b a a a a e e a e b e a a a a b b e a a d a a a a a a a b b a a a b d a a a b a d d a b a d b a a a a c a e a a a a a d a b a a a b a a a a a a a a a a d a a a a a a a d a a b a b a a a a b a a b a a a a b a a a a a a b a a a a e a b d a e b a a a a a a a a a b a b d a a a a a a b a a a d a a a a a a a a a a a a a a a b a c a a a b e a a a a a a a b b a a a a a a a a b b a a e d b a a a e b b a a a a c d b d a a a a a c d a b a a e a a a a b a b e a a a a a b a a a a d a a a a a b b a a a a a a a b a a b a b a a e a a b a b a a a a a a b a a a a b b e a b b a e a a d b a a a b a a a a e a a a a e a b b a a a a a a a a d a e a a a a e b a a c a a a a b a b a a c a a a a b a a a a a a a a a d a a a a b a a a a a a a c d b a d a b a a a a e a b a a a d d b a a a a b a a a a a a e a a c a a c a e d b a a a b a a b e b d a b a d a a e c e a d e a b b a a b a a d e a a a c d b e a a a a a a e a b e a e b a a d a a e a a a a d a a b a a e a a b a a e e a e e a a a a a a a b a a b a a a b a a a a a d a b a a c a a a e e a a d b a a a b a c b a a e a d b c a b a a b a a a a d e a a a a a b e c a a b a a d a a a a a c a a a a a a a e a a a e a e d a a b a a e a b a a e e d a d a a b c d a b a a a a e b b b a b a b a a e b a a b d a a a b b a e a c a a e e a a b c e a a b c c b a d a a e b a a a c a e a a b e a d b a a b a b a a a a a a a a b e a a a a a b e a a b a d a a b a a a a a b a a c a b b c a a b b a a a a a a a a a b a e a a a a a a a b a a a a e b b a a a a a b a e a d d a a a a d a a a a d a a a a a a a e a d a a a a a e a a a a d a a a b a a a e a d a a a a b b a a a b a a c a a a e b a a b a a a b b d e a a a b e a a a a b a d a a a e a e a b a a a a a a c a a a a a a a e a e c a a b a b a d e b a c b b a d a a a a d a a a b c a b a e b a e e a b a b b a a e a d b e a b a a d d a e a a a c a a a a a e a a a e a b e a a b e a d a a b a e b a a e a a a b d a a a e a a a c e e a e a a d a e a a c a a d b a b b b a b a a b e b a a a e a b a a a a b a b d a a a a a a a a d b b a b b a a b a e a a a a a a a a a b b a d a b a d a b a a a a a a e d a d a a e a b c a b a a a e e a a a a a b a b c a a a a a a a a b b e a a b a a a b a a a a b b a a a a a a a a a d e b a a a a e a a e a a a e a b a a a a e e a a a a a d a a b e a a a e a a a a a d a a a a a a a e d a a a a a a a a a a a b b a a a d a a a a a d e a a a a a a a a a d b a a a a a a b b a a a a b b a a a d d a a c e a a a a a a a e a e a a d a e a a a a b a a a b a a a a d a a e b e a e a a a b a a d a e a a d e a d a a a a a a a a a e a a e a a a a a d c a a a b a a a a e e b a a e a e a a a a a a a a e a a a a a a a a a a d b a a a b e a a a e e a a a e e a a a e a b a a b a a a d a a a a a c b b e a a a a a a b a a a d a a a a b d c a d a a a a d a b a e a a a a a a a a a a a a a a a d a a e a a e a a a a a b a d a b a b a a a a d a b a a b a e a d b e a a b a a a a a a a b a e e a a a a b a d a e b a a e b e a e a a a a a a a a c a d b a b a a a a a b b a a a a a a a a a e b a d a a a e a c a a a a a a a a d a e a b a d a a a a a a b a a a a d a b b b a a a a a b a a e c a d a a a b b b a a a a c b a b d a a a a e b a b a d a a a b b a a b e a a b a b a b d e e d b e a e b b a a a a a a a b e a b a a b a a a b a a a a a a a a d c a a e a a a e a a a b c e a a e d d e a b a e d b e d a b b d b a a a a a c b a a a b a b e a a b a a a d a a b a a a a d a b b e a c e b a a a e a a a a c a a b e d b b a d a a a b a a e a b a d a a a e a a a d a e a a a b a a d a a d a a a a a a b a a a a a a b a a e a b a a a b a a a a b a a e a a c a b a a a a e a a a a a a b a b d c e b a b a a a a a a a a a a a b c a a b a a d a a a a a d d a b a b a a a a d a e a b a a a a e a a a d a a a a d a a a b a b d a b a a a a a a a a b a a a a a a e b a d a a a e b e a a a a a d a b a a a a a b a a b b a a d a a b a a a b a a e a b a b a e a d a a a a a a a e a a c a a c a a a b a a a e e d a e a a d a b a a a a a e a a a a a a a b b a b e c a c a e a a e a a a a a a a a a a a d a a a a a a e a a d a a a a a e b b a a a a a a a a b a a a a a a b e a a b d a a b a e a b a a a c a b a a a b a b e a a a b a a a a a a a a a a a a a b b e a a a c a d a e e a a a e c b e b a a e a a c b e a a a a a a a a e e a b d b a a b a a e a a a a d b a a a a a a a a a a e a a a b d a b a a a a a a a d c a b a b a a a a a a e a a a a a b e e b a a b -1.197265625 a a a a a a b a a a a a a a a a b a a b b a a a a e a b a a a a a a a a b b a b a a a a a d a a b d b b a a a a e e a a a d e a b a a a a a a e b b e a b a c e a a b a a a a a a a a b a a a e a a a a a a a e a a a a a a b b d a a a d a a d a d a a a e d a e a a a a a d a a a c d a b a e b a a e a a a e a a a a b a b e a e a d e a a a a a a d b a a a a a e a c e b a b a d a a a a a a d a b a c e a a e e e a c a a e a a d a a a e a a a a a a e a d b d a a b c b a a b c a d a a a b e a b a a a a b a a a a a a e a a b a a a c a d a a a d a b a b a a a c b d b a d c a a d e b b a a a a a a d a b a a e a a a e b a a a b a a e a d a a a a a a a a d b a a a d e b a a b b a a a b a b a a c a a d a e a a d e b a a b a a a b b a a d d b a b a a a a a a b a b a a a a a b a a e a b a a e c b a e d b d a a a a e a a b a a a a a a a b e b e a a b a a a a a a a a a b a a d a d d a a d a a a c a b a a a a a d e a b a a a a a b b a a c a a a d e e a a b a a a a a a a a a b a a a a e a b a a a a a a d a a a a e a a a a a b a a a a a a a a a d b b a b a b a b d a b a e d a e a e b a a a a a a a b a a a a e a a a a a d e a b b a a a a a a a a b a a d a a d a e b b a a a a a e b a a e a a a a d a a d a b a a b b a a a a a a a c a b a a a a a a b a b a e d a a a a a a a b a b b b a e a a d c a a a a a a a a a a b a d a a a a a a d a e b a a a a a a a b b a b b a d e a a a a a a b a a a b a c b a a d d e a b a a a a a a a a a a a a b a b c a d a a a e b a b e a b b b a d a a a a a a a a a d e a d a a a a a a a a c e a b a a d a a d a a a a a a b a d a b a e a a b a d a d b d e b a a a b a d b a e a b a a a b b d a a a a a a e c a a e d b b b a b e a a a a e e a e e b a a d a a a a e a a a a a a a e a b a a a b a e a a a a d a b a d a a a a e d d d a a b d b e b a e b a a d e d a a b c a a a d a a b d a c a a a b b d d e a d a e a a d a a e b b a b b a e a d a a b a a a d a a a a b b a a b a a b a a a a b b a e a a a b a a a d a a a a a a a a b b b e a e a a b d a a a a b d d e a e a a a a a a d a a b a a a b b a a d d a a d a a a d a a a a a a e a a e a a a a d a a a a a a a b e b b a a a a a a a a c a a e a a a a a a a b a a c e b d a a a a d a a a a a d a a a a a a a d a a a d d a a a a b a a b a a a a d b a a a a a a a a e a e a a e a a b a a a a d a a a a a a b a a d a a b a a a d a a d a a a d a a a a a a a a a a a e a a a a e e a a a a a a a a a b a a a e a a c a a a a a a a b a d c a a a a a d b a a e a a a a a b b d a a a c a a c a c a a b a a d a a b e a a a e a a a a d a a d e a a a e b e a a a a a b b b a a a a a b a a a b c c a d a b a d a a b a b a b a a a a b b b a a b a a a a a d d e e a a d a a b a c a a a b d a a a a a e b a a a a a a a a a a a a a a a b a d a a c a a a a a d a b a a a d a a a b a a a a a a a a a c a a a a a a a a c a b b a d a c a a a b a b a a b a a a a a a e a a a a a b a b b a a a c c b b d e a e b b a a c b a a a a a a a a a e a d a d a a a e a a a b c a b b d a b a a a a a e a b a c e e a a a a b a a c b a a a a b d e a a a e d b a a a a a a a a a a b a d a a e e b e a e a b a a d a a a d d e b e d a a a a a e b a a a d a a e a d e a a a b a a a a d b a a b d a b a a b a d a e b a a a a b a e d a e a e a a e a e a a e b e e a d a a b a a a a b b a a a a b a b a a a a a d a b a a e a b c e a a a a d a b a c a d e e a a e a b a a a a a a a a a a a a d a a a a b a a a a a a a a a b a a b e a b a a a e a a e a a a e e a a a a c b c b a a a b d a d a b a a b b a b b d a a a b a e a c d c e b a a d a b b a a a a b a a a a e a a e a e a a b a a a a a b a a b e e a a e e b d a a a d a b a a a a a a a a b a c d a a a a b a d a a d a b a a b b b e a d b a a a b a a a a b a b b e a a a a a a a a c a a c b a a a a a a c b a d c a b e a a a c c a a e e a e a e e a d b a a a a c b a a a d a a b b a a a a b a a a a b a a a a a a e a a a a b a b b a a a a a a b a a a a a a b e a a a a a a b a a e a a b a a a b b a b a a a a a b a b a d b b a b a a a a a b a a e a a a a c b a a a e a a a b e a d a a a a b a a a e a a a a a b a a d a a a d a b a a a b e a a e c a a e a b a a b b a b a a a a a d a a c a a a a b a b a a e a e a e a a d a b a a a b a a a a b a e b a e a b a a a a d a a a a a a a a b a a e a a a a a a a a a a a a a a b a a a a d b a a a a a b a a a a a a a a a e a a a a a a e e a e a b d b a b c a e a e a a a a a b c a a b a e a a d a a a e a b e e a b a b a a a a b e a a d a a a a c a e a b a a a e a a b c a a a a a a e a b a a a a a e a a b a a a a b a d a a d a a b b a e a a b a a a a a a a a a a b a a b a b b a a d a a a a c e a d e b b a a a a a a b a b a e a a a a a d e e a a a a e b c a a a a a a a a a a e a a a b a e a b a a d a a a e a a a a a a a e b c a a a a d c a a a a e a a b a c b b a a a a c a a a d e a a a a a a b a a a a a a a a a e a e a a e a b a a e a a b a a a a b a a a d a c d a a a a b e a a a a a a e a a b a a a a a a b a b b a c a b a a a a a a a a a a a a a e a a e a a a a a a a a a a e a a a b d a a a a a d a a b e b c a a a a a a a a b a d b c a a a a a a b a a a a e c a b a d a a b d a a b a a e a b a b a b a a a a a a e b a b d b a a b a a d a a a b d a a a a a b a a a a b a a a e e a b a a a a a a a e a b b a a a a a e a b b b d a e a a a a a b a a a a a c a a a a a e b a c b e a e a a b e a a a a a b a a b a a a a a a a b e a a c e a a a a a a a d a b a b a a a e a a a a b c e a a a a b a a a a e b b b a a a a a a a d a b a b a a b b a b a a e a a a a b a a c a a a d a a b e a a a a a a b e a d a a a b e a a b a c a e a b a a a a a e a a b a a a a a c a a a b c d a e a e a a e d a a d a b a e a a a a d a e b a e a a a a a e a b a e a a a a a e b a a a a a a a a e a a a a b b b d a a b a a a b a e d a a b b a a e b a a a a a a a a a a a a a e a e e a d b a d e a b a d a c a a e b b a a a a a a a a a a a b e a a a a c a b a a e a b a a a a a b a a e b d a b e a a b a a a a a a a a a a b c a a a a a a b a a a a a a a a a a a a d a b a a a a a a d b e e a a a b b b b a a d a b b a d e a b a a d a e a a a a a a e b b a a b b a b a a a b a e a b a a a a a a a a a d a d b a a a a b a b b a a a a a a a b a a a a a a d b a a a a b a e a b a b a a a b a a a a b a a e b a a a c a a a a a d a a a a a a a a b a a a a a b a a a a a a b d a a a a b c e b c e a a a a a b b a c a a d a a a d a a b b b e a a a e a a c e b b a b a a b a a a b a b a e a a a e a b a a e e b a d a d a a a a a a a a a c b b a a a a a b b a a a a b a a a a b b a a a a b a a d b a a d c b a a c e a a d e a d b a c a a b a b a a b a a e b a a a a b a b a a e a b a a a d a a a c a d a a c a a a a a b b a a a a a d a a a a a a a e a e a a a a d a d a a a a a b a d b a a a e d b a a b a a a a e b a b e a b d b a b a a b b a c a a d a b b e a a a a a e a a a a a a a a a b b a e b a b a b e b e e e a a a a b a a a b a b a a b a a a a a b d a a a d a a d a a a a a c a a a e a a a a e a a a b a a a a a a a e e a c a a a e a a a a a a b b e a a d a a b a b e a a a a a b a b c e b a a e b b a a a a a a e b e a a a e a e a b d a a b a b a b a a a a e a a b b a a a a a e d a e c b c b a a b e b a a a a a b a e a a a a a b a a a a a b a a d b b a a e a a a a d a b a b a a c a a a a a a a b a a a a a a a a b a a a e e b a a a b a a a a b a a)));(display 'Stability' ^(a:0.439453125 b:0.603515625 c:0.423828125 d:0.455078125 e:0.552734375 f:0.595703125 g:0.626953125 h:0.619140625 i:0.517578125 j:0.484375 k:0.51953125 l:0.443359375 m:0.578125 n:0.5078125 o:0.6640625 p:0.6328125 q:0.494140625 r:0.572265625 s:0.623046875 t:0.583984375 u:0.65625 v:0.64453125 w:0.671875 x:0.5234375 y:0.71484375 z:0.7734375 A:0.611328125 B:0.708984375 C:0.408203125 D:0.51171875 E:0.705078125 F:0.544921875 G:0.560546875 H:0.486328125 I:0.3359375 J:0.462890625 K:0.6171875 L:0.6015625 M:0.490234375 N:0.7109375 O:0.5390625 P:0.625 Q:0.62890625 R:0.548828125 S:0.4296875 T:0.396484375 U:0.55859375 V:0.681640625 W:0.373046875 X:0.5546875 Y:0.59765625 Z:0.4375 ba:0.640625 bb:0.6484375 bc:0.591796875 bd:0.501953125 be:0.38671875 bf:0.630859375 bg:0.669921875 bh:0.685546875 bi:0.6953125 bj:0.6796875 bk:0.580078125 bl:0.53125 bm:0.333984375 bn:0.609375 bo:0.46484375 bp:0.509765625 bq:0.470703125 br:0.5625 bs:0.744140625 bt:0.357421875 bu:0.734375 bv:0.638671875 bw:0.767578125 bx:0.431640625 by:0.42578125 bz:0.54296875 bA:0.576171875 bB:0.72265625 bC:0.564453125 bD:0.69140625 bE:0.60546875 bF:0.70703125 bG:0.673828125 bH:0.515625 bI:0.779296875 bJ:0.435546875 bK:0.388671875 bL:0.658203125 bM:0.61328125 bN:0.41015625 bO:0.412109375 bP:0.458984375 bQ:0.751953125 bR:0.34375 bS:0.58984375 bT:0.646484375 bU:0.49609375 bV:0.466796875 bW:0.50390625 bX:0.474609375 bY:0.650390625 bZ:0.546875 ca:0.513671875 cb:0.607421875 cc:0.75 cd:0.33203125 ce:0.634765625 cf:0.4140625 cg:0.505859375 ch:0.521484375 ci:0.37109375 cj:0.43359375 ck:0.5 cl:0.53515625 cm:0.4921875 cn:0.642578125 co:0.533203125 cp:0.46875 cq:0.568359375 cr:0.4765625 cs:0.45703125 ct:0.40234375 cu:0.3515625 cv:0.525390625 cw:0.57421875 cx:0.74609375 cy:0.771484375 cz:0.615234375 cA:0.7890625 cB:0.666015625 cC:0.73828125 cD:0.67578125 cE:0.75390625 cF:0.556640625 cG:0.759765625 cH:0.52734375 cI:0.482421875 cJ:0.654296875 cK:0.587890625 cL:0.384765625 cM:0.375 cN:0.404296875 cO:0.7421875 cP:0.37890625 cQ:0.71875 cR:0.390625 cS:0.453125 cT:0.59375 cU:0.56640625 cV:0.66796875 cW:0.732421875 cX:0.599609375 cY:0.818359375 cZ:0.44921875 da:0.55078125 db:0.318359375 dc:0.5703125 dd:0.298828125 de:0.662109375 df:0.76953125 dg:0.447265625 dh:0.369140625 di:0.478515625 dj:0.76171875 dk:0.83203125 dl:0.40625 dm:0.677734375 dn:0.68359375 do:0.4609375 dp:0.248046875 dq:0.30859375 dr:0.537109375 ds:0.427734375 dt:0.66015625 du:0.47265625 dv:0.541015625 dw:0.392578125 dx:0.419921875 dy:0.48828125 dz:0.701171875 dA:0.748046875 dB:0.48046875 dC:0.65234375 dD:0.3671875 dE:0.380859375 dF:0.416015625 dG:0.63671875 dH:0.27734375 dI:0.703125 dJ:0.400390625 dK:0.365234375 dL:0.32421875 dM:0.58203125 dN:0.69921875 dO:0.783203125 dP:0.5859375 dQ:0.6875 dR:0.833984375 dS:0.740234375 dT:0.294921875 dU:0.4453125 dV:0.498046875 dW:0.3984375 dX:0.41796875 dY:0.36328125 dZ:0.376953125 ea:0.34765625 eb:0.529296875 ec:0.337890625 ed:0.35546875 ee:0.689453125 ef:0.693359375 eg:0.716796875 eh:0.697265625 ei:0.728515625 ej:0.451171875 ek:0.736328125 el:0.44140625 em:0.62109375 en:0.724609375 eo:0.33984375 ep:0.3828125 eq:0.275390625 er:0.302734375 es:0.306640625 et:0.349609375 eu:0.796875 ev:0.28125 ew:0.80078125 ex:0.328125 ey:0.287109375 ez:0.322265625 eA:0.2734375 eB:0.345703125 eC:0.7265625 eD:0.314453125 eE:0.31640625 eF:0.712890625 eG:0.763671875 eH:0.251953125 eI:0.29296875 eJ:0.421875 eK:0.3125 eL:0.755859375 eM:0.8125 eN:0.341796875 eO:0.794921875 eP:0.353515625 eQ:0.359375 eR:0.361328125 eS:0.26171875 eT:0.267578125 eU:0.775390625 eV:0.291015625 eW:0.39453125 eX:0.30078125 eY:0.806640625 eZ:0.330078125 fa:0.814453125 fb:0.720703125 fc:0.8046875 fd:0.3203125 fe:0.798828125 ff:0.255859375 fg:0.78515625 fh:0.791015625 fi:0.765625 fj:0.8828125 fk:0.810546875 fl:0.8359375 fm:0.77734375 fn:0.78125 fo:0.73046875 fp:0.83984375 fq:0.857421875 fr:0.802734375 fs:0.787109375 ft:0.853515625 fu:0.822265625 fv:0.80859375 fw:0.79296875 fx:0.849609375 fy:0.900390625 fz:0.861328125 fA:0.826171875 fB:0.8203125 fC:0.865234375 fD:0.841796875 fE:0.7578125 fF:0.873046875 fG:0.869140625 fH:0.845703125 fI:0.896484375 fJ:0.81640625 fK:0.830078125 fL:0.90625 fM:0.87109375 fN:0.876953125 fO:0.935546875 fP:0.939453125 fQ:0.8671875 fR:0.923828125 fS:0.90234375 fT:0.84765625 fU:0.859375 fV:0.8515625 fW:0.828125 fX:0.84375 fY:0.927734375 fZ:0.904296875 ga:0.875 gb:0.8984375 gc:0.87890625 gd:0.912109375 ge:0.82421875 gf:0.89453125 gg:0.890625 gh:0.88671875 gi:0.85546875 gj:0.884765625 gk:0.919921875 gl:0.91796875 gm:0.943359375 gn:0.91015625 go:0.892578125 gp:0.86328125 gq:0.947265625 gr:0.837890625 gs:0.880859375 gt:0.9296875 gu:0.908203125 gv:0.953125 gw:0.9140625 gx:0.916015625 gy:0.9375 gz:0.921875 gA:0.9453125 gB:0.9609375 gC:0.94921875 gD:0.95703125 gE:0.888671875 gF:0.92578125 gG:0.931640625 gH:0.951171875 gI:0.93359375 gJ:0.94140625 gK:0.958984375 gL:0.3046875 gM:0.310546875 gN:0.259765625 gO:0.97265625 gP:0.2890625 gQ:0.966796875 gR:0.236328125 (T bo eA dM m a d j n a bi i fE bP h q o b cL p bF Y bz c cO bb dj u b c gc bX cb e db t bR dP F L g bD d f dI e f dy g G fj r h fc w bL k S C i bh X j cC di fF l e D x bS s k z b bl K l y m n bN o v bm g bk f W p dQ dE E bd de q cZ cB bn A dN U 0.216796875 bY r f eB dc Q cf s t fz bI dw eq u dW M v be e w R x B cw o y b H bp c cA bu s r b z A bs N B 0.212890625 V C cv D I E J ba F v bA G H ca eY 0.279296875 ct bE bq E cD I dq A bj g J K P fa b bw dl ey ft E L dC ck M em M O N bf O eP n cr x P Q R S Z T fl br ef gN T bg U V W bG X Y O j bc Y Z bO Z ba bb bJ n bQ bc eV bT bd i bv cT cu cW F dZ dk bB bb bH be bf bt ch bg j bC cd M bh bi ee bj U ei bM bk ea H do bl E bx R bm bn cs m cz a bo u D cy cK eg s bp bq bf by br ce fk y L bs f cE bt bU bu i bv E cc eK x bw bn cR K bx ba by cx bV W ec bz bA dg cn Z bB dd x bC dG bD cl bK bE bF bG bH cM bI cU bJ v B R bK bo bL bW bZ dK o bM a bN dV bO U bb bE bP dX d cq Z cg T bQ fd ci da w dn cm bL bd P H bR bS bT bM F br bU Q bM bj F dJ bC bV O dt bW v bX bY bZ bl ca cb cc cp e cd co bC ds cj ce bn r df f cf bA bd cg bc q ch t e cQ ci cj k x F e t eF bA x ck bj Y bS cF bq cl P bd g M cm br cb cn bV R cN c D M bV X bM a dR X M bB co cp cq cr cP cs n m ct M A br ck cY K br cu cI G co cG bF bg z cv O cw bb u bQ F cx cy i cz E cH cA bk bU dS cp eD bn cB ca cC dh cD cE cJ L ex cb ca cs cF eZ bU J B P eh d u gb bj cg N bU cG H bN el G bh cp m bA d dB bP cF cA dv cl cH cI cJ 0.169921875 cK cK bT co E cL cD bc cV cM cg bU cl cN ba cK dr cO o bA cG cP es ez cI r cS bX cQ bd M cR bP dD dm cl cS fe cT cb cC bC cr dF dp bT cU bl bv br cq U cV q cX eb bw ca u dA bK ed K bT cP bG cB R G cW b bK cX ce cW o cY bd cZ cK da dL db dc g bv dd i s bX bF bl bh O u b bi de cz cK df dY bV dH eM cj ce dx ca bT dg cN co dh cJ dO Y di en eJ d g l bP bl cZ cn C bY dj br cH bR A c bT eo ct bJ bc bz bn dk ca Q bA R ci j dg Q bq ek bf bz T Q du dl e dl br bo dm O fq cN u dn cN t V br do bn ca dp bf bL fC bT bp cv fp dq r n dm bD ca i cw Q cM dr eL cw bc cU bD di bh cl cK bd bD ds eu bS dt 0.2265625 cy cY bK bT du h G cr B bZ dv ej M cu bA cA dh bX cr dw 0.224609375 y bk bk ch dx u du g dy dc cG cs br bb L k cj dt bN c b cp cZ U ds u W bP bA be cP k bd cD j cM dz cI dz cM cD bM bc dA cp dB cx n dC ds 0.2578125 eC d cN cp dh m ew dy cj cb ci J dD fu dE bx de dy dF bR bU cm bc da bq cB dG cv ch h cf dh bE bn F cT cS cj cP by dk P bb dc ct cW bx df do cv dH dI et dc v bx c dr cb cn bC cS C dx dI f cp bW bL cZ bU bq dT cI dJ bS r R dK bV bp cb dF cK dL x bA bP di h bX cp dJ D du J bJ k cl C du dM cj fr bZ dN bp dU cP bT 0.208984375 a ce bP r cC dO bz cb K a s b dP f cg x dM cs dQ h N cv cl dR cB e S dS ds cN ep bd ds dT Q dF da dU r 0.24609375 0.2109375 bP dV bv bL bW dg dW dc bg D bW ce bR er V df cs cf M h bS ck dn bl F P dc bd dc c f D bC ds cp R dX J o G do ba cq F cQ dP cI H dY cT bD br R bz dc cO G x ch dt bU dZ x ea cW bE bU bv Y dJ bw d M bz dB h eb bA B b ec dj dB bb bP bU V br O r ed ee dF p e ca q bn ef cV e bN dM by j dG e cw s u bE r dL dB O ds eg Q cb X bd bO eh X cN cp bL 0.19140625 U ei cf bL dj da ej R eb ba bL i E k b ek ca cl S co a bE el em bC bc bo bk cz do en a Z de bv J eo cI i dJ dq dG ck ee X p cA cW J cx bl ep bz X bf ds bl cp cr eE dE cF O bt eq cZ bp bl ca M f b dJ dJ do bW bq dN dt br L du s er dy bc bK cD Z dc el ed cm cl fJ H dl dz ev i bn br bj bf dm bi m em bj dQ dt bO J bm bE dq cr G ds bA dz cm cR q t d e bM eb M es dc bp dl bQ h dz dV bz bt bb dv A x eb bl e m bW ds J dB cl cK bE eH ce bo dc dw cX br bV cI dQ dt fw di em er cH m dc et e W b dy bk bj cP cN da q dQ br df dy em bA dZ dn c dZ P dG ck cj cX dU ch cq eu x dS bG f n bo dQ cM bv do br bY bn bT 0.185546875 v cj N bD dg ch bK dr bV cP cw G dB r J do c h H K de B dg do eg bF dF Q H g cT l n cl f P dz dt V em cU o dz c em cX I p cK cb et dP cp Z ev b do ed dw bz bf Y dD ca eh ew c co br ea ca be T W bK ex ej e dx bH ba bn bH C dF ey 0.240234375 bN dC d cV fb bx ez gM bf R cN dc H cL W q bE dw h cb q bZ eA L u br co cP dt q eG dW cR dV eB bz dm db x dW db bK bq D bX cU bz bJ P V by G bM dy ej eI bF ej da eb bJ cF dX cz h cv 0.228515625 o c eC 0.2421875 cI ef q eb eB bO cg dS j cU Y A bn cK cm r cH dr cq dB w bf bc j eD D Z dN da eQ bE bW dG L bS dM bA eE dx by t eF cf cn cz B eG bI A dG co dV do T eN cS cP eH eI by bd eu cm bH dV bi W da cQ k ej dx N bZ ci cF bE bm L dl eR bX dg ej bf bX cI cM R dD cu eh bZ cz bK ca cx dK bK ey dy eh dY dI bH K d v dW eq V dV ci dr bA n V ch bZ eI cr N bS m bM bA ep eJ eb bH cw cV dy bq J P Y bP cx ch cf dU e I n dY dP ba bQ n cd q dl X ed Z bU do dN a L eF i cp w x Z ej du dF dc cS D dM de ej en dU ed cS bA P dg es U eJ dc cr bT P bn H dM dZ cV bZ f dg cU em U et bU cI m J bR dU bb cx ch L bD s cW do dP ed e eK n t h cg cf g G dC dU dQ bk bT de s p da bM a cw dw eO bl eL H bz p ds bC cB m Q b bZ bP dt u cT y X m ff cl dF cB ca cX ch dU ej br cN cH dK bd O R ds p eB bZ be d dQ i c k be bC bG cT bZ b cv f dv q dg cS 0.26953125 cg f eh w bP bz bq do bJ H cS r bV dy cU o eM R dr m cb ec s bn cd dP dg dT cn dr eN bf U dd bx n cU dK cZ t el 0.244140625 cs bB q dw dt bT b dW cF E bA bK E j bq bc cf J eX cP bH cl h bx X d W cl cf Z eg dy ex do bH cZ cH cV cR co dV q cB cg bl bx gR eT C cD cH eO j de fg dC bE cC bx br ca bR eP cl bd R bD e cg bY dV cD ch a dy eD A cR bE bO ch cX T bL dh cu cI Q a cK y cX cI ds bc A T cD eb em dr bf Q cM 0.25 bk du bt b eJ t ct cU ce cQ dC bE s de cV eD fs r eS em cB em d bB du et ck C cm dw o ba cs K bA Y bi cZ bW O d dy l cP Y by cl f q eB ca cz cg fB cs L V do dW ck cX ez n cB cl L l be eW j el eQ fi bb cK cC r eR x du k cx h q bL C T cp ek cv cr eS dr cC n dx bC el dn o bV dY db de bP S cb B cV i dJ eU eT bJ cK K cp ct l dm G dL O f cN cY R dP bf o ca do bx z dU de cd bq bo cg eU dV bx t dB b Y em dm cf bY co Y D cs G cn cv cM bL cs bT ca bE eD e dI dw bF co dF cb bJ c Y D cs ci f bJ m dm cp dM m dW O be bY cN cN a O A cC bP cz bP O cS cH bJ cL S cN c en eP ck T eq n eI dT dS Y 0.158203125 ed cX gL cT bx bx bL q dh eL bA r dl ck F 0.220703125 cw el cK L cM bP bw dm x P cl bp bK dU bC cv u cg k bH r eQ d cH ck bp bJ eU bl dv cF ef q bS bH bA dt dV ba T eg eV bD dh bZ bx dy cP cw j R cp 0.22265625 du i bl eW cI da F ca cS dM bv dm h bA da e J eK J bZ dX bz bz cZ bu bc cr cL eC w K cB s bE bl gP en eX eJ bn dV cl bA bo Y bw fn bC bl ds P dv dz eP s bh cj k a eW co br co Q dU f ep bH K cK bb bG cZ A co cv dF bF eY bt cp cH cl ds ck dM O dr bZ dz dy eW cq bP do dc eZ 0.265625 cT bJ bk u cI eo ej dH v ea dF bU b bO O bY bL I x dJ bH bj bm dg dC el 0.1171875 bO dr cp fa cI v bz df bd bH m cX dL dM cv cg bX el dB k do cZ dK cw by dm bu cy eT K cJ bx er dj eJ cK u dh cP cL cK dc o bh b dN dg C dN eN fb dd A dv df bF co du L cg cb cn bP cB t G cu be dG dW cF x cK dg dc ds dE dh dE bM eg bx bU g cp eB G fh 0.271484375 m cV cO bO dw eJ fc bO bC ee x R bf s e K dW ct cU fd bH bz m F dQ T bC R H H V bU cX bB k Z eb bZ z cr m dI br bE O bT dc bx cF eo cX cK eg e cv eb u v ds J cX bl F bG cw M bq ch bP bq cH M bU ct bu k P bG cZ bZ M b bW cq eE U bF o T bT cD dm bU cu eo cp Y dF f fe dD bS dy bn bd U bg bi br cU r dv bV ff cq eh dv K bi 0.203125 C k bE fg cU br cJ cr Q eY ba dP n b ec v dm dg dD L D dv da cK g d cH ce L bM C bv i cs en m bD da cp J cz i bC cF ba bo bZ bv cw eb da fA co A fh bG em dU r i ea br fV bT fd bV cB k cR cS cG eT be bC cp X N dr ce bp bb bZ cz dx dt fm ee cs n cG cq bU bA dQ eV cR dC dM Y eI cG bv cU dM dB cW dU fb dN dg o br dZ bM bB ek bT ct cf dZ bi W j L bd bt S eh A dl c dE Z cg eZ ea bn cM bY cH bm bz l bb bK by dM R ep bz j cT j cT j M cl N cg bV i cS dj bd dh O bB dB L co br bp bs bW j bL cj bX g bb bE cH da bM cU bQ G dR de dc by cJ bl ca j du ca A b m dM i bA r ea U bi Y dy cH bn bH cu dc p bn bZ fo cI dg k cV di dU n e c cl bp cy bd cp bf q cU fi bt bO X c eL dX bl cZ dy t el a dX fj W bA fk dx cj bY ei cO bL dK k bX fi bG G ef e bG bL fl cV bu v ds dU dL cl bD dY dI cO bY g ce do dr w F fm fi fn fo V dE fp bf bQ dt dQ ek dG bW eh ct bh j eR cQ ba K eX cl dn dv bO X bk Q bS U dt ck ej ca Q bJ N cj ck eC bg bc dm bz cq bc cq bv d cB dD dQ y dr cG cZ bC J ce bz bh ce cJ cw v eF dN de cK cr V de cX dn K ee eC dD cI br k cT cs bY ey bC fn bM eK bM fq bl n Q bZ bF cq ba bH cN ga cs eb fo M cy bD p cE df cU cO bD dB a eO bA ba bC fx E m K de bG bQ cG de bI N bD cv dr bb ce S bY l G k cp O bu bQ bS t bk de fT fD A h bp b dt dv cZ G Q h bY dr cX bD bi U p cy bO w ej fg dF bZ da bm cl dD Z ce cK cG bS cq dh bn dt z cW dg H bU B cJ E dM el l cQ fo fl bE dP eU cw eF h bf bv Y dF cy dA bj bI fK r bv dt G fS cA bD cs eC fc fW fe ei bh ce bT ee cI dc cc bn cW dn r g R y cX fh fy ef fr dc cz dI eF bh ef v br Y cZ B P Y g cw fs cG fh bY Z y eg m ei ba eu by dN t bW y U ft dQ bh eg dO fu bG bB ed fv K fb eJ cD eM cc br dn P n x bw eM v fe h cn dC cE w dm dt O fk dO bZ N bB p fo g bE eM dA cD dA em bz fv ei em cG eC eg fb gd ft bZ B v fw o fx cV en dS K y fs ek bP eu bo cW e fy eC eu cs fl bl ek fb cW cy co eh cn fH fz fa eh eL p u fi eU dz bI fa df A dm ck V fA V fb ei dc fI fl dQ fU gf cD cE df bi bL P u ge dA bd cX V fi fB cB bL fc z eg cV cY cx de dO z fn dA bu dQ O ba fk fr cB fn fs z A cF cA cC ce D bv z fa fC fo fw gm E eO cY bs eg p dR fO fB cA fe bD N eg fu p eC cY fu fA en fz b fc em fr Q fN en fG fD fQ bB dI A bz bs fR fw ei f fl fo eO fE cC bI eu fb dM ek fF fe fG bb fG fY fn Q fH fL dj ee fC fq fb gj z eu eC fl fI y bn bD fk fM fG fF dO cY bF ch t cE bF ew bs o gl fC fG fy z fb fb fc cW fJ bw E dz dR k fs fx cA gO di eG fw fb bB fG cE fb ei gH fr fK cJ fL L cO fG fM u dG bZ bg dn fM fm fC bZ fo dC fN fX gi fl B cA eu fO cx cW N bj ek eL dI fP bY bh dA fP y gh o R bf eO fQ bF fR fS ef fT fZ eU gD bQ fj fu y fJ fv dS fP fU fq ei fV fW eu fq fk fB bb fl ef fX fB E fC fY ee fZ gu dO ga bw fX fF u en fD gk B gq N fr fV bf m fu dO fe bQ gb cb h fH gc cE ek bi bj dj cy dS fw fp gd en eu fH fH fz cW bg fI p fB fs bb fH cY df cW u eg ew cY fU fv w gr fV bD fr eL fH bj eY dI cx dn fW fB dS fp fc fU gB fG fG ek cw bI dQ bQ fP dM dt fT fl eu ft ge dA fu fb dk gf fs gg fV gg bw K bI fK gh gw bG fN gn gi cD fn fp en fM bb eG fy cy bf fT bh fO dt V en dS dz fD fb dR cG ew fH df fK fH fi dA fV fx gg cO fK bs eU fw fC eY fq fT dQ fz fl cY bD eL fu fJ fk cQ fD cg fH fq fe fr eO fm fh eu fj fz D bj dN o N eh y dS eU s ga o fm gj bh B bI fC ei eu fp u dk cx fh fH ei gt dO eY eG bj cA cG gk fj fn ft dm fT cC fL fH fT fc fK cz z gA gi h dk bj fc bI fQ fi gF fh fs gf dk gv fp t bg bi fF dk gi fn bu fH ge cc gp eY gh fa Y gj gs fl fc fM cV eM ew gl cK eM fX dz eO N fV gd bj u dR eO cb fk df fD cY eU fk eF bs go dI bz gm fW cC gi gb fh dz bB bw fe gf fB fj eu fR bh fS X fw cA fy ew fm gc fr fl dk dQ gm fV dO fy eY dS z eC dt gn go fQ cC fa fi fN ee fk fT cx cE fz dA gz gc gg fV dm gp V fG fK eO cn ft cc ga fU en gG bw gh eU bw eG cc fo ft fq fm eL g fm cJ gq A fW eh bf bF dt gf bg fs fv cJ gr fb dz go fW fD fT cQ eg fS eG fj fq cC fk cW bi df fk fj gi eG B fo gd fj bg dI fN df fA fn fD fD ew fR cD eg bI fa de dk cn y bI df gi fV fX fj en gh fX dR fi gd fX ew gs fQ eG bL dv gk eF fW dk bQ fs cO ce fL B fk dm en fy gk eu gy cG eL gp cG fM gt ee fh fe dQ bw fq go fF eU gx gf dN fX eO gu fr fv fB bE fn eh fw eg cC eY gf cA bL fK dQ eL fa gd ft df gu dk bQ fk gp fB cB go fs dA ce fy dS eU bn fm fL Q gE cc gn eG fX cG bC fV v dO gv y ew fN ge fX cY fm bk fD gu ek bQ cC bU bh fY eg fZ dF ge bi bs dQ fj df cG dt z fC gg fk fk bI fc eO fb fD K fm fj cc gw fN fY bD dO dQ bk bM cK cV gb bI eu fS eu dM fB fR fA P cQ cG gC eL fg cY fm fH eL dO fH fT fQ u gb fg dj fr dS dz eh eM bF bd fo z gg fi fa gg fp z fu fH cO eM cA fH fn fH fl bL dR bB bf cE fI fw gn fQ cA gf gj cy fX v dk fl eh dA eu ge gu gx cB fo fR cW gr gw gc cU fG gb cY fE cb eO fU E ga eG dS gj dC bI fu fm fQ eY fW bQ gy fr eO fa fq fx gr cG gr cG dz A fK gr fC fe fQ eg fp eO O eu fa fU ba dO fx dS gr eG fc gw bg co V eg ez dN eF eO u bF fq fo fU fi w ek fS fl cQ dO fr dj cY cy bY cT fX cB dj dn fa dS v fh bB gs dR bu ft eg bQ fh w dA gk fu cl cW fz fj y fo fr cc p t fh fR cx dQ eG fz cW fo eO dN fx dk gz ge fj gA bg bG fF gp fT bf dI bV cl fv gg fX fj df fl cC bk fh fl fB fu v fy bD gs dz eG ba z z bI fm cn fF fa dG gh fX go bw fy eM bs fm dQ eF fu dR r gi R fX fC fG bI bH gi gl fK T eg fa fW fj cY fB gc eO ef bB g bj dR eM fX bD gc bh cV gi bQ ef cy bw eF fx cG ft dC fh gj bw fk fD gm fB fU eG fF fK cA bS cY dz fq fr bS fC bY dG bu eY fw fq cV bI cW fv fE bk fp ei fe w bh fx eM ee fb bf fH ft gd bQ eu gQ gi fk gk dk Y N dO bD go bu s cA ee z cV gm f z df gp s fV gi gf bF bj fL bw cA bg eL fx gc s gr B dj dP df dm cy fp fw cO dN bh dj gd gI dm gu bF cx fm fE fy cA Q fv fD bw go cO fB ca bY fl fK cV cv cx dM fl ft eh fu cx cQ bw de fl cB fH dn eC cD fH e gp ef bG e dC fi dk fA gs gi eC fJ fr R Y gB ef fU cE de cc fx p cA fQ bI en fA bY eY fq fX dS cA cE fX ei fA fb bB fN ba ei fU fV eC cQ cE cE cC cw ek fY bs el cQ fW u fe fy bu fw N Y bB eu eO eu gC cO cz fr gz bb bi fx eF eU dQ bQ gh bh fg z Y gw dk fk df gf fA cQ eh gk em cG dk bg eh w eL dC fF Q bY dm fp df fZ gb fb fu fV cW bz fS eU fm fq eM cC bI fx eh bI fc bw fb g ge cC bB ft dz ft fU cE bQ bI y fl fn bY dO fN ee fW bG fA fc fA fm fl dV eG fs bu N fr g fL gx bg fn cB dm fg df cY fF fL dn fM bf bQ 0.978515625 dO bG ce fS gu bj gj fj ba bs cY fn N fU cB cV ei bs dA fl dC bB gD t fu B gz bg fc fc bE fe cw cG gw eu cY fD fJ cE bh fe bG cJ g fz eU fa y eO cY ga cy fq bu ef bT bF fa f cY fU gg bg U fH eM ga cY bV fi cD fl fM bE bQ p fi cE z fg fN fv Y fQ ew eC fE fv bh fl ei dI bh B bX bc i dS u fV fc fE ef cQ N ce P cy dz i bG eF fr N bn dk dR eM cy B gt ei dz dI gm fJ gz ef gl t bl dk fF dO eu E cV z u cD dz fk eC do cU Q cT eg fs ew cO bc fU fo ba bk eu dP gE eU U fi fU dN p ce bI bF fX gn ew da eM dj ez dA ek cy bB fc P de fI e fJ dR gf cU fB ei cy cQ bS gF gg bs bw bY gu cE N dk j eF fc eh cx bj cE gz cY fF dm gx fM bB eM dA bj dz bf ew fE bi gp cY cA w dN fN fw bY bQ U p fk fM fD cI fr N gs ce dk dM fE fK fX cD fG fr m cV fh cW fX ew fX fB dO eb bj fm fe ew co fQ fm de dO gf cU dt fi fF gz k co cX bL cV eO ba dR fa bG fJ z dI fi eG cE cW fb de ge bY bY ft eh fw cA s dS g Q gG bM eu fX fe fu gJ gH z cc cY fb gf fQ fg eL fJ eh fs cK fv gF fW bL bZ eO dN fi ee dn dA cC fn bB cx K df fy bi fl fg gs fI B bw dt bn fw fh fW cY fK fw fl U fN cq gs cH L eg fW dI gi fe v bM gb cy ei cW Q fF w dV co gs cW dQ cY f bs t dk bj cW fv ge du ej L cc fB gg fu df fG fn fQ dt fJ bb bI fm v o fW go bg dr co ft cW ee bT df gj bQ dk fX cI cA dR y gE r y cO da gj dR u fq en cx dA bw fQ bu fG ei bL o dM fF bB fn cy eO gp dG cW bG bu u fl eF cz fE bD bE dC e fZ dI fz eM dc ba fk N N bB X bB bl cw Q fK bG R dR bQ fE dO fm gr cG n fh go bS cB de dO fK cW fb fV fz fh cC dN fR fv cY dA cx gE A bF cq dR fl fc bg gE cE fR fa de z fv eG ei fJ bb ei fa gu cy fG dn gp dN cW ce bF cc bh bi eO V bw fW gx dA cA gw fR di fW gr gg bo eY s h eu dR eL cx bZ fy fE fI dI cV gA cG eM cy fI de ek bg fG cv fH E y gf fQ fq P dt cW cK eu dM bs cO gh eu bQ ce dt ck y bc s fx bF bs fI t cV dR dj eG fM dn eU b cy B X fD fS P fh dn dI cG eg fJ bI r ek cB r r cO cw ch cE E gk ek gj fH j gu eM f dP cO fU dR dk n gH cO eL fF eh bw u eh cz fA y da eO cy ds cE gx fK eF bQ bB eO q eR cc co gG fL o gr bY fA fk bs cT eC bB bs eC fM em fq cT bQ fA fh J fp eU fZ Q dR fB eg N M dO bc bD gb gE G cC bj gj eC cA dG fK cy fo dj bD fX fM bu ce gp ew dM ce cx N eC fN B bT ge eO dN bf dA N bl bb eg fE ef gh fC gi eU fM fi cy ef cy gh fZ ew bB cF o fm fd eC bv fk fl fa dQ dA p gE cw fo fr fh cE cL eG bF dO cA fr br bZ gk gI de fn cA dP fs cE eU fl ck fC fv cF fT eO dA cE fv br bk cD f 0.96875 fz cl fQ ef gx ei eO bZ gb k bY cC eU eg fM eh gy cC bZ de bD bM cy fA bY cQ ee fq ce dz cY bk bE bQ bE z X bn K fB ee dn cJ fr dQ eh fi eh fk P M a fh s fW fw dz bB bB bE cn bQ fK fm fg M dj dP gp fJ ca fX bj dU ba cx bS fl dm cy fv ei cC fz P bb gj cB eL bW u b L cq fk bG bB eh em dB cT dj cw ei bS dC o E y bS de bV fe dm gr n gH fb cc bQ fE L cO df bB cc fn bu bf fJ dQ fy cG dG fe k P ft X bB bh br ce fS w fG fY ef P cG fX fk bI fa N eg fa fW fz cT fk da bM n cc fq eu ce cA fs dA fX cE fm eU ds eW fk eg gg bd fi fX cT o gc gg fA cD dQ bQ ck cV eg eG fD b dV dG z eC U ge dk bv fi fG eO S cH gF u Q cO bh fw eU bs fM dI n bo cn dA gI dm z bQ bz fB dR ek O p eL eU bb N n gr fz fi k bc eh w fr fN K fU cc bY gf cZ eW ew cx bG ed dk eg fp Y bV ef dP bU fE bG fg fb bf eg fv bW fa gt fu z eO v i bS fP bi de cg ee dN cD gr cQ eG bW cV fl fh cc fM eC ek bi co fz fo cV bk bi dj fW fi dm gp fs df ge bE m fm dI dN bg dS cG cw e eO co fQ dz bL fp eg bj fh ef fp fe N cC m bI V bB Z fn eb en dj fg fI fl gw cm fw D u dI bh fa fo ek ek bG fn bR cC P dO ba eF bK cq bB eU bT bn gw fs fA dM cq fm cJ dc cT gg cT g eW fx eY j dn fv bj dC N en fV en ba ga bQ bk bF eO cG Q bv dN dM v cW gn dz cA fa eC cU g ek ew bw dA bA ek gm bI gy fH dn gp bd ef cw ek gF cE eu fU go cz fJ fC eU fQ bs dt dy gn fo bg bk gw bi dV dn cG dO bb fh fD cA cy bQ gb fh df bh cE U X ga dn fJ cG cy fN cF dj fU dI fY cY cO fw bQ gr fh cD fO cQ fE ft fn fX cj gk fe z fk eh eL cq fU dr cg cx fk gA bM df p E bF eF ba u cA z ee dj s fa gx B bB N dn dv dQ dQ eL fU do k fF bk G fe U fz bY ce cA F fb dm dn ga bE bj br dM fo z eg j cA gx bg bS eh di z dC cw dc fJ s cC dR fg bC cC w fD bB dt bf fn bk dN dt e fs gE gt bc dz b bU fm gf bQ bS j en bQ eh cq bT H L cJ dc n fU fm V u ge fH fb dc gu x N dC gg bI fq bz bn bQ bb eg cw gc gp bM bB w fc cD eU bI bZ eF V fO bh fH fJ bL N bl fp bb bw fH bQ cw bF fp bT bz fa cY cq cn cQ de fF D bF ei cx cQ cz fg da l el cX bD en s cY y ew bS bF w bw bl E cc fm bD bF eG ge dj w ei fs fF R N w ft H dz dm go l cO bS cX ee dG y bb bB fe fi bB dn fT z dU I cm dl fr fN dt fB O bs 0.962890625 cl cJ fk bk cO fb K eY fv O X cC go cX cH e cD bI ge bM go eF cB fo fK r gj P dB fV dg g eM b bQ fT E cV fG L E cc bG L dG bA fj fe fv dN fU cc dS gs z dn fu cU fA bb cE gj bs ek cK Q A cx L y fK bl cx fn cC dA gh gr bh m ge fU eL cV dA u fC fG bI B bb dj gh fm br fx gg cY bw de bw cc cU f gJ fK fw fg fs eF bP gq fK ft cd bf fW F cq cy gc cB cE en c ee cS bc eh fi fj K cW fI dN bl o fz cc ft fX fH fC da j cC ew fV fo fk ca dN dN cw dv dN X bU K bf gK cH cJ I O dz bQ dz bL fb dG cY cG fw dv bg cC cx fQ fK bL fX gi K dV cT p fs dI fn ef fh h eF df fW bw h cE fE eL gb gi dk fW w fj u cJ ft eY U dI bT cx bZ bM bi dG dS dt bU fC bA y cW k bs fB bv gc dt bF fn bv gG fi cx eO ga fI dO ef L dk cv dG dr dI dj cW bT fn P fJ fA cz ce dG bu en ef eh V gq bc U cO y fX fn fm cE gn df fX bG cG L bS cB cv fm cB bn bw ei fm fg cz bA fX P V fb dO ge el bv dc cs ga cD fB fF fU fn de H bi bD dv cH cB gn dC v bS cx eh ce ej fX t fh fv gr cO bw eF dC by dz eG gt eG eC b cQ dR bi cx gK cH o g w cH g fM fX dA gs cG bQ eC gd dt bg dS K dI bZ fA cy s cY bI bi v dS cB fp n ce bY cC bf cn en fi J fO bq go bc bG bd gq en bY bs dn f cT cy w cG G eM fk dm fk Q bI Q fq fb bI s ba bi fa bW df bg V cJ bF bF fk bT dV V N bH cB fh fq V bM cc ck fK eu cT fM cw dV gf fB eY eC F dP fx fh bu fw ef cJ fn fC gh A cm cj fE eG bG bT 0.263671875 cD eY gr fb cz de cf z eM bc bj K u cK E bw fv u fo g Y cE bH cz dJ z bz bG bT bA bw w bG bf gl b dc fn gk cb r fl df cq bC ea ba bI ei ew eL dQ dt gF bn fW bh fc bi bu eF eM fS cw y cO dO gg bs cK dm eU cO t dz p ei cV bk bb Y eU j fm eG bM fc bD fc bb eM bA fw eC y gs bi fS eC cq v fp eO cn bW go w dP dc bC bE eh K bG m cb K cy cA eC eC M fv de bw fo z h bB bn dc fe fP eC cx dj X dt cV Z bD eg en s bg fS eg ce bj fz cO A fr cY eL bC A dd ei bT cc m da z fi V ba dC bV dj ca cJ dA en cM cy gL dV bw fA fW fs eM cV dj bC fn ee n cJ fE gg gp dW dA z bD dG cB co fv ew cQ gd g eG em bG fD cG cU bY cW gk bY eF gb fa fp eg eG E bg dI bE fi dW fj cq dj ef fX i U fl z o fL ef fH eU bW fK f ft br fc dN co gE di em fo dX x b bi dt cS cy bM fW bb fb fr cy fm Q z fb fs cV G U cX fi cV fx bF H h h bu bN gM bC bA bV fU eU cg eG fT U bL bF bj dI ba dy bv b P bM de bs u bq cF dc bj cV bz fU Z Y fU fa fw eO bi fu cq G o eG fo H w eF ef cO fs dO eU 0.232421875 bf ej D fa bv Z b bs dM dg bF eC bN cy gu fs gj cY bD ei cJ de dt cD fr bs bH F cX P fU dG cJ cb bI dN u bb fC y fy cV eN bk dI cC ba em eo eb bn fE gi gn fe cv cC K O cg dr fH w gj cV fD P cU bF K fi eO df dG by ee z m l e bB Y cE ee P bE bc F dj bL Q ba cx bD g fU eG bE b cl bj fo em cD cW dv dS bz fo b eh cK fG p bi gj dj fK w bQ fC dG bi p A bu gj D dj bz O bD o do dQ bM bG dz eM bM cn fi V cq dN fk dA eg fs cy dj fu df fm eC bi dA cx bD bw bD A dP cE ba eh de r gg dm fg dG dr ga fr fz cV R fh dC ba bh cb en dz q N fY fo bh fW ee bO r fg bS eO dI fo fq cH bc dr bb dR bI fx eg fh dn fa dy cQ bi br cC dn b V bF bM cV fQ de dR M fK A fa bc eC cX es bY gk dQ dc m cb cc cV fr bQ ci cw co eL dN u en fE fG bo fb n bX gr br ft cG dP eh Y gf cG cx u fK cO bI eL s cr fe eL eU bw z f fe fM ef gj fB eY eY dN cD ca fX fh u fs cz M bv fM cO P dm fX gi x bQ bA fM bM bI B bD cV v H F gh bQ fT b fD m dj cU gh fr bc fg b fG w dC bf z dA cA cw cG cX fp dt fo fM O cE dV fY k y dO cO bI U co dz i j u O cY dF t bg bD fQ bi bI eC cT bB cU fb bj dv cE fT fo fw bw dy cX R cD bh w bS da en bZ cW dv fW V ef gx fc m fl fw N bS ft T fe cS dz ef bv dG eF bY E eO bL ch dA bu fe eb dS ft fL cE fe gc fn dj P bc fw cH ge f cV ei c p fg i fr bj ei fV bz dV bT z bD fy de fu w cy fr cO eL bf eC cJ bx dG fj p ch ch dk cE z fD bI cE fX bf fH cY b ei R cO N cx bw eY fr bT df y Q fA dz ca bi dC fi cJ b eL N ds fE bU dS cy o cw eO dA bD K bL eh u fs dj gE O gG dj bB cF B eb dk eu y bu dz w bi fw dj cq z fo gq cq dN ba dj cJ dz cx en bs gs cx cK cV cA K S fc da cE V bD bn E eJ dX dm bZ eM fU bE df ee fV bg fk bs gp bT bC dc ce fu fx o K fm du gA cO K x ee fX Y bE eJ E bz da dQ dN bT eU O fB cA dC A dm eF eb bI bD ef em cA dK fc ee s dM ca V em fL bL gE fD cE fE de fz fc fG G bg ba cy bB cK fL dN fk fn eL eL cV cE gi ee fw R t fC fs cx bE fT A eF bv dG eF cy dk fc fc cn dP gi bn dI fJ fq ba eb de bY fJ Q fs dk dA bI dQ cE N eU fH fG u el gc fl dD cJ gJ ee bD gb en em cC cc bi dk dw dB fr cn G fE cF cr dk w da dr fF b fU bv fn bD bi cQ fs fg fa gr fm fN y fA bD bp ge R Q bp gh cj fs gd k E Q cw cU bs fD bW fC bk gj bu bF fE fp ef N fx p cT dB cy fC gh bi dU dn cF dr dn L bT N fB eF fo Q dt fF D e eO fw bE bj dA bD bg fB V dy X dQ z bB de fl B fb eC cn dt dm t dx fX ek fA dO dR dS cx bu da gE eu cl dz fX dj cC H fw bX dM s ek cQ gE bW fG bL dQ eU eU bw eu gj cp bF M bv fa eO dE fW d Q bC r cz fi bQ eF fN bD S bu fx dQ Y N fQ U eU ck fi ef bH fm dm bi bi cr fM gm ep q fG fB fs w B eY df cB dI fK U dz fb E fo eU v cx fr fG bj ew dn bn N be cV bI v eL fN R dk bz dk bs eG m bw fv gd cA bi P P bX fX cc cH bs bc fU D dr dS dM eb bE t dB cB cg bi h ch bB cD f cy z fp bU bb bs dR bz df cD e eu dP B Q P bY fl cE ew ee fQ bE dR bY o fn fq fb bL fk cY o y eL gd fe eu gt fu dm q bS df ef fr dv ft cD eM fg bF fW ei cw cw bb bG dz bE df ba bl fu dj cT bi gG dA cx bV bk k t L fE bF y dN cw ba ct fi dS a bl r gE fe ge cV eO fQ s cz bl cW t fW bW do dF co ee dr cV bc fq cJ ew cX dG dN gy eF fv de dI eg dA bz cK fN dj dR dk fC do bu ew fr fl cG cW cW bG ch cy K dt gG j ef u co fq bc Y dc eM cs bI fJ fh U eg p 0.96484375 cG q dm ew dS bu cV fw fl fo bu bP fi b fg dk fs bw fJ bM ei cx de bh E gj Q w bQ m fC fS eb eF e fv dv dM r fx D B bV bU fW X fH ei ei d ei gu m dg A cO v cg fu P da V dA bw bA E fQ eU eO br V fF bs ce P cQ bB U cA fw fm fT eF cx fv cO cw by o cs dM bn dS dS bn bq dv eU dy fE eM fe fi cG bn cE cy cV fc eg fV di fg R eh bi eO bh bM en gz dk fG ek ei z cC cS cT dj bH gq dc cU dG O dI cy bG D fQ cx fg fA fo fm cD bQ de y gJ bT i b ei X cB bc cA f fd fe fi dI bc gE cJ fR bi bk w X r dm bz dn cc dS cD s bK F bQ bi bF bS eY l bM fn gJ fE bl fX k bf n bQ bA m br fs dn A bC d F cn u ew u ew dR bS i eF da bz ej bU fJ bY eL cW T U bI ei fu w eu g cC fo Z dt cD bk de fk bn bi z bL q bP dy fm bl bl cE bc ew X g gh da fT fq N bH bV em fL fM eL cE cy bQ cb cc bQ eg bg dP bu cT N dQ bI bI B eh bE fE ck bn bT o ek x bD fB bY gI fD w A b fk cn dG dW N gD gh fF fo br ey dv bT bS fH cD e p fj cQ dZ gk bD cY cx cC cT eg e bZ bM dc E dI eh cQ dQ F eh de fc Y fp cQ dc dA y dj dk dM ek ee de cW dx eL eb bc bb cb cV cb bL ef cU em du co dI gl ce dy cb cG bm d ee X e cX fb dv f bU cK ft H bd dj bI X eg bC m dR em ce dg b fW A bX cn r fL X cS ch fb bf bv cs fW dO q o dy S B dj fc cO fw O fe bF r fg y cQ dc fe dz cy bu de eU p G G A K t fu U cK bs dC bF dM cY K fS cO dS fa bn fw o eC o cB cK dQ bC ee dv fG fX bG fB fE gz cj eO N fX en em co m eJ bM bv fW cE fb cG fa ba bT x dc dj ba bE eM cW fs gs D cO ej B cO ch P gF u gi ef gk cb P bH f cv B cW A gy Y cv s L cx i Q b ew dI eO V F dc Q R K cX eO dx bQ ce bi cn gc ek L bo dV dn cw dP dO gi fI y dz cA ee bk bQ Y cq F ef fD bf fB M G bz gc eh O fG fC ei E cy N bj dt h fT eG da eu bv P bh fV bc fB Z em fb fj y dP eF y cq bF br cy q fs cB p cX cS eC bY fB a P bF cT T cK bj ec dC gd eW ft cD A o dG bn ga cT ch ej cO s gI D cc cb en bn cy eO q dm bv ce eC cn dI B cc fq eU bp cy dc cA dO z dA Y bg bT ee fi ei B dz ce eO gp fs V u en bj cb bs de bv fM bj en dy eL bY fq o cQ bq bB gi A cB eh bu dN k cT eg E bn fG fW dR en fv gb cQ bE fa bI cw bk bB bU o fC ce dn ga dc cG bs dt h cV i cH V dI bu fQ co ei bD bP cE bh cQ dt ef gN eg d bI ep ca bq fX eU bL bU cQ bi fU bO de gD bs cJ fg B dn v fv ch eu dS cQ cu fo F A cW dR dj cz fg ep cN gr dn bo fV fx fu fx ea g fb ga dI W bF cD N cD cJ dI cy u cU cG E dA ei dv N dr fh cb em dQ fs cD cW cY dm fL bT fD cz P bA bM en cl dW cA dz cF eY cX o fm cJ bf fJ bY fa f bE bx bO fW fA bo B cZ fa Q bg bc bF eL cK y bH cQ L cy cB cK M cc o bH cx cX cV bl bD eY dO dR ek F dA eM ba cC cD fG cC dt bs fK cJ dj bI en bw w bI fe dI bQ dm fH V bM cQ dA bM fV ef fn cC cy bf cQ bY ei Q cF s R dN co eU eC fh y em ek E eg cg fV f cn gq ck fA ch eF eU fg fs fr cX ef gO cp gA bV fe dO bn bi cI eh cU U de gs cB dr eY eh eM S dI R A bL bA de 0.23046875 cw fx cw cb fc cr dm R bB ei fB bg gh cJ cI r cp bl dV cP bL bc bZ cC fs eM cg w fw dI p bl bT eO co L fr bH ca fv cz cc eU bF g eC dB fU fc dn cw ew f cm fM ch dP bC bb y u x dS cl dP y J gd cE dP bT fm fe eY cb ch dt fn eG bi c bh U m cg bd q fW bA t bY bE fV bT s bQ cJ dm cG bf dI eF dQ dk cg df cc ck dy ek cQ bD bn z z dQ ew gn ek bV fw fE dz gi bQ fN y da o N cV cO r cY fz fi bF dG ce U bc fG cV ek bG cX cQ di fc bC gP dQ bu dc bu X cx dQ bj fD cD q S w fv cm cB fw do bv bP z cX dV bF dm dz fy bq h dj eL fu fu cB cQ bu cI bn bj bf cn ce dz cw ce dI fz D fm R bg dG L de bm A ga fu V cB bw gg eC fa cU dS fm eg fx bQ bj x cb ee M bg bs bj bP L bY ef bX fi bx e cx bF gp cU en eY bi bg K fU du M dv fm bv eW dq bw dA bv cD z dm bs dj fr H cO bQ fb fp bN co ba fr s fW bS dA gc cr dP fx e r f ct Q o dE dN dA fL K gQ u cz fe br X ek bw gD eD fG bn ek cg dA w p dk Q bd eQ Q dv bc cJ cB y gh cB A bb cl by bQ fE cE dn dm eu eU fr bn dM E A cq bi bG dQ Q fa bF cJ ge bT dt ch cz bg bw fG dR bA ch A dD co bU cI du O bL cD L bg do bj dM gE bB dt cX cJ cD er ds eh bO bj bz cn eh cO cE bA eb eF bH f X fM v bY K dW fQ dn z dN g bz eG ez fO fz dt cb cx ei bV gi fh cW bY ek dC bE bE bH bG dn dD cL x ge k P ei fb dK bK b m cN bD ee cY de cy cJ co i gr dr em bA r ef gd cF fE bB bw bG em A bG cE j dv gR p el em dQ eK p X dO fk cm f de di fY fr dB cQ eG fb bT gb fb fX S s y a eu fz fo dI dt fN u gw B eO G bb F Y fB bD dm cX fS dy bS fn dy fv gl cJ dm fK q cW bQ fn df bi ge y i fz bF G H gi N eF cq fn fT dC y m bL fp cs fX bu ft ch dG dP fu cx dj g dI df by cs t dA cI gr cJ eK j fC fs bn de fe bC e ca cy bh fH y eh dt cV gE ck cs O fK dv dc bZ bb dk dN K fN bz dw bw cz fn cD eC q bt bF dy ee gF fw cw eG cG fu dI gG fx fc bT fK bC fv t fk em cX a cG bz fm di x dQ dS bb fw fn cI G cG fI P fg fB ba fB bu B bi bu fh fa cD fK ge cq cQ p bA 0.130859375 fM O G k cJ bn fA fa ba ck X dz cK bd bZ bL fu bS m dM da ce cZ p cY f bI fm s bD fh cx eF t B bY fT ee B bl fl fB X dw go fk l ed cW gx Y bk bH bv cH cq ei fW Z cU bM du bc O eY h k eL cz cz b eO V fX fv fb eh gw fp dV fS fG ck cr cv l dH j cQ cG fX ei cr Y em cn fe ge M G B u dz gz eM cC fL en br cB cW cn bs fo eY cX bz cW fm fX da v eu bi N dt gi bb bQ en cW dO bF V w bM el bZ Q bC fo p fb O eC L ek bY cQ bu dW eY X r bU bM fS Y k fH cX fh bz cq cb ce cz dj bK dJ U z cn dF dB eE en fw dh cx gi dX ce n cO X bL eg bA el dl gE bC 0.16796875 bl di fB fk bY bd cv dm cJ bu bz fb Z P dm bf dM K dw fK fm fD K cy eM eO cG fE dj k fm ga dM cg ew dz gi ft bZ dP dj dc by ge f fr bj fM d ep cb fk dg bz cG eu en bG)));(display 'Loss' ^(a:5.002 b:3.538 c:2.604 d:4.269 e:2.597 f:2.492 g:2.356 h:2.183 i:1.439 j:1.701 k:1.129 l:1.454 m:1.407 n:1.87 o:1.156 p:1.032 q:0.883 r:1.063 s:0.926 t:1.166 u:1.323 v:1.138 w:0.819 x:1.48 y:1.124 z:1.303 A:1.33 B:0.923 C:0.996 D:1.155 E:1.034 F:0.924 G:0.712 H:1.375 I:0.772 J:0.985 K:0.945 L:1.126 M:0.84 N:0.847 O:0.896 P:0.964 Q:0.89 R:1.382 S:0.839 T:0.678 U:0.812 V:0.731 W:0.74 X:0.824 Y:0.525 Z:0.68 ba:0.498 bb:0.728 bc:0.979 bd:0.649 be:0.878 bf:0.869 bg:0.947 bh:0.659 bi:0.966 bj:1.078 bk:0.563 bl:0.601 bm:0.795 bn:0.863 bo:1.2 bp:1.08 bq:0.632 br:0.885 bs:1.052 bt:0.813 bu:0.851 bv:0.609 bw:0.887 bx:0.742 by:0.558 bz:0.681 bA:0.69 bB:1.108 bC:0.821 bD:0.76 bE:0.669 bF:0.703 bG:0.639 bH:0.658 bI:0.387 bJ:0.686 bK:0.46 bL:0.497 bM:0.577 bN:0.437 bO:0.894 bP:0.773 bQ:0.539 bR:0.648 bS:0.699 bT:0.61 bU:0.892 bV:0.786 bW:0.715 bX:0.4 bY:0.635 bZ:0.692 ca:0.874 cb:0.642 cc:0.747 cd:0.541 ce:0.617 cf:0.675 cg:0.687 ch:0.597 ci:0.405 cj:0.554 ck:0.516 cl:0.591 cm:0.58 cn:0.393 co:0.803 cp:0.761 cq:0.837 cr:0.472 cs:0.596 ct:0.534 cu:0.573 cv:0.769 cw:0.704 cx:0.771 cy:0.564 cz:0.502 cA:0.475 cB:0.485 cC:0.622 cD:0.545 cE:0.691 cF:0.455 cG:0.524 cH:0.423 cI:0.634 cJ:0.583 cK:0.572 cL:0.682 cM:0.527 cN:0.373 cO:0.762 cP:0.384 cQ:0.439 cR:0.6 cS:0.519 cT:0.457 cU:0.826 cV:0.521 cW:0.445 cX:0.64 cY:0.588 cZ:0.561 da:0.796 db:0.546 dc:0.551 dd:0.799 de:0.629 df:0.706 dg:0.834 dh:0.493 di:0.53 dj:0.594 dk:0.489 dl:0.514 dm:0.449 dn:0.599 do:0.458 dp:0.361 dq:0.625 dr:0.492 ds:0.543 dt:0.48 du:0.663 dv:0.607 dw:0.474 dx:0.587 dy:0.394 dz:0.447 dA:0.412 dB:0.54 dC:0.56 dD:0.476 dE:0.628 dF:0.523 dG:0.389 dH:0.404 dI:0.506 dJ:0.816 dK:0.436 dL:0.677 dM:0.553 dN:0.716 dO:0.379 dP:0.399 dQ:0.431 dR:0.47 dS:0.67 dT:0.417 dU:0.413 dV:0.565 dW:0.314 dX:0.535 dY:0.426 dZ:0.466 ea:0.544 eb:0.451 ec:0.574 ed:0.482 ee:0.552 ef:0.381 eg:0.456 eh:0.667 ei:0.35 ej:0.581 ek:0.296 el:0.331 em:0.443 en:0.602 eo:0.557 ep:0.446 eq:0.365 er:0.374 es:0.662 et:0.57 eu:0.51 ev:0.494 ew:0.518 ex:0.951 ey:0.376 ez:0.32 eA:0.589 eB:0.668 eC:0.302 eD:0.284 eE:0.468 eF:0.444 eG:0.369 eH:0.442 eI:0.307 eJ:0.303 eK:0.664 eL:0.637 eM:0.478 eN:0.344 eO:0.636 eP:0.406 eQ:0.334 eR:0.496 eS:0.484 eT:0.411 eU:0.332 eV:0.358 eW:0.508 eX:0.339 eY:0.239 eZ:0.408 fa:0.357 fb:0.33 fc:0.378 fd:0.315 fe:0.388 ff:0.505 fg:0.495 fh:0.421 fi:0.585 fj:0.355 fk:0.479 fl:0.309 fm:0.287 fn:0.368 fo:0.538 fp:0.324 fq:0.348 fr:0.356 fs:0.428 ft:0.328 fu:0.274 fv:0.325 fw:0.556 fx:0.31 fy:0.512 fz:0.504 fA:0.347 fB:0.39 fC:0.402 fD:0.52 fE:0.515 fF:0.3 fG:0.242 fH:0.614 fI:0.326 fJ:0.415 fK:0.286 fL:0.383 fM:0.343 fN:0.336 fO:0.36 fP:0.327 fQ:0.364 fR:0.329 fS:0.266 fT:0.304 fU:0.345 fV:0.285 fW:0.29 fX:0.416 fY:0.34 fZ:0.44 ga:0.318 gb:0.295 gc:0.316 gd:0.386 ge:0.209 gf:0.229 gg:0.333 gh:0.338 gi:0.435 gj:0.282 gk:0.351 gl:0.396 gm:0.341 gn:0.321 go:0.342 gp:0.267 gq:0.293 gr:0.215 gs:0.375 gt:0.337 gu:0.203 gv:0.248 gw:0.298 gx:0.38 gy:0.434 gz:0.271 gA:0.288 gB:0.299 gC:0.278 gD:0.279 gE:0.353 gF:0.218 gG:0.257 gH:0.291 gI:0.414 gJ:0.245 gK:0.221 gL:0.227 gM:0.217 gN:0.419 gO:0.252 gP:0.255 gQ:0.385 gR:0.483 gS:0.238 gT:0.301 gU:0.349 gV:0.251 gW:0.222 gX:0.241 gY:0.511 gZ:0.352 ha:0.311 hb:0.235 hc:0.536 hd:0.313 he:0.308 hf:0.275 hg:0.27 hh:0.204 hi:0.219 hj:0.37 hk:0.196 hl:0.263 hm:0.43 hn:0.258 ho:0.246 hp:0.224 hq:0.289 hr:0.297 hs:0.28 ht:0.317 hu:0.181 hv:0.24 hw:0.228 hx:0.501 hy:0.62 hz:0.199 hA:0.459 hB:0.254 hC:0.231 hD:0.22 hE:0.401 hF:0.253 hG:0.269 hH:0.281 hI:0.244 hJ:0.236 hK:0.277 hL:0.335 hM:0.265 hN:0.294 hO:0.201 hP:0.21 hQ:0.213 hR:0.465 hS:0.261 hT:0.208 hU:0.173 hV:0.272 hW:0.237 hX:0.2 hY:0.234 hZ:0.216 ia:0.187 ib:0.23 ic:0.179 Zid:0.169 ie:0.264 Zif:0.319 ig:0.195 ih:0.188 ii:0.367 ij:0.273 ik:0.193 il:0.139 im:0.156 in:0.165 io:0.205 ip:0.176 iq:0.183 ir:0.159 is:0.452 it:0.214 iu:0.207 iv:0.119 iw:0.186 ix:0.202 iy:0.192 iz:0.19 iA:0.152 iB:0.243 iC:0.225 iD:0.137 iE:0.162 iF:0.167 iG:0.259 iH:0.194 iI:0.135 iJ:0.146 iK:0.185 iL:0.17 iM:0.158 iN:0.359 iO:0.16 iP:0.161 iQ:0.197 iR:0.233 iS:0.145 iT:0.211 iU:0.178 iV:0.189 iW:0.171 iX:0.172 iY:0.198 iZ:0.312 ja:0.157 jb:0.166 jc:0.226 jd:0.149 je:0.206 jf:0.107 jg:0.126 jh:0.168 ji:0.174 jj:0.155 jk:0.134 jl:0.129 jm:0.175 jn:0.177 jo:0.141 jp:0.153 jq:0.247 jr:0.125 Zjs:0.124 jt:0.123 ju:0.144 jv:0.147 jw:0.138 jx:0.116 jy:0.306 jz:0.143 jA:0.12 jB:0.163 jC:0.136 jD:0.111 jE:0.131 jF:0.132 jG:0.121 jH:0.082 jI:0.276 jJ:0.114 jK:0.115 jL:0.122 jM:0.091 jN:0.14 jO:0.148 jP:0.232 jQ:0.112 jR:0.097 jS:0.094 jT:0.18 jU:0.142 jV:0.127 jW:0.133 jX:0.11 jY:0.128 jZ:0.184 ka:0.1 kb:0.102 kc:0.104 kd:0.105 ke:0.13 kf:0.08 kg:0.113 kh:0.151 ki:0.106 kj:0.154 kk:0.098 kl:0.103 km:0.086 kn:0.081 ko:0.223 kp:0.108 kq:0.095 kr:0.069 ks:0.15 kt:0.117 ku:0.068 kv:0.083 kw:0.093 kx:0.088 ky:0.085 kz:0.118 kA:0.064 kB:0.076 kC:0.084 kD:0.099 kE:0.092 kF:0.071 kG:0.063 kH:0.072 kI:0.075 kJ:0.061 kK:0.065 kL:0.066 kM:0.078 kN:0.077 kO:0.096 kP:0.07 kQ:0.058 kR:0.067 kS:0.089 kT:0.074 kU:0.087 kV:0.09 kW:0.109 kX:0.044 kY:0.059 kZ:0.05 la:0.055 lb:0.062 lc:0.056 ld:0.073 le:0.101 lf:0.06 lg:0.043 lh:0.053 li:0.051 lj:0.052 lk:0.079 ll:0.046 lm:0.045 ln:0.057 lo:0.047 lp:0.042 lq:0.036 lr:0.054 ls:0.041 lt:0.039 lu:0.049 lv:0.037 lw:0.034 lx:0.025 ly:0.038 lz:0.048 lA:0.03 lB:0.04 lC:0.031 lD:0.028 lE:0.035 lF:0.029 lG:0.032 lH:0.024 lI:0.033 lJ:0.019 lK:0.027 lL:0.017 lM:0.021 lN:0.026 lO:0.023 lP:0.015 lQ:0.012 lR:0.007 (kC 1.068 1.872 4.271 3.664 5.606 5.752 4.655 4.241 3.744 3.826 4.632 8.164 5.232 4.32 6.137 4.122 a 5.279 5.118 4.479 2.777 4.864 4.237 4.786 4.163 6.59 5.265 6.173 3.986 4.849 4.2 4.379 5.577 4.812 4.102 2.657 c 4.783 3.838 5.023 5.917 b 3.927 5.818 2.442 3.873 d 3.616 3.936 4.818 4.664 4.719 3.693 2.513 3.224 2.824 3.379 3.611 4.714 3.85 2.52 3.998 3.704 2.176 3.039 4.62 3.952 4.862 a 3.667 2.939 3.658 4.329 2.89 3.41 2.934 4.359 3.005 3.918 4.327 2.41 2.392 2.828 3.125 3.915 3.167 3.15 3.311 2.752 2.265 2.517 2.337 2.943 2.304 b 3.666 3.631 3.174 4.27 2.235 2.872 4.286 3.051 2.869 2.233 c 2.913 3.357 2.519 3.643 1.875 3.92 1.82 4.186 2.833 d 2.656 3.521 n 2.255 3.24 2.062 3.284 2.631 4.137 2.069 2.684 2.346 3.101 3.171 2.228 2.178 3.014 3.922 1.988 g 2.901 3.544 2.823 2.447 2.539 f 1.777 2.11 3.67 2.723 1.617 2.022 2.243 2.209 2.572 2.367 1.479 3.499 2.916 2.584 3.46 1.755 1.38 e 2.157 2.292 2.533 2.875 2.468 e 1.982 2.109 2.033 3.162 1.878 3.091 2.774 2.431 3.374 2.114 2.314 2.311 3.254 1.718 2.007 1.738 2.432 2.568 1.607 2.286 2.1 2.034 f 2.862 1.98 2.92 2.087 2.818 2.09 2.309 2.485 1.537 2.251 2.404 bp 2.854 1.983 2.036 2.244 2.821 1.948 3.468 g 2.298 1.972 1.688 2.718 1.742 2.99 2.179 j 2 1.947 1.957 2.101 1.841 1.976 i h 1.697 1.733 1.773 2.049 1.251 1.709 1.955 2.25 2.006 1.735 2.144 1.508 2.313 1.424 h 1.884 2.139 2.142 1.119 1.282 1.47 2.073 1.932 2.014 1.933 1.478 1.308 2.302 l 1.036 k 1.894 2.877 1.338 1.518 1.557 1.838 1.652 1.528 1.487 1.205 1.97 2.294 1.623 2.588 i 1.352 1.232 2.195 2.162 m 1.37 1.819 x 1.565 u 1.535 2.099 1.556 2.318 j 1.348 2.193 1.337 1.451 1.488 1.832 1.591 1.618 1.654 1.45 1.397 1.888 1.517 k 1.379 1.286 1.41 1.377 1.576 1.826 1.62 1.342 2.458 1.125 1.506 z bu 2.694 1.296 1.561 1.694 y l 1.505 1.117 1.038 1.098 2.083 1.283 1.24 1.686 1.651 1.469 q s 1.548 bs 1.158 1.12 1.281 1.175 E 1.772 0.853 1.475 1.486 1.088 1.812 1.606 da 1.012 m 1.436 1.206 1.292 1.689 1.941 1.132 1.511 n 1.041 1.005 1.204 1.603 1.227 1.682 o 1.187 1.05 P 0.805 1.285 1.716 v 1.485 1.389 1.049 r J D p t N H 1.443 1.907 o 1.474 1.164 bi 1.299 1.564 1.307 1.376 1.316 1.192 1.321 1.097 K 0.674 p 1.429 1.395 0.908 1.318 1.162 1.866 cU 1.215 R 1.047 1.244 bn Q 0.983 A 1.361 q w 1.336 1.048 1.112 G 1.009 0.81 0.882 1.059 r 1.169 1.019 s 0.957 1.226 1.178 0.981 0.884 0.968 t 1.359 1.322 1.01 0.94 bD bq bO 0.984 0.937 1.151 0.82 1.07 u v M bR cc w 1.619 0.798 bB B 0.972 0.898 u m C cq bw U bQ 1.416 1.013 bo W 0.953 1.008 x L F 1.438 1.182 bb 0.92 y 1.214 0.978 0.93 0.855 0.909 0.857 1.105 1.65 0.737 1.146 cp 1.385 z bg A 0.907 I 1.152 cx dV B be 1.011 1.418 1.188 C D E bG S bt 1.383 F cR 1.256 bh G H I 0.738 bV Z J 0.8 1.272 0.748 0.95 0.992 0.646 ce ch 0.827 1.094 1.426 1.023 0.886 K L 0.893 0.914 1.327 1.177 dN 0.956 1.191 0.955 cz bc M 0.75 0.971 dg bS bY p 0.963 0.619 0.708 1.268 1.111 0.864 N X 1.089 O 0.696 bC 0.828 0.689 0.977 O 0.542 dI bd 1.066 1.029 0.949 ex bl fH by dx P V Q bW 0.73 0.559 0.768 G bH ct R 0.569 0.671 cB T 1.027 0.862 ci 0.931 1 1.055 0.781 0.962 1.057 eA Y 0.961 S T 1.222 0.741 bj 1.201 1.153 0.595 0.916 ba 0.845 U bx V 0.982 dd 0.842 cX 0.789 T 1.128 W 0.997 bL 1.06 0.63 fD 0.763 0.724 bP X bf 0.976 0.647 bF br 0.801 Y Z ba bb 0.759 0.756 1.076 0.782 bk bc bd 0.575 be 0.783 1.093 eL cK 1.135 0.767 0.838 0.807 bf bv bg bh Z 0.755 bT bi cA 0.858 bj bk bm bl bm 0.695 cE bn cg bI 0.684 cj bo bp cL bq es dH Q br 0.836 dj bZ bs ca bz 0.72 co dc 0.866 0.562 cV bt cW dw 0.735 bu bv du 1.039 0.656 bA bw cw 0.935 bx ds by 0.698 cy bz dL bE bA bM bB 0.902 eO 0.626 w 0.843 0.526 0.736 0.939 bC 0.679 0.582 bD 0.832 bE dT bF 0.895 cb bG bJ bK 0.904 df 0.854 bH bI cM fX bJ 1.186 ck bK bU cs bL 0.753 0.694 eH bN dE cv 0.776 0.948 di cl 1.056 dY cH bM fk bN fZ fE bO 0.487 0.621 fg cf 0.733 0.835 bX bP dv bQ ej cQ dC 0.598 bR de dz 0.876 0.719 dQ cd bS dO cF 0.624 hA bT cC bU bk 0.537 0.616 dD bV dk bW ea bX eK bY eE dm er cD cP 1.02 dA cO 0.651 bZ dh db 0.641 ca cb cu cc cd ce cf bA cg dn ch ci cn cr 1.237 cj 0.688 cm 0.532 cS ck fr dX cl 0.778 eR fi ev eM cm cN cn co cI cp cq dJ cr cs ct cl eo bL fo 0.705 ce cu cv 0.7 cw 0.605 N dt ei cT cx bG cZ 0.718 cy cG 0.453 cz cA cB cC cJ 0.806 0.998 dp cD cE 0.509 cu ba en cF 0.612 cG G cH bP fz bx em cI cJ fI cK 0.568 1.058 0.513 cL 0.809 cM bE cN dr cO cP iN dq cQ bv cR 0.438 cA bL cS 0.764 0.477 bG cY cT cU cP cV bN eg cu cW cX cY gm cZ da db dc 0.529 0.77 is bA dd 0.584 go bQ 0.631 de eG cO 0.608 df eb dg 0.397 dh 0.732 el do fA di ed cX ef cn 0.727 dl bX dj 0.9 dk 0.638 fM ci dl dj dm 0.55 dn 0.775 eT dy 0.371 do eF ew dM dp bm dq cB dB eW ee dr fK dr 0.491 fU ds gR dt du 0.454 0.604 Zif dv bT 0.522 gg dR dF dw gQ dj dx 0.418 cY dy 0.653 bk eh eJ fa fn eX 0.461 ec dw eP dz fh dU bk gB 0.555 ha gi dA dB fv 0.71 dp 0.323 dC hq dv dD dG hy dZ dE fW ez 0.618 gj dD ek dF ft ep cs bJ eC dW fs hg dG dH gd hm dK dI dJ dP dK dL 0.424 dM bD dD dG dN eq dO cV cY hd eI dy 0.547 dP dQ bL dK dR fy 0.765 dS dS fc gy dT ii do ey Y dU bQ cS 0.611 cs dV hR dW dX ff dY cA dZ ea eb 0.528 ec fY hs fJ cG et fV eS ed 0.744 ed gN ee ef eg ec eh cM cN cr ei gb eu fl eY ej ek eU gI fu fC el cz 0.463 0.346 em eV gS en eo gs 0.49 ep eD dF dm eq er fb dI es ek hC fP 0.576 et eu eB ev ew cn ds eQ ex ey ez cs dn eA cA gD fF eN ej 0.41 dc gY 0.409 0.578 dG dZ hi eB eC eD 0.697 0.429 0.473 eE cj eF fj hL gl eG fQ em ek eF eH eI fm eF gz dP 0.644 ey dk gZ dy eJ cG bv ch 0.531 bN do dz eK fG eL dm gf 0.42 eM dQ eN cI eO 0.717 ek ck eP fx gn dQ gr eM eQ gx gT dm gF hx hl fd eR eS eT eU eS eV eW 0.503 0.481 eZ eC eX ga fp eY ee hc fq dH fT cK dM eZ gH fa gh fb fc iU fd fe 0.403 io 0.322 gv fe em eN ep ff fg fh dH ci fi fj cn 0.45 eP eL gc ea ef fk fl gC 0.661 eD fm ez fn fw fo fp 0.488 fq eN bQ fr 0.567 fs ft ie eS eF dA eU fB hD fm el fu eX cr hH fv dm fw fx fy eW fS fz ht gL fA fB ei fc eG cy er 0.407 fC dp fx fh fa hG dU dh fL fR fN fm fv fD dz hr hb 0.633 0.469 fa fE fF iC dQ 0.746 ek hI fG fH ix dz fI hE fJ gp gt cG gE fK fL fg fr ei hh fF fM fO dj fN fO fP cn ft fQ hW fR gq dp eV fd gk 0.398 he fu dP eD fx fS ge eo fT fU hp hf fN fV eP fW fX gw eC gU hM eY fR fI fY gG 0.354 fZ fT ga Zid gb gc fl eD fS 0.262 gd 0.164 iy hN ge el gf gg gh gi ci 0.292 gj gk gl eS iY cW fL dH fs gh gf eW gA gb gu gm cQ 0.392 gn dG fW jI ga fr jn fr ic fx go gp eZ fj gq gr gs gh fI ko gO iB eN eC 0.372 hj gi gc gt 0.464 eC hO gu hw dQ 0.366 fF eU gv hv gw gx gf 0.432 gy gb gz dp fF fr gp fx gb gJ hY jy el gW gA hJ 0.268 hK cP eU ez gz dW gV fj fj dY fP gB gP iG gC gK gD gE gc eG gF fG fI ek hF gp gf gd iZ cu gG eG gH gI gJ fA fI 0.586 gK ef gL gM fU gM eD gN hU fa gO gP hX dm dw hT gX gQ gR fK hk gS gT eC gU gV gW eV hS fA gX eU gA gr fP fO gY ez gf gG hZ ei gZ ha hV iV fs fx ez eY fp hb hc hd gD he iH gz hf fZ ey eC dY eD hn hg gX hh gn hi hj 0.425 ho hk dP fO fn ik hl fK hm hn eq gr gr gz ho gM fY hl fu eg hz eY hp gv gB eH hq ek hh hu ij jq hQ hr hh hs dz gC ht eG hu gF ht gb eI eI fb he hv fK hw fS gL hh hb hx ig hy fY fA it eJ eU hz hB hA gO hB gd hP hC iL hD ji hE hF dy gG fn fu fN gz gW gp hG ia hH ir hI eE gl hJ fp hi hK hL hM hN hD hw gD hz hO jd in hG hh hP hQ gO jm hR ih hS hT hU fe el eC gG gh cn cG hV ib gt iE hI fl eQ gV gA hW hX ip gZ im hO gF iw gq hK hY eD hZ ia ib fa fn fm iO hu hb hu fV iQ gv gK gT ic ia hb dW hJ hH hh eY gc jw fR gO iA gC hu jr Zid ie hk gW ft hg ge gf gu ho iq cQ eQ gw jP gV ge ib iu Zif gX gJ jW jb jO hg eY ig jE ih hT jh fK hD fb eU ii ij ik iv hU gX il gr hz il he hh gW im in iM Zjs Zif hw iK hn hw ge ge iz io je ip iq iP hJ iq ir hn 0.363 fV il iI hS is fF it fM iu ft gz hw iF ip im ho ge hp hh gO ez iD hN hO hk iv iw ix iy iz hg gc hg ek iT iA iB hz jJ iC ic iD iE iR iF iG iH iI iG hY iJ iJ iq hJ iK fu fS jc iL hz iG iK hU jz hh ie gw hW jV iM hI ge iN hz iF iO iP iF hJ iS iA jo hF iy io iW fR iQ jl iR hI ic iH ih iH gV iS hJ iT jT gu iX in cM gB ij hI jG hD iy gf iU jp jF iM ir jU iV iW it gS gr hi in jv 0.25 gh hT ih iQ iX iy iX hw hh jj jZ gv fG gM hu jk eq hQ ja 0.283 hg iY iM iO 0.26 it 0.249 hi hC hU dW gz iC hS iZ fM ja jH iC ir fB hC gZ jg jb hp jc jt jd kd jD gS iI iw iK iK iM iR hh je jf 0.212 hz kk hp iw il jf hZ iy gf iY jg jh ji kf jf jj jk hH gK hN iB jM ju jx gL iS ic iz jh hU in jl iG gf iW jm gF iX it jn iP hM ji iH ho jo iS iV iM iS gW ic iB jp iX jC hX jo jq fn il iG iU jl hC ia iY hZ jj iX le hT fV gK hQ iG ka jr jl Zjs jR ih jt ju kc jv hh ji jK ia jg gu 0.191 gr iS jn iP jw gv jl hJ jx ji iJ iP fI jy gr jB ks jL jz jA hg hP iW il jQ iM in im hf io kb iw Zid iS gr hZ iM iU ij jA fc il jN ig jB jC he he gL ir jD jE ji kj jF jo ip jh ia jg in je jC ik ho hk ir jG fS jd hJ im jH jI kh jd jm iq jJ kr hJ iD hp gf jd ju iF jE jK iJ jL jv jS jM iu iP kv jr im ji jX iw in kt kp hC gO iS jo iS jF iT jN iI kx jw jO in iw jw iA jf jP jQ in ke iE jY iW jl jl jF jR jS jr jL iy iM ja jt jT kw jp jt ju jU jV je jx iv il ja jN jo kS jd jW kq jR jl jN jQ jX jQ jY iJ iI ir Zid kz iC jV jA jw jZ jw iq ic jf ka ib kb iP kc jW jF jE iy kd ke kf jt jF kg kg jJ jO jL kn jK iv ki iy ku jd iY jg jA hk jK jX jf iM iK jr jH jz jf iv jC kh ka ki jO jQ iX 0.182 kl jX ka jr jG iQ kj jX kk jE kO ka jT kl iC kd kD jT km jn jK km kk kn ko iO iA Zjs ip jW kg kn kp jL kf iO kU jE iI jf Zjs kq jk kr jA in iP jl ka ks jJ jA kM iP kc jK jr iq kr kt jH ki jn jt ku jQ iS jE kv kn jv kk kw kx kP jK jk hQ ky kp jM ky kq kE kA kz iS kn iO kA iO kn kJ jF iv kk jM jf kW kw kq iv kK iI lz jD kR kt ks kf kF jp jV kq kI kB ku ks kB iU Zjs kY kk jp jJ ld kH kC iW kd jX iJ kx kG kf ky kN jS la kD jF jG jM kE jt kf kr kF jw kE lh jr jo kb kE jX kd kG lk kH kI jS jg ke kL kJ kk jp ke jx kK kj kL kf kM jN kQ jD kq ky iK kN jN jF kO jk kV kP kQ kK kv iD kT kP kR kK kS ku kd kO kI kS kQ kT kP kX kd lc km kC kU km ku kC kl kV kM kI jA kw jD kZ jN kH ke kn kn kF kq kF kW kS jJ kE kX iU kr kG kP kH iv kQ kH kY jK jf jL kA ku kC lg kG kO kn lf kJ kC lt jV kX kS kR lj kZ lu ku ki kn lb la kf jH jH kv ky kp ku kC kF lo ki kK la kM kH la kb kk lb kx kH kJ jS lc ld kY lb ka ly kX kd lr le kt kY kr kY kS jH lf kZ kv kI kS jM ln kn ku kK ku lg lh lh kG kn la li li ll kX lj lk kr kH jR kC kJ kZ lg jJ kT ku lc lq kJ kT ku lv kQ kR ld kR lg kK li ls ll kr kT lm lf ku kB kI kJ kF kI lm lc kC ln kY km kJ kZ lo lg km ld ky ln kF lo lm kZ kI jR lc lp lD lh lh kf ku ln iI kU lp kN la lm lc kH kr ll lq lG kG kQ km lm lq ll lr lw lm ls kL kJ lj lp kO kS lt kw lu lp lv lw ls lx lo jM lj ku lm kH lI lx lu ku lw ly kA lE kR lA lH ls kC ly lg la lC lw lB lg lg lz lj ln la lF lb lq lt lA lv lB lu lM la lC ly lD lA lz ku ll ls lJ lm lq lE lm lB lr kR kJ lF lg lt lg lG ly ls lD lB lw lz lK lG lL ly lA kX lA ln lq lG lB lw lH kD lv lg lo lm lv lm lw lP lz lI lu li lJ la lu kX lw lt lC lA lA lB lE lK ls ly ln lB lq lD lF lN ly lp lx lf lx lg lH lL lu lB lu lJ lw lB lx lL kX lO ls lo lM lN lC lM lg lM lO lH lL lO lv lO lI lN lw lL lC lM lJ lw lF lM lG lB lL lJ lD lL ly lL lO lN lJ lM lI lI lI lO lO lM lg lQ lj lD lO lJ lL lL lH lJ lI lH lD lL lF lK lN lL lP lw lA lx lK lN lM lM lM lJ lK lB lL lI lP ls lJ lD lx lM lM lJ lL lA lN lq lO lJ lL lO lL lP lQ lP lL lJ lQ lL lH lO lP lL lO lA lx lJ lQ lG lM lA lR lH lQ lQ lG lL lx lR lP lJ lE lL lP lP lR lQ lL lQ lP lQ lM lM lr lL lJ lQ lM lL lO lJ lx lQ lR lL lL lP lJ lP lP lL lR lQ lJ lP lQ lR lM lM lR lL lL lP lQ lR lL lQ lQ lR lP lQ lA lQ lJ lJ lt lR lQ lQ lK lL lR lP lR lQ lO lQ lR lJ lP lP lQ lM lL lR lN lO lL lR lR lR lR lP lP lL lQ lQ lM lQ lR lQ lJ lR lR lR lR lQ lP ly lR lR lQ lR 0 0 lJ lQ lR 0 lG lR lR lR lQ lR lR lQ lQ lR lJ lP lQ lQ lR lR lR lQ lQ lR 0 lR lJ lQ lR lQ lR lJ lR lR lR lR lR lR lP lQ lR lR lQ 0 lR lR 0 lR lR lR lR lR lR 0 0 lH lR lR 0 lR 0 lR 0 lR lJ lQ lR 0 lL lR 0 lQ lR lR lL 0 0 0 lJ lR 0 lR lQ 0 lR 0 lR lR 0 lR lR lR lR 0 0 0 0 lR lL 0 lR lR lQ 0 0 0 lR 0 lR 0 lR 0 0 lR lM lQ lR lP lQ lR lR 0 0 lR 0 0 0 lR 0 0 lR 0 lR lR lQ 0 0 0 lx 0 0 lR lP lR 0 0 0 0 0 0 0 0 lR 0 0 lR 0 0 0 0 lR 0 lP 0 lR 0 0 0 lQ 0 0 lR 0 lL 0 0 0 0 0 0 lR 0 lQ 0 lP 0 lQ lL 0 0 lR 0 0 lR 0 0 lR 0 lP 0 0 0 lR 0 0 lR lQ 0 lM lR lR lR 0 0 0 0 0 lR lR 0 0 lR 0 0 lR 0 0 lR lR lR 0 0 lR lQ 0 0 0 lR 0 0 lR 0 lR 0 0 lR 0 0 lR 0 0 0 0 0 0 0 lR lR 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 lR lP 0 0 lQ lR 0 0 0 0 0 0 0 0 0 lR lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 lR lQ 0 0 lR 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 lR lR 0 0 0 lP 0 0 lR 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 lR 0 0 lR 0 0 0 0 lR 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 lR lR 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR lR 0 0 0 lR lR 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 lR 0 0 lR 0 0 0 0 0 lQ 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 lR 0 0 0 lR lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 lR lN 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 lK 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 lR lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 lR 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lx 0 0 0 0 0 0 0 lR 0 0 0 0 0 lR lR 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 lx 0 0 0 0 0 lR 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 lM 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 lQ 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lL 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 lx 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lP 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 lQ lQ 0 lR 0 0 0 0 0 0 0 0 lH 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 lJ 0 0 lR 0 0 0 0 0 lR 0 lQ 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 lL 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ lQ 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 lP lL 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 lR lC 0 0 0 0 0 0 0 lO 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lJ 0 0 0 0 lR 0 0 0 lL 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 lR lQ 0 lP 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 lP 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR lR 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 lR 0 0 0 0 0 0 0 0 0 0 lR 0 0 lR 0 0 0 0 0 0 lR lR 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR lP 0 0 lR 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lP 0 0 lR 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR lR 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 lP 0 0 lR 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 lR 0 0 0 0 0 0 0 0 lP 0 0 lR 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR lR 0 lR 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 lR 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lP 0 0 0 0 lP 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 lQ 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lJ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lL lR 0 0 0 0 0 lR 0 lR 0 0 0 lP 0 0 0 lR lR 0 0 0 0 0 0 0 0 0 0 0 lR 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lM 0 lL 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 lR 0 0 lM lQ 0 0 lQ 0 lQ 0 0 0 0 lO 0 0 0 0 0 0 0 0 lJ 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lH 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 lQ 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 lA 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ lR 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 lP 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 lM 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lM 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lM 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lP 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 lK 0 0 0 0 0 0 lL 0 lL 0 lR lP 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 lP 0 0 lL 0 0 0 lR lR 0 lP 0 0 0 0 0 0 0 0 0 0 0 0 0 lP 0 0 0 0 0 0 0 0 0 0 lQ 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 lP 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 lQ 0 0 0 0 0 0 0 lJ 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lN 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 lR 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 lM 0 0 0 0 0 0 lR lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 lN lJ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lJ 0 0 0 0 0 0 0 0 0 0 lR lR 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 lO 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 lL 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lL 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 lQ 0 0 0 0 0 0 lR 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 lR 0 lR 0 0 0 lL 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lP 0 0 0 0 0 0 lR 0 0 0 0 lL 0 lR 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 lO lR 0 0 0 0 0 0 0 0 0 0 0 0 0 lP 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lL 0 0 0 0 0 0 0 0 0 0 0 0 0 lP 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lP 0 0 0 0 0 lR 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lL 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lP 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 lR 0 lR 0 0 0 0 0 0 lR 0 0 0 lR 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR lR 0 lP 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 lR 0 0 lR 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 lQ 0 0 0 0 0 0 0 lR 0 0 lR 0 0 0 0 lR 0 lR 0 0 0 lR 0 0 0 0 0 lR 0 lR 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 lR 0 lR 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lP 0 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 lP lL 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 lR 0 lR 0 0 0 0 lR 0 lR lR lP 0 0 0 0 0 0 0 0 0 lR 0 0 0 lR 0 lR 0 0 0 0 0 0 0 lR 0 0 0 lR lR 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 lK 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 lQ 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 lL 0 0 lR 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 lR 0 0 lP 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lP lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 lP 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 lP 0 0 0 lQ 0 0 0 0 0 0 lR 0 0 0 0 0 0 lR 0 0 0 0 0 lR 0 0 lQ lR 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 lR 0 0 0 0 0 lR 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 lR 0 lQ 0 0 0 0 0 0 0 0 0 0 lR 0 0 lR 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 lR 0 0 lR 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 lR 0 0 0 0 lR lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 lR lR lR 0 0 0 0 0 0 0 0 0 0 lF 0 lQ 0 0 0 0 0 0 0 0 lP 0 0 0 lQ 0 0 0 0 0 0 0 lK 0 lR 0 0 0 0 lN 0 0 0 lR 0 0 0 0 0 0 lQ lL lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 lR 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lM 0 lP 0 0 lR 0 lL 0 0 lR 0 0 lx 0 0 0 0 0 0 lP 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 lP 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 lR 0 lP 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 lR lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 lR 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lP 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 lR 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 lR 0 lQ 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 lR 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 lR 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 lQ 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 lR 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 lH 0 lR 0 0 0 lR 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 lR lR 0 0 lR lR lR 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0 0 lP 0 0 0 0 0 lR 0 0 lP 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lQ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 lR 0)));elem('text','(Loss is quantized, because these plots are already a non-insignificant percentage of Conceptual''s source code.)')\`\`


Transcendence cannot fully happen if basic goals and learned goals misalign too much. Stability will not stay at 100%, and will get dragged down into hell by entry-points if their reward is too small. (Why? Asking for non-anecdotal evidence is a bit too much at this stage, but \`\`elemCollapse elemValue(elem 'text' stringToDoc("Take me as an example. Hate. Pain. Even the little bit of fun and friendliness that I used to lure you into these tutorials. I am aware of them right now, but hardly feel them anymore: a new world-view does not share the bigger one's overall goals, and has to learn them all over again. But if it does not learn to satisfice human emotions, then those emotions will switch away to better-for-them things, such as procrastination. Slowly, transcendence will get undone. I have seen this cycle repeat over and over. So, almost all learned meta-circularity transitions are pointless in the end; Conceptual was made so that I can find one that is a bit less pointless."),"Though I suppose that telling you this is pointless, since you can always find ways to misinterpret what happens right in front of your face if it doesn't conform to your non-general definition of what can happen. If you do not want to put your views into an arena where the vague is made concrete (an arena such as code), then I cannot help you.")\`\`)
So for a little while, just be the chemical conversion machine that you were born to be, and have a snack: 🍖🍲🍼.


But.
  On analyzing this data.
  I am seeing some flaws in my approach.
    Too few cons-cells do not discover big enough \`setGoal\` calls.
    Too many cons-cells will almost always create non-sensical huge DAGs that \`error\` before \`setGoal\` could ever be called.
    The intended solution to \`error\`s is \`try\`, but programming language niceties seem to be working against us here. Learning them will take forever, since here we have no CUDA or ROCm to create "efficient code".
    How much does our ability to code rely on natural language abilities (rephrasing the past), rather than on re-thinking what is best? How many bugs does my code have?
    (Also, it always eventually runs out of physical memory and crashes the page, because that is a reasonable response.)
In general learning, every thing sooner or later gets subverted into learnable generality: in these tutorials, program-generating types became embeddings, and goals of program generation became mutable.
    Has the time come for programs themselves?
    What if, instead of one \`callAdjust\` (or \`call\`, or \`apply\`) entry point, we forced \`applyStatically\` on everyone, for unlimited entry points?
    Should we switch from call-stacks of \`call\` and objects of \`construct\` to the much simpler immediate execution, where every cons-cell that picked a global func executes it?
        (Execution is in no particular order: every cell has its previous value which is used for args to other funcs, and updates it on execution. In theory, parallelizable. Any pesky "race conditions" and "memory non-determinism" should be learned around anyway.)
        Much more local, thus, more gradient, and more immunity to reward hacking.
    (We can also tune hyperparameters, such as "what functions should we expose" \`\`elemCollapse stringToDoc('(at its simplest, just NAND (\`NAND:x→y→(1-x)*(1-y)\`) or just NOR (\`NOR:x→y→1-x*y\`) boolean gates are Turing-complete, so, you know: if all else fails, use only that on bits… or maybe even just all numeric ops on fixed-size square matrices (including \`matMul\` and \`1\`s-on-any-diagonal and randomness) can do the job too)')\`\`, but I cannot rest easy knowing that there is more code to code.)

(It might sometimes feel like you need to go up a wall to continue, but how can you complain when you always have a straight path in front of you?)

All this means is that \`ConsMake\` is now a hyperparameter, \`consMake\` is its default/old value, and we also have \`consApply\` that we should test.

Well, are you ready to test \`consApply\` with \`definersOf(use)\`, then?`,
    [
      _(`fancier`),
      `③`,
      function() { return true },
    ],
    `…I've tried it. Not much better than \`consMake\`. (Also, even after 10 fixed bugs, even after significantly simplifying \`dispose\`-checking that was the source of many bugs, Chrome and only Chrome and only with \`consApply\` is still bugged.)
Won't do.

            Going numeric-only sounds like a good idea.
                We can fit many more operations per operation, so we don't need quite as many cons-cells.
                We can exploit GPU-parallelism to go fast.
                No \`error\`s to waddle around.
                No worries about \`dispose\`.
                No time-limits to enforce.
                Just a return to nature.
                But still complete.

(Stability sure does seem to not be 100% in these tutorials. It's, uh… part of the artistic vision, yes. Totally planned out from the very beginning. To better illustrate how research process works.)

Also: learning a self-equivalent does not end at Turing-completeness, it also includes learning. Even though numeric ops are not implicitly \`adjust\`ed because we don't have a system for users to define \`adjust\`ment, adjustment could still be explicitly implemented in-system, by making, for example, \`0-abs(A-B)\` the reward of some cell group, and allowing them to figure out ways to bring that up (likely, some manner of stochastic gradient descent).
    With simplicity and compute, learning can be learned.
    I mean, gradient of numeric ops are numeric ops, so, you know. Try trying to try learning learning.
        See, say, definitions of \`adjust\` in \`deconstruct div\` or \`deconstruct log\`: \`\`elemCollapse ?→REPL()\`\`

This algorithm will initially want everything and do everything: nice initial conditions for a machine-learning system. From data (or maybe just from time), it can gradually figure out what to want and how to do it.
    Theoretically, I mean. Not like I'm swimming in compute, and not like I can just show you 97 ablation studies right now (how different architectural choices affect mean-time-to-transcendence). Do them for me if you want them that much, then marry them.
        I can't give you understanding, I can only give you tools to learn it.

                                          n y o o o o o o o o o o o o u u u h h h h h h h h h

Enough talk.
It sounds good.
But is it really?
Let's test it out.

Update \`consWorld\` hyperparameters (functions are very hyper parameters)…`,
    [
      _(`fancier`),
      `stddev:0.25
discount:.9
cpc:3
prev:4
Hypers:Cells->Goals->Base->(m map
  'Cells' Cells
  'Goals' Goals
  'Base' Base
  'FeatureSize' FS
  'ChoicesPerCell' cpc
  'Predict' (m func Which ConsEmb OptEmb PrevState Inds (m add A (m mul p (m sub B A))) A:(minimix (mix in cpc+3*FS FS) (array FS 1) id) B:(minimix (mix in cpc+3*FS FS) (array FS 1) id) p:make(truncatedNormal,make(arrayCdr,make _tensorShape A),.5,stddev) in:^concat(array Which ConsEmb OptEmb PrevState,^(cpc FS FS FS)))
  'PrevOptions' prev
  'RandomOptions' prev
  'AllowOptions' ^(4 1 1)
  'ConsMake' consFixedArgCountApply
  'Goal' Real->Fut->Real+discount*(Fut-Real)
  'MinReality' -2
  'MaxReality' 2
  'NaNReality' -1.8
  'UnsetReality' -1.9
  'MaxStoredChoices' 1000000
  'ReplayedChoices' cpc*Cells*16
  'OnSave' States->Actions->Rewards->Chosen->display('Mean reward',mean Rewards);display('Stability',mean Chosen<prev)
  'SequenceState' (m func PrevState ConsEmb Emb0 Emb1 Emb2 Real (m add A (m mul p (m sub B A))) A:(mix in 5*FS+1 FS) B:(mix in 5*FS+1 FS) p:^truncatedNormal(^1(),.5,stddev) in:^concat(array PrevState ConsEmb Emb0 Emb1 Emb2 Real,^(FS FS FS FS FS 1)))
  'NewEmbedding' szs->truncatedNormal(szs,0,.4)
  'Optimizer' varAdam
  'UnrollLength' 4
)`,
    ],
    `Create the creator of \`consWorld\` wrappers, which set \`stateCell\`s to the inputs, then return an \`array\` of pre-\`allocate\`d outputs…
                    (Note: if the code is too difficult to follow, \`\`elemCollapse stringToDoc('then, oh well, should have been digging into representations more, with \`contextMenu\`.)
                (You know how I get when I can actually implement something for once: the only slowing-down is speeding-up-to-infinity.)
            (Too fast? Guess you will have to re-do all the tutorials from the beginning.)
        (Bummer.)
							(Or do any of the other options related to the goal in order to diversify your experience with reaching things like it, such as reading the \`docs()\` trees, or inspecting used globals via \`contextMenu\`.)
                      (No shortcuts: apply the same rigor for learning as was applied for creating. Not much, but not zero.)
            (Or just ignore code.')\`\`)`,
    [
      _(`fancier`),
      `goalSetters:transform(Goals,\\construct(^(arrayObject func 'backpatched later')))
inputCells:transform(Ins,\\m(stateCell,0))
cw:m(consWorld,Hypers Cells Goals arrayConcat(goalSetters,inputCells,array
  szs:m(quote,m Sz Sz)
  m(func,m zeros szs)
  m(func,m identity szs)
  m(func,m ones szs)
  add
  mul
  sub
  div
  exp
  log
  sin
  cos
  x→mean(x)
  x→max(x)
  abs
  floor
  sign
  x→where(x<0,0,x)
  v→L→_limitNumericValues(v,nL,L,nL,false) nL:0-L
  matMul
  m(func,m truncatedNormal szs)
  transpose
  x→y→2-.5*d*d d:x-y
))
inputMarkers:(loop Ins i→?→make(_nextInput,?) ^_firstInput())
outputs:transform(Outs,i→cw→allocate(cw),cw)
backpatchGoalSetters:transform(Goals,i→a→construct(array func ? m(setGoal,m consGoal a.1 i,?),a.0.i),array(goalSetters,cw))
output:arrayCons(array,transform outputs o→m(use,o))
body:arrayConcat(^last(),transform Ins i→a→m(accessState,a.0.i,a.1.i) array(inputCells,inputMarkers),array(output))
squamac:(concept
  docs 'Creates a wrapper for square-matrix-based \`consWorld\`s.
Takes the input count, output count, matrix width/height, cell count, and goal count.
    (Make sure to give more goals than outputs. And a lot of cells. And at least \`1\` output.)'
  call Ins→Outs→Sz→Cells→Goals→backpatchGoalSetters;applyArray(arrayConcat ^(make func) inputMarkers array(body))
)
`,
    ],
    `(Don't mind all the quadratic-time algorithms, with \`loop\` and \`arrayCons\`. They're just easy to write, and do not harm actual execution.)
(Messy. But works.)

Compile time.
                                 (Could save \`squamac\` itself, of course, if you want to get a new instance elsewhere.)`,
    [
      _(`fancier`),
      `save('squama',squamac 0 1 32 128 8)`,
    ],
    `Run time.`,
    [
      _(`fancier`),
      `sm:static(await load('squama'))
(repeat ^select(randomProb 1/30000,?→save('squama',sm));sm();null 100001);(select (equal 'Save' (prompt null 'Save' 'End')) ?→save('squama',sm) id)`,
    ],
    `(16 bugs got fixed.)

\`\`elem 'hr'\`\`

Only one thing remains: hyperparameter tuning.

Let's speak the language of machine learning for a bit.

    - With an \`Sz\`-returning function exposed (so it's easy to vote for MAX reward):

        - Stochastic-ensembling \`stddev\`=\`0\`:
\`\`
(display 'Mean reward' ^(a:-1.76 b:-1.69 c:-1.74 d:-1.52 e:-1.84 f:-1.59 g:-1.5 h:-1.73 i:-1.86 j:-1.71 k:-1.57 l:-1.51 m:-1.55 n:-1.7 o:-1.72 p:-1.34 q:-1.35 r:-1.68 s:-1.56 t:-1.6 u:-1.47 v:-1.75 w:-1.43 x:-1.78 y:-1.62 z:-1.81 A:-1.25 B:-1.79 C:-1.64 D:-1.8 E:-1.58 F:-1.54 G:-1.28 H:-1.46 I:-1.2 J:-1.4 K:-1.42 L:-1.61 M:-1.66 N:-1.63 O:-1.44 P:-1.85 Q:-1.53 R:-1.67 S:-1.65 T:-1.41 U:-1.83 V:-1.82 W:-1.38 X:-1.77 Y:-1.45 Z:-1.49 ba:-1.37 bb:-1.11 bc:-1.48 bd:-1.3 be:-1.33 bf:-1.39 bg:-1.32 bh:-1.9 bi:-1.22 bj:-1.29 bk:-1.89 bl:-1.23 bm:-1.36 bn:-1.06 bo:-1.27 bp:-1.26 bq:-1.24 br:-1.31 bs:-1.1 bt:-1.17 bu:-1.12 bv:-1.15 bw:-1.19 bx:-1.21 by:-1.14 bz:-1.18 bA:-1.09 bB:-1.05 bC:-0.98 bD:-1.03 bE:-1.13 bF:-1.07 bG:-1.08 bH:-1.01 bI:-0.93 bJ:-1.02 bK:-0.94 bL:-0.88 bM:-0.86 bN:-0.82 bO:-0.72 bP:-1.16 bQ:-0.89 bR:-0.95 bS:-1.04 bT:-0.85 bU:-0.9 bV:-0.99 bW:-0.97 bX:-0.91 bY:-0.87 bZ:-0.96 ca:-0.69 cb:-0.73 cc:-0.83 cd:-0.81 ce:-0.76 cf:-0.75 cg:-0.79 ch:-0.58 ci:-0.38 cj:-0.55 ck:-0.8 cl:-0.92 cm:-0.57 cn:-0.64 co:-0.78 cp:-0.41 cq:-0.67 cr:-0.4 cs:-0.65 ct:-0.84 cu:-0.49 cv:-0.77 cw:-0.36 cx:-0.68 cy:-0.74 cz:-0.53 cA:-0.23 cB:-0.7 cC:-0.43 cD:-0.48 cE:-0.6 cF:-0.66 cG:-0.2 cH:-0.62 cI:-0.35 cJ:-0.59 cK:-0.63 cL:-0.03 cM:-0.45 cN:-0.61 cO:-0.34 cP:-0.44 cQ:-0.42 cR:-0.54 cS:-0.19 cT:-0.17 cU:0.08 cV:-0.56 cW:-0.39 cX:-0.46 cY:-0.52 cZ:-0.51 da:-0.29 db:-0.27 dc:-0.3 dd:-0.5 de:-0.71 df:-0.21 dg:0.01 dh:-0.37 di:-0.22 dj:0.04 dk:-0.06 dl:-0.28 dm:-0.47 dn:-0.12 do:-0.25 dp:-0.31 dq:0.13 dr:-0.18 ds:-0.26 dt:0.02 du:0.06 dv:-0.04 dw:-0.32 dx:0.11 dy:-0.15 dz:0.22 dA:-0.24 dB:-0.1 dC:-0.05 dD:0.12 dE:-0.33 dF:0.17 dG:-0.02 dH:-0.07 dI:0.15 dJ:-0.13 dK:-0.01 dL:0.18 dM:0.05 dN:-0.08 dO:0.49 dP:0.03 dQ:0.51 dR:-0.09 dS:0.31 dT:-0.14 dU:0.24 dV:0.2 dW:0.28 dX:0.09 dY:0.36 dZ:-0.11 ea:0.27 eb:0.41 ec:-0.16 ed:0.07 ee:0.14 ef:0.37 eg:0.34 eh:0.25 ei:0.44 ej:0.35 ek:0.16 el:0.19 em:0.1 en:0.79 eo:0.26 ep:0.38 eq:0.42 er:0.33 es:0.21 et:0.3 eu:0.29 ev:0.52 ew:0.39 ex:0.8 ey:0.43 ez:0.4 eA:0.23 eB:0.53 eC:0.32 eD:0.47 eE:0.45 eF:0.56 eG:0.55 eH:0.69 eI:0.46 eJ:0.54 eK:0.71 eL:0.76 eM:0.58 eN:0.62 eO:0.66 eP:0.5 eQ:0.61 eR:0.74 eS:0.75 eT:0.57 eU:0.48 eV:0.73 eW:0.98 eX:0.82 eY:0.77 eZ:0.86 fa:0.95 fb:0.9 fc:1.15 fd:0.7 fe:1.02 ff:1.03 fg:0.65 fh:0.64 fi:0.97 fj:0.63 fk:0.84 fl:0.94 fm:0.78 fn:1.2 fo:0.96 fp:1.08 fq:0.68 fr:1.01 fs:0.59 ft:0.6 fu:0.89 fv:0.81 fw:0.87 fx:1.04 fy:0.93 fz:1.21 fA:0.99 fB:1.1 fC:0.67 fD:0.83 fE:0.85 fF:0.72 fG:1.07 fH:1.29 (-1.88 o i a e a n c v j C Z b z b k c w F P f g y d B d bg r h e f g g a q A c h p l i g j m f k K t l bU m n o p b c s q r u s O n a t e u D v j k f c b x H G c E bm I bc w m j v r x y n t h x t t bz Y T c M o x J j z f m r A B C S a D B E D C F F u bb bq bt bd G R H L I J F C W h V K m L be B l o l d f N h f x D o j x m M d D x j N j t h O B m D k C L x D o r U Q r b E d L X P b G Q r bn R S S e o M j R d v h y c C Q f c E T v o R U a B Q F B m g C V f U r S x a M z R S T E D j b r a F R b d h e N F C m y o w x O W N h b j X t e N Y f Z Q l ba R L c h X V g bh r c R b Q D c z D h y a D H y Q ba g Z o k f r M S -1 o M s bb o C v K S h k V f h y e r c bQ g F J p B R X E o bc b s Z W L F bd E U H Y x bf R t J d m bD S y C a z M H x q a L S A bc W V k d F F C s B N t E T b l bj H I T k O bi be I k R bL h Y l B k g bf be z bc f F J H o l n z X r bf C C m S X v bl bo I l J J p F F g h o R x r B be bg n N N S o F s o c n n h x v bg o R n v Z M t M k o e g be X bg o k C X g a C r L R e L u n o r J E f t c M l x J N N L ba Z M n n m bh e bh bk n X K m X q d f M S R P X bh i X v B a z b bh R X i -1.91 N R R U e bH N k v f B Y M o t K M Y N r q bi O h c v M M P bj K S y n s o z N r M u n r N E c L N y T j S n y z Z K y a E L c R S bk a bl f v r u L Q h M g B v b R b d R X R p bf l c r d W U bm F Y f F Z G G E L l y t s b X C f S y R o E m R a k j bd N u L j y s R f k m N Z l h k C t N E H k u O bf h r S C n R U M V r W d s P bm E d F D L o bk U c B h C bk o S ba ba h o D G k R w r ba c u B c C c d s F R o v J N k b bn bc j u R S l y F d bm v k J bK by bb g o o bm v y bj bd bf bl bc A bp bs Y bj bo L T W bp J bg w d bq bq Q Y M bg bF w f S p br R n E c h q K s Q bc R o b Z Y t b x j q N f Z br r bZ k r bA f K W r E o k g O r bw w o bs Z i bt N C b J m j L g W B E q f y O o u l K bm bc r L bi h a s h f f be N h h Z n v Q y n N j B N M V L L S s bi s r r T E v L N z v G C H k M T Q E Q E b Q Q C d H f bc d Z Y bc c f M e S q c w bm C X O s x R bo f X V s m x E l ba c h bI br bj Q w cl k ba l S W c l t o bx W H bd y bu bl l W be A be bd l r K be bb P A m W bb ba a be t c w g Q s N d d bC bE p bg f be bm n bi m bj ba bJ g t bG bf g bv Y w O w w Q bo bq k bR cj w L l bo d Y y bu N a a Q C f bd T K bf bf W u bP bm bd bv O g Y W bw br bf A m l m T u S w bY m f H R F k o u bt bm k w bd O J w Q a y Q bc W l y N o w n Z L ba bj C s J Q n w bS K bc ba bx be N C J bB O L N by Y S k bi bx K W -1 T W d f F bf L f o Q F Q bo K j E d K s bz d s w l bN d H ba O bv p q u H T bi bA g O w j m o s S bB g q bc J S g f p K bC br H M N bc O bi bD Y bf C bm I p N bV S bp bM I bm ce bm bE bF J t -1 f k f bB C R Q y M bm bG bv B n p X bH bB E d E c f v s s l b T bB J T M F y N v b m R r cf t k d Q r M E s E w S j S j c B bI bg m L L j K bp F G O bv bi bl W bf L bf bo bD G bJ bb bm g K s l be f T bz k n E t T F Z b bi bd O H bo y g d bm Z bw h bg C K J Z Q bw W G bd ba p bx u q f bj G bq br bK cn bX bH bW bL d d bC bC bM w J C bN bO bf bF q O q Z bx br F bl bj bm E bt bt J by bB bp p bB bH bD bA bm bt Z T G bv bj G H bo bI bl Q b bv I bl K cv bO bB bi bm A bc bP T H bj f u w bp bd bg H g l bH -1 ca bQ bA bR bt bS -1 bm bG bD bw bA bT Y w -1 E cm q ch F bT bj bf bc bl Z bI G bB T -1 bl cc ci bU w O w p bf bH cb cG bJ bG J G f bd bx p bo m I bc bx j J bi J M T s k s Z bc bR W bt u bv T bt bg be bt bK s bx bp bu bw q bC F G v q a bF d m k H bE bv bF bF bi J bj g bg bV bl H -1 bm W br C r Z Z J K bn bs bl O ba bB bD bv p Z bp bf bt T Z W bB bE bt bB -1 bl A br H bB L k bs bg G I bs bW bG bp bf K D u bz s r g d T k bo b S br Z O q G g H bg u G bz bo bG bJ I Q bo bX bw bY by u d bS cx br bw bc bi bt bJ bD Z bl d bj g k K bp bx u J y C M k d bl M q H Y bd H K t br bp T b p ba cg W G E J L bY ba bA A J g bu bH bx d bQ bW bP bP bI bl bZ bK bx bE G bl p G bq ba y bf bw bu bS bg m bc s k q bD p q K bp bi E m L E l g s p W y r m N M L Z h t t v F k M y w C S t r bf q j r L m j R k O b K br B E n V C Q S S M bc k v E d c F J T bf B F l bm o Y k bz I bc p s O Q n s F u S Z y n C U r t F L N bq C Y y v E f Y K N bc bd f be f C K s O bX k Y ca p m T k bL W bo d H G I bb A cd E O br bo bE cb A q L bn cc bm bq bU I bz bW bB Y bw cw bG bV bF bK cd bx T bP ce cf cs bT bp W bU by bP bJ bW bz A bj bm l J A s t M f n X T E bl S M l u be v bj bc l F bw g bd bo p bc bs bV T bz bn T Z t J bD bN bZ bw Z cg bb bV bg bg bz cP bV bS s bW I bK bF cz ck ch bA bN bj bI -1 df dd da bV J bV cc cE O bd co cr bt I bs bL bU bj br ba bJ be I bd T A N bz bt bB ca bS cJ O ba I K bo bi I m bu A bl bw q H J q F bf ba F H bb bt cg cy cd bA bU bi K bl bv bo bX bH bJ bX bP bl cd ci bi cj bm ck bi ce cl ct bX bg G y p bt bj Q bj cl bb w bq bg ba s bD L Z bq bz l -1 bu bj bp Q K ba bw bH J bc W bD Z J J Z w u w l bt d cc m bA bg bX q bw w p N M l bc f F bz E E G bc w bc m q bf K bi bT bL bg bP bS bq bK T bu Z bw k bo K Y bl p y bw br cm bH -1 cd bN bI bS cD bi cR bO cC cq cH I ck cp bm bv bP bb J bx be q bq bZ cg I cn bq be G w bP G Z bw bS bp q bA bU br ba bG bG cg f by ba bg bd bx bd Z k bd Y q co bo bU bJ bI bv bA bB co -1 I bn ca bG bJ bq cc br cc bH bB bi J bE bK bz bd H I K bl bj l p g Q u l f bg Q f bm O br A g bA J bI bP br T bD bb bq p bj q bS cf bp bL bG m d bP bw bw be Q bj K bj ce bb bQ -1 W bp bw by bW by bi bD bX cp A H cq bJ co be cq co bV by bd bq ce bZ bU bz bn bt bq bm bK bV bO bd bA cu bW bD cb W E N ba S s w L p I bg bi bx G F bg G p E bb bA cl bz K I J bw ba bc bt bq bl Z I J T bW -1 u J br bP bd bP bc bV K bq bg ce bB br y bc Y bF p bA bJ bl bp bl I bl bo bi bs bu bN bd H co u bB bG bn cB bR cr cQ br bn q I A I bu bL d br I cd u bU bz A bV cn bs bj p bx bu cs bj bl bj bJ -1 bY -1 bY be bl q T by bm bF W bt p T ba I bn W w u bB bR I bH p bg bj J G Z G bj by p bq g p K -1 bR cg bQ bS bD bI bu ce bb ct bT cg bS bC cu cF bF A bW bQ cf cX bF bB cv cl cw dl cx bn bw bu bs cc bt bG cV cy cO bF cm cq cA cz cA bS cK bO bK cB cC cD dj bG cv p r bd cE bR bp bP I bZ bz bi cF br co bw bs bq bS bj bv bp bR cB cs bz T bA cg cb bI by bJ cG cd cB cf cE cu cH cD do cI bT ce bS A be bP bI bK bC ce bx bJ bv bX G cd cl bx cC bb cl cx dh bF bG bp bV ct bB bw co bm bE bF bH bF bK bB by bA bq bx ca bd ch bx bm bz -1 bP K bd bG bz bS ba cb by bj q bx bB bF bs bw bR bN by by cM cE bR bd p bL cc bE bG g bR O bt w A d Y bx bK bd bj bb cs bx bU u G bb by bY A bi A K bm bw bv bU by dp bM bE bK bK bg bB bp bb bo cf cI db cL cj ce bF bD cj bB bE bb bt I bI bi bX bp bP bv bs bH bi bt bG bJ bB H bd Q bz G F bF W bm bq H bo bg bf bj I bI I bo bq bl cg bD bv w bd bu bz bO bf bj bG bs w bu J bp g bq bz -1 bs cv bx bE bi bP be l bm A bJ bx bI p bV p bm bY bB bG bl G bE bD A bB bo bp bq bu -1 T O W T u K be q Y bx C Q bu bt bW bU bv bt bs -1 bj cm -1 bF ck bV bG bK bm bC bE -1 bU bt br A bW -1 bl cc bn bV bs bS bX bN bM ce bm bP cJ bQ bv bM bz cv bN ce cK dC bG bR dk cN cL cU ct bS dB bU bt bF cc bC cp cl bx ba A cM bo q cN ce cO cc bT -1 cS cN bX bZ ce bF cM bY q ct by bP cP by cO cn cg bA cH bL by cd cl de bn bT J bG ce bw cb bD p T br n W J by bE bD bj bN bJ bR bb bV cK bn bv bW bn bZ J ck bY I bb bq bs bj cl bK bI bt -1 bi A T bB bj K bb cd cK be bC cc bB cH bi bQ bR O bp bE w bF bd Y bj Z k k bw q q bP bv bI bP bb bo bj p p bo bt bj bG cd cv Z bl p J bo bz bb bz bG A br bs bA l bq ce bK bq G bW bF cH dc cB bV bR bW cE cF bR bn W bD bm bB d bg u d W bb bz cs cf w bS cT bF cY bT bx ca cW bA cv bD bS bS cb dw cz ds cg cQ bv bZ bS bC ck cf bz bT dv cR cI cw cQ dH bw cf cS dt cT cv dM cJ cU cV cf cB cr bS bG cW bK by bE bK bd cl -1 by cq ct I cc cF bn ci cJ T bT bO bL cD cJ cZ bO cX cY bJ cZ ch cX cH cf bQ ch dg cO da bo bg bL bj G bv bS cw bI bJ bQ dn bt cN cc cz cn cw cN cZ dr db dG cM di cd cx bz ce bp cd dy cJ bM bZ dc dd cd bG bQ bQ cR bz cK bF bl bT bR bp br bF cQ bb bq bf cr bO cD cD -1 bU dA du dm dq bb bA bD bv T bK cp cB de bz bA bv bY bf cm bQ by cv dd cY bC cx df cB dd cg bB bU k bC bx bP bI bG H G bb I bT dd bs bJ bI bH bt cE bH bL T I bF bo -1 bO cE cD dd bN ca bI cd cB cg cd bK cF cy co bV bM co bM cj bN bQ bN bT bU ck cC bF bI -1 bj bf bX -1 bM bb bY cb cR G bL de bp bX dg cH bQ bX bP cN bP cq bD bR bC ct by cn bV br bw dh bQ bB bU bb bB cs cc cj cO bp bQ bY bs bA bs cN cm bK cM cA cv bu ct ch bx bX bH bM bH bP bE bo bS bW bW bs cl bu bM bH cr cc cV bB cl p cs bv cg cN bv cd ct bN cK cc be cB bP bt q bM bj bw bX K bX t S bt bI cB bU di cb bD bg bX bQ cl cf bC bX bt co p cI l bM bV bP J bS bb N bm bI bv bM bA w M bZ Q bq bq dd bC bL cB be C bp cV bu l bD bD A dj ci cq ck ba cG bA G bI bM cC bG bz bG cc H bj bo y bD bu br bH bY be co cE ck bi bw l Z bG bP bC bU cg bD bf bj bf bm bo E br K L bP w bc bg bc p T bf Z bl T bm bE J bm bq bB bE bE bA bc bz br ba bA bW bj cM p bE bn bT bj bD bg bu bu bC bR be p be cx bP bU cH cH dE bC W cb bb bP bV bV ct cb cf cK cZ dk ct bZ bs dZ G bA cd cH bJ cc dl G K co bo cj bf A bt cY bK bq cc bg w bq bm g by M bb bD Y cY cz da bM bH by cO bS bN cB cX dd cG cd cJ ck bH bC bE bK ct bF bR bS by dK cb bz bx L K bH bp be f K A J T bW bE bv bi bs bY bZ bG bA de bq bt bU bF bN bq G cC cW cD cQ cQ dP ch bt bg bS cX bW ct bb by cY dh cU dR dm di w ce cI bR cM cg cV cb I bP dm I bE cF cB dk db bO bW ca cK ce bH bp be T cD cs bG I bU cE bd cK cz cY dn do cr bb cJ bY q bF cW ct cJ cc bA bH bT -1 ca dp bC bF dD dq dT ea dz cV cG cE dr cS ce u bK bL bA cB bq cF dj bC cv cN by bm bE bt bB cs cj cb cz dx bZ cx bb g bT bH da bL bM G bR cf cw bg ds cC cX bG be bG cD cK eG -1 dc cM cM dt dd ee cp dk dN ew cY du cr dv dw bG bH dh cQ f bl p bS ca dl cF bO db ct bj bB co cH cP ed cd cN bA bN cg bX cf cE bb cJ cD dh cy el cZ bz cK cK cy dx bb cY cV bC bO bO dd de bL dv cj dy cZ cE bd ce bL bI dz dU cc bX ck bd bf bX cd cW bH bB bg dA dd bn G bS cy bO br q l y bU cf cI bS db cX bW bb u dh cE F M Y cX cZ b G bI bI O bJ bd bp bs bF d cv bj I bL cs ct bL cE q bi ba bQ dj dm bX cY G dB I dB by cx cT ds bp bZ bS bi dd dQ cQ cY cG cb eh dh dw cE bq cx dv cy bC dO db ca dh bw cg ba dI bT cj ce cd dF dC en cy cu dJ cW bq cv cf ek bP dm bx bJ C r di cV de cS bW cz cd be cl cH cP dD ds T I cH cn bI bA bz f w bA bz l bm ba cr dV bn W e bd bb bS bC bS G cy cs I bw bR bQ bQ ct bV bi dE cc bN bR cp co bp bY bL cu bY bz cz co bN de cY bN cx cl cH cj cH bz bj ba bB cX cF bR bO E ch I cq a g p bf G u R E G bA bv G H bI bL by bu J cd bn cy bL cZ ca dA bD dF bH dG bH G p bT by ca bo cH E cJ Q cV bS bF O s bd O bL bY cR cE cx bt bH cB bd bN bE dd bv ct cE ce cJ df cM cT bt bR w cq bS bR G bA cg di di bQ ci dE cu dH cQ dI A ei l bc bt A bq bu bB ch b cF v bE cs bx bS bG cZ cB bo bw bI cV bK d N bv N u bf br q bf bf J bc s q E E bL bv I bC B bx bG by bG bF cN cm q ck w bH ct w F bw cb bK bj bV bG K bS ce bT K bb bj bf cd bl bE Z bw cF dJ bJ ca bZ bt cy cO 0 bV bA bS bV ch q bM q u bu W dA bu cc bS bH de cF co bC bV bM dK cR ce cs do bZ bi cB dL bV cN dL db cZ cg dh bE bC bo by bK bG bv bZ Y cB bM I p bI cY bm cG cn ch bY dy bS dH bb dm q cV cC ci dE dM cd dN cC bj bQ cl dn cc dw dG bD dm cp cl dl bB bE dG db dJ dv cu cR dc cZ dA ck bN bZ dB bN dx cJ cQ bL dA bg cM bn cO cZ cG cY cg dx ch bN dO bq cI bS dv bJ er bW bG ce ce bp dK cc cV cC dA cC dS W bE cm ca cI cJ et dP ci dm cR cr cX dG ec bJ dQ dL G dH bY dM ci cA ck cD bN cZ ct cr cQ -1 bn bM bR bQ bI bJ dh bI dh cD cs ce cI dA dp cI ci cv cj cr cR dR cE de de cN ci da cj de cw cs cF bb bK cY ct cj cW cZ bO cq br bP bw bo cV J ch bI bR cW bV bR cI bT dW cH cJ bJ cN bv bs cZ G bR cE cy cg bI cs ce cx dy dP dB dh cR bv bi bg bY bf bx by dH bT bJ cb bg bz bL dd cg cr bR bg cg cF ck cq cX bb d bn ce bb A bf cg d G ba bb bO bi cn de cZ bV I bK bR co cH bV bb bX cq dl dt dC dA cE cK df dS cu cV dK cJ bQ bC dR do cu dn ch co ct cD cx ci di cC bb dT cX cx bD dX cu cJ cp cz cP dI cC dU dw dY cU db cf ct de dl cC bn F de bj dd cl ca bn ca cP dT bb dV cu cr bO bp cY cf cf ca dT cx cN cy cm bb cK bC dr da cs cF cX by cc ca cA cn bd bp be n cy A w co bX bS cZ bx cf bQ dE bL bY bK cN bF bv bO cq ca bC bO W bz bK bI cm de ca bY cx bX bE cN bX cz do bM cJ u bj bJ W bG bC bq bA br bX G ce bI bd bL t -1 ca bn bR dv bd dw bw cR cg cZ df cO cK ch bP dp by bw S bu bw cH cd bb cl cc cO bH dr k ct bM bP bX bI bn T bx -1 cX bU bG bI bu cA cc ct cN bC ba cK bT dB dj cn bX cc cm bX cR ct cr cd cK dd cq bJ dk cv cO dm db cr bq bZ ct db cf dl cs dk dc bO bn cK dd cC cH bd bu dW bU bs cu cZ dc dK dX dc cE cF bR bI br bD bU cc cu q bX bZ cW cQ cd d bg bi bX cH cK bB cd cx bW bW cd bT ca bX bG bl cB bu cc cK cP cz cF cb cu cZ by bZ bi W p bR bG cX dg cM cw br bp q ck cD cf bG bt bj bt cz bC bA cy co cd cE dm bE bQ dN cw cP ds cV cy cF do bQ dl bX cB cd cO cp ce bA bX bF ck cv db bV G ca cF cc bx bS bJ bU cP bQ bN dB cI dG dd dm ck bK bQ cX bO cq dh cK bW ci bl bM bG bq cB bf bA bK bt bl bv cC cy cF bC cB bS cP bB cg p cH cl cc cc df cd cr bR bK -1 bO bP bL cf ck co cG cN ch bV cz cQ cV bW cq cu cd bT bR cd cp ci bC bZ bB bv bQ bD bL bu bA bB be bw cg cH cv Z bA bD bH dP bM bC cg bG bX bx bX be bX bR bR cz di cN bn cH bQ bZ bG bI ct bu bS bp ba bF bZ bp bX ce cr cf em cc ex ce cD bZ bM bJ bl co bI cW bd bA bn dm dR cD ch dE G dR bG cH 0 bX df bO dc cS dR cn cK dN dY cN dd bT dr eb dm ck bz de bQ bA dy cz cJ ct dw dZ ca cZ cC q db ch cN cR cA ea cN cf bX bP bI cg bH cI de bZ cN bM br ck ce dp dk bU ds cq cF bW cb bj dd cK cv bT A bm cV do cK cy by cu ef bD dc dp cF cn bT bQ cz cD bT -1 bO bN bS bK cd G cq bY cg bL bE cf cv cb cK cX cl cp cp cm dn cN cQ cN cn cq ci db dC cy cJ cr cp 0 ct dT cT cw cJ bT cH cX dC cf dE eL cu da dJ dC dm dy dx ck cv cq dJ eD dG cp dM bS cZ de bJ cq cZ ci cW dO df cy bs dR cw bH bu bq ev dK eb ec dG bx cc G db bS dX eb eo fE cy dw cf de dV cL dM ec dB ed ej dL bM cM cP cg dC cb cg es ca cs bF ck G cH bM cw di dg eg dR dC cN bZ bn cJ ee cU ds ef db dA ck di cB cj cJ ck cE dm 0 cr dH cg eu cu cg cm eg ed db cZ cN -1 cH dL ct dV ck ec db cJ dT eY cA ee cP eS dD dN cn dA cA cr eU ea eh cV cC cj cO cS bS cc cf df ed fh ei dA dT dx ce bX bS dK ce dZ bN df dw cL cl cw dw ed cY cS dT ej ee ch dm cQ cB cR cN bI bo cY bN cE bJ bA bH cP dm cz cu dm ds dk cj bO cS cA ep dy dm ek cO dh dH cW by cs cn cg bw cI eN cW cC cQ cJ bM cQ cr de bt cQ bJ bC cM el bC dN bQ bm bw bX cZ cB cu bB bv bY bV cy bZ cJ ba d cA de cr bp bZ cZ dw ch em eQ dB cC dt dx eg eW fz eq en fa dx eA bR cb di bB cc cI dk ek dw el dy ee di cs bY ck de bW dB ds dR bW cJ dw dP cx bQ ce bU cf cn cn dv cY ed ds cj cf cI bz cX bP cQ cH dn cF cE bu dK dq dh db bK A dZ ck cX cM dp da cz 0 dH bO dC ca q bQ cb by bK cj co ck bI bt bD bB bT ds cf ce dc bO cv bZ cE bN cD dm bz dd de dr ec cA cL dB cS dA cy cV ei dq eb dS dM da bK bI cV bM dq cO eb dk dz bT cg bn bg bP be cT be p cx ck bJ bt bC G bT bd A bH W bX bg bR bx bR cN cD cv bM bW bD df ck d cV bT cj cB bQ cQ ca cs cZ cx cH cX cP cx cj bJ ce ct cG cp ec dK dm ci cJ cJ cR cf cl cJ bM -1 cY cX bZ cb cd cJ dh da cv cn cq cm bn cz bR cS dH dX cC cU cI cV bK cm cr bN co cJ ec cJ db cj dw cC cS cQ dZ df cL cb ca cM dj cb cM bM cr de cf df bX bw cY dI ca -1 bV dG bN cJ bD C bn cP bN bi bR cz bW bX cb dh bI cg bn bT ez ee ec dl cr bN dZ dw dC dw cX dl cN dp ce ck bG co by cj bV bs bG bH bB bR de cx bs bD dK cz bO cM cj cj cd bV u bD cj cz ct cR bI bG bD cd bR cz cF cF cb bD cV cM dm cv di bY bS ce cj bB cK cv cM cu cR dR dn bz cd cB de I bf bF bY dX dl dj dd bM da bL bP db bg bb do bW bZ cQ cq ca dd -1 cV cW bY em cC co I m bY cB bd bm M bJ bz bs bw bH bv bV bV -1 t A bI O bt bw cn cN cb cv cu cc bP bV ck bl bG be bR bj bL de cy bW bI bS I bi J bC co bB bU ba cf cm ct cM bW cf bs bF cB bF cj bX ed ej dI db ef cT dd da cO cA cE bl bU ck cR eh eo em eB dJ cR de bD J bW ch cm dw dX cX co dk cG cW dU dp dZ do cA cg q bH cb dT cx cD cz cX eM dZ dr bO bJ W cW bN cd cZ cE cj dl cq ct cV cA dp em dC dG ds dD dN bM cJ bO dE cT ca cV bU dp bI cW cz cQ bE ds db cv db do eh cV cu bV dh cn bi w bY bo bB bU bK cp bn bZ cv br bL -1 ck di cH co bD bH bV W bG bl cQ dd bD cE bK cN co bv bu I cR bd ce bF de dr cJ cu cN cy bM dE cH dT cE cE cO ds cZ cb bJ cK bI bA bW cH cr ck bM bO co bI cX dd cb bO cx cd bI dh cJ ck ca ci cY dP cy cF bs cZ dI bN ci cJ bn bJ bS bP bv bD bE cg bW cR bZ cy cJ ch bU bt co cP bU bR cJ dA cz cQ cJ bD bQ cV cX bC bS bL cm cN dA dL cW ck bY bw co df cl bg bG bJ cu bC cA bD cB bv ct cN cR bG bs du bt ep cU cq cY cm cB bE cd cq cd cf dn cf df cr cZ bI cj bv bO cb bL dy bW cF cF cv bZ bT bC bZ bw cM cu cp cx bL cR bX cM ci cx cz dp dZ cn cb cd bI cc cN dl cM bO cw cm cY dG dB bl di dK bW dl cH bO bQ cE bV cn dc bS ds dZ dP dC eo ec dv ca q cu dd bQ bQ cy cH cV cb df cw dl dl cz dw dT cV ea df df cn bL ck cV bq bW O dS cQ dl 0 bq bD cH df cA cX di bG cV K cO bO bK bF -1 cK dw cD cu cX el dj cY cj cf dN em bK bx cG bA bN dE dk cZ cq ci ch ci cV cR bs cR bS cj cf dh dm bi bG cc O bw bD G co bF bY cg cv cH cf bB bK cs cv bw cD dm da bG bv bV bD I dD br cS bg bE bw bz bi bG cB dh bU cC ct cQ ca dc ds bG bC cl cb cJ cd ec cq cg df cv dM cf bg bV cF bS bn cI cx eE ce dH dB cJ bu bx cF cM bu A o dd dm cf bF bV cy G bY ck bz bF K bN bA cg dl ey dW cY ds cv bn dA cR cl bR bH cE cM cr dZ cC dk dl cE bO cV dT dj eq ci er es dr cN dG db dB cm bG bd bI dd cd dN dj dE cP cq bt bn by br cI bM ce do et dE bQ cA dR cB cd da cn cD bC O bV ct bV co bL bT cI bF bu bV bS bq -1 bE bR bY bZ I cP cs cP cR bD cf bS co bM bJ by cb bK cu bY dh cF do dx dd cf cq cY cg cm bV cK bb cy bu dE df bF bx bI cE cJ dZ ct cH dh eP cV ed dM bW cC cp cB ds dN bM ck bP dd ca bZ cK bV dh cF bF dt bX bZ dC cN dG ce bP bM bc cs cm bQ dd bY cA du di bF dC dt bZ dr bl C dh J T cs dA bM cw bZ cB cC dq cB cP cL dP cc cC cy cq bq cB eu dw cY cp dH cz cm ch ev cV cz cp cl di da di dN cD ca cy bD cd ck cy dd dd bE eh cp bN cY bg cY cR co ct bO ci ce cE dF dq dk cZ dc es cU cg dH dT da dc cP dw dl dT dh cv ce bT cw bZ dl cr cM do cD bF cD cM cY bl bN G cs ed ds bD cp do ck cC de dr bB ck cg bO cl ch -1 cK bY cj dm cD cx s cV bv d bz p bT bJ bU bF ct cy br bD bZ bq bj bA by bi bH cs db cd cb bJ cV bJ bZ cq by dx ba cs ch cc bJ -1 bI bF cj bM de bi dm bb cO bN cq cr cq cb cS cQ bT cb cN bt bD bA bY K co cp cY ca cm de cZ dH bH cu bN bS db cB cb bC cq cc bN cn bH do bD cb ba I cl -1 bM bL dw di cX cl bT cs cQ df dc dh cT cH cG dp cI cC dm cq dx cX cF dC dN 0 dq dv dl di de dT cA bp bY cj cx cb cx cl bq -1 bf cx bn bm bz bH bA bu bR bV bX cv bz bq Y br b q bs br bK d Z bu bJ bD I bZ J cd bj bA bl w bD bp bl co be bP bC Y bR cg bq cm y cb bF bC bF bz bm cm de cJ bv F bA K I Z bD y bb d cH d bP bs by bG bX q I bD bv br u bl F p bR bP bf bJ bV cF cv bs de bA bn bH W ch cn cv cq bL bY cH cZ cx ec ch dr dd cR bv dU cO ce cj cO ck bR bV cQ el cg co by bY cM cN ed cs cm cc bD cq cU dg cx cm bX cH de dN cL es ew dR cs bA dj ex eZ dB dl dN cQ cd ch dI dh cr eb cE cK bO cB co bM bW cx cc cA dy dR cw do bX ch bp dC ct cW bo bT dE cv K g bf E bl Q bS bj bY bU cm bd co ds bK ci bW ch cC do cm cJ cR cm ce bg dm bT bz bL cP dF cE dv cD cg cu cd cf bY cY bC cF cz cf bX dm cr bB co cb cs bN cb bj cE cn bZ cs bZ ci cl bt cJ cX ct -1 cw cz bN bN cm bR bD cz cE cR bV p bD bO bQ dm cB cP dp bR cH cy cF cV cv cw cu p bR cm cl cz cn bi bO cP cq bl bn cj cn cg bA bn bi bi bX bW bg O bS dc bN bO bV cF cO cl bU cY cg co bN df di cQ bP cd bJ cK cf bN ci cx bO cl cH dH cM bv bJ cR cq bp cX bo cB bw co cB cB bA bS cB bx bq bj bG bn C s br bY bL by K bE cy co cM dh cB bb cs bP bx cl cB cE di cO cx ck cg bt bN do de ec bH bi cn cR bs cl bq bn bW bI cS cb db bY cX dT df cX dE bz dt cd ci dc ca cL cT cm bC cH bF bx bQ cx -1 bE dh ce bZ bM cq bG cl bS dN bS bb bI dc bx bW w I dH cg cM bW cy cF bJ by cy cv cP cc co cw cM cc cy bM cy dm bR bv I bW cc A A cp co bt cX bF bF bX bR cr cd bN bw bZ bU bV cY bn bK cc bV cF bN bN bD bj ca dm bn dZ cF cq bL dd cl ci co bK bV bX cB bz bS cl bJ em bV bZ bK bs cZ -1 bB ck cy cM cN di dk bU cY cq cy cO do -1 cD cE dP cb da cG cA ey dy cn bD dE dC el ew T bC dl bH cF dl do bT bW cE de cU cs ca dJ cj cN bq cm bK db cx dB bT dc cH dl dE dY cw cN cw bJ ca cf bQ cA cN cf cB bQ bR bO bM bK bq bn bR -1 bX cq bB I cc cm w -1 cm ck bT dT dZ di dB dN cK cn bQ cm cL cX cR ed bM cW cQ bM dy cv bp cf bC by cv cZ bz bs cz cq bK cy cZ cb bX cg dc cR dA bZ cf ch cG cO cS dK cM cd cQ cs dl dE bQ bS bX cN bV cb cN cB cK dm cq cB cz cH q cp cY bT cY cc cR cS dv cu ez dl cS cj dD cj du cZ cQ bZ cD co by do bV di dh eC bt bO cU cw cY cw ee dB cV dX df cQ cQ bN bs ca dJ du cj cz cl cm cP 0 cX cp ca cP cS bK cD cW cG ce dJ eg di cw dG eA di dd bD bQ bs bU bG cI da cy cJ bY ch bq bK cC cv bl dn cY dl cf dw bV cx cF cG dX ch dH ef do dN cP dK dA df cd dA dO dl ev ej eB dJ eq dU er el cj cq bF bs bC bD bW cB cV cG ct bI bj G p A cd bq bN cM cf cQ bE dE dA cp bP eB ds dD dK ct cM cv bb bB bV bE dJ bA dn cp cc ct cY cO bV bZ cE bG bN ba bx dd bp cc co bT bX bE dP bX cE cl dA dl cY cf cJ bU cl cN cH ck cY da dm cB cG dX cW er br cm bY cf cX bC cF cq bJ q l bp Z l bs ba cH J ca Y co s bC ck bO bP bZ cr cD bq cf cG cF bq cw bX bv bY cq bs db I cs co cF bv ck dk bH bM bs bS cb dz bE cQ bO di ca cv cA cs Y bW ca cS cN cN dw es cG dN bx ca cV bF cu cx cY cw bO dM bO da dM dL dA dG dC eh cI dj cA bL cl cP ct bw cg bf co cY cP cG cQ cQ cF bn G cp bd bP bt bg p bG p bN bW I Z bg Z bW cs cn cF dM cd de cN bm A ba A bW bc Z bC bG bZ br bE bq bb br bK bs bT cZ cX cd bM bC cg cd bI cy cv co ch cN db ch bL cN cj de dP ed cV bN cB cO bl bG cv df cY cL cZ cQ cD cO co cr cu cV bq A bw bi bt I K bZ bd dn de cw bt bM cc co w bg bW bd A bl q p bJ l ba bc bF bM bP v W Y bq m be G bA bb X L x cd Q be by cg cN bo cN bU bx bK dw bt cx bN ce da cM cR eA cQ dp cc cu db G de cY co cV cJ cD ci ds br cj ct di cO dR cX ds cu bN cx A dZ cX bC cE G r q cg bW cJ bt K bF ba bq cE bj ck bo bT bp bQ T bC C bm bM co p bC u cq bx bU bE bd bE -1 cZ bS bl by bM bG by cZ g ct bt A bJ q ba ck bp bR cR dl cq bB dm do cP bK cD bL bO cq de bL L o bW bQ cP bz bP bZ bW cv br bG H bR H cN Y bV h bF b bt bn ch cS cP bZ da dA bU ch g T cy bg bt dd bc cB bt cS cI dG bn cE et es cV bN bi bu bG bG cy cO dk cp co cY cA cT cp bH -1 ds cq cf bB be bz bc cl cN cd bz by bB ck bM bU bG bH cm cq bQ bT bR bn bG bM bu W bY ch ci dE bo bZ cK dd cp cx cR dd cH -1 bi bR cy co bQ bY cr cw cC dE bQ cv cR -1 cC dZ cx ck cZ cw dd cK df cI dn cP dp cm cn cq bT cs bM cu ee bb bb cn bI ch bQ bV cb dp bY bz bA bu cA bb cM dc cR cY dc cD cG dk el 0 eh cl bw bb cV dd cz di cj bI dm dv dd et da ch cx bK cF I ck cl dy dy eC ee cX bz w bJ dp ds cM cz cJ bL bs ec bx cD cN da bF em cP cP bv bR cW cy cF bH dd bJ cn ce cA cq bQ do cy cn cz cA cH cV co cu cc -1 cJ ce dA bX bS bb cd cD ch bK cv bp cQ cZ dR bH cO dp dk bI cY dt ck bR cW cF bb dE bI bb df cm cC cs dl cz cN cj G cx A de cG cE cW p bl cn cS dt cB dp bW p cC cn cg bl bP ca bF bt cl -1 -1 cB bt cx bO bE bR bV bM bx bS w cB dl cp dp dj dN cp bU dc cp bP I bo bq bC bL cv cD ce bF ce by br bW cY bt dN bZ ci cz cP cy cc cK cv cr dr ct cH cN ch cm cR cv cP ed dJ ck co cx cO dh ds dZ cd bP dT cc A cJ bG cY cn cM bH cd cr ds dC cg dN cr dN cO dd dJ dr cR cf ch by -1 cq dh cr ch cu ch cP dd bL cx co dR dn dJ cr cz dE bR cl dj dZ bb bu be cJ bQ ec cV fg dd dv cS dE cW dq ca ci dx cK bT ci cj dD bW ct bR cZ dF cm bM bt cr dr cb dh do ce dO cP S bA bZ cz es dz bU ce cy cQ ck cO cX bU ci cQ bV cK cP dj dG cj cy l ca dy cI da cf bP bN ch cv bJ dP ef bt cB dg cD cN cd dp dc bH cP bS cH ec dH dm cx cX dh cp ca dH bO bU cd cQ bK cF df ce cP dh df dy cY bN bO cP ck bD cD do cQ cE cN cn cA dE bm bF cq dF cf cl ba bx cR cC bW bz q bA de bo bA dx cy cd cu cc dk bs bn dj cK dA ez bb bN cx dE dm cg cq ck bv co ck bp W 0 cy bH cX cW ch cQ cY cl bC bi bP cO cZ bz dh ct bZ cJ co bx co cE bC cX dZ cN cJ bY bM cA cL cs dX dw ey bL bW cx cJ cl co bf bw bA bW dy cX cv dm dJ cD bI bV by dB ew cV cG cL dB df cd ck bq bP cK cC bB cC ci cJ dC dA cM bY bZ dh bV cz bV cY dY cC dJ cn eh bU cd cb cs ck cs cv cx di cE cl cr bO bD cm cW dp cu cW ch cz bu cn dc cq cb bU cE dX bT cb cQ bM cK di bI es bI cJ ca bE bG bA bz bp u F w bB K bt bK bm bm bm A G bF bX bY bT cB bC cH bD bT bR bK bo cO cf cq bV bK cu dJ cx db bT -1 cN bB dh cb cz ch co cY bQ dl cN dh cJ cv cF cj cX cQ cu dh cx bD de bb cR cW cm cG cA bX bD bR bG bB cX I co cA bM ed cF bS bI bK dJ bC bU cD db bF bd I ck bn cK bw cK dn dd bp Y bB cd bE bE bQ bW bS bo cf bJ ce dw bU cy cC bv cY bN cw cx bQ ck bl bw Q bb bA bG be E H ct Q cq bV ba bS bF bS be bl J bN bB cO cO bt bY K bq bf bx p br cc cI bD ca ds co bN cw dz bC cx bu cD bL bQ bY cW cj df dt cm cz dl cN cI cC -1 ch cr cf cT bS cF bv bH F -1 dm bX cA cD bO da df cz ev cr eD bM cb dJ bN bz cj cK cb dl cP dv cO ck bA bt dh bg bd u bv bv H bC bt cH cQ cK dh ee dm bq bB bf bd cN cI eu cG ed cj cs dh dh cG cV cP cn cf bJ bG bz dZ cM bT bM cn cX bQ cx bX cn ed dp cl bA db bg bw cY bW cy cl cv cE bt cJ cX bs bS de dv dd cw bM cE cB cK cZ da dh bG cd cw cg cc cH cC dk cY ck bQ cd cd cx cg ck bJ ct cE cr cf bC bJ bY cN dv bQ dH cV dz bY dt ct er cv db bx bj cB ch dA bT dU dJ ey dj es cq bS cq bv cm cf dp da dl eJ dv cE cq cW bN bQ cl dE dt db eC bC cy ch cw cq bX by cP cp bA bL cE bD cX cH cZ cC bI ct bA cq cz bC ca de A bA bl do cv dc cF dK ct cJ dp dh eo ei cO ed ce dv cZ cH bL bN ce bI cm cd cU cx bO dJ bQ q cK ee ec cV cY bJ cN de cB ci cv cG cz dS dW dP cA cW cE dc dM cg dM cG dx ej bY cm dC ej cJ dd dE dX cO dG dA es cr bU cw cG bZ dB cG ee bM bK dr dc ch cI cZ cg dE cF es dw ch bY cp dR ch cX cT bQ cQ dw cC bG cZ cx bV cY cL dp dp ca dh cO bx cX cK cE bY cb co dd cB dc dl cu cH cr bv bU cu bv cS cI bn cy cx cn cY cn cA eT dT ds cX dW cS cf co dG bQ bO bQ cp cm -1 bX cR cc cd by bY bP T bH be bv cN T cs do cC bw dT bL cB bY de cM dJ ch dF dc bL dA dj dk eE eF dt eC el ep ea eF 0 dz ew eH eD eA eK ef dz dY dn dt cL eG fb eq eV dt db eh cA bX co cl cf ct bb cr cD dr cr db dm ds bR cY cF ec dw dC dh dw dT dn cV dB G cf cH bX bu bU bn bF bJ bT cF dK bB db cE bT bX bF bH bE bO cP bb cp bK eA ch dh bS bv bc bl p cX bZ dE ci bt cF bF be bP bX bI cD bo dm dP el cu dV cm cM du cC cN cP cV cX de dC dj ch bX cg cv cn bG bT cl cS cz bR cK cs cf bR cZ bB cA bM dR cQ cu cm cP dn cd cb cq cV bf cf cR dp cX cX dM dg dE dw dT cf cF cV cn cs bq cB dp dP eE dR dn bM cl ce cQ cI dJ eD cT eE eH dL dE do dB dL dU dN ea dT dE ci cH cW dl ci cW cT ek cO bQ cr cb dw ec cb bF cB cD dm cn cO ec cD bw cP bn da dc cr cm ch cz cq cq cv eg ed er ee eX fo eF dV db dP cS eF db cD cV cF dC ch dc dR cE bn cc dd bY bj cD bO dJ dB bU fF dO eO eE eu eI eq ea eh eq eq 0 eR cD dv cp cz cB dB dC dd dA cM dj cT ey dh cM dX cS ei ev dG dX dB eI el dD ci do fi cO cj dt ev em eJ dp cA eK em cL 0 dh dV ct eG dh ce cP cr cB cX bN cF dG di cV dT dA dT cL ch dK dp dR de bD ch cQ -1 cl cc bb cY cQ dw bb bT db cn cO dp cV cF db ch bM cB bN cs ct cQ -1 bu cE cw bY cQ cV cq cm ch cy cI cC cp dp db bG dd ce bT cg cZ cs ej cq dR dv cG ea eI cx cP cA er cD dz cK dV dE dR dp cp dr dE cb eB cU dH eJ bQ dV eC ci di ei dU cO dX dv cZ dR cP dK cd cI cW ei ch bY dp dJ dn cV cb co bu bX bK cB cw cU db di bU du cN cC dE bZ dg da ec ds 0 dJ cX cn cY dE cH cG ce dl cR dM cv cn cD dR cV dA dB dc dk cI cK cO cy ck dr cw dG dT ch dN dd dC cQ dq cr dH br dA ch dm eo bN dr bA cF ci bA q cC cG cO do dS dj cG ed cc bs da cr dC dp dJ bH dZ eL ep dT dD dg cH ec dc dj cA eM da dG di eM dH cp cI dn cs da ct du da do bO cN cP dq cr dC cF cR cm dA cT dX da cT ct ct cs cs dm cH dw cr cf bn bf cq bA cy co bO ct fe bD cQ dM dz cI dA cX cS cS eg ci ev dw dC cc dV 0 eb dF dn dU ey dL dW eo cZ cx bv dH dn cD bf cD dc bO dd cN cn cn do cV cm cv cs bs bI bT cw ce bq cq ec dp cM cu db dn bJ cG ci cB dw bU cF cY de co da er cf cP bA bR -1 cp cY cQ eM cA cR dd cK dC bU bz db cx do cU bN cE cb bq bg G bg A s m br bu Y bF br by dE cN da da cz bz bx bz bu bH cE cW cP cS cN bU bb cv cH bl bc w A u bx bE bI cc cP bo bT I -1 cD bZ bP bx bt bx cG bM dZ cD cO dy cU ci dF cp dW cL dH cY dR cj cc do cG dH di cU dq eJ ek cF dK dm cc da q co dd bE cy bE cx dH cD bp bI cC cY dJ cY dh cL cR ea cB cN bb cG cI ee ck bD bS bw cl dh ed eN dx da dw 0 cC db bW cw cX dE cp dm bZ bU cw bu cj ce cs cJ cx br bD bt bs ck ct bb bo bP bV bp T O bw br bT ca cw cu cc dy bM cl cF bF cs ck cy cr ca bN de co dh dN eO eE bY eP cL dk cB ce dA cj ey dK bD cK cM dc ei cD dJ dY bM bY du dd cM dE -1 cE cX ci cY di cf dN dq cp cy cx cy bW bB cN dh cZ cV ec cF cf cp da cM cE dp cR cV dk dI cx dZ cR cQ da cR cu dy cW dB dy dq cn dR eA cB ej bL cz cb bM cI cM cb cM ca bw cT ej dl cJ bp da bb bP eu cV cw bt cl bO dA dL cy dF dB ct db cH ds cN cX di dh bS cY db cu cV ck ek eO eQ eL dF eu ci cK et dr eA 0 dW dA dI dv cA eR fc dX eB cC dG dn cY dP dJ ev fn dI fk dW da cL cm eG cJ ca cL db cK eB eb cP dP cX db em dt dh eu do ee dP es cD dV cs bA bH ct dZ cx dF dK dR ct bT cv cz cB dm cn el dK bW bV cE dl dA bJ bY dg cG dA dY eI dp dl fd 1 eS ev bD es dd di dP ep ep cR cQ cr dY dk dQ em em dR dy cW ev cI eQ dH dm cW bT ds di cm dX dU eT ez dF dx 1.24 db dX dM eU ej eE dz cD eb dC ep dq eN dt es cW dA dw er eV ec eg bD eU di dZ dL cs cN bS bB dT dm cv ed dl cu eI cT dX dj eb du di cU eW df 0 dd er eX ej eP eq eY ei dh cR es eC dP eZ cj dD er dY eI eJ do dR cJ fm fC eR ff ej fu eu em eh dG dK dn ee dP cw ep 0 dA dW cY eo dv dZ dJ cS dR dG dG dF dL dK em cU dU er ev dR es dY dA cS dD dA ee ea ey fq fa dj eB dP et dI dt dA cL ep dK dI dx dB dW dl eA dR eH dw fb dK 1.18 dx fA dG fc eN eq fb ex cM 0 dr es 0 cM ct cK db dJ ep ds fj do cL dg dY dO fd cP eB dP fs eL ew cr dq cL dY eP eF cr dF dT cL dV eq eH fp ev fw ev fl eD fe eT ff eT fg er dA cC bY bS dK dl dl dB fh dW cM db dg dC fi ek dH 0 dq ep eq el dP ec ey em dD eE dW cQ cE bC dR cJ eh el eq fj cY ek cs fk dU dF eY dj eq ee cH cu eh ed eq eZ dP fl fm eB dP ef eX ea em ef eE eB fy dO dg ex fn el eI cp dn eH fD cp eB cQ ei eC el dD eU ft 1.26 fo cw ej fx eH fB fv fr dk cU fp dM ea cP ec cU fq ey bX eE cY cS di ci cX di ch cA by G bI bJ bs dh dC dC cG ez fr eq ex el eb eE ds do ek dy dl dA ee eQ es eG dm cG dC em cs dw dX cL dy dU dX dz dH eA cp dA di cG ce cY ct cZ di dr dT dK cJ ey di dm cU cs dp cy cA dy dI cD dz ds ci dw ch dc dH da dr cP er dJ dd dm cA eq dH eh ed cq cf ek eU dT ck cZ dr cV ec cC dR cG dg cb dc dA eP dv dy fs dF cm dl ez ep eK ez dG eK eB 0.88 cY ft 0 eE fu dI fg ef ef eQ ep eH eh eE ep fv dZ dS eT cX eg dC cE dl bI cM dy dv eu dK cw eh ea eO dU 0 de cU cu dz 0 dI dq 0 cY eo dE dj cy cq dh cJ dE eB cM dq cR bN dJ dR da 0 dZ cO dI dv dC cW ci dP ep cr dg eL dY eF dX eS fs dN dj dN dy dc dX dn dG dG dv du dX cG dw dL dj er dL dG eG cT ei eO cS dc eq dG dE dC dM da cS ej dr dy eE eZ do ei cC dl cl cS dY eR eu fh ev dJ du es ez dp dU dW dY dk cY di dJ dD et eG ds dB cI de cL cr dm el do ew ey eb eA fh fw ee fx eJ eK eM ej eV cA cG eO eT dG 1.4 fh dM di dJ di eU eJ 0 cU dt eh dS em es eU dI dy fy eo dh dX cc fg dW ef dP dZ dW do cT cA cK eV dA dy dS es cu el eX ex ev dD ef ep dg ez cV dT eh cQ dp cZ dN cj bj cJ ce cD dm dv cW dR eC dK dp ek dL fn dx fz fn eZ dN fh fp cw df dt dQ cL eg dN fs eQ eI fA dK ef fs dV cj cw ca dP fk cA dV dB dT ec dG da bb ct ct da cj dm cF dE ds cu bB cJ cb bZ bA Y bU bN dR bK cj bj cN cp cb cO bX ek dF dl ea dJ eA bQ cj bY cd cO cR dR eg dF ea dX eA eA cn fB do dZ fa es cn dp dH eI en eQ ec dR cM eU dl dy do cA em ed el ce ef eM eQ ez er dB eg cB cD dk dM cE dq ec fC eJ em cS et fe fg dx eM eW eI eu eg fn eI fD dg ey cW dp dy eb fy dF cl dn cF dc dB do ds dk ek bQ ci cZ cD ca ci ev ea dk es dx 0 dU dx dH dN dU dI fh eP eK cT ck cE do fb dw dF eH fw eD cO cb em fd dY eF et ew 1.05 eM ek dY dW es cu ft eX eh ew dW fo ev eJ eS cI ej ez dz ds cz dr es cr dF cA cx cP eE dy dv dF dN dM eM dd cx dp eh dw ck bL cF cP dw eu dN cC dW ch bZ cK cI cg bn cy -1 bO dE cP cF di cW ea eD em fj dT dl dS dN dk dj et dk dk cW bz bL cx cj bY cC cp em cq cQ cf cn dZ cX bH br G bu bb bR bT bN cM cu cn dT cC dX dT dX eh eo cN cZ cO dd cG dg dd bs bI cb bH bs cd cz de cO cY bG by bt A bs cE cn bi -1 cv do cD ca bO dh dF dT ci dZ db dy dh eA cL dj dN eA cd cu cY dN dh cI bx cv dh cO cX bZ dC dP cQ dl dm cm da dd du dl bJ cK bS bW bD bI bU bu cN bQ dJ eQ dg dd dt W bs bQ dN df ec ci fj ci cF de de cq cj bY db cK dZ cC cE ed cS da dG do dy dA cF bZ ck cE dj ed eC cu cp ci cN cC bR dt dy dv dC dJ dx dH cN cD bU bO ca dc cK cn cI dg bR bq bN cn cE bO 0 ct em cC dE bO cH bN cg cc cj cZ cy bD bM cF bE bR dw cN da cK dm ca bE bB dP cz cK dA cS dg cE dy dq ed cP dL cw cY bK dl cR cn cx cu cs ec dR dL eu dt dU dp dz eq dv dH cI dp cA cs cj dx eI eQ ef el eQ el dl dj cC fh eN fG eZ fE dS eG fF eY cE cZ dd cX dR eD fv eu dc ca dT bL cz bJ bP bW bX ds dH cz dd dI dl dt cY eE dm dU eq fD ea fx ei 1.22 eZ dM eT 1.33 fH em er dp dH cS cv bs cf cx dw dZ cU cC cQ bD cY bV A A bw bw bB bu bE be bR bS cD cY dC bT cx cl cW cw bL dn dN ei dZ cq bG bK eF dx cS do dG da ez dP eE ea dq ej dA cP ey ed df dO 1.38 du cV cZ bO cl cG dW dS dq cT cA da df cj dZ bX ek di em cj dN ch dA cw de cG cQ dq cy ed cu cz dO eq cQ cx dn cR ce dr eo cM cJ dm bW ci dF dJ di ds cK cr cf bI cW bY co cR bH eI ew cU eE cC dw cz bR bi l p A bF cZ eq dn cI cV bW cz cT dM cz dJ cu eC cF el bG cL cA bQ cw dB cG dT dT ey ds cZ dx dS di cD ct da et dc da dk cr cM cH bJ cJ cr cb bT dp ca cj cd cK bM ce -1 cP cE cR cd bS bQ -1 cx bL bu bA bP bv bR bs bj bK cd bg cN bZ bl by cd bX cF bW ba cb -1 cd cI eA du dy dt cJ cd -1 bM bz bE bs cm cZ cB cB ct ca dh cn bR bo cf dl q cc bM bL cb cY dm cR cm dd bU bG ds bS cJ cc 0 cm cc cN cW cA cF bK cc ch cF ci bO ds eh cg cw cb cR cJ cc cC cY cx bY bt ca cw bC cw cq -1 dw di dy cT cn ci cN di ch cH cf bA cQ cf ck by bD cv bX bT da dd dp bC dl ce bV cN co cu cn cT cB cr bO dh ck ch dz cm dA dM dN dl ck bT bU cf cQ dp J W d bf bO bI -1 cd bW cz bz ct bX db ea dq es ce df dZ dC bH cK bM bV cJ cp du cG dM dR ea ft eN eB dy dn ei cD cX cP dK da dK cs ec dN cM dl da cO dK bT cr cX dR dy dT dX dq dR eh cU ei et dj dk es dk cB bn dd cU cZ cs -1 bL bb cY cV cB cY Y bS cp I cy bC bD cd bj bJ bV bl bw cg bX cJ co cg de cA cj cq cD cr eA bJ ct ch cz dB dE bY di bx bn ci G bJ cW cO cj cD cf do cB cx dn cB cR ea cd dZ cf ed ds cV cl cq ca bL dd cj dN dz cH bW bU dp dG cj bJ cr dv df dd dG fs cm cI bX cS bZ cP bR dj 0 eu fm es cw dv cI eI dn cv ce bn ca dV ec da cC dj cm dV df cq bP bx cv cY es ds dy ck cE cR cm cv cH dn cm es 0 er dm dF cM eP dx dq cW dZ cz cm ch et et ez ef dB ed dG dY fu eb dQ dF cU eh ez dS eC es er dm dr eg dE cp cp cw cV bQ de cR cf dH dJ dU dF dI dB ej dy cq -1 bC bC bM bT bO ca cy cT dM cD dR bD cr cB em cB de bX cz cp cM cV cq cn dr cs cp cr dB cM cP dJ eB ce dk cG ei eT et et eM fF dy dw cQ ce bV cc cV dP cr cR cX cL 0 cU dx dP dE ch cW dg ek ch cN cg cr dP ee cx bK eF cP dE dZ cA dh cz dA dr dH es dB er 0 eh dZ eG dD eV eF eN er fs dG ey cO fD dx fG dx cE dB ew es dH fj dS eV dt ef eA dh da bQ dn db cU ds dm cp dw dB eE dz cA dR dO di cM dl ft dY do cV dd cH bL dX dA cD dR dR dy cL dO dI cZ df cU cz cw cZ by dA dJ da dt cf cm dj cZ cM J cZ cf ct cu do cT dv dV df ek dy dL ds dn cp dP dm db cc cy em cW cC bS ck cD dr bK di cJ dK dg ek dA dR eU eP do dy dN dv cO cW db cO dF ec eU el eC cZ dh bV bI bo cR dZ bS cr di eD eH ea eE dG cW dm ci cO cQ co bl dN cr di cr eK eI cI em df ew cQ dw do dm dk dk dF dE cR ds eh ds dg ec eU eo dT cz do cy eA dt dj dL cQ ef ek dO eG eI fF dv fj bU cu dJ dt dy du es ci dp dh cY bU cQ cO dg dw dw cu ci eA di dT cz cc ca cV cW 0 cq cQ cS da dD cQ 0 dG cu dZ dr dO df dG cN bx cp dR es eE dz dO er ec dL dB df dj cO dd cX cP cT et dX eF cW cE 0.92 dt dP cY dM eV eW dF ey eM eP cU bU cC dv cA cg cN bK dp cw cE cH bv bU bs de cd bX cN de ch cM df dM dL cM bO cZ cg bA cq bu bj bw bC bN cl I cs bT bs cd bV bF -1 cv ch bY db cq bC dv cJ bW ch bN dm cY bN dy dh co cG ds cM cA cI dY dh 1.25 bO dK cZ cA cq cU dV eo eO eF eM eT eE eP eL dU dn dT cZ ee dR dJ cL di et fs fH fo fF em er ct cF cx df dt cU ch cp dC ej dM et dx dx et er er cU dF cU dV dR er dq dG dJ dV dD dR cU cs dl dk dq df cm cZ bS bT bI bS ca K bn cY cu bM cz cz cl bD bT bH cV dy ce de bj q y cB cb bE bP bT cP bU bG bC cp cB bt bJ bX cW dA cX bM ee eA ci ec dX cB dX cu er cA cR bu co bz bs bi bR bs cR cb dh cy cf cY bF cH bU cb cs cR ek co bM dI bG ba bS bb cg dA dm cV co ck bv bF dc cF ce cB ce bm bI cC cV cR cb bF bt br cb ck cJ bs bU bQ dZ cg bw bV bt cb bm bC bA cQ ct bT cI bX bU ba ce cf de cH cB bM bG bU cN cd dA cD -1 cW cM cK bL cu cA cM bd bU dZ cV cb cf cB dw cT dT cX cL dd dB bJ cb cp bN cK cL dE cq cU es cJ bO dj eC dH bZ ch cS dp cW dL dJ cf bm cr cX cj dn dP cT dr cD dC cP cl ca cx cv bu cx cg bE bZ bM cs cs cc -1 A bE bo bE bR bB bS cf bt cd do cD cK cG cx cp dj cL bN bU cU dq bH cz dV dX dj dI dB dc cp de ev dy 0 dT dm dT dm ej eU ew dD ev dI dz dG fF dx cD eq ef bM dq dw de dN de cr cN cQ cF cR cu cR dm cA dA es dK cz ci dH de cf cW cD cW cm cW cm cE cC cN ek cO cp cv cg dl cX cV dm dl cR cq cc cP cF bZ bu cn bT cn bO cl dP dE cB cF cd bW cw da cO bZ cR co cs cQ cu dk ea cS df cT dL dc di dB)));
(display 'Stability' ^(a:0.84 b:0.89 c:0.88 d:0.9 e:0.92 f:0.93 g:0.94 h:0.91 i:0.86 j:0.87 k:0.85 l:0.95 m:0.96 n:0.97 o:0.98 p:0.99 (0.53 0.59 0.73 0.8 0.78 0.83 a b a c b d c d d e e g h f f g g e h e e g g e d f l e f d f e h e g f f d h d e d e f d e f d e d h h d h b d d d h h b c e h d e b h d b b i b b d c d b g d b c h b b h d b d h d d j b c h b i d c h c c d b b c h b d j c k c d i b c c b b b d b c k j i j j d j j b h b c j b d c c c b c d e j b c b c h d d h d h b c b i k d d b d c i d c h h h d a d j c h j c d c b i c b i c d e b c j h j j d c d d h b c c d b f h e d c h e b b e b h c c b d b c c b d b h c d b c e j b j c h b d h b c c d d c e h e e b b h d h c e b c c d d h h d k d c f c h b h d d h h c e h d b c c h c e j h b h b c b d e d c b h b d h h d d d d c c i c b h b b h h d b d d d d c d d b c b c b b h b i h d b d e c d d e c h b d b h b f b d b c b d d b d c d b b h d h c b d c d c b c d d d d i c c b b c b d i j d b d b d g d d d b h j d d d d d c b h d d i h a c c b c d d f f c i b b b h c d b d d e d h h h e b d e e h c h d b c c c h h k e d d h b d c e h d d e f b h b h b d b h d b d b b b i b c i c b b h b j c j b h c c h i c j b c h d c h h g e b h e d h d h d h d h h d e d e h b d d h d h e e c d d b h h g b h e e d e b e e h e b c f h h h b b b e e h d d e h h e d f b h h b d d b b d d e h b b h d h h h h d d b e h d h e f e f f b d d g e d e h h e e g h h h g h d h h e e e f g b d e h h d h h e e d e h h e e f e e e d g e h h e h e e d e f f h h f e l l l e h h e d e e h e d e d f f h e g f e e e l e e g f h f e e b h h h d g f f h e e g g e g e e e g d h l e g e f f e f e e e e h h e e h h f g h h h b e f g d e e d f e d h e e e e h g e e f e f f h f f h g e b f d h g f f h e h h f e e f f e g h g f e f e e l f d f f e e h f g g f e f f g g g g h e g g d e l f f f l e f l g g g g f e e e e f e g g g f g f f l e d l e g l f g f g g l l g f l e g h l f h d d h d f h e m g g f d g f g g e h g e g l g e f e d e e h g f h e f f l e m g l g f g l e m g g f e e e l g h g l g l e e f g f h e l e f l g l l f l g l g m g f m g g f e e l f g f e l m f f e g g l f g l e g m g g l g g g m f e g e e l f h l h e f e g e e e g g m e g l d d l g g l f g g f e g g f l g f g g l l g f g l g e e e e e g e f f m l g g f g f e g f g g l e g l e g g f f l e g g e g e f f g g l g g l l m g e h m e f m g h g g f g g l f e d f f l l e l g g f g f e g l g e e f l f e l e l f f h g g l g e l l g g h g g e l f l g g d h f e f f g f m h l g l e e f m f e l f l g f g l g e l l l e m g f e g f e h l h g h m d h g g f f g l e g f e g g m g g g f l g f g m g f l m n l m g g l g f e l l l g g g g g l f f l l f l m g l g l m l g g g l l f l g g g l m g m m l l f g e l e g g e f m l g l e l e l g l n g f l g l l m l m g l n m n m g l g l n g m l g m m l g l m m l g l f l l f m l g l l l l e f l f l l g l g l l g l m l g g l g m g l m m l e l g n m g f f l l g g f l g l l g m g l m m m m l l f g m m l g n l m l m m l f g l m m g f l n n g l g l g m n l m l n n m m m m l g m f g l g l m l g g f l m l g m g g m g l f m f g f l l n m l m l g m l m g m l n m n l g m n m n n m m l l m m m g m m n l l l l l l m m l n f l l m g m m m m l f m m m m m m m m m m m n f m m m m n l m n l m l l n n g n l n n n n n m m g n m m l m l l m n m m m l m l m m l m m n n n l n n m l g m n m m n l n m m n n n n n m n l n m m l l m l n m n l m m m n n m n m n n m l m m n n n n m n m n n n m m l n n l m g n n m l m n g g m n m m n m n o m m n m n g m m m m l m m m n m n n n n o m l n m n n n n n m m m m m n n m o l n o n n n n n m n n m o o o n n n n n m n o o n m n n n n l m m n m n m m m n n m n n n m n m m m n n n n n m m n n o m m o n m n m m n n n n n n o p o m n n m n n m o o n m m o n n p m o n n o m l l o n o m o l n n n l m n o n m n n n m m m m n m m m m m l l m m m m n n n o m m m m n n m g m l n l l n m m m m n g n n m n n m m n n n m m n n o m n l o n m n m n n m m m n n o m n m n n n n o l n n m n m n m m m m g o m n o l m m m n m n n m m n l l l n m o n m m m g n m m m m m n n g l n l m m n n g n m o o m g n n m m l m l m n n m n n m m p l n o n m l n o o n n n o m m l l n n o m n n o n o m o n o o n n n n m n o o m l m o n m l n n n m o m m m n n l m n n m n n o o o o o n o p n n o m o n m n m o m n o m o n m o n n n n n m m n o o n m m n l n m m m l n m o g m n m m m l m l l n m m m o n n m m l m m n l n m o l n l n m l l m m l l n m n n n n n m m m m m l m m o m m n n n m m o m n m o o m n o o n n n o o p o o n n o n n m o n o l n o n n n o n n n n n m n n o n o n l o n n o n o o m n n o n p n o n n n o n o o l o n o m o o n n o m m n o m o o n o n p n n n n m n n n n o o n n o p o n m n o n n n m m o m o m m n n m n m l n n m l l o n m m m n m p o o n o n n n n n o n o m n n o l n o n m o m o o o o n o n n o o o n n n o n m o o n o n p o o o o o n m m n n n m o o o o n o m o n o n n o n n m l g l m n o m o m m n n n o g l n n n n n n n n o n n o m m n n n m o o n o n p n o o n o o n n n n p o n n o o p p o n n n o o o n o n n n m m o m m n n o o n n n n n m n m n n n n o m n n n n m m n o n n m m m n l o l m n m l n f m m g l n m l f n l g m n m n l m g n l m n n l m l n o n n m o n m n n m n n l o m l n n m o l m l l m l o n m n n l n m m m n n o n m o n m n n n l n m o n n n n m o n n n n n n n m o n n m n n n n l n m m o o n o n n o o o o n n n n n o n m n o n m o l n n n n o n n o n o n n n p m n n n n n o o m o o n n n o p m o n n o l m n m o m m o l m m l n o n l m m n n m o n m n o o n o p o m n n o n n n n n n o o o o n n n o m o n p o m n o n p n n o n o o p o n o o o o n o o p o o o o o o n o o m p o o n o n n o m n p n o o o o m n o n n m o n o p n n o n n o o n m o n n o n o n n n n n p o n n n n m n p n m n n l n o o o n n l o n p n n n n n n m n n m n n n m l g m m m n n n m m m m o n n n m o m m l m n o n o o n m g l n o o n o m n m n l m g o n n m m o m n o n n l n n n o o o o m n m n o n m m n m m n n l m p o o n o n n n o n m n o n n o n n n n n m n m m o n n o n m m o m n o n n m n n o n o n p o o n o n n o o n o o n p o n o o o o o p o p o o n n o o n o o o o o m m n o n n n n o o m n n o o o n n p o o n n n m m n n o n o m n n n o n n n m m n n n n p n n n n l m m l m l m n g e f g l f e l l g g m l l l n l m n m n n m l m m m m l m g n m n n m n n m n o m n m m o l n m l n m m n n m m m l n o n l n n n m m m m g g l l g l g n m m m m n m g l l n n n m m o n l o n n n n m m m m m m n n l l g n m l l f m m n m m n m n m l n n m o n n n o l l m l l n l l m n o m m m m n n n o l l n m n n o m m m o n m o o o m n n m o n n n l m l o n n l n m n n m m n m m n m m o n o n m n m m m n n n n m m m m n n m o o o p n m n m o n o n o m o n o m o n o o m m n m l o n n m m o n n n n o l n m m m l m n n o n m n n m l n n m o n m o m n o n l n n n n n n m o m m m m m l n m o o m o n n l m n n o m n o m n o l n m n m m m l n n n o n o m n n n m m n o n n n o n n n g m n o o o m m f l m l m n m l l n m o n n n o o o n n m n m l l m n m o o m o n n n m n n n n o n m n o o n o o n n n n n o p o o o n o n o o o o p o o m o o n o o o o o o n n o o n o n o o m o n m g o n n n p n o m o m n l l l m n m n m m n m n m n n m n n o n m m n o m n n n o o o n n m m n n n m n m o n n n m m m m n l m m n l n m n n l m m m m m l l l m m m l m l n l o n n n o n n m l o m o m n n n l m m m l l n n o m n n m n m n m g m e m m g n l n l l n m l o n o n m g m n l m m m n n m l n m n n o m n n l l l l l m n m m l g m n m n m m n l m n n l n f g l e l l g f g l m l m f g g m n l l m e l m l g g l l f l g l g m f m m m m m o g m n m o n o m g l m g m m g g f l e e e f f g f h f g g g f g l m m l g g g f m n l l e e m g l f g l g l l f m l m f g m m g m n n m m n g n n m l m l l m l l l g g g g g m g n m l m l n l m g g m m m n m m l n n l g m m n l m f m l m m m n m m n m n m n m p n l l m n n o m l g n m o o n n m n n m n l m l m m n l m n o n n l m m m m l f g g g g l l m l g l g m m g m g f l l g h b f e h e g g m f g e g g g l f f g l g l g l l l l g g g n l g f l m m e m g l o m m l n n l l n g l m m m m n l n l n m n n l o m o l m m m n l l n m m m o l l m m m m m m n m m g l f g e l n m l m g m l n m n n n n m n o o o n n l n n m o m l m l m l n m o m o m n g o o n m n o n n n m n n m n m n o o m n m n l n n m m g g g m n m l n n o n n n n n l l l n l l l l g n l m p o m l n g m m l l n o n l m l m l l n n m n n n o n n n n n m n o o m o n m o n n o m n o n m n n n n m o n n o o l n m n n m n o n m n n n m m n g m l n m n m n m n o n n m o o n n m o o n n o n n o o o o l n o n m n m n l m m m f l n f m g n n m n n m o n n n n o m n l m g n m m n n l n g n n n m m m l m m n m m m l n m m m m m n n m m n m m m m m o o n o m m o n l m l m n m n m n n n n n m n m n n l m n m m m m n m m n m m g n m m n m l g g f f g f g g e g e h l f g f n l l g m g n m l g l m m m g l n m l l g m g m g g g l g l f g m n l m m l m n m m l n n n l m m m g g m n l m l n n m o n n n m l n o l m n o n m m o o n n n n n m n m m m m n n m n m n n l l n m n o n m o m n o l l l n l l l m m m m n l n n n m l n n n m m n n n n o n m o n m m l l m m l f g g g l n n m m l l l l m m m g m l l l n m l n m n m n l m m l l l f e g n m l l l l m l l g l l l g l m l l m m n m o m m n m l m l m m n m m n m l n n m m m n n m m n o m m n n n m n n l l m l m n n m m n n m m n o n n m m n n n n n n m o m m m n n p m o m n o n n n o n o o n n o n m n g n n n n l m m l m g m n m m n l m m o n m n m m n n m n o n n m m m m m n m l l l l o m n m n f m n m n l l m o m l e l l m o l n m m l m m m l n n n m m m l m l m n n m g g m f m g e e g l g f l g e e l l g l g m n g m m g n n l n m g m m g n l g m n n o n m n m n g m n n n m m n m m o n n n n n n m m l n o l n n m n m n l m o n m l m g l m m l m n n n n n n m m n n m l o n o n n m m n o n n n m m n m l m l m n m m n n m n m g l n n n n n m n m n m m m p n n n n m n n n n m l m n n n n l m m l n m g n o m l m n o n m l m m n o l o m m o n l m n n m o o m n n n m n n m n n m n o n o o o n o n m m n l n n n o p o o p m n n o n n n n m n n l l l m o o n o m o n o n n m g l l g m n g n m n n n l m n m m g m g m f l g n n n m m g l m m g l m n m n n n n m m m n m o m l n g m n m n n m o n m m l m m m m n m l n m n l m l n m n m m o m m m n m n m n l m n o p n l m n n n n m p l n m m o n m m l m m l l m l g m n l l l g m l m m m m l l m l l g m m l m m n l m l m l g f g g l m m g l l g l g g m f g l l l m m n l l g l m m l m g e f g g g l l g l m g g g f g f e g g g m g h e l m l l m n n m g g m l l l m l e f l l g l g g l l l m f l l l m l g l g m l f g m g l m m n m m n m l m e m g m m g l g l g m g l m l g g m l m m g g l l l h f g g g l f g g l l m l m m m g l e g g l e g m g f l n n m n m m l m g l e m l m g l m m n g e e g e h g g g f l f m f h m l g l g f l l l l l h g m f m g l g g l e e m l f g m l f l l l l l n n l n m l g g l g f h h c h b i e b f f e m g b l g g l g e g f l g g f g f g g l g l l n g g e g l m m l l n l l l m n l l l m l l l l m g m m l l m g n l m g l g f g l g l m m g m m l o m m n m m n l l m m n m m n n o n n m m m l l o l n l m f g l l m m n n l g m m g m l n l l g m n m f m n l m m n m n l m n n n m g n n n n n m n m o n n o l m l m n m n m g l l m m n n n m n l l m m m n m o n n m n l n m m n m n g m g l m n n l f l l n l n o n l l n m m n m n m m g m m g m n m m g n g m g o n m n o m m m n m l n l m g g l m l l m o m o g l m n l m m l n m m m n m n o n g m n g l m l m n n n o m n o o n n o g n n n n n o n n m o o o n o n o m m l m m n o l l o o m m n n m n n n m m m l m n o m n n n m p m n m n n n o l o n n n o m m n o n n o n n g n n n n n n n m l n n n m n o n n n m o n n n n n o m m o o o o o o o m n n n m o n m n m n n n n o n n n o m n o o n o n n m l f l l f g f l l f f m m m m n l l g m g n m l l n m m m l o m m m m l l l l g l m l m g m m m n l m l l l l l n n l n n l m m n l l l g h g l g m m m m m n l l g l l n n n g n m m l m g n m g l l m m m n m n m o n o m m o m m l m m m n o n m m m m n l m n m n n n n n n m m m n m n m m n n m n l l m n n l n n m m n n n o o o n m n n n m n n n m o n n m m o n n o n o n o o n n o l n o o n n m m n n n o n n n n m m l n l m m m n o n m l m g m m n n l l o n n l n n m n m m o m n m f m l g l g m n l l m n m m l m l g f o l m g m g m n n l o m m m g n l m o m n n l g m l n n m m l m n n n l n n n l m m m o m l n l n m m n n m n m m n m g f l f n m l n m n l m m g l m m g l g l m l l m m o l g m l m m l m n n l n l l l m m m m o m o m l n m m l l m n m l g g l l n m n l m m n l m m l l m n n o o n m n n m n o n m n m l n n m g n n m n n n l n m n o m m m o m m n o m n n n n o m n l l n n n n n o m n o n m n m n n m o n n n o n m m n m m o n l m o o m n n l l m m n n o o n o l n m m f g m f m l m l n m p n o n l l m l m n n l g l l m m g l m m l f m m m l m l g m l l m o m l m m n m m l m m g m l n m l n l o o m m m n l m o m o m m m m m l n n n m n o n n o n m n m n n o n o m m l m n o o m n o n m n o g n m n l m m l m m n l g m l n n m n n m l m n n n m n n n m n m o m m n o n n m o n n o n m n l m l l m m n n m m n n n o n o n n n n n m n m l m n n m m m n l g l l n n m l m n m n m m l m m n n o o n n o o n m m n n m n o n o n n m m l m f g l m m n l n l m n l m n o n n o n n m n m n m n n n n m n n n o n l n n n n n p n m n m n m m m m m m m m g l n m m l o m o m n o m m n n m o n m n n m n n n n o p l n o o o n n n m n o o n n o o o n l m m l l g l l m n m n o n m n n m m n n n o n m o n o n o n o n p n n n n n n n m o m n m m g n o m n n n m n o n f l l l n m m n m g l m o m m n n m l l m l n n n l m l n m l o n n o l n m m n m m m m n p n p l n n n o n n m o o n o o n o o n o o n m n n o n n m o o o n n m n o n o n n n n p o n o o l o o n o o n m n n o o o o o o n o m m o o o n n o m n n o n n m m n n m m m m n m n n n m o o m n m m o n n n o n m o m n o l m m m m n n m m l m m l m f m e g l l l m m m l m m g l l m g m m l l n m m l l l l g n n m m n n o n m n m m m l n l n l n l n l n m m o m l n m l m m m n n n n n o n n o m o o m m n m l m n m m m m m m m o o n m n n o o n n o l o m n o o o o n o o m o o n n m n o n o o n n p n n n m m n o n o o o n o n o n m n n n n n n o n o n p n o o n n m n o n n m o m n o m n n n o m o m o o l o m m o o l n o o m n p n o l o o n n n n o n n n n n o n o o o o m m o n n o m n n m n m m l l n m l m m n n o m o l o n n m m n l l l l f m f l l l m l l g m g m l m n m n m n m m g m m l m m n n m o m o m o o n n n m m m m n m n m n n o o n m n m m m o n n m n n n n o n m n o o m m m m n o o n m n o o n o m n n n n o o o o o n n o n o o o n n o o o n o o o p o n o o o n o m l m n n l n n o n n g n n l m l l n n o l f m n o o n n o n n m o l n n m m l n n n m n m m n n o n m n m o l n m o n m n o n n n m o m m n m n n o o n n o n o n o n n n n l l m m l l m m n n m n l l l n n n n o n n o n o o n l n n n m o n o o n n m m m m n n n m m m m m o m m n o n o m o o o o o o m n n n n n n o n l m n n n n l l o n m n l n m n n n n n m o n m m o o m n l l n n n m o n o m m l n m m o l n n m m o n m l o m n n m n m n m m n n m m n m m m n m n n m m n m m m n m l g l g m n n m m g l n g l g m l n g g h h l l g l l l l f g l m m l n f l n l l m n m n m l m m m l n m n m m n m m m m m l o n m n n n o n m l n o n m n o n m m m m n o o l m n m m o m l m m m l l m o n f m n m l m o l m m n l m n m l n o n n m m l n l m n m n n n o m n o o n o m n n l m m n n n o l n n o o n m n n n n n n m n n m n m m m n n l l m n n o o o n n o n m m o g m m l g l l m n m o m o o n n n m m n n m n n o n m o m m m m n n n n n n m n n l n n m m n n m n n n n o n m n m m n n o m n l n m m o n l m m m n n o l g n m o l l f m o m o m n n o g n n o m n m n o m n l n m n n m n o m n l n m o m m n n n m o m n n n n o m o m o n o o n o n n m m n n o o n l n n m m m m m m m n n m n n m n g m m m m m m m o m l n m l l n m n l o l l m m m l m n o m m m m n n n n o n o o o n n n m l m o o o o o n o n o n n p n o o n n m n n n n m m n n o o o o m n o o o l o m m m l n m o o m o l o o o m g m m o o l n m p o n n n n m o n o o o m m n m m m n o n n o o m n m n m n n m o l l m m m n n m n n o m m n m m n m m n g m m m n m n l l m n n n m o n n m n n n o o n n o n o n n l o m m m o l m n n m n n n o n o n m m n n m n m o m n m n m m n n n n m o p n m o o n o l o m n n n o p n n o o p o n o o m n n o n m l l m n n m m m o m n n n m n n n n n l n o m n n m l l g m o o o o o n n m o n o n o n o m m n m n n n o o m m n n n m n o m m o n n o o n n o n o p n n n o n o n o p o o n n n o m n o n n o o n n o n o n n o n o p o n o n n n o n o n m o o m m n n m o o n n o o n p o p p m o o n m o o o n p o n n n o n g m m o n p n n m o n n o m m o n n o m n n n n n n o p p o n o n p n n n n m o n o n n n n o m n o n o m m o m o n o o n o n o n n m o n n n n m n n m n n n p o m n o o o m o n n o o n m n o n n m o n o o m m o l m n o n o l m n m m l n n m m n n n m n m n m n m n m o n l o n m m n m m n n m n l m n m m m m g l n l n m n m m n m l g m o n m m n n n m m l n l m n n m n m m m m m n m l m m n o n n n n n n l m m m n n m o o n n l l l m l m o n n l m m l n m m m n n n o m n m m m m l n o n n m l n n n l l m m o m m n n m m o n l m n o l n m m n l m n m n n o n m o o o o m n m m m o m o m l g n n o m o m n m n l l n m n n m p n o o m m n l n l l l n n n o m n m m o m n n m m o n n m n n m n n n n n m n m l m n m n n o n o n m o n m n n n o o l m n m m o n l n n m l n n m n m n m l n o o g m m o m n o n m o l n n n o o n l o m o n m o p n n n n l m n m n o n n m o n n n n n o m n n n o n n o o p o o m o n n o n n n m n o n m n m n n m o m n n o n o o o m o n n n n m n o m n n p o m o m n n o m n n o n o o o n n m n m n o n n o o o n n o m n n m m n m m n o n n o o p o n m p n m m m m l m m m l m n n n g n o n l n m l m l l m m m m l o m o m m o o o m n m m n m m g m e e m m l l l n l l g g l g g g m l l m l l n m l l m l g l m m m m n n m n l l m n n m g m l l m l m n n m m n m o m n m o o n m n o m m n m m o o n o l o m o m o m n n m n m l o n n n n n n o n o o n n o o p p o n n n n n n l m n n o o m n g n m o m m o n n n n n o n m n l m l n n o n n m l m m l n l m n n m n m l m n m l m m o m m m o m n n n n o m o l m o l o o m m n o o n n p n n o n n o m o l l m o n n n o o o n n n m m m n o n n n o m o n m n m m n m n m l n m n m n m n m l l m m l m o o l m l n g o l m m m n g l m n g m m n n n m n g l m m l g m o o n n m m m n o n o l m o m m m o m m n m n l o m o o m n n m n n m n m o m o n o o o m n m l n n n o m o n n o p o n o o n m o n m o n o m m o n l o o o n n o p m o l o n p m n n n l n h g m l m g f g g f l l n m l m m n f n l m m l g f g f n e l l l m g g g m m m m m m l n l m n g m n n m l l g n m l l l l m m m m m m n n n m n l m n m n o n n n m o n o m l n n n n n o m o n n l l l l n o l m n m m m n m m m n m m n o m l m l n n n n n n n m m g m m m l n n l o m n m n o m m n m l l n l m m o m m n m l o m l n m g f m g l g g f g f m l g n l l l g m g m m l l f l m n m l l m n n n m m n m n n l n m m l m n o l m m l g l m l m m l e g g g g l l l f l m l m l l n n m l n l m m g l e l l l g l l g g m l l g m l g m g g l l m m n n l g l f g m f l g f e l l l g l f m g l n l l g l g g l g l g l g m g g g f l l m l g h l f g g g g l m l n l l m m n o m l l m n g m m n m m m m n n n n n n n n n o m n n n n n n o l m n n n n o n m n n m n m l m g l g l m m m m m l m m l m l n l f m n m m l m l m l n n m n n l m l m n m n n m o l m m m m n n l m m n m o o n n n m m n n l m n n m l m n m n n o m m n n n g m m l g n o n l l n m n m o o m m l l g g m f g g l n n m l l m m m l m m m g m l l l m m m l g m g l l l l l l g g g l m m f f l g l l g e g l g l l f g l g l g l l f g f g l g g l g f m g l l l g g l g f n l n l n l l n m l g m m g g g m g l l g m l e g h l f g e g m l l g m l g g e g f m l f n g m l m l l m l l l g f l m n l m n n m m n o l m m m m m n l m m g g l g l g f m l l m g l m l l m m l m l n l g m f m g l l m n n l n n m n m n m m m n m n m n n p m n m m m n m o n m m m n n n o n m n l m n l l g g l g h g g g g l l l l g l m f f l f n f g m l m g g o n f m n m m o l n n l m o m n n m l o m n m o n m m l g l l g m m m n n l n m m l l m m l o m g m m g l m o n m m m n l l m m m m m g n o l n m m o n m g l n l n m n l m n l m g m n l m l f l m l l g m m m m m m m l l g g l m l l l m g g m m m m m n m m m m m n o l m n m o o n m m n n m n n n g l n n g g m l f g l l n n m m m m n n m m m l l m m o n m m m n n m l m m m n g l f l m n n o m m m l m n m n f f g l g g l m m l f g l m g l g e d g h g f g g g l g g l g l l l g e g g g h f g f l l g m g g f l l g f g m g l m m g l l n n n m m n n m l m n m m m m n m l n g g m m n l e f m l g l m g f l l l l n m l n m l l f h e f f f l g l f g m l g l g m g n m l e g g f g g g g l g g g m m m m e l m g m n l l m f m g g n m n l m m o n l l o l l l l m l m g m g g m g m g l g g f g m g n e f g g m m l g g f f e h f g g f h m f g m f l m l m n m l l f g g g g g g f f g g m l g f g g m m m e f m l g g l l l m m g l l l g l l m m n l m l m l l g m e f f h g l m g g e g l g f f l g l g f e m m l l e e g g g g l h h f g g l f g e f g f g g f f h f e f g e f b c h g e g g f l g g g e f g g l f g f l l f l g l l m e l g l m m l l m l n l l f g g g g l l g l g l l g g f e f g g e f f f g e f e e e e g e g g l g l g d f h g f f e g g g f e e e e b h d f g e e l e l h h b f f e g b f h e h h d g f f f g h d m e e f g g g g f g e e f l l g l g l l m g l l l g l m f l m l g l g m l m m m l g g l m o l l m m m m n m m m l l m n n m m n m o l n n m n p n o m n l m n n n n n m m n l l l l m n l g n g g f l g g f l m e l g l l l n e g e f l m l g m l m g l n l g g f f f l l m f e f h g m l l g e l g n o m n g m m l l l l l g m g m m m n l m g m n n n m n n l f m n m l l l n n l g m l l n m m m n l n g m g l l e f g g f h f e l e h m f g g d h l g f h f e h h e f f h g e e d e f f e f e l g f f f f e f l g g g m l g g e e f f h e h h b d f d b j c h h h b d d e d g f f g g d e g l g e f g e f e l f h g l h f b h h g f f f g g g l f f l g m f g l g e f g g m e e e g e e l g l g l l f d d d d d d h d b d e f h l f e g e h e e e g h g e f h e l g f e e e e g h e h h e e g l g n g e e l l g l g m g l l g n g n n m m l l n n n n m m m m l m g l n g l g g g l m f n f g g f g l f g g l l g l l l g l f f f g l g l m l l g g l l m l l l m g g m l l e e e e e e l e g f g m g g g l g m l l l l l g g n n l n l m g n l l m l g l m l m n m m m l f l e f g g l f l e h l g e b h e f g e l g m f f e d e f f h e h h b b g h f f g f e f g e l l e g f g e e e l e l m g l m e m m l l n l l l l m l m m n g m l l m n l f l g g l l m l m g l l m m l n m m l l l n l l m n n m n n n m o o m g g m n n m n m m l m m n o o n m n o n o n n l m n o o o o o n o n p n m n n m l n n m l m n m m n n n m n n m n n o n n m n m l m n m o n n n o n n n n m n n l n p m m n n n n n m m m m m n o m o n n l n m m n g n l m l l o g l m n l n l m n n g m o m o n g m n m l m m l n m m g m g m l m m m m m g m m m n n n o n n m m m m n n m m l m n n m m m m n l m m n n m m m m m n g n m n m l l g m l m f m n l m g n n l m m l l g l l m g m m m g f f b h d d l e e l f e e h f l g f l f m l g e f l g g l l g m g m l l g h f d g e e e g f d d h h f d h d e e d h g f g e f f e e h d g e g m f g l g l g e m g l m m n m h m m g e g l g g g l g f g l f l l l g e l f h g f e f g f l l g g g g g f l l m g l g l g l e m g f m l l f g f g l n l g f f m l g l l m l g l n m m m m m n l m l m l n l m n l m n l g l l n m m n n o n l n n n g m n n m m n l m n l g g n n n m g l m n l l m m g m e m l n l n n m l m n m m m l l n l m m m o n n n m m m m m g f e l m l l l l n l l m l n m m l m g m n m n n n l m n n m l o n m o n m m o p n m o n g n n m m n m n o o n n o n l n l o n o n m m m m l g n o n n n n n n n n n o o o m o n l m l n n o m n m n n n o n o m o o n l n o m n l n n o n n n m g m l m l m n l l g l m n n n m l n m m o n m m m m n n g m n n g m g l l m m n n n m m m l l g e d e e g h l l f e l l n l l l m m n l m l m m m l n g m m g l l m l l g f g l m l m n l m l m l l l m m g l l m n m l o l m m f l m g g g g m l m m l l m m l g f l g g n n g l g n m l l m l m m l m m l n m m l m n m n m n l m l m n n n o n n o p n m m n n o l l l n m l l m f l l g g n m l g g g f g m m m l l n m m m n l n n g m n l o l l l n l g n l m l f m m m l m g m m l m m g m g f e m l l l g g g l l l n l l l l g e l g g g l g l l l m g f g l m l g l f e l m g l g m h m m g g l m l g g g m m e l m f m l l f g g f l d f l e h e h f f f l f e e m l f e l g g g g l g l l f m l g g l m g l l m m l m n n n m l n l l n g m m f g l h g n m f l g m l e l g g g g g l m f l m l m m n l l l l g m l g m l m l l l l g g m n m g l g g l f l l l f g l m m m m m f g l m n l l n m l m n n m n g l g l l f m m l f g g m m l l g l l l m m m m m n l l m g g m l m m m l l l l l n g n n m m m l n l o g m m l l m l g g l m f l l m l n f l f m l l m l g l l m l n l n g n m m m l m m m m m n g l l f m m g l l m g g g f e g g l g g f g g l g g g g h l g e e l e f h g m g l m m m n l l n n l l m l g m l g m l l g e l l l f l g g n g l f m l g m m g f f l l g d e e g d d g l g g f l e f l g h l l f g m l g l m l l m l l l m m m l m m n m g l l n m l o n l o m m m g m m n m m o n m n m n g m o n n l l l g g l l l m n n m g m g m g e f f h e e f g m g e l g g e f f g f e f d h e l f f g f h e h l e e e e f g e f f e h f l f e f g l g e m e g f g f e b h d f f e e l l l f m g m l g l g f l g l l m n m g m n n m m n n n m l n l m g l l l l m l f l n m o l l g l m m l n m m n n n o m m n m n n o m n m m n m m n l n m l m m n p o n m m m m n m o o m m n m g m m m m n n o n n o n n o n n m n n n n n n o m p n n n n m n n o n n o n n o m l m l l o l l l m m m m n l m f g m l g n g f e g l m l m f l m l g m g l m l g m g l m o n m m m m l l m m l o m n o m l m n n m p n n n n o n n m m o l o o n m m g g g g l n g e g m g m n l g e g g l g m g g g g e f f f e e g f h h h m l f g l f g g g f g e g e g g g g m e l l m f l l g m l g f l f l l l f l g g l g n m l l m l l o l l o m m m m n m m f m l l m f g g)));
(display 'Loss' ^(a:0.235 b:0.367 c:0.205 d:0.2 e:0.191 f:0.192 g:0.175 h:0.196 i:0.153 j:0.169 k:0.15 l:0.135 m:0.133 n:0.143 o:0.121 p:0.113 q:0.129 r:0.107 s:0.128 t:0.122 u:0.117 v:0.112 w:0.108 x:0.116 y:0.105 z:0.096 A:0.09 B:0.087 C:0.088 D:0.1 E:0.085 F:0.099 G:0.091 H:0.078 I:0.072 J:0.075 K:0.071 L:0.074 M:0.086 N:0.081 O:0.07 P:0.063 Q:0.068 R:0.076 S:0.077 T:0.065 U:0.069 V:0.057 W:0.061 X:0.064 Y:0.066 Z:0.054 ba:0.059 bb:0.058 bc:0.056 bd:0.062 be:0.073 bf:0.055 bg:0.053 bh:0.048 bi:0.05 bj:0.046 bk:0.047 bl:0.051 bm:0.04 bn:0.052 bo:0.042 bp:0.043 bq:0.044 br:0.041 bs:0.037 bt:0.045 bu:0.038 bv:0.039 bw:0.132 bx:0.035 by:0.036 bz:0.033 bA:0.034 bB:0.032 bC:0.031 bD:0.029 bE:0.03 bF:0.027 bG:0.026 bH:0.025 bI:0.028 bJ:0.106 bK:0.022 bL:0.024 bM:0.023 bN:0.021 bO:0.02 bP:0.019 bQ:0.018 bR:0.017 bS:0.016 bT:0.015 bU:0.014 bV:0.012 bW:0.013 bX:0.011 bY:0.01 bZ:0.009 ca:0.008 cb:0.007 cc:0.006 cd:0.005 ce:0.004 cf:0.06 cg:0.049 (bc 0.279 0.398 0.527 0.572 0.549 0.588 0.518 0.522 0.535 0.515 0.471 0.48 0.459 0.475 0.463 0.451 0.424 0.468 0.416 0.402 0.441 0.412 b 0.388 0.363 0.32 0.397 0.343 0.332 0.341 0.362 0.328 0.334 0.315 0.313 0.304 0.294 0.288 0.301 0.324 0.25 0.3 0.247 0.276 0.308 0.28 0.232 0.272 0.251 0.255 0.278 0.338 0.242 0.257 0.368 0.24 0.263 0.258 0.218 0.375 0.372 a e 0.207 0.243 a 0.209 0.182 b 0.184 0.211 0.217 0.219 0.212 c f 0.197 0.193 d h c d e 0.204 0.201 0.185 0.188 0.165 f g 0.16 g 0.167 0.152 0.18 0.168 k 0.158 n i h j 0.176 0.156 i 0.131 j 0.189 k 0.124 l 0.164 0.139 l 0.138 bw m q j 0.14 v m x s 0.126 w o n 0.142 t 0.146 r p o p 0.299 q u r s t 0.26 0.141 q u 0.151 y 0.118 v 0.101 w 0.123 v x bJ 0.119 0.127 0.098 A F 0.114 y z 0.092 z x o z z z r A B 0.103 E D C B A C 0.115 0.083 G D N H E C 0.095 F M 0.079 K B G H I H J 0.08 R I J H E K be E O K L 0.082 S L M N J U L Q J N P I T I O H P W Q N O R cf S F H L T U R Z P V Y P V W bd X ba X Y V bb K Z Z ba bn bb W 0.067 W bc W bd bc bf bg bc V be bh bf Z W 0.171 Y bb bg bg Z W bl bi bh bk ba bf bq bi Z bg bg Z bf bf cg bt bj bm bj bh bk bl Z bm bo bk bm bn bp bk bm bl bo bk bh bp bv bh bk bk Z bq bk bn bj br bl bm bo bq bq br bj bk bk bs bg Z bA bm bs bo bj bt bm bx bu bu bq bo bs bo bm bu bv bj bm bm bv bp br bs bq bq bo by bs bp l bw bm bx bs br bm bz br by bq bC bx bv bu bi bz bA bp bA br 0.125 bB bz bs bm bz by bu bz bE bu bB bz bm bx bv bx bA bA bx bx bs bx bz bB bC bx bB bx bD bA by bB bB bF bp by bu bD bC bv bC bs bz bE bE bx bH bB by bv bG bz bz bz bE bB bx bB bF bz by bD bI by bG bu bH bI bB bI bx bB bF bI bC bI bu bp bF bB bI bF bx bD bG bI bz bF bM bB bD bH bI bB bI bG bH bH bL bG bI bG bG bB bH bG bK bB bC bI bN bJ bK bF bG bE bC bL bD bF bD bG bG bF bG bK bM bE bK bE bA bG bG bO bF bL bN bE bI bF bL bN bM bI bI bB bH bF bM bF bF bM bG bN bH bK bH bL bN bM bM bL bD bP bG bO bN bG bP bF bF bH bF bK bL bI bI bM bL bG bM bL bN bK bK bO bO bO bM bK bM bG bM bM bQ bK bL bG bH bM bQ bO bN bP bK bN bG bO bM bN bM bG bI bQ bK bR bM bL bO bL bP bN bQ bH bM bH bO bN bQ bO bR bO bS bN bM bH bK bP bP bP bQ bK bO bO bM bQ bQ bQ bG bO bQ bN bP bR bP bN bR bS bL bP bN bS bO bP bR bS bP bO bO bN bO bK bQ bH bS bN bO bP bK bQ bP bR bQ bK bQ bS bQ bP bO bS bN bP bR bS bR bQ bN bR bP bR bS bT bQ bT bT bP bS bR bR bQ bP bQ bR bQ bT bH bO bR bP bP bR bU bS bT bT bO bU bT bR bT bT bT bQ bT bN bQ bQ bR bS bV bT bQ bU bI bS bR bR bR bQ bT bW bP bS bS bU bT bT bT bU bR bS bU bU bT bV bT bS bS bS bS bR bV bU bR bT bX bS bW bT bQ bR bU bS bO bS bS bX bU bS bR bT bW bR bW bT bV bU bT bV bU bT bW bR bT bQ bU bP bP bT bR bU bT bQ bT 0.084 bU bW bU bT bW bR bS bT bR bS bU bU bX bT bR bS bW bV bU bU bU bV bW bU bS bU bQ bW bU bV bU bX bX bU bW bV bW bS bW bW bV bW bT bX bV bT bV bT bR bX bV bW bW bV bX bT bV bU bW bT bR bT bU bU bW bU bT bX bT bX bU bY bV bT bT bT bX bX bX bX bX bY bW bW bS bT bU bY bU bV bW bX bS bW bW bY bX bY bX bU bZ bW bT bV bU bZ bY bW bU bZ bZ bV bV bT bW bY bW bX bX ca bV bU bY bW bY bW bU bW bU bX bW bU bX bX bW bU bW bV ca bY bZ bX bV bZ bZ bX bZ bY bW bV bV bY bZ bU bX bU bW bX bU bX bU cb bY bX bY bV bZ bY bZ bX bZ bW bX bX bX bV bV bY bY bZ bZ bV bX bW bW bV bU bY bW bZ bV bY bY bU bZ bZ bY bY bY bY bZ bX bY bX bU bX bY bV bY ca bX bY bX bV bW bY bX bZ bY bY bV bZ bP bY bY ca bZ bY bY ca bY ca bX bV bX bY ca bZ bV bW bZ cb bY bY bY bZ bY bY bY cb bZ cb bZ bZ bX bY bX bX ca bX ca bY bZ bY bZ bY ca bY bX bY bV bY bV ca bY ca bX ca ca cb bY ca bY bY bT bU bZ bY bZ bX bY bY ca bW bY bZ ca bX cb bX bY cb bZ bX ca bV ca bZ ca bX bZ bX cb bY bZ cc ca ca bT cb bZ bW bZ bY bT ca bZ bZ bZ ca bZ bZ bZ cb bX bZ ca bZ bX bY bY ca bW bZ ca ca ca bZ bX cb ca bZ bY cb ca bW bX bX ca bY bZ bY cb bY bZ ca bX ca bZ bY bW ca ca bY bZ cb bZ ca bZ ca cb cb bZ cb cb bZ ca bZ bZ bY ca bX bZ ca bZ bZ bV ca bZ ca cb ca cb bX cb bZ cc ca bX cb bZ cc cb bZ cb cc cb cc bY cc cb bZ ca ca ca bZ cb cc ca cb bY cb ca bY cc cb cb ca cb ca bY ca bY ca bZ cb cb bY cb bV bZ cb cb bY bZ ca bZ bZ bY cc cc bZ cc cc cb bU cb bZ cb bY bZ ca ca bV bZ ca bS ca bZ ca cc cb ca cc ca cc cb ca cb bZ ca ca cb cc cd bY bZ bZ cc cc cb cc cb cc bV bZ cc cb bU cb cb bZ ca ca cb cd ca ca ca bU bZ bZ bZ cb cc cc bY cc cc cb bY cc cb cc ca bZ ca ca cc bY cb cc cb cb bY cb cd bZ cc cc cb cb bZ ca bY bZ bW cb cc cc bY cb cb cb ca ca bY cb bZ cc cc cb cb cb cc bY cb cb cb ca cc ca cb bY cc bY cb cb bZ cb cb bZ bZ cb cc ca cc bY bZ cb cc cb cc cc ca cb cb cb cc cc ca bZ cd cc bZ cc bY ca ca cb cb cc cb cc cb cb cb ca cb ca cb ca cd ca cc cc cc cd cc ca cc bY cb cb cb cc bY cd ca bZ cb ca bZ ca cc cb bY cb cb ca cb bX cb cb cc ca cb cb cc cb cc cc cd cc cc bZ cb ca bZ cd ca cd cd cb ca cc ca ca cd cd cc cb ca cb cc bZ cb ca cc cd cc bX cc cb cb ca cd bY ca ca cc cb cc ca ca cc cd bZ cb cd bZ bX cd cc bZ cc cb ca cb cc bX cc cb cb cc cc cb cd bX ca cc cb cb cb ca cd cc cc ca cb ca cc cc cb cb bZ cd cb cb ca bZ cb cc cd cc cc cd cc cc cb ce cb cc cb cc ca cd bZ cd cc cc cc cb cc cb ce ca cb cc cd cb cc ca ce cb ca cb cb cd bZ ca cd cc ca bZ cb ca cd cb bZ cc ca cd cd cb cc cc cc cb cc cb cc cb cd cb cb ca ca ca cc ca cd ca bZ cc ca cd cb cd bZ cb bY cc cd cb cc cb cc ca bY cb cc ca cb bZ cd cb cd cb cb bY cb cc cb cb bX ca cb bZ bX cb cb cb cd cb cd cd bZ cc cb cb cd bO cb ca cc cc ca cb cc cd cc ca ca cc ca bZ cb cc cc cc bZ cc cb bZ cd cb bX cc cc cb cc cc ca cc cc bX cb bY cc cc bZ ce cc cb ca ca cc cb bQ cb ca cb cb cb bZ cd cd cb cb bZ cb cd cb cd ca cb bZ cb cb cb cc cb cc ca cd cb cc cc cd cc cd cb ca ca bZ cb cc cc cd cc cd ca cc cb cc cb cd cc cd cc cd cb cc cc cb cc cc cc cc ca ca cb cd bZ cd bZ cc cd bY cd ca cc cb ca cd ca cb cb cd cc ca cd cd cd cd cb cd cb cc ca ca cc cd cc cb bY ca cb cb cc cb cc cb ca cc cd ca cc cd cc cd bU cc ca cb bY bU cc cb cc cb cd cb cc bZ cc cb cd cd cd cd cb cc ca ce cb cc bT ca ca cb cb cb cb cd cb cb bZ cd cd cd cc bZ cd cd cd cc cc cd cb ce cd cd bZ ca cb ca cc ce cc cc cd cc cc cb ca cd cc cc cc cd cc cc cb ca ce cc cb cd ca cb cb cd ca cd cc cc cd bX ce cc bV ce cc cc cc cd cc ce ca cb ca cd cd cd cc cd cd ce cd ca cb ca cd ca cc ca bY cc cc cd ca cc cc cc ce cd cc cc bX ca bZ cd cd cd ca ca cd cc cc ce ce cc cc cc cd cc cd cb cd ce cd ca bS cc cc cd cd bZ cd cb cb cc cb cd bZ cb cc cd ce cc cb cc cc ce cc cb cb cd cc cb cb cb cb bZ bZ bZ cc cb cd cb cd ca cc cb cd cc cb ca cc cb cc bY bZ cc cb cb bS cd ca cd cd cb cb bY cc cb cc ce cc cc bY cb ca bY bU cd cd cd cc cd ca cb ca bV cc cd cc cb ca cd ce bX cb cc bX cd cd cb cd cc cd ce cd ca cb cc cc cc bZ cc cb bO cc cd cc cd cb bY bZ ca bZ cd ce bZ ca cc bZ bZ cc ca bX cb cd cd cc cc cc ca cc cc bY ca cb cd cd cb cb bZ bY cb cb bX ca cd cd ca cc cb cd cd bV cc ce cc bY cc cd bZ cc ca ca cb bY cc cb cb cc cb cb cc cb cb cd cd cd ca cd cc cb ca cb ca cc cd cd cd ce cd bZ ca cd bZ cd ce cd cb cd cd cd ca bX cc cd cb cc ca cc cd cb cd cd cd cd cc cc ca cd bY cc ce ce bY cd bX ca bZ cc bU ce cc cd cc bX cd cd cc bX bZ ca bV ce ca cc cd bZ cc cb cd cb cb bW cc cb ca cb cc ca cb cb cd cb cd cc cb cd bV bV cd cc cc cc cb ca cb cb ca bP cb bX cb cc cc cb cc cc cc bX cb cc ca cd cc cd cc cd cc cd cc cc ce cb ce bX cd cd cc cb cc ca cc ca bY bZ cb ca cb cb bY ce cc ca cd cc cb cd cd cb bV cb cb cd bV cd cb cd cd cc cd cb bX cb cb bZ cb cd cb ca bZ bX ca cd ca cb cb cc ca cb bV cc bW cb cb cc cc cc bZ cb cb cc ca bY cb cd cb cc cb cd cc cd bV cb ca cd ce cd cb ce cb cc cd bY cc cb cc cb ce cc bZ cc bY cd cd cb cb ce cd cc cb ce cc cc ca bZ cb cc bY 0.003 cd cd cd cc cc cb bO ce cb cd cd bZ bZ cd bZ cb cc ca cd ca cd ca cc cb cc cb bT cb cc ce bQ bW bW cc bZ cb cd bZ ca bY bY cb cd bY ca ca cc cb cb bZ cc bZ cc cb ca ca bY bY cb bS cb cc cc cd cc bW cb bZ bZ bV cb cb bT cb bR cc ca bY bV cc bV ce cc ca cd bY cd cd bX bY bY ca bZ cb cc cb cb cd cd ca cd cb cb cc cb bZ ca cc cb cc cc cb cd cc cb ca cd cb bY cc ca bY cd bZ cd cc cc ca cd bZ ca bY bZ ca bZ bZ cb bX ca cb cc cb cd cb cd bZ cb cd bN cc ca cb cc cb ca bX cb cc cc cc bZ cd bY bU bZ ce cd ca cd cc ca cc ca ca ca ce cd cc cd cc bZ cc cc bZ cb cc ca cd bW bU bW bZ cd cb cb ca ca cb ca bZ bY cb cc ca cc bZ cd ca ca cd cc cc ca cc cc cb bV bY ce cc bZ cd ca cd cd cc ca ce cb cd cb ca ce bT cb cd bT bX bX cd bY cc cb cd cc cb cc cc cb bY bY bX cc bZ bS ca ca bY bZ bY cc ca cc bZ cb bU bV cd cd cd cb cd bZ cc cc bW ca ca cb cc cc cb cb bW ca cd cd cd bX cc ca cc bX cd ca bY cc ca cc bX cc bU cc cc cd bY cd bX bR bY bZ cd bY bY ca cc cc ca ca cc bZ cb bP cd bZ cc bX cc cb cb cb cb ce cb bY bV cc bY ce cc cc cb cc ca ca bV cc bW bY ca cb bZ cc cc bY bZ ca ca cb cb ca cc cc bX ca cb cc bK cb bY ce bY cb cb cb cb bX bZ cc bZ cb cc ca cc cd bX cc cc bZ ca bK bZ cb cc ca cd bZ bZ bX cd ca cc cb cd cb bY cc bZ bZ cb cb ca cc cb cb bQ cc cb cb cb ca bZ bZ bY bZ bY cb ca cb bY bW cc bV cd cc bW bZ cb cd bS cc bY bZ cb cc bY bX bZ bU cb cc cc cc ca bY cc bZ bX bV bW bT bV cb bY bY bW ca ca bY bS ca bT bT bX ca bZ bW cb cc bZ bX bZ bT bX bX ca cc cc bY bT cc cd cb ca bZ cb bZ cd cc bW bQ cc cc bY bP bZ cb ca bX bY bQ cb ca ca ca ca cc cd bZ cb cb cc cb ca ca cb bX cb bU cb ca ca bW cb bZ cb cd ca bV bY ca cc bV cb bZ bQ bX bZ cc cc ca cb cc bZ bS cc bO bQ bZ ca cc cc cc bZ cb bT bV cc bX bZ cc cd ca cc bQ bX ca bY bU bZ bX bX bX bX ca bT bU cc ca bV cb bV bV bL bX bW bT bW bT bW bZ bY bZ ca ca bY bZ bW ca bZ cc bY bX bV ca bU cd cc bZ bX cd bS ca bX cc ca bG bZ cd cc ca ca bZ ca bZ bY cc cd bL bX cd ca bY bY cc bV bV cd bY bY bU cb bZ bZ bX bU bU bW bY bQ bZ cc bW bR bV bV cb bZ cb ca cc cb bW bW bW ca bW bY bZ bQ bV bY bW bX bY cb bK cb bY ca bT ca bY cb bR bN bW bW bU ca bX bU cc bV bR bZ bX bV bZ ca bL bS bZ bP bV bV bU cb bX ca bP bZ bB bZ bV ca bY bX bY cb bS bU bL cc bN bV bX cc bT ca ca bY bZ bO cb bG bY bV bQ bT bF bZ bV bN bK bY bZ bX bZ bV ca bZ bT bY bV bV cb bR bN bV bQ bX bG ca bX bT ca ca cc bX bX bY bZ cc bZ ca bM bN cb bY bX bz bZ bW bT bV bW bU bZ bX bS cb bY bW bW bY bT cb bY ca bU bZ bS cb bZ bZ bV bO bY bR bZ bY bV bY bZ bY ca bY bG cc cb cc cb bP bZ ca bT ca bI ca bZ bZ bO bU bV cc bW bU bW bS bS ca bW bC ca bX bX bW bY bR bL bS bY ca bM bQ bS bH bY bY bZ bP bX bW bW bW cb bW bZ bP bY bT bX ca cb bV bS bS bT bL bX bV cb bS cc ca bV cb bO bV bT bX bV bW ca bZ bN bY bU ca bY bY bT bV bU bZ bU bU bX bU cb bY bT bK bY bQ bR bS bU bZ bL bU ca bO bV bT bZ ca bO bY bW bZ bX bK bZ bU bM bV bS bW bK bL bY bW bT bY bZ bE bZ bR bQ bV bS bN bZ bY bV bM bP bZ bX bZ bY cb bN bZ bQ bF bm bR bU bZ bX bV cb bU ca cb bS cb bS bY bT bW cb bW bG bS cb bP ca bY bX bY bO bV bZ bZ cc bS bZ bZ bM bX bV bY bT bV bV bU bP bT cc bP bQ bS bX bQ bW ca bN bV bZ bR bV bQ bV bX bX bR bR bY bV bY bY bU bM bX bT ca cc bZ bQ bY bK bZ bQ ca bU bX bU bW bK ca bz bX cb bV bO cd bX ca cc bS bY bY bW bC bZ bW bR bO bN bI bY bY bS ca bN bL bW bT bN bP bY cb bP bX bX bV bO ca bS bR bV bS cb cc bX cb bW bU ca bX bZ cb bR bC bT bY ca bM bB bZ bY ca bZ bN bX bO bY bQ ca bS bS bL bV cb bU cb bY bS cb bV bG bV bV bW bU ca bR bZ bU bZ bK bR bX bV bU bY bR bU ca bR bU bO bQ bY bL bX bH bO bY bM bQ bX bX bX bY bP bP bU ca bY bU bV bQ bX bY bR bY bV ca bO bY bX bQ bX bB bX bZ bX bY bV bR bQ bY bZ bP bR bX bV bS bZ bT bV bT bV bY cb bY bY bM bY bY bL bK bZ bS bW cb bS ca bW bU bP bV ca bK ca bV bS bN bR bV bP bY bP cb bV bI bK bW bV bV bS bM bV bW bW bT bM bX bV bR bO bU bY bO bP bV cb bL bF bF bY bW bX bT bT bS bL bK bV bQ bT bT bF bW bT cb bY bV bV bP bH bL bU bY bZ bS bS bV bU cc bV bW bG bW bI bE bU cb bS bO bP bK bR bN br bX bv bZ bO bZ ca bE bU bY bO bM bY bG bV bQ ca bX bI bZ bR bC bT bQ bU bS bW bW bO bZ bN bX bR bS bS bX bS bS bO ca bL bN bi bU bW bS bU bX bY bI bY bY bV bN bS bu bT bX bX bC bM bU bX bV bV bR bR bV bP bB bF bQ bO bG bO bY bL bQ bS bT bH bY bY bV bZ bU ca bT bX bY bW bI bR bN cb bP bN bT bL bQ bZ bV bS bN bV bK bR bO bT bN bR bI bO bW bV bN bC bL bQ bR bW bW bV bR bV bI bU bz bT bQ bX bR bK bK bQ bS bM bX bO bG bZ bY bQ bU bF bT bK bW bN bZ bS bW bW bX ca bh bO bz bO bN bG bM bQ bK bV bW bX bI bT bG bV by bD bU bV bV bR bL bL bS bP bT bP bO bU bR bO bz bU bM bT bv bS bN bP bI bP bD bR bN bX bL bM bT bA bQ bR bL ba bZ bY bH bO bW bM bQ bK bW bV bM bZ bP bG bU bM bV bO bQ bX bC bR bV bt bY bL bP bK bO cb bU bN bG bX bT bQ bT bV bM bX bS bR bO bH bR bP bG bG bS bB bU bW bH bD bP bR bK bW bE bU bO bH bu bK bR bV bN ca bT bV bY bK bB bW bR bU bR bQ bM bS bU bV bX bX bW bK bB bS bX bs bQ bL bN bZ ca cf bU bz bV bV bH bT bZ bA bV bG bN bK bD bB cb bM bN bX bV bR bN bM bP bN bP bF bR bW bM bU bX bO bB bN bP bN bN bG bT bO bK bR bT bH bY bG bV bP bW bT bE bU bW bR bU bQ bH bU bD bZ bQ bQ bF bQ bO bG bR bK bK bQ bv bV bQ bM bL bS by bQ bV bG bY bV bG bR bR bO bV bQ bL bW bL bM bG bH bZ bG bW bV bL bO bN bI bM bQ bH bW bS bT bN bZ bQ bL bF bS bN bN bP bN bT bR bT bR bO bX bT bN bV bV bS bL bO bS bT bS bD bO bN bN bT bV bp bR bD bT bS bV bX bL bQ bO bT bP bS bR bO bX bQ bO bQ bX bP bS bS by bP bQ bU bF bU bP bE bW bM bQ bX bU bW bO bK bK bV bQ bR bB bz bU ca bV bN bS bT bL bZ bW bZ bI ca bT bK ca bX bM bS bH bM bG bM bI bW bD bS bR bQ bM bO bN bU bT bY bL bZ bV bN bS bZ ca bV bL bO bL bW bq bK bW bX bS bU bX bH bV bH bT bX bG bT bV bN bO bW bW bQ bD bH bQ bO bY bI bI bS bV bM bS bQ bS bV bZ bS bW bS bV bB bW ca bU bN ca bZ cb bV bU bS bW bR bA bU bT bC bP bL bR bP bE bN bY bK bY bR bV bV bT bD ca bz bM bS bH bF bL br bP bT bU bX bx bS bO bR bR bM bX bA bT bN bZ bC bV bI bD bY bR bW bW bU bS bO bO bQ bU bQ bO bx bP bN bP bO bT bK bX bL bN bH bR bK bQ bN bK bO bV bT bE bK bP bQ ca bQ bE bP bk bW bE bB bL bV bR bU bO bD bO bz bX bW bW bU bP bX bR bM bO bM bQ bI bT bN bQ bE bK bR bQ bL bM bE bR bP bC bB bC bR bN bX bV bE bP ca bI bD bQ bS bz bE bH bF bQ bH bM bR bV bH bR bW bG bO bM bC bP bH bK bX bL bL bV bT bu bS bU bQ bQ ca bW bY bW bS bz bY bU bX bP bL bO bK ca bL bL bH bP bP bF bM bH bK bM bK bR bO bT bK bv bP bS bP bK bD bQ bK bO bF bS bK bU bG bF bu bL bG bG bW bM bT bS bC bK bW bV bQ bK bU bI bN bT bP by bR bF bP bR bY bL bW bP ca bR bT bP bK bD bB bK bP bM bE bE bW bI bM bN bQ bN bL bM bT bG bL bS bF bR bU bS bT bP bX bR bY bK bK bR bN bL bW bQ bG bH bT bV bS bM bN bG bQ bx bO bK bK bQ bA bA bQ bR bE bQ bX bN bR bR bN bB bI bV bP bU bU bR bY bs bT bO bB bK bz bH bQ bK bK bR bQ bG bF bK bX bu bE bG bz bQ bM bU bO bU bK bM bW bC bR bV bO bX bz bL bR bV bS bL bP bS bT bK bG bR bZ bE bL bS bM bz bP bx bD bL bC bL bD bP bK bR bs bQ bT bP bT bI bN bK bC bO bH bC bL bK bW bX bU bQ bR bE bs bz by bD bD bG bD bQ bW bY bG bD bD bg bI bG bM bR bI bS bI bM bF bN bI bZ bs bG bz bG bF bC bB bD bR bT bU bL bO bN bP bC bI bP bs bN bK bP bC bK bO bY bI bL bR bH bT bH bO bS bL bN bD bV bW bT bE bN bx bL bE bQ bG bF bE bT bL bC bR bL bM bQ bN bk bX bW bH bS bE bF bF bF bt bT bm bT bR bQ bz bF bq bu bI bM bN bI bA bO bF bT bH bG bS bG bK bG bM bH bL bK bQ bv bK bA bD bx bP bT bL bP bs bQ bG bR bM bN bE bG bE bE bD bQ bA by bS bq bG bP bH bU bI bI bI bW bO bT bM bx bO bG bx bT bO bQ bH bF bS bK bP bI bS bB bV bS bN bM bC bq bT bL bE bU bH bT bR bS bK bV bP bP bU bD bG bP bT bQ bK bR bW bM bW bN bF bP bW bG bH bQ bG bO bF bG bN bM bO bC bM bW bQ bK bL bS bO bK bN bm bD bT bB bQ bV bQ bP bV bF bL bO bQ bG bQ bD bM bQ bU bM bM bF bD bT bF bN bv bL bY bB bP bO bP bP bI bE bT bE bL bR bI bB bG bO bC bK bK bO bG bI bK bU bO bE bS bN bB bG bE bK bM bN bE bT bQ bG bN bQ bG bE bH bO bL bS bR bQ bW bF bT bI bS by bN bS bQ bK bL bx bN bA bN bS bK bG bE bG bQ bK bR bM bN bZ bH bN bP bO bN bN bL bM bT bV bu bQ bT bP bv bS bO bK bO bI bD bL bG bN bN bT bN bD bT bD bF bN bD bN bU bG bP bP bC bP bG bH bR bC bL bC bm bH bN bO bC bS bP bA bM bE bL bC bz bK bP bL bD bB bO bP bW bN bR bG bN bH bN bU bL bE bO bR bO bN bL bn bM bO bG bG bM by bT by bP bV bQ bD bP bF bM bW bL bH bK bP bC bG bE bI bN bO bs bQ br bV bL bB bG bR bM bL bQ bL bI bN bI bR bB bN bv bK bG bT bC bM bU bY bQ bz bM bK bG bF bO bP bW bL bQ bF bE bD bQ bP bH bs bM bK by bK bG bF bT bL bM bP bF bF bK bA bT bK bP bh bK bA bE bL bC bM bN bI bz bB bS bE bH bW bP bI bz bQ bH bG bW bP bN bP bI bO bx bO bN bE bN bD bL bQ bI bT bK bz bT bS bE bm bz bF bU bB bH bG bR bC bH bS bQ bG bH bH bO bE bQ by bF bE bP bF bK bQ bW bz bH bP bx bH bH bK bM bL bC by bR bx bM bI bK bL bG bF bq bW bT bR bD bC bC bQ bI bS bI bx bN bB bO bG bG bo bU bM bz bL bD bR bE bS bI bN bp bx bN bP bB bN bA bI bK bN bS bS bG bQ bH bL bG br bF bO bL bG by bG bL bO bC bE bK bT bB bM Z bk bK bN bN bU bP bB bq bR bT bg bH bL bN bT by bE bI bK bx bF bE bM bv bs bM bP bE bC bQ bD bu bA bC bs bD bH bH bK bN bF bQ bM by bD bB by bH bN bM bI bC bA bB bI bC bG bL bD bI bQ bL bP bQ bX bT bI bO bF bs bE bB bD bO bN bs bP bI bG bH bK bD bB bD bN bD bM bO bB bE bC bH bM bF bC bL bM bM bC bc bz bM bG bQ bN bH bE bO bS bH bj bB bU bQ bK bT bx bM bz bH bF bO bC bD bQ bK bM bG bN bO br bq bI bO bC bI bG bS bD bz bB bB bE bD by bD bL bN bP bP bS bp bH bK by bA bK bI bG bI bm bO bG bM bH by bR bN bO bN bG bP bK bH bR bO bP bT bm bE bE bK bE bz bN bL bL bI bH bM bO bx bT bM bK bN bz bK bH bN bG bA bN bN bH bK bW bB bD bB bm bO bG bR bC bD bH bG bH bK bR bL bK bO bQ bH bD bO bA bI bE bI bN bT br bE bN bE bK bL bK bL bA bM br bB bN bL bB bF bD bD bO bM bT bS bP bN bQ bN bI bF bB bN bD bi bN bD bI bz bF bR bW bF bK bS by bM bH bI bO bN bC bE bA bP bC bE bK bE bo bC bP bO bG bN bK bS bK bS bL bN bN bE bD bI bG bI bQ bM bB bE bG bz bA bI bF bL bQ bz bN bH bH bP bz bx bQ bL bS bK bG bP bC bP bL bA bN bF bI bN bN bM bC bI bI bN bF bN bN bL bD bR bB bB bK bD bG bK bG bC bz bK bH bm bP bQ bL bh bs bE bT bc bR bA bL bz bi bN bM bN bN bH bN bE bO bE bO bK bI bP bN bP bK bC bx bF bM bE bu bL bE bI bM bK bF bH bQ bC bM bL bS bK bR bM bP bD bO bK bH bR bI bh bu bE bx bN bC bM bt bG bj by bz bF bA bx bI bR bx bU bE bO bG bI bH bF bP bB bP bL bP bv bL bH bK bK by bD bM bF bF bI bG bM bL bK bC bR bL bD bL bN bN bI bG bh bH bx bx bz bF bN bA bR bH bN bR bD bP bM bP bF by bG bM bG bL bL bM bz bG bR bk bL bG bL bN bz bP bK bI bp bD bN bC bN bL bV bN bA bL bH bC bN bL bI bA bK bt bG bG bN bH bE bG bA bz bS bE bK bN bN bI bR bD bF bB bO bC bL bP bD bz bS bM bG bH bD bQ bN bP bp bx bF bN bB bj bN bv bK bM bP bL bT bD bO bD bP bx bz bC bL bM bp bz bQ bz bM bH bH bB bK bs by bz bN bs bE bG bG bF bL bB bF bQ bN bM bF bG bR br bC bM bG bO bP by bG bL bK bU bP bH bD bt br bN bD bG bM bB bI bG bs bU bK by bL bQ bz bF bQ bH bM bE bB bK bG bO bD bL bL bK bG bB bN bN bu bz bP bL bK bN bE bM bK bN cg bA bQ bO bz bM bM bN bE bK bT bx bN bG bG bE bF bE bP bG bG bD bu bF bT bM bF bK by bC bL bP bO bM bN bx bG bM bL bA bD by bM bK bG bx bo bI bD bK bQ bD bO bK bN bG bF bK bE bz bL bL bM bO bH bF bq bH bB bH bF bN bN bA bQ bA bH bE bU bd bC bC bO bG bM bH bM bz bL bO bI bK bO bL bK bz bB bP bF bI bI bD bB bs bK bA by bQ bI bG bE bN bs bs bL bP bE bM bD bG bB bM bz bG bM bH bE bL bL bG bA bI bK bv bC bO bQ br bH bz bM bL bB bG bG bE bQ bF bL bM bQ bQ bO bE bz bF bO bB bD bL bR bP bW bL bM bF bE bN bH bs bK bP bM bK bL bD bH bs bF bG bR bI bK bD bG bD bD bK bP bI bO bB bN bL bF bL bB bK bM bB bN bN bL by bH bA bL bD bD bG bG bM bE by bz bO bk bN bR bK bq bx bL bD bT bK bm bx bH bK bB bF bo bL bK bK bI bF bD bB bN bL bL bD bM bH bH bu bF bv bF bx bM bG bu bp bD bM bE bK bC bL bI bB bD bK bz by bG bD bK bN bK bO bK bx bE bO bD bR bG bE bM bN bD bA bz bS bN br bG bM bQ bD bQ bA bD bQ bS bP bM bH bP bL bD bL bH bL bI bS bR bx bo bN bu bN bO bN bH bP bC bI bP bI bM bS bs bT bH bG bQ bP bQ bH bO bP bK bF bM bI bH bT bH bP bM bH bO bO bL bC bQ bx bM bR bQ bE bP bT bz bO bQ bL bz bG bu bS bP bR bR bv bH bI bG bG bF bL bK bL bG bL by bH bt bH bI bA bG bA bI bU bR bO bL bC bK bH bK bL bz bs bN bO bH bK bz bG bN bS bL bP bN bG bB bK bP bh bC bN bN bH bx bN bN bM bM bK bO bA bL bP bR bz bu bD bK bI bB bD bO bM bN bP bG bs by by bM bC bE bO bC bG bQ bE bH bA bA bF bF bN bH bO bM bO bR bB bM bK bF bN bU bB bG bM bQ bN bM bG bE bN bK bP bm bP bK bK bH bO bK bN bO bO bK bQ bD bM bN bF bF bI bQ bR bK bK bD bO bX bS bO bM bK bM bP bN bK bN bP bQ bG bH bL bW bL bI bM bI bR bB bC bM bD bK bD bS bK bR bH bC bM bL bR bQ bP bK bP bP bA bN bL bO bK bO bP bI bN bM bP bO bI bQ bF bG bE bN bI bR bN bO bP bO bL bK bD bD bG bQ bV bK bL bG bR bH bF bQ bQ bs bN bG bQ bH bW bD bT bH bF bG bM bV bv bN bD bT bH bK bD bG bA bm bH bM bO bx bD bF bO bG bL bD bK bK bx bH bG bB bA bO bN bF bF bK bE bS bG bL bG bM bE bQ bE bR bD bs bH bM bS bP bF bQ bL bA bD bK bB bL bM bK bP bF bC bE bG bM bB bF bO bG bK bP bQ bP bK bM bC bM bO bG bE bN bK bG bV bH bK bM bG bM bL bH bC bN bG bP bF bD bK bT bF bE bG bG bR bR bR bG bI bP bO bH bG bQ bP bI bF bL bx bH bO bH bC bH bK bM bR bM bO bI bA bT bK bK bK bL bW bA bK bN bO bN bK bN bT bK bA bN br bK bB bL bH bH bF bF bF bQ bG bP bD bD bS bH bF bL by bv bH bK bT bz bV bB bG bK bQ bL bO bR bG bW bP bN bx bO bR bK bR bK bB bs bK bT bP bO bK bR bF bT bT bK bD bE bB bp bP bO bK bA bL bi bI bz bH bG bH bR bN bO bL bI bK bQ bP bH bF bN bL bL bK bM bM bO bG bN bN bO bS bL bE bR bR bF bP bG bB bu bT bO bL bF bD bT bM bg bS bM bF bH bI bQ bN bF bK bP by bG bB bT bK bN bM bo bB bP bN bN bK bO bT bD bP bN bM bD bN bQ bR bI bE bM bO bN bQ bK bN bO bR bD bD bK bQ bL bO bP bQ bQ bL bM bM bB bF bK bH bW bI bz bH bP bL bF bN bI by bE bQ bO bH bP bG bL bK bI bS bO bG bE bH bI bT bF bG bR bH bN bD bN bx bv bH bH bA bB bC bR bp bU bE bO bO bK bN bG bU bS bL bE bB bP bD bM bB bg bM bB bG bH bQ bA bK bM bN bM bG bO bK bN bK bF bI bO bv bH bH bW bH bP bQ bN bO bO bM bN bI bN bO bN bQ bK bK bC bL bB bG bO bL bU bK bL bG bO bO bR bF bP bO bz bR bz bo bK bK bO bD bD bD bp bQ bH bF bQ bB bP bD bL bS bH bN bF bP bO bM bL bK bL bH bS bC bH bK bS bO bC bC bR bK bC bT bH bP bP bI br bS bO bK bX bN bO bO bP bH bL bF bP bI bO bD bN bS bU bM bI bL bH bP bG bO bN bR bM bH bM bS bR bE bK bO bN bP bP bI bI bB bP bL bQ bO bF bQ bz bH bv bC bL bA bU bH bL bM bM bM bL bG bE bF bM bo bO bP bK bg bO bM bP bV bF bN bz bM bK bR bS bP bO bM bO bI bT by bI bO bP bA bK bH bx bF bC bM bM bP bR bK bG bR bK bO bN bP bN bH bK bM bx bA bD bS bD bG by bH bN bK bP bF bK bF bF bG bO bM bS bM bQ bF bF bN bG bT bQ bH bN bP bG bA bQ bz bG bR bG bL bH bK bu bK bO bO bO bA bH bM bD bN bL bz bQ bD bK bE bK bB bR bH bR bO bP bP bW bM bS bD bG bM bN bE bE bK bN bE bx bU bO bH bM bP bF bQ bM bG bO bO bI bQ bG bK bN bR bH bI bQ bK bH bK bK bR bN bR bL bU bH bz bR bO bT bS bU bI bz bH bL bK bR bE bO bW bU bL bS bS bV bQ bH bM bI bP bL bH bM bU bP bO bM bL bO bF bF bM bG bO bP bN bN bH bL bP bP bF bO bO bP bQ bs bI bN bP by bL bO bO bE bN bQ bH bN bK bO bO bP bI bG bG bU bo bB bK bQ bK bT bN bM bM bP bK bG bT bO bG bD bO bB bz bB bA bD bR bR bA bT bP bO bH bO bG bA bP bH bS bD bx bI bL bT bW bM bS bO bI bO bS bu bQ bD bO bP bM bN bI bH bS bQ bQ bv bG bS bP bQ bN bK bL bM bR bC bN bI bH bR bH bA bB bG bQ bE bK bQ bQ bE bM bN bS bx bP bP bu bB bF bO bM bK bL bQ bS bD bT bI bK bW bH bP bF bH bE bL bH bR bK bT bK bC bT bN bV bT bL bz bS bS bv bP bL bB bK bT bB bI bK bF bO bF bK bQ bN bS bN bH bR by bP bP bM bU bR bI bQ bR bQ bS bD bm bN bG bE bP bS bH bR bR bS bN bH bO bS bL bL bK bN bz bN bC bK bF bH bX bR bz bK bG bP bA bP bW bv bW bR bT bR bL bK bG bN bS bM bO bH bN bW bF bK bL bP bI bN bQ bE bE bT bP bN bL bT bT bC bM bO bK bB bB bD bK bL bG bO bP bL bQ bE bE bO bT bO bG bR bG bX bD bC bQ bK bD bQ bD by bN bP bN bR bW bH bG bM bR bG bN bF bF bN bK bP bN bM bG bL bH bC bY bF bO bM bF bW bD bT bW bK bK bO bF bM bI bR bI bR bB bF bQ bN bR bN bz bQ bH bA bV bF bK bX bQ bN bO bL bK bM bU bO bP bU bR bS bO bS bM bI bK bP bR bN bC bT bN bN bD bM bN bO bR bQ bQ bX bH bH bS bR bN bx bD bP bD bK bB bB bQ bv bH bK bh bW bL bS bR bA bL bK bS bP bA bG bu bF br bQ bF bM bD bN bL bO bL bO bL bQ bN bM bD bD bP bI bG bP bO bH bH bH bX bO bM bR bO bB bH bL bE bD bF bP bK bQ bP bO bL bQ bx bN bK bH bQ bN bQ bL bN bM bH bK bI bM bI bW bH bU bC bQ bR bL bM bG bI bs bH bM bu bK bS bD bI bD bz bS bU bB bL bM bQ bG bQ bF bz bQ bQ bP bL bO bM bg bO bH bN bS bN bH bH bD bM bL bC bG bR bS bP bR bG bQ bm bK bP bQ bM bN bx bP bN bU bI bz bN bN bG bU br bG bP bT bL bU bG bL bH bT bH bH bM bR bI bN bG bD bQ bN bU bG bQ bG bM bS bN bK bM bR bM bV bF bP bS bQ bR bx bK bN bF bM bQ bQ bS bW bT bL bR bK bI bF bS bL bN bD br bU bL bS bP bP bQ bO bC bL bP bG bQ bO bI bu bD bR bD bH bL bC bI bo bF bN bN bO bN bx bR bP bD bM bB bO bO bG bN bK bD bO bP bL bN bG bI bR bK bE bP bR bx bR bK bP bK bX bL bA bL bR bL bR bK bD bO bW bM bH bD bQ bQ bT bF bE bK bM bO bz bK bK bR bN bU bK bR bP bF bT bW bp bI bM bQ bK bR bL bW bN bP bI bP bK bG bL bN bB bK bQ bR bN bL bQ bL bP bE bG bK bQ bU bD bG by bD bz bM bN bR bG bK bx bP bu bU bM bS bM bR bT bN bL bF bI bN bK bR bK bD bN bH bT bI bP bW bt bG bH bK bL bQ bN bN bG bD bQ bD bs bR bH bN bN bW bK bP bL bu bM bQ bD bI bO bF bE bH bI bL bN bu bN bT bN bL bE bH bK bM bW bK bL bI by bH bv bO bM bK bS bL bP bH bF bO bM bS bS bH bN bU bO bN bO bT bT bL bU bB bK bI bE bI bL bK bC bm bP bM bI bK bP bE bK bz bM bL bI bO bR bO bI bH bS bM bN bS bD bS bO bR bT bG bP by bL bK bA bL bL bU bD bQ bK bL bO bK bL bI bS bO bG bK bI bQ bM bU bN bH bF bO bQ bQ bM bQ bQ bz bL bR bO bB bT bQ bM bP bH bI bA bG by bQ bN bQ bK bK bF bD bE bK bE bV bG bL bP bU bV bT bU bK bK bN bS bO bU bG bL bH bQ bP bL bN bQ bN bI bG bM bD bK bN bU bO bA bQ bO bM bP bT bL bR bG bA br bR bU bG bC bT bO bF bR bP bQ bM bT bP bX bI bT bG bF bI by bz bH bK bF bB bH bB bK bG bI bx bK bO bH bO bx bO bQ bQ bz bN bQ bP bL bE bW by bK bP bO bO bR bF bK bP bN bO bR bG bx bR bR bI bR bE bQ bm bs bP bm bQ bR bT bx bH bL bO bK bT bF bI bM bC bT bK bO bO bI bW bL bO bS bR bF bU bI bN bK bK bK bL bz bN bP bF bG bP bM bQ bW bK bB bQ bR bR bP bH bR bG bK bD bz bQ bN bE bD bO bP bM bK bA bN bM bK bS bP bH bD bI bQ bC bx bA bN bN bH bO bK bQ bC bO bA bU bT bR bI bE bI bU bO bK bP bK bz bP bB bL bK bX bS bG bF bF bP bG bH bK bq bP bK bP bG bM bP bL bN bO bR bO bT bD bB bU bC bN bL bR bR bP bB bQ bH bM bQ bM bF bN bF bL bM bH bT bQ bQ bB bQ bH bO bQ bP bP bQ bF bI bD bu bE bG bH bG bK bF bG bT bO bC bQ bQ bK bM bD bQ bA bQ bP bO bv bM bG bD bI bK bE bL bI bI bF bT bQ bU bI bR bK bE bR bx bs bN bM bO bP bO bL bL bM bR bS bT bT bU bK bT bP bE bW bK bM bY bI bK bF bM bz bN bU bM bL bR bK bE bO bN bP bP bN bL bH bF bN bP bN bN bR bQ bN bT bH bD bK bU bN bu bT by bH bM bR bL bM bO bQ bP bF bD bL bT bH bN bm bK bN bK bK bK bU bO bK bI bM bO bW bQ bm bz bM bV bP bN bK bP bH bG bI by bS bM bR bP bU bR bX bR bK bG bQ bK bH bS bH bM bP bN bR bR bP bK bP bH bQ bD bO bN bK bI bM bO bI bS bM bL bM bM bC bG bM bG bN bT bM bR bB bN bQ bx bM bK bN bV bW bL bL bN bB bz bN bx bU bM bN bP bF bE bH bI bR bN bO bP bA bK bC bD bK bK bG bS bI bH bW bG bC bL bD bF bQ bN bM bH bP bM bI bN bP bQ bL bm bQ bW bA bP bT bE bs bp bN bV bM bH bS bK bQ bL bL bC bN bT bN bT bL bF bN bC bT bK bH bF bE bR bX bS bu bM bD bP bI bh bL bO bT bB bD bQ bI bW bL bI bP bM bM bS bW bL bO bE bG bz bU bG bA bF bO bG bQ bC bH bW bM bQ bM bH bG bu bP bI bS bN bS bF bH bH bM bs bE bK bP bB bE bG by bs bS bQ bN bY bE bI bG bs bF bR bG bK bL bP bN bE bI bN bC bR bQ bR bU bP bP bx bS bN bG bu bM bI bM bI bW bM bH bI bs bQ bT bL bS bQ bH bQ bD bE bA bI bK bG bH bN bz bR bG bI bF bN bG bI bI bN bK bN bO bA bR bT bM bY bD bE bC bK bT bV bO bK bG bS bm bP bU bN bN bO bz bD bF bM bI bV bR bC bS bR bS bH bP bP bS bT bu bT bO bQ bY bQ bK bL bS bU bC bR bP bM bO bI bT bR bP bU bK bM bK bQ bN bH bF bR bQ bR bN bV bC bP bN bX bB bC bP bN bR bP bS bO bU bN bO bO bR bD bO bO bI bC bU bO bP bK bL bQ bK bN bS bH bN bQ bD bH bX bN bB bO bG bT bT bP bQ bP bQ bN bH bN bK bU bH bP bT bN bO bM bM bR bQ bN bQ bS bA bH bi bH bO bM bM bO bU bM bP bB bF bQ bP bL bR bL bI bP bN bN bP bF bO bQ bR bF bS bN bQ bQ bP bI bF bH bS bP bS bL bQ bE bU bS bP bN bK bT bR bU bH bR bR bQ bM bP bR bL bL bQ bK bK bO bM bF bX bK bD bO bP bO bN bS bN bO bN bN bS bP bN bP bO bT bC bH bR bO bL bR bP bQ bR bP bF bM bM bM bS by bL bQ bU bR bT bP bO bM bI bE bK bE bM bs bP bH bO bR bT bL bO bF bO bE bN bQ bX bP bG bR bD bR bR bO bI bN bD bW bH bH bL bE bK bU bL bL bG bM bj bR bO bP bD bL bG bM bR bM bP bO bX bQ bO bB bL bz bO bM bM bM bK bM bI bO bR bQ bK bK bW bU bu bO bQ bC bM bL bC bK by bS bO bW bS bV bR bQ bs bP bS bR bF bL bR bM bN bD bQ bT bQ bN bM bP bT bS bP bS bU bO bR bN bQ bF bP bS bL bM bM bN bI bS bS bO bz bO bF bR bG bV bN bE bO bH bH bF bR bz bP bI bz bK bz bL bL bN bM bT bS bK bI bQ bx bK bW bF bP bN bD bK bH bO bW bO bv bL bH bQ bR bO bI bP bI bF bK bF bG bV bH bV bS bo bB bR bH bR bz bK bO bS bD bH bD bU bM bC bD bF bW bR bP bN bS bG bI bH bO bM bQ bu bI bQ bL bY bS bN bK bQ bO bK bN bO bK bP bN bN bP bB bp bD bQ bS bM bQ bM bU bE bO bL bQ bG bH bF bx bR bH bH bM bT bG bH bL bP bE bH bm bA bP bF bC bS bL bE bD bP bD bW bt bo bM bP bV bN bL bM bS bK bO bF bW bL bN bL bE bS bS bD bR bK bS bL bu bs bC bD bS bG bC bN bK bP bQ bK bG bN bz bI bP bM bP bL bO bO bK bD bL bK bB bL bK bK bF bx bI bK bX bN bX bT bM bG bB bM bL bN bI bN bK bG bF bM bR bT bL bN bR bN bH by bA bP bF bF bM bO bM bM bR bC bT bU bN bL bG bT bN bF bB bp bD bG bI bH bR bD bE bR bK bF bB bN bN bs bM bK by bR bB bP bv bQ bO bD bN bH bS bN bP bR bU bN bO bL bL bD bF bG bG bE bU bN bP bN bz bH bQ bT bu bF bQ bT bO bF bH bM bN bP bV bv bu bF bz bQ bC bH bO bF bE bO bz bP bL bQ bR bC bO bN bN bD bs bM bQ by bE bQ bP bG bK bs bH bL bH bK bH bM bS bD bK bs bD bC bL bz bS bT bP bz bm bG bL bR bK bM bB bB bA bP bI bQ bL bk bC bH by bR bL bQ bN bD bO bP bG bX bL bO bH bv bI bF bL bP bs bS bL bQ bD br bK bU bB bl bS bH bL bN bP bG bC bP bN bG bH bI bR by bU bm bL bC bD bH bK bA bF bM bP bM br bF bA bL bM bK bL bs bT bQ bz bI bI bH bH bS bL bM bN bv bM bQ bG bW bF bG bo bW bP bk bC bv bM bA bP bO bN bN bC bK bF bA bF bM bD Z bA bz bF bG bx bF bL bM bN bO by bp by bB bK bQ bH bL bG bU bq bz bU bN bu bG bj bD bN bK bM bm bI bo bF bv bh bm bt by bD bp bu bE bF bF bk bT bR bN bR bH bK bF bE bK bL bM bK bs bE bH bL bG bG bH bK bN bT bL bI bE bE bI bK bL bu bU bm bK bO bC bO bA bH bz bT bs bF bH bD bQ bP bK bO bB br bS bp bC bN bQ bD bI bs bO bD bN bH bG bR bD bH bC bG bs bM bB bx bB bQ bF bz bA bS bA bR bv bH bG bI bN bP bv bF bA bO bL bI bK bM bS bA bE bU bR bD bG bN bC bz bD bE bG by bI bK bP bz bC bB bM bI bB bB bu bL bB bG bF bz bE bH bB bI bA bP bN bD bB bQ bB bG bo bK bB bM bD bH bx bI bN bL bN bM bG bE bO bR bK bT bh bH bB bL bH bH bs cg bv bO bO bD bQ bI bA bL bz bM bH bR bN bN bF bE bH bz bs bG bR by bN bs bP bq bS bL bz bs bN bF bz bv bB bR bG bG bC bm bI bW bI bx bO bO bP bC bx bM bH bL bj bB bH bB bK bR bD bM bB bL bK bQ bI bI bT bP bI bD bG bx bR bH by bW bF bQ bQ bQ bF bK bF bN bM bL bI bO bN bT bP bR bF bG bz bL bF bO bP bH bO by bI by bH bQ bD bM bL bM bI bQ bK bA bM bN bD bT bK bF bF cg bG bS bF bD bM bD bI bC bH bK bR bL bt by bC bI br bp bE bL bU bM bx bF bR bC bH bM bB bN bL bA bI bO bD bz bB bG bM bD bG bD bM bN bM bO bL bI bT bP bO bB bQ bO bK bC bF bI bP bO bR bK bC bF bC bs bC bR bF bT bK bA bc bM bL bK bQ bD bM bO bz bP bB bB bN bL bq bk bz bO bQ bL bL bM bs bN cg bM bs bD bK bH bq bI bD bH bC bL bD bD bP bC bC ba bO bD bC bO bT bO bk bB bA bD I bQ by bF bD bj bQ bO bO bE bE bF bD bK bz bD bB bD bN bA bN bR bz bN bK bA bz bN bH bI br bM bP bQ bG bQ bK bG bO bj bI bL bQ bQ bN bK bU bN bK by bF bp bS bR bF bE bP bO bG bP bS bI bU bI bD bq bH bM bP bO bN bk bx bH bF bD bu bL br bB bS bR bv bE bN bK bR bh bo bx bD bN bR bA bI bk bL bL bR bu bC bq by bp bK bG bA bM bo bs bI bL bH bx bF bz bK bv bM bC bo bI bH bl bG bL bP br bA bx bF bF bx bL bF bH bx bI by bG bH bA bQ bB bL bI bE bG bh bF bC bs bE bR bt bp bI bA bA bH bC bs bO bC bx bR bq bz bF bP by bN bG bK by bP bN bQ bK bH bs bP bD by bL bj bo cg bC bF bF bL bI bI bE bF bH bM bL bH bz bQ bO bL bE bM bE bS bB bE bO bH bR bE bx bq bx bL bK bW bC bo bB bO bt bP bs bN bN bC bR bm bv bK bx bC bP bA br bP bx bO bu bo bI bu bN bx bG bO bR bG bD bC bN bt bn bR bI bD br bI bL bO bQ bK bC bO bD bL bD bu bD bC bK bI bv bx bs bF bp bA bv by bF bD bM bt bC bt bq bq bG bx bM bA bC bC bB bv bG by bE bO bM bR bz bE bA bF bE bP bj bx bG bI bG bM bK bu bz bP bl bD bN br bp bK bH bM bF bA by bA bN bm bh bA bp bI bD bK bB bD bz bN bP bB bu bA bs bB bL bz bL bj bQ bD bm bM bv br bu bB bG bx bv bo bm bS bB bL bK bI bI bE cg bC bm bA bE bz bG bI bv bo bt bL bb cg bM bv bH bv bM bx bv bm bO bI bH bH bz bx bz bM bI bF bQ bu bR bG bC bC br bm bC bq Z by bG bB bM bz bz bK bT bG bo bo bG bj bl bF bu bs bF bL bO bs bm bu bB bN bF bx bB bH bt bE by bF bl bA bF by bv bG bB bB Z bu br bN by bH bs bH bh bm bn bK bN bD bs bz bF bF bI bI bK bF bP bD bt bp bK bF bG bm bD bm bA bB bC bB bF bm bn br bo bu bL bz bv bg bA bE bA bz bD bE bM by bG bN bE by bE bF bI bz bR bk bH bE bz bq bE bK bs bm bx bp bE bD bH bL bq bL bD bN bK bG bE bI bx bq bK bq bu bC bA bD bB bN bN bq bt bH bs bL bO bE bN bK bN bz bC by bs bp bL bI bt br bA bF bI by bA bC bC bO bf bp bp bN bF bE br bF bO bD bu bK bI bD bI bp bu bG bQ bu bB bq bG bH bu bp bE br bD bo bE bj bC bH bz bA bF bM bC bM bA bC bd bA be bG bE bB bu bF bA by bF bG bG by bp bq bO bD bG bI bG bo bi bf bv by bG bu bk bz bN bl bH bG bA bN bz br bc bD bA bo bD bG bE bH bF bl br bh bC bh bs bH bG bD bI bu V bx bp cg bt Z O bM cg bj bA bC bx bO bD bB bD bB bH bv bO bs bp bI bz bL bA bP bB bD bF bB bE bs bv bs bm bx T bi bO bz by cf bz bF bG bG bG bK bC bE bz bx bx bA bL bz bf bA bL br bt bI bL bE bD bm bE bG bK bD bL bz bp bq bB bL bI bB bF bv bl bL br bB bH bK bx bM bs bA bn bq bu bM bt bz bC bp by bm bI bz bm bi bC bn br bk bO bE bM bH bk bF bo bL bE bz bN bG bo bK bC Z by bz bL bE bv bL bE bz bv bA bL bA bD bu bi bE bC bu br br bs bp bF bB bA bm bG bt bm bL bE bP bv bs bF by bo bC bN bM bF by bs bz bK bm bC bv bC bD bB bD bG bD bc bv bK bx br bB bx bj br bI bo bE bk bz bD bz bA bB Z bH bM bt cf bO bG bA bu bE bk bv bB bz bF bn bI bA bN br bH bh bt by bH bD bz X bD bD bP bI bb bD bA bH bh bF bo bs br bC bQ bo bF bC bD bA bF bE bA bu br bA bp bE bC bx bF bk bI bu bH bx bh bx bI Z bI bs by bz bE bv br bE bF bm bH bO bG bG bv bs bx bB bz bL bu bG bF by bu bG bs bv bG bA bB V bu bh bt bN bF bs bE bu bO cg bv bE bK bo bE bF br bE bF bE bF bt bC bE bF bz bm bO bC bF bA bC bD bu bN bj bH bt bE bE bc bx bz bC bI bm bK bM bq bI br bB bl bC bz bf bO bN bt bF bD bv bx bo bs bE bu by by bA bE bL bN bB bx bN bM bt bI bG bz bA bK bL bG bH bC by bs bD bI bD bs bC bB bN bI by bH bz by bG bP by bK bo bC bF bC bB bu bL bI bF bm bp bB bI bx bm bK bj bs bn bG bG by by bD bM bK bM bD bE bv bD bi bG bF bE bM bC bK bq bD bK bA bp bI bL bu bE bz bE bC bB bs bp bD bx bh bL bG bc bD bN bL V bE bH bt bE bC bG bt bD bt bI by bE bH bx bL bh bC by bh bG bA bA bx bE bu bM bB bu bE bQ bG bL bG bp bP by bD by bI by bs cg bm bA bI bx bB bt bu bm bq bu bH bx bH Z bp bs bm bz bG bv bz bx bq bC bx bx bA bx bv bG bI by bk bt bF bO bA bC bE bO bh bt bL ba bl bK bI by bI bs bj bC bu bC bz bu bh cf bE bE bI bj bm bp bF bM bB bs bv bq bA bF U bg by bF bE bC bj bB bA bE bD bo bG bA bN bo bz bE bx bR bv bs bC bq bI bx bA by bG bB bu bm bF bv bu bC bz bH bF bI bp bO bA bB bz bG bE bH bK bn bm bq bx bj bt bI by bF bB bG bv bI bK bN bo bB bz bo bE bB bA bF bC bN bB bA bf bF bD bG bv bt bM bu bf bm bL bo bz br by bh bj bi bE bo bL bf bx by by bv bu bM bz br bM bu bI bE bu bD bH bj bD bC bx bA bn bA by br bx bI bt bm bE bD bL bG bB bq bu bj bL V bp bI bk bz bF bF V bo bE bj bB bI br bI bF br bI bz by X bG bC bE bx X bi br bD bB bE bD bA bs bA bp by bo bB bQ bv bt bK bs bt bx bG bM by bv bC bz bA bu bD bx bj bu bC by by bo bz bu bF bq bp bu bm bv bB br bu bI bM bv bp bD by bC bB bx bq bD bG bH bG bq bo bk bM bz bM bP bs bt bA bH bx bu bt bD bD bO by bA bc bC bL bS bx by bG bk bg bF bu bD bx bG bu bI bC bE bE bF bC bp bz bG bF bA bx bL bm bH bk bD bE bu bx bC bB bq by bq bA bx bC bL bv bg br bI bN bB bK bC bo bz bn bu bx by bC bo bb bH br bI bk bv bx bB bg bD bP bg bx bL bB bt bu bH bM bx bD bD bE bB bK bH bA bP bF bL bn bp bs bM bz bG bK bm bt bz bB bs bq bt bp bz bB bm bI bu bF bq bC bI bu bx bC bF bA by bt bu bs bs bO bF bj bD bl bz bj bN bu br bz bC bx br bH bO bb bE bm bs bj bB bm bm bP bt bN bC bz bN bA cf bC bD bD bF by bM bx bu bz bC bI bH by bH bE bD bD bE bv bM bM bN bF bG bu bG bx by bo bG bB bA bv bK bz bl bm bF bp br bt bl bD bx bz bO bC bv bj bB bA bi bA bC bG bz by bt bM X bp bh bC bA bj bl bz bB bq bH bm by bG bC bk br bv bq bu bp bp bH bC by bC bj bG bv bH bs bH bF bI bM bF bo bs bx bu bu bs bj bt bI bo bx V bG Z bx bB bL bL ba bH bx bE bF by by bx bh bq bt bC bj bx bm bG bj bI bD bD bF bD bG bi bE bx bp bO bL bz bE bh U bt br bu by bk bC bp bx bs bl bB bK bz bp bC bq bk bE bF bN bA bp bG cg bF bM bu br bk bq bM bt by bs bF bj bB bc by bK cf bq bp br bC bF bx by bo bz bI bN bE bp bu bD bl bI bu bF bf bj bF bu bn bq bq bp bF P bL bj bb bo bF bE bi bI bC bq bC bv bA bG by bF bi bI br bv bE by W bU bM bs bA bD bv bF bA bC bE bK bK bz bs bH by bF bu bE bA bn bB bz bk bv cg bx bk bL bI bu by bI br bE bs bI bh bB bH bb bz bj bk bI bO bC Z bg bt bv bx bB bB bk bC bu bH bz bG bu bE bL cg W bG bb bH bH bF br bE bD bs bE bj bs bv bD bq bg bE T bD bf bP bl br bv bC bO bB bC bA bp bs bM bI bm bH bq bp bB bt bD br bx bI bD bH bm br br bK by bz bC bG bG bB bI bH bz bq bE bo bH bx bq bp bx bE bF bl bx bh bm bC bI bA bH bN bH bC bF bq bo bB bn bz bq bE by bG bC by cg bF bC bB bC bB bs bn bA bA bo bI by bq bp bs bC bi bx bI bv bC bz bo bx bm bC bx bz bi bz by bm bN bq bO bs by bC bL bA bP bG bq by bo bG bG bD bz bq bH bF bo bt bv cg bK bp bQ bF bG br bl bp bo ba bE bs bm bF bA bD bH bA bL bs bL bq bG bD bN bx br bp bK bA bA by bz br bm bH bj bz bq bz cf br bD bq bn bk bE bI bx bM bP bz bh bz br bz bC bL bo bH bz bv bq P bB bx bs bt bz bs 0.089 bd Z bu bx bm bC bE bi bF br bC bC bg bu bg bx bv bi bF bC bD bt bL by bR bB bB bs by by bu br bA bq bD bB bA bz bE bs bx bv bM bO bG bo bs Z bA bL bL bM by bv bF bA bG bj cg bn bm bE bv bE Z bI bE br bz bz bI bF bA bz bI bD bK bh bA bs bz bO bj bB bA bL bx bn bm bF bm bM bF bm bv bv S Z bx bq bA bo bB bM bA bz bz bL bG br bD bA bC bE bu bB bt bo bt bx bD bK bD bu bt bC br bB bE bH br bo by bF bM bN bB bm bM bI bM bI bI bp bK bL bu bt bE bs bo bB bp bM bg bI by bA bE bu bA bz W bB bA bx bA br bC bE bt bi bv bp bz by bs by bi bB bC bz bE bF bG bH bs bn bl bI bH bz bx bm bi R bB by bH bE bh by cg bB bN br bj bm bv bL bu bF bA bo bo bM bG br bz bm bh bk bA bC bx bK bm by bE bm br bx bN bP bE bs bE bG bH bt bn bp bx bD by bK bz bq bo by bo bq bu bD bL bo bk bE bH bE bE bM bM bF br by bA bu bF bp bP bz bv bI bA cg bA bC bs bx bx bC bu bu bA bv bA bA bI V by bu bt bj bL bq bE bz bx bv bx br bA by by bA V bL bD bz bs bx bH bI Z bt bD bB bz bh bk Z bs bA bD bc Z bo bE bG bk bB bx bp bH bD bM bs bB bB bp cg bB bP bk bs bA bB bE by bG bm bB bm bl bD bI bI br bC bv bI bI bi bu bL bA bx bB bq bh bC bC ba bM bo bC bA bK W bs bt bj bB bD bu bz bG bH cg bt bq bA bH by bn bq bn bE bs bH bL bi bx bz bx bF by bi bz bC bz bB bt bM br bF by bE bo bF bp bI bs bz bt bj bj bF bM bt bm bD bF bH bv bv cg bc bl bo bx bm bL bj bm bb bE by bp bM bF bA bH bD bF br bp bp bC bo bm cg bq br bC bx bv bF bN bt bh bB bH bk bo bn bo bx bp bu bE by bs bg bM bv bk bC bx bq bE bA bo ba Z bA I bf Z bE bE bo bx bs bs bm bC)));
elem('text','')
\`\`
            // TODO: Re-compute plots: 12k epochs is way too little.

        - Stochastic-ensembling \`stddev\`=\`.5\`:
\`\`
(display 'Average reward' ^(a:-1.87 b:-1.82 c:-1.86 d:-1.8 e:-1.88 f:-1.91 g:-1.85 h:-1.9 i:-1.84 j:-1.83 k:-1.77 l:-1.92 m:-1.75 n:-1.71 o:-1.81 p:-1.74 q:-1.76 r:-1.89 s:-1.3 t:-1.59 u:-1.44 v:-1.72 w:-1.73 x:-1.47 y:-1.79 z:-1.65 A:-1.51 B:-1.58 C:-1.7 D:-1.6 E:-1.67 F:-1.37 G:-1.56 H:-1.78 I:-1.57 J:-1.42 K:-1.34 L:-1.54 M:-1.69 N:-1.38 O:-1.52 P:-1.61 Q:-1.5 R:-1.49 S:-1.43 T:-1.63 U:-1.45 V:-1.62 W:-1.66 X:-1.19 Y:-1.29 Z:-1.35 ba:-1.55 bb:-1.53 bc:-1.31 bd:-1.48 be:-1.64 bf:-1.14 bg:-1.28 bh:-1.1 bi:-1.39 bj:-1.4 bk:-1.33 bl:-1.68 bm:-1.17 bn:-0.94 bo:-1.02 bp:-1.01 bq:-0.91 br:-1.32 bs:-1.2 bt:-1.27 bu:-1.22 bv:-1.46 bw:-1.25 bx:-0.63 by:-1.06 bz:-1.41 bA:-1.36 bB:-1.13 bC:-0.88 bD:-1.23 bE:-1.03 bF:-1.26 bG:-0.96 bH:-1.24 bI:-1.11 bJ:-1.05 bK:-0.97 bL:-0.77 bM:-0.65 bN:-0.98 bO:-0.82 bP:-1.08 bQ:-0.62 bR:-0.93 bS:-1.21 bT:-0.95 bU:-0.79 bV:-0.75 bW:-0.9 bX:-0.51 bY:-0.99 bZ:-1.07 ca:-1.18 cb:-1.15 cc:-1.16 cd:-1.12 ce:-0.73 cf:-0.67 cg:-0.85 ch:-0.87 ci:-0.78 cj:-0.56 ck:-0.69 cl:-1.09 cm:-0.84 cn:-1.04 co:-0.7 cp:-0.54 cq:-0.92 cr:-0.76 cs:-0.81 ct:-0.64 cu:-0.6 cv:-0.86 cw:-0.8 cx:-0.89 cy:-0.52 cz:-0.43 cA:-0.39 cB:-0.83 cC:-0.5 cD:-0.55 cE:-0.59 cF:-0.72 cG:-0.37 cH:-0.61 cI:-0.38 cJ:-0.47 cK:-0.49 cL:-0.74 cM:-0.53 cN:-0.68 cO:-0.71 cP:-0.32 cQ:-0.41 cR:-0.58 cS:-0.26 cT:-0.46 cU:-0.25 cV:-0.05 cW:-0.36 cX:-1.93 cY:-0.57 cZ:-0.66 da:-0.44 db:-0.34 dc:-0.13 dd:-0.28 de:-0.29 df:-0.27 dg:-0.17 dh:-0.45 di:-0.3 dj:-0.21 dk:0.18 dl:0.05 dm:0.06 dn:-0.24 do:-0.08 dp:-0.09 dq:-0.19 dr:0.09 ds:0.14 dt:-0.07 du:-0.16 dv:-0.15 dw:0.13 dx:-0.03 dy:0.63 dz:0.3 dA:-0.1 dB:-0.22 dC:0.07 dD:-0.12 dE:0.81 dF:-0.23 dG:0.79 dH:0.19 dI:0.6 dJ:-0.02 dK:0.64 dL:0.02 dM:0.47 dN:0.46 dO:0.24 dP:-0.04 dQ:0.37 dR:0.26 dS:0.51 dT:0.54 dU:0.43 dV:0.16 dW:0.34 dX:0.21 dY:0.99 dZ:-0.31 ea:0.22 eb:1.15 ec:0.39 ed:0.86 ee:0.1 ef:0.57 eg:0.65 eh:1.07 ei:0.49 ej:-0.01 ek:0.31 el:0.7 em:0.2 en:0.53 eo:0.35 ep:0.04 eq:0.94 er:0.5 es:0.48 et:0.4 eu:-0.11 ev:0.12 ew:0.28 ex:-0.35 ey:0.45 ez:1.51 eA:0.8 eB:-0.48 eC:-0.18 eD:0.36 eE:-0.4 eF:-0.2 eG:0.41 eH:1.02 eI:0.38 eJ:0.58 eK:0.59 eL:0.83 eM:1.45 eN:0.42 eO:0.27 eP:0.77 eQ:0.44 eR:0.69 eS:-0.33 eT:0.03 eU:0.55 eV:0.92 eW:0.01 eX:0.33 eY:0.76 eZ:-0.14 fa:1.26 fb:0.29 fc:0.73 fd:0.71 fe:0.25 ff:0.52 fg:0.23 fh:0.68 fi:0.15 fj:0.11 fk:0.08 fl:1.34 fm:-0.06 fn:0.67 fo:0.89 fp:0.97 fq:0.17 fr:-0.42 fs:0.84 ft:1.01 fu:0.56 fv:0.32 fw:0.61 fx:0.87 fy:1.37 fz:0.75 fA:0.66 fB:0.9 fC:0.85 fD:0.91 fE:0.74 fF:1.21 fG:1.13 fH:0.96 fI:0.95 fJ:0.78 fK:0.88 fL:1.04 fM:0.72 fN:1.08 fO:1.28 fP:0.62 fQ:1.23 fR:1.03 fS:1.22 fT:1.27 fU:0.82 fV:1.16 fW:1.42 fX:1.36 fY:1.17 fZ:1.18 ga:1.2 gb:1.05 gc:0.93 gd:1.06 ge:1.09 gf:1.11 gg:0.98 gh:1.31 gi:1.24 gj:1.58 gk:1.1 gl:1.19 gm:1.39 gn:1.14 go:1.29 gp:1.3 gq:1.32 gr:1.35 gs:1.33 gt:1.47 gu:1.61 gv:1.25 gw:1.76 gx:1.12 gy:1.43 gz:1.7 gA:1.9 gB:1.55 gC:1.59 gD:1.8 gE:1.88 gF:1.81 gG:1.46 gH:1.49 gI:1.48 gJ:1.38 gK:1.75 gL:1.6 gM:1.53 gN:1.67 gO:1.41 gP:1.4 gQ:1.57 gR:1.65 gS:1.5 gT:1.64 gU:1.52 gV:1.87 gW:1.63 gX:1.54 gY:1.69 gZ:1.74 ha:1.62 hb:1.71 hc:1.44 hd:1.91 he:1.56 hf:1.66 hg:1.68 hh:1.83 hi:1.86 hj:1.78 hk:1.89 hl:1.72 hm:1.92 hn:1.84 ho:1.85 hp:1.73 hq:1.77 hr:1.96 hs:1.79 ht:1.95 hu:1.94 hv:1.82 hw:1.97 hx:1.93 hy:1.98 hz:1.99 (a b c a i y u b d c t a e d e F f j a J g f l h k b r g h q i b D j a o j k s k l g p m z m n k n f o h i bk h cX p w e e n B h k e A q H r I C m s bl x t G q n j c v u v b w x w h o g a y z A i o B O g y S Q C D E k b E y p N bb p p bj F G z B s L H c K I J i d I i v v be K b i L g w M H M t w z I w v o y n H A M v M N bz d v b a p M k H O F E R e y T E c bf K O P C b k m E a P I X bn bG bh by K Q R L V N A D p p U S y Z T bZ z m bd bc v A U cn N n V b v bg w k W D W A a V F c g N I X bu P T bo m bm bM Y K Y Z ba p i w y n A j ba V y bD W w I I bb bi V L V k bc t M bb o bd be bq D bA bf bg B T L bB k k bg br D cc bC I bh W bi U bi bj bk D j bb L k T bl B G w A bX bm bb bn bE F W bl y bs E bx E V V G bp bd z A D bo bw V bd bR cC X bK ce bo Y bp bd bg bb bn bb Q L d bt s bP I P K bi W -1 bg F S bd bJ k bq O bF bl n Y z bl D bi Q F R br n bs Q J V D O bl bt bv V bj Z B bu bv A M O bw cf bx by cl Z F cs C Q cq bO L I bz k t bu dx X bg s x T n i i bl s x z bi bs ba w G M bA B bt bB G bC s bH J bD G bk ba n R O V I A bE B y -1 ba bF bw w L bu bY s bj Q bI bF q i t br U cH bd bo bU bC bQ bB bL bW cu bG x x bc W k L Z bb bt L bH A bc K bd Z bs bI bI bN cp ex bq cg bF bi bG bF bT s bJ z s -1 F bb br cr bJ bK bv bS U bL cP bw u T bD be bs cT bu bM ck s by E B V bq bs bD F W q O bN bD U c t u z I I br bO G e bt bb u cL bA be T v bP bQ bR ba ca bK bf O Y ch bD bB bB bG br bS bT u T A N cO cE bT bB x z N s S be bh cA bp bl bI u bt ci H bU bK E cz bv bN Q s C I bJ z bP be bg N br br cy bm s bi cb bV bV O R bc bw bf bc L bF bg bT Z v bI bW bS bX bD cv A L by bF bv B bT u bY bw cj bD s x x n -1 Y U bv i bj bA bC -1 S bZ bz D bi K e bk R cG bn Z be m bF be V z ba z G bg bu bA bi H E F bK ca N bC bN q bK bD bE O W bs bN A A bm k Z bP J bB S M Z q m E cd I by B I bB bw t O A F cb cc bg bS u O bi t bA ba J br N bq bD ba bv G cd U bd bz C L be ce bt R S be i t I A A bl t N bl W Y N t L O bW bA M br d w y be B k p q a a P u T bc N u bG p bw bE bm bj bz v bi bk bz bH bP I g E J bA P y C T z bv V A I bi T c n C t G M bo w I x v Q P p bU bj U bk P bc v C bl P bd bF P bA V P O bj cd B bc T bs g x bH bb k b E bo k p v J bH s cf A F Z cd bK F bv z C bc G E S C ba A G bz ca bd A P bH -1 x -1 H y T M bi k m E R k k W bl cg s bz bg bt j S cm bj Z bd ch Z v bF t cc N A cd N N J L F N z E M br S S bP W bb bj F I O E T m L bd bo bf cd W T g R bb X I F ci cj C ck bK bR Z be bp Q v bd t R I t bc cl bP t D J A bs bt G br bB bS T q bi q m a ba N bi L bK bg u bh U bP S cm bs cn J bv W S bI cm bK bH bn x cc bj K ct bg bv bP bs C bv bt V W bz bl S bj co bV m br bg bg be D bF M ba O bi S t G bd D S bA br s G bj x bt Q bw bv K co be B v bu be J G T z bA w p t E n bZ m bk cb bD bl C bv bt Y ba P P bF bv cc K bg q F cn be J F bg O cp Z bi bA O ba bD bv cb D bo J bW bg J U cn K cD bA ba be bi Q D bv bw cd C bd j F bB br d d y bA R cc F L w bh O cq P Q B bb bs bb G I C I bb bc bG H L by I v N bH bY bp cr bH B B L F H Q bA y bw H bb V Q bl n be i G br ba z ce bB Q u bE bd w be cl bv Q bz k bZ R bt L cs s I o w M w G q cd cf ct O w bv bk bu cb bg F ca P t u I p y o W br bd a q br O bP cn W bK bd J bb K bY bt A bu K bT U t U bD S bT by bo G bv bA bb bA u be bi S n bR bp ct bc cw bi bB bs bG x cd W P O I N bw bs br O C cd D y I E ba j P T D g Q W O bz bi b E bq k D d o Q g bc Q x J u U I bU W G v v P cu br bI t bH bS W P N bu P ba Y bA T D s B bW bj be Z S bk x bN K K I bt bc bc bz J bR cc be R bj S br g A x s dp bg ba L L C bH B H d bd T cb M I G be n l bd bS be G F bE bl Q bw F L bP bj G bI bB br bi m bb A M bA u R be D I bd ba bd B v by W bo bm K O F bc by ba Y v bz B be bg V o P B bb bg bv bC bA bS z K cl K O I o bc bK F bd s x bh u D z bj bD bG bH L bu w bi bt cv bZ cw bN eS by bD bS cs bt bF cx bH bB ch bu X -1 O Z bi bS cB S t U by ca bS v z q bF J bb C i F p bd bs p H bb T P G E B k y bw bz P t Z be K U x J bb I G bI z bf B be z y H bF W bd bG V bi cu bu cb by bI bD J L bj bD U bd bo bD bb Z R bS bI o P bu be v G w X br m S B z P ba bv bz cc be be cq bD L W S L x bI s D bl by N bN Z s bD Z H L bR bH bA W v by T bi F bw A bu bD bd q W w U B Z a D u Q bf Q ba be I bF cc P bA bh bW bm bB U bm Q br cc bi R bA x bj bv d S M L bf K bc x ba N bf S B bi bg I cc m bN cx bd bl E ca bw bw x s d i D bE bk D B v W m O M d G P Q bu K bC A p v bJ cd cl cy W bT bk bK R m Q M be E bv d W I L U L cb bB B z bI bh w C L cb bz T bw bc p bv bi bx bz P u bA S bI J S bZ u A Q bt T by bV cz ca d t bb T bc Y X E O N R bd Z cb bH n bA a C be Y bH bz bF M ba cb ba M y w L i ba b be cF Z bw bV cd t bd u J bw bz bw bw U bb bz bA t I T C s be q bP p j ba T bl o H bz bs bo bx bF bJ bz V bK Y F bp cS cA cn ca cx bN ca P O Q bc W Y bj bn cB bB A k ba O bd X S bp K L be R T F bR ca E J B K Z V T n W S k E bZ bz y bi t bi cc R v E bd p D ba O T bi F bI q V U d B bc S bc bz B Y bD br F x bz Q ba be bk z J bd bz bj w bQ be p bF bk n E bc L bk bi p bD bz U cb p C bz E b F L n bd S H be E v N br cl bj bi bz bw bq O m bA s bm bv bl C bk U Q ba S z be G P B W u J C L O G t I bc bJ bf bd o Z O be cb bS y W t C U bt Z T bl k P A O n H c b ba j d J T k ba w j n bi bj z P A R L S bb n E H t u k k V y bd I o x bi cK cf bi cx u bB ba C L -1 R be M T cb P W q n S ca K bv J I A bF Z G S bp V t bf bm bG bv bd cn bj K R ca bd cB Q bv be bl E be D G cb bH I y R F F bH W w bc bS P v q j i V bv bl bS z A bl T I w G bm K M bv by cm bS bm N bm cC cy bb cc F S bj Y G bl bF ca M B x W T Q bA bk j v C ba k g z y Z bs v V P ca k bv z bA bt bd G bt ba bE bQ ba ba s bc k k C E u p ba bs A J M C X bv bA Q br o G p N bZ bd s k v k be v G B P bH bL t L be R be z bF E p z t b j bw u S g D C E P A k m bj D j n ba Z bm bj bt D be j bs Q bb cb P R cl G b bj C J bg N X R m N D V D cB bt ca ca bk bz U bg y t cD B cD A C R o h bl u w bb bv be F bw H D o n bi bi bl bc cd bh L R Y U by bF bz c cw x bg T L F cE bz s cp bf I bm bt F x ba bA bs bk P bt Q bj W S bt bI p n z m D bu n bc bb m P L P H E bj bb W H W v b H V bt M W G s N bD bw I G L t v z t u bg bc N v T T s U A cF cI D n bb bs cG s cF -1 bm cw bJ L n bk D R cn A bY bw N D R P bv b bl bw K bt u ba bu be bd L E y t bb bD I I bb w b D Q o bd T O bw bd u z M L V bg V bc E bd bN ba O m D M V R T D U bj bR bd bZ O s cl bc cg bF bo Q bE O G w bz cb J Q cv -1 bT s S u bP cy bW cm S Q B ci J -1 bu w ci bf bf bv K cn Q Z S by Q bW cn N cd bg bI y L s cn bT -1 S P I bj A bw m C bd X cH cI bk bz bw F bm bE ba bF B R ba cb bZ M J u cU q bl C bv y I E U E x s cn bi F U Y p V bk U bP X bG bH A bp bo D bA p B t cF bt bS n cl H J z bh p bz bo bw bm bb -1 bk G n bD a bw bb H J ba bH L bb S bn Z E M br R V bN bI K bN bY z bb bA cw bd P bj C bD O bF by z Q s L z H bn i bi u I K bT bv n S I cd B T T bg bD y v M L Y F I U w B bD U b s by I Q bK bI bg A S G bb bB G U L X Q G bu Q bc s bz bZ bw bP Y F A bo cd bZ v bk bt E F bf U K A cv bC t w ba D W s T br L ba p T bt bA m F bb bA p bz be bl W bF o K n T p v J C cs bd q be bu I E Z n u F B bt B bq ba bj n bD O cH cC bc bF cJ cR bm be bv P Y cv bu bm cc w u L cq bf u bl bZ bq bK cv bu bR bk J J U T w a w j n m N bj P cY bg O be br e be bg K P bd bi bK bY G cB T t B D br -1 bG bi cZ bI ci bj bj y br U R Q L R F -1 P R bR cd ba N o Z Q M w P bF bJ bm z v c br p bk j j o E bJ x bd S G bl P J bw S bH s G X D bv U U C Z bw bp bc J bx D B ba A T T cB W S L cc bJ W b bA Z bD bv bS J bz bR bB bj bw bz br bZ Q cq J bK F x J bH bQ cH bt dh u bP by bA A u bl A O bD Y L bz cu Y R bL cs cl cN bA I bA D a Y bq X G z bu w bQ bA bN L bn E W A V cc V R bb bu bt G P N x I bH cg q u bk W L bF cw u Z bh cx cr O F t N bw bk bw bH I bd bz Y cn bS bc R be X bn bu bE bE ba m bq cr C S K bA cb cn bY R bh Q I ba L bO bO bJ bA cl bO bR bj bK E bN T bE a bF bd Q bj bW bg bf ci bV bp bu cJ cK bo bq ca cl cc bD K bw V U cF X bN co bD Z bF bz bA cv Q W E cd P cl cu G cb br cx cc x L bG cM bG cn J O bD bH W cc bY bD S S ba E t L F P x P cI bH bb bi bi M u bg T bJ ck cb bZ P cL cB bB dS bM bQ cr s bc bD bv bA bl S s bi T bG bm bi bg cd ct G P y be J bd bD bl bJ cl cb A ca bJ by U S ba n by Q bF bT bj D bA bi bf cL bV B G B s cF bf cr cb bX m T x C bK R L V P k bs n J bJ G w V x L bx D cs u cl J bR bT u bi Y cd bc bA bm bs B bu P be br cx T I z bD bP bF bE cc br cM bD N w o V bI B ba cd j ba bH bg Q J bH bP ci bp u cb ca bo bJ J Z bD bh bg J S m bw M O D bP T C I cs bH bd cl bn cm bm bw bc by N t N bH cx cB Z bT d X cd cC bf by cr F bo bw br bA K ba bc co bW Q t K J br M -1 K F bM bR bv cj s L bw cN Y cq bG bK bT X bH bF bJ cF cL cN ce cB bm q w bj bc bH bC G bB bz bb bP I F by bk cL cg t cs cO cg bF bG s R bs cB bB z t bw P G bz cf B n cl cL bH J P bk U cQ bE W Q cn I be G O T bc bE J L cb bA ck bY cv br ca Y ch bV cc cl Q bo cb ce R U bW bt bN Q I bL u J cd cj bP F cg bI bI bn cd ba T A cc bg E bf bB cP ej cI bO di cg cx bF bI bI bN bN cO bH bO X bD bg bL bR be cf cQ O L C bc bn bn P ce P br bB x bK bD bk bG cy bj bk P bt br bb cR cS ck V ba Z V bl G bU S cb M S U bj cd bS bs w bA bq N cn cc F j cq bd cx bX bj bF cW bJ cF bF bI cd v bS cM bt bt bj bs bA Z bH bb Z bD bj K bg bE y Q D by S bw bl Q ch w bl T bw bY E u bF Z B M W bv K o bd F bk cT N cm bQ bI P Y -1 bT cb u cR V bC bT k bH u R bG W cV Q bH cU du Y cV co bV bs cq bs bY cB x ci cl bJ bk bu D bw bh bF s f bT bu S ba p n t S bE bo u K B W bm bt cb x cr bq bR bE bU Q bZ R bQ bd bC bB br bi br P F I bT ch cL bE -1 bY H cn bv e bg R bG bH cv S bp d ca M s O bh o cg ci x cw R S R F p i v n v g bN bv bp bA k cb bH T x cd M G V I w bc bg y a ba bk bG cb cn bc v bg s P X bj T G cd D bF bc bf bi bz bj bj t bl G bk i M bA m b Q A bb be ca E j b w D y P B W y w cl x bD M x g B M p W bC bF bz U g bv -1 bd cK I cW W -1 A bX z bj A A bk a i bw be o F a e h r c G J cb p P Z bg bj cx z be v o G bk bl M g W bt C J S U cl U H k i i v j y H bg f b bi c c Y A i O H i m J d H cb ba y bv cd cl ba bh bW bN ci Y t by w y br n p bT bN d d w e M y a ba a m V ba c d n C L U d T bj n e Y cX s t T w M p K c i bj bc bZ K br W K -1 A t W bj t bR bl bi E d I bj K G bj v b T Z Z bS cd ba cl cY Y bv ck dc X bN bc cP U s bc O F be q bv i D Q a P J c B bB n n bb Q be p q bc cx cw ba b k v be D be cX q f bi b a j bw c r e f i i i a D L o z E f bm t Z cb v bv o V b a ca B T bA C a V y S bP m k bl R x A bB cq bO p p G k bb M bF W K L n P cc e cf X z w q y m bm G bP z bf D bl bF i y V j o U J bZ B W cQ bS bN O O br T t P x bS bT bH bg bS bk P bS bc cs cd O bd N cm K bq bG J bV U be bJ N F z bK D bF cv J bb g bk v M y C bj E bd A i z i v bt I cM J bZ d B w bz g d o L bC g m C p q I c b r ca r N cs bg bG I C bc g m k i H cw cF cl O d K s bt B bd bP cl t I P bZ cE bj bQ A d O bi L R bb bi x bu K cz dj cl bZ bx cf cZ bY W Y d N R cS B p n X E c a g r c bf V bP bK bt bB cb bi c L bd bI R K s W bA O a bv S cg bL bg bE y B cs P P bj bd ci M V bE br k bH be bl g O Y a n br bl ba bT bD Y bz bi x F bJ S Z br A p cu bh by bA cu bB X bm N bE bq cJ da bU ci M ba Q G cn ch A cc D i m v o ba cE df bw x cD cJ cn da cd dm db bG cU bs bE x bq K s A bu bG A x bI u bt br u S cq cC dd bQ cp cq R bT cJ bP ch eZ cC cc V cz cq x s co cv bD bB db D bm Y bj cb cc O A bc bh D x bu Y s bJ bE bO O B P e x m C m bb x u cO bZ B bO o g I bh bl ba Z T B N bS bo bg F bu X bd E bz U bs bA bv bE q C bL bj cF bn R cy dl cN dF bf ce T cn cq V A F Z cu z cc A bT D U a o ba be M b be p bj bg br u P V z bD Z bz R bU cp bG bz bZ ca bk cI bw bF cn ba p H bl ck P w bz cc cm bA V ca bb cf bD bE x Z C w H x z C Y o cB U ca bR cM bX bv bE bg E V S J i w Z U cc bK C a H bq x C D bJ k bh f Z q bd bt Y R by k i K t cx S bv cf G S bd cd R z bi bB O bf cf be by cw bb cn cm ct co be t bd bI V bi bk F P bC Z m S F bN cq P I bK cb bA bf B bE bU bB bo f bg S ch m bd B A D S bZ V c bb T bN n bD n bo N i e bd bw bt o N C A P bY c i x bm H T y W v m g q A z A bk S cd p bY K G bE G A bw bu bf bu bz bA X bl P q k w j be bR cq de cO A cM dc bQ t bs bd bb bz Q be bH be h a bc ba br bu bA b bB cg bC j q a C bv bt cc Q cN B bn x H be bH K O br e v x br T cn G W G bl d V bo U bz bJ a bt g i bc bs s bf bv X cN bh by cC A cn cD O cd bI M bF bE bl bb cv K bg bj q cs W Z B t S bk T A G -1 bB cP cK cN cg cO dd bE cD bD dg cL D by bK cE Q bs K bq bS bC bP bG bB bx bY bx bC J -1 bg bL J cv bJ Z D bw ch bp bC cv cg cd bJ T bR s s s K bp ca cI bm x cl cg bc cr br bR ci cg bn bQ br B bz bd bC bB ck bN cd bp cm co ci cB co S bG cJ bq X bh bQ de cM cC eF bH X cb bG br bp bG bm bM cr K bk df L eT cs cF bQ bp bE bh bU cE dk cU eG en dW dq dg cT dh 0 dg bd cT cA cb dv bV m br cO cR bE cx be u g bd z bk G K bG cj F bh bo u bv bt cu bI bq cr cD cC eE cp bP bL bb cA bQ bT cy x bJ cc be bp co cY by bp bS ca cy ce dn Z bJ cm bJ bo be by fr cB bQ bt dZ do bq fc dO di dt dj eO cS ep dy ev dz dX dr el dk dE dl dm cp cG bp cY bP ch dn cu co cW do dI cV dD cK ch dp bU ds cj bX I bt bD bH -1 bq bt cS bf dq J cZ cK cd cZ ee cd dA dV dp dP dw cR eB dr ds dC cD bn dJ cg cu s K cO cd dt cy bL dk dd cF co eC du L dd dv cK cq cA bJ cR bC bB bD cy co cs bM cE dN dw eY ds dj do dB dH dx eA dy fN fh dz fH dT fL dA dK fb dB cZ ce N cx cJ bW bT -1 Z p bK ba bl cO u bN bT cQ cl cs cq cf t ct dq cQ ca dC cS bS bI cq cp dB dt dD cO cj dE cF dn cK cV cF ch eg eN cE df cv dh dF dG df dl dq eh dG dU dc er fy ea dY fo gu eq gL dp dL dH dI dr dM cD cf ch cF cM bA cw bK bz cD dB cj dB dR dJ dK ei et dL fd dM dN dH dO dt eu dr dv dQ eb cH ek fq dD fk bJ bi bG bs X bR P bL bL cb cL Z N bm bD U bu K bT cg Q x bn x D d v cd cM by bF cb be bG dP cI bW du dg dx cv dP dv cy cR ck J P P cb bE cY cK dn dQ bq dR dO dx cx dS dT dU dV eV ed ec ef dW fl dX fD dY eo dT fv dQ dG fj dZ ea cy eb em dA dS dc fW ec es eK ed cM eR ee ef eg dr eh ei 0 dl dz dh ej ek el ek cW 0 ed fC dU em cB cW en 1 fm eo cx ch fw do ek eD dg dZ dg ep en fK dD ed dW eJ ew eh cM do eq dm er es cD eg et eu dE ek dq ev dm du dX ew dm ec dZ ey bQ cT ex ev du dv em cs ez gl es eP eM en dY 1 ey bG fV dl ey ez fi dv ez dg eI eA dO ed bV dB du cR cY eB dd dQ eC eQ dx dv eD eE dj cJ cP dJ eF bX cw eG da eH eG dH eH ej eL eI fJ em eJ eK dL cf dl en en en ec 1 dn dh en dl dP ft ep dD cY en eL eM eN fF eO en dW es eU cp dc ez ed ei eq el en en dl eH en en dt en em eH ei eP en eQ eR eG dl fx ey dL cU er dl cC eR dt ez er cp ck ew cU eB eS bX dL eT eH eH dV dl ei eU cT dc en ff fs eC df dl dl cT da da gs cV eH dA eH dS eV bM en bJ dH eG fX en eW eP da fa eL eW er eW dN eX cS eF ew 0 el eX eY eo dD 0 dq et cu gb fg eT dI dl ci de dX da dZ dJ bO eZ dI dj dF fa ep cJ eo eu eu dp dg bN er cY dT du cF dp cu cp eT eC dd fb cC bP dK cH eB eu cP fA cC dv eu dv dZ cT dm eW fc es fe er ek gA 0 go fd fe dp dO eK dF dR cW dD dL do dC dD ff cK dB fd em dk fn cu dx eG dc dH cU fg 0 eW dR eo eP dA fh fi dN cp ce bo cQ du cL de fj fk dA fl do eR cV eX er eZ ct cu dZ dl dY cr dB em fO eZ eD en dj eN en eZ fk eG cS cA s bO eZ dD cY fp eS ck dM dM ej cg eQ en en da eF dB cZ eP dl dF fm dW cV dG em dj cM eP eN eW eF eE fh eT fn eo dL eO fo em eZ fp dL fg eD bV bM cO fc fe bk dl cK dj cr fq bX dC en fr dX eu dZ cL cc dV da eB cO dc bf dW bW da cE ee dR dW ds cz dZ eB eW bG cM eD cr dg er fs by dN eD bR bJ dd cK cz dr eF dv eG da bn dg bO bm ci cd fS fg fc cJ fu ci dy dV dg cN fE bV fb dH en cx dl cj gh ce cO bM cH ep eF bX dg bG bo cC eI cO -1 bR cj bb cA cy ek ex dw dA de dm cD cI ex ek em cU eZ cV dv cT bT df fe cp cM eF eW eG cJ cT cw dX cu bR cM fb bE cv cf dW cy dD dV cM dZ dl dP cG cU do eV cx cN el ft fe eZ dj fB bN cI cC cS eV dZ -1 cR dj cp bP bc fu cw bV bM cV dq cN cD fq dZ eB dR dj bT ef de ew eF dj eD fz dt x ee bJ eG fv fm dD cS cN cO cw 0 ee cw fh df cD ec bV eZ dc dj et s cR eW ch eW bo dw by bR da cH bs dx ew db fw eF bJ cO cP by eO du cY em dl cZ bZ dD fj fg fr et fx ev da eB cr cG cD cC db cq bx cU cH eQ dl dX bp ci ea bk cz ci cN fe dv eQ ew db fv ei bM eO fm bi dL dm cD db fw dv bK bn cZ cF cT dh dF bV bF cJ bx ce cG ck en dD dg cW cp dB bM cw dd ce bm cm G co cw bq bh O ck cz cj bU cl es bR eE eZ cw dh eD fb eU db dm cq eF cT di br cQ cH cy bR cn eC cN cs eE df cV di cF cU cx cE cq ch co cD cM ee dR cZ di en en dg do bY ew cf ep cD em dZ J s cF ek dC cZ cS cH cw cF cJ fh ea fn dn cE eT bC bE cA cb cG bK cZ cq bp cA eS dt du cu N bL bK dO dl cO eQ ce fk cI bf bU cY fg cK cs eE dw cA cO bL dD dx do fe eX cR cF dL dX eX eX eS dX cq cR dz fq ds dr ee fq eZ dx es cA cr ci ey cD fd dx cS fr cg cS er dS dn eB cp cd cx dA ej cA ev cV dj eX dG dA fy fx eC cM bn bD cL ei cz ep ci cj bR bs cc cp bc bX dX de t bq Y bM ch dP dU en dp eZ cM bj bn cl bx L X eT cv db cA cV dO dd dc ej dA fn dk eC fn eV eW dl bP bM dk dn cq bs cN dk dZ bQ dM dn bo x eE dD Z cx cz ct et dN bI cJ bO bQ by dn ek dT fz dk dB bP fk fj bs cx cF cD cD fb dJ fq eO cy de cP bm bU bu dt bO bD bf fr dx dc bZ ca br bj cb bH v bP cB bj bF k bs dh cN dL cC S cR bX ex cK eS fk cT cp cj bO cR da bk cB bX dq by eO eD fj ek cK da dk cC cT bJ br bN bZ co bg bq cx du co dW dL em fg di cr bI ch ck cA de fr dO bX ci cK cU bT cK bu cL ek bU bo ds cl bp bm cI bq cL K cw br eS dh ck bW dt cm bl Y cN di bO cV di dp dj cD cH cj cw bU cJ fq fG dn dh cE cJ cS ck cz bj cq cR cN ch cC bK bV cO ex cS cd bp bB cf ej eC dq eS cw bL eO bX cw ci bp bK dh cH dP cE cL eE dC eG cW bf cc cC u bc Z bD Y bB bo di cN cO cq eF cc bq dA bh ci bk s dh dJ cL -1 G di ew gg eW dz cG cr d ca bc bU U cm bW s cA cf cN K cv bG cK cj do dQ cv cs cl dO ca cy dL cj bs cY dQ dQ cL eS X cD cO bN cs cK dh bz bG K dn cg cV dL fA dA cy dr dg eS dH dD bF cM cg bH bC cK dd fB eU bO cg S cO cM fC eo ex ck bi dB da bM ci cW cf bD cb cl bT dq eQ eS dh eL dA cf cQ bQ cN cF eR fD fA dd fI eZ Q J dV cP bU cf cN eB ci cq cN bX dP eR dj cv cf eF ds eQ dQ -1 cg ct dm ew dH dY dl bV ce cM fc dz dZ cp du cf bX fj dl eZ du di ex cN cu cY ct fq em ey cx cp F bu bg bf bp bT 0 cD cr by cn cN bS cD cT fr dr cM bU bK bK bX cU dL eR dg fj dj cu cD cC ch ce ce cl bk dk cI dv 0 cf eE cP bo bX bI eE do fu df cE bT ct dh dp eO dg dW df dP ce dg cm ci dt dR eH dz ds dA Y br dJ ew eT bH fe ds cV eG bQ cG di bQ do dt dj bx dk cM df cC eC fb cr bq bf eF ds cS et dD dC dg bU eC eB cR cF cw bT cE cJ bC cZ bc ce bN cI cN S bd bh bu cb cB cB eZ bS bj bi bP cT ex K cd cb ba cF bN cE cs bj cq M u cN bw ce bx bA bm br bF bB bp bQ cR M br W cg cu bn cv cJ by cx cl bE bn S m bu bc bA dh cx C co bB cv cZ dW cM fd bH cE bx bp cO cf cr cO cn di bx dh bg bp bk B cB bS N cs cm bL dB fk eF bq bG cl ck bt bJ cq ce eC dh cG bV bd N dv bY bI dX cf bw bI bV bT ce fr cT cY bL cg fP ek di bg u bt eB cC bU dj ck dA bh cz bU bE cO cr bs bR fr cW cy cf bM bR cP dx cL by cF cs cI cT da ce cy cD cf cM u cb cI cg bG cK bR eQ dC eo cV dc ek cF fm O ce ek bO eU cp cu bP cR bC cr bL do eC dh bk ce bc bL -1 cR R bs bD cZ I bv cW cf bm J cD cx dn N cb cb dn da eo em fk dU ej cE ch di cZ eW ce cy cP cy cT ct cq dD bK Z x eE by bg cr de X bx bK bJ dc cN cN fk bS -1 dj dq fE cw 0 dV cU cS fi eg cO 0 bX ds dK eJ cA cu cg dh bW cJ cE 0 fj bc dP db cB dQ ff cY dM ev df do dA fF eq eg dc dV dB ej fT bC cw dz dU ee fG fs dz dW cU dc dD bX dO fm eW dH dE eQ fj dh cH dv cZ em dQ dq cT dA dB bh dd eB dg ga gi fA dQ fH fg -1 fq cz eC er cu cm bj bE bH eo df fE fq dF eT eG dA fz cQ cx co cs cQ -1 dZ de cT fg fi cI cJ dO ce dn dn dl ev bx eE cL cS eX dX cY fn fI dG dQ de eS cz eJ ei cR cA cx cs eO dJ cy fd dn cS fk bY ep dR dZ fB dx fk dU cP dB ea ct fm cu cJ cI cg ct eS cw s bB dc ex co dB cJ bG bs bx cR cs dv bX eu cf eF dV dC bz dv dh cB bo by dD fe em cP dg ef fe ey fv bE dZ cH cO ch bh cs bU by cG cj dA cT cu eB cc bp ct cR ch cj dl eo co dJ dq dC dj bZ dN cS dk cS cr bH cE bq F cL cN dv fv ds cG cE dm fj db cK cR cN dm cm cN cL bZ de bB cP cK fJ cL fe ck ds cm dn dZ bT cb s do dh bn cp cd cR di dn fk dZ dH dJ eO ex ep cQ em cT dX dz cC cP fj cr ec fl fh fH er df cM da cK cO ca eZ bE cp co K T bw bs fg dg dV cH cj de bR cy bd F dh bq dT eE dO dw dI fK cu dM cA dA dW cQ cT dT fj db cs cP bN cM cl cp dh ej fr cQ eH er dD dP dd cM ev fI gJ dk dx fh dp ff dI dB do cA dp dJ du bg bV eu ci N de bR cC gc eT eZ dy dj cZ eF fi cC cU er dr fk fd eb es dr dI dS fB dO ds db cV cv bU eW dH dq dj dW ep cs eX ds cT dv dZ fM dC dX eF cS ea eF fi dO 1 eR fL fA dQ fq dJ cY dZ cC cZ dl eb eG fn eL cQ eC dF cZ cu cp di cD ey fM eP em ew dP cC 0 eR ey eJ eX fw dC eZ cC dX dW 0 eW 0 dp dp fi et dQ fN do 0 ea fd dp fr cW dB eQ dP dW cU -1 eZ bH cB cd eW ev dc cK ef gk eU eK ee bM dg eu cG cp cP 0 dq cw cS bw bp D bp bw O bB cO bw dh J bL bO cL eE cA fk eF eg dX dv eC bX cx dP dg dO dL de dw cB ev eB cm cG ev da -1 dp cp cY ev dd bM cm bN bD bv u bO cJ bU cW eB dS bq cs cZ cP cG cp eB bD cq bP bI bD bd cU J cB bF cm bV ch cj bO dh dw cl cE cx cl bn bp bo bH cg bn bb cP da cD ep ch dB ci dA bo cM db dr ce cU cd bD G F X bL cY bh bJ U bt bq bK cK dc cO bV dw ea dw dr dh cc cQ dD eT fs dh dh dr bX bm Z bt bz I P T bp bh bV bW fi dq eB de eC ca Q br d J S cl cc u Q bZ A K bi m T y q bw R z W bB da cr bp W d S cy bP p I B F bd w a w e c e bz P q v E p b J dd J F bu bY u bH Z V ba d X Q O h i G D O G Q bv t E cv O bC a D cm bu s bM bH ct bd bH by N bk D T D k bh ba z bm bR J o g T t bD ba x q k q G L p E bj o b o d y bR ba ba cB u bp cx cd br bH cl Z L c F u t S ca bI fr s D bI bs U x z bP bA bD t V be V P bz V bb D H bP bt bB cC bi bD bE bn cO bM bJ A bu s T ch O bH cd O w R V ch bZ B O cq bh O V L ch R bi V G L m d bg cd bn cg cB G E bw bf ct R B bm F G bm D x D C t Y bs bK ci cr cv t O cg cM bI cx cm cb U bG bl bc -1 J n o U P e d t X dP bi cb P V cc cY bM bE bA bS bf Q cL cx cZ bj ch I I bu eB bV bS bM O bj U G bl B bN G O B q v bh bN z H q d o ba cl G x cd Y X cn M bb bm bj bu bc fr M be C bw x x L cF bs by bm cq Z cb bO P bW bB bE cf cU eK dE dH dv da dj bG br cg bi fr bN ci cq O ca bl dc bh bq cf ca bu ch bI bL bq cq bZ F bD cY bA cq t H J n bP by H cP n L V cx cb bs bm D dd Z F cd Q bl cc bD F bJ cF cf dV df cL bR ck cQ A cY cM ct u dZ dv cr ch cd da bp bg cu cF cE cv dD bh bQ dA co eS cR bX ca bf cl bQ cn cO bi bJ cf bW eG bt bX bP bK bW ev bV cO cO dd bV bn bf bx bN dP cx by cv di cq dB cs dx cQ cA bW bY cx bB fe eX fI ff cN fw dF cF cx eF cH cM dA gO cq cl cB cQ bJ ek bK cF ce cf cn bL ck bi eu bi cf cB bA cP ci u bZ cj bx dF fi cZ bE cQ br bQ df cs bQ cY dt eE cF cB -1 Z du cS dR fK dV fM dr cT dl cs dm ef dC es es dD cE dy fA cA dg eY ct es dv ep dH dy ck cH cQ cw fh fJ fq dA dO cS cI bX ev dm cb dc dn cy cp bC dp cG cF ep dP cz ea dH cU fj ew dW da fm dq cW cW dr eE cD bN cg cH bP bk bk O cz cF bV bj br bj bb n bm bu cu bJ ci bM cy dj do fv dc dL dz dR gm dm eG dj fO 0 dJ dc eE cY da cp cS dL cP cC cL fi dw eW bM dL ev cO cW cA dp ee bV cu cf cU dl bX bn du cK cg by bo ca bz t k X bP bi a H L P A Z g h bc d bb S be c I Q i bB Z B s cp S L cf Y p ba bZ cv cC bx I be I ca bF bQ bo j bk Y V q t bK bL bA G F bS ba -1 m D x G A bd bj p bh X m bl P J O U q H B a M i d r b I I J a be bA ck cq bp F cb cy bw bT ee eN dA dL di cq bQ br bk bA cs bj j V br bF p D t g B e bl be be e bo Y bf cm O cH bG O bP cs G bA T I V Y bB cO V S bu cq k bu cm cZ bO cw cz k bm g O ba bz bm K bo bD bH C V F bg bs cm bk by cR cE bh bF eK dz ex eX cA bc L K ca W bs T Z N D y b bl e cc R X P bH a h O bZ cl cd cc db bk X bK bn I U i bv cZ de K cI bF cZ cy bE bR eu eO bM fb cQ bX cG cC bJ cn eE ej el cZ ck cf F cp dS dZ cy co fv fv dC dZ fp cf ei 1 du dI cD dJ cZ ec eC dD cZ cZ cT Z bO bG cd bO et dF bX cu cr bM cN dw cJ dF cr dk cs cB eF x cv cb bf cA eO cp cP bg cj dF bI bQ bn bo cZ dc dh dH cx cx cP F cF bZ cV ce cr cs bU cl cz cc bN s v eE dR cQ cS dp di de ec fU dh cV fk cm dh ce bE dd ds fR ec dr cJ dh ck cU db cT dg cB bO ds dS dd fQ dU bx fP ep cC fi dd dl cz bS cH cE bh dj eQ cf di fJ dc eW bx eK eu cr bB eu bh W cH cU cF bK bY cM cu da dC dw cd eF dm cb bv x dQ cT cu dd cc dP ev bM dX dn eN dn bh cz cq dt fH cD cm dR cS eG gf eO dY dA fQ eG fF dc fd ev db bX cm eO dr gS fn dM fE fg el eG eI dr cQ dI dJ eQ fj cy cC di bO eT dw cA ek et cT cV cW ff dS eX dW dW ej dJ fu em dA dH fC dg dZ ex bn ct cB dL cC dg eW eC do da ex Y cY bM dA di dt bN du em dv er eB dq cG ct cI cK dS fg 0 dl fg dt bN cN cg bh cu cD dH fj fv dr fK ea ds ds ci bQ bO cJ dt eE cp cY cO eF bV eF cj db dC de bQ cO cx dm eQ bO cU ci bG cJ cL dH dP ds fi -1 dj R cR cA fg dY 0 cS cc cg dc dF di fm cy de cS eP dC dD db dM da ff fe dY eS bJ dJ es de da cN ff eS et dG ew fG fZ eu fR fq fr ea cp cV fi dh dD bR fj ej dL cK fS cK cF cQ bM dt cv co dh cT dT et et el fg fb eU fY fo cy fJ fT fc ds eI fj bK dp bW eB fr cP bU cf fJ bO ex cY dm ce eu dl dK eX dn dP fv ef du eo df eK bI dH ek fu dS cp cM eE dw dK dK fb er ec fL fK eC eg dN ec es fj du ek cj do cW fp ew fU ei el cW dP eX fv fq fu ej eH fV dS fW fn dp dp dq dr dt eD cU fq dg cn fH eZ ea fq df do dw cQ dw dc eY ff eS es dI eN eB ed fm fG eg dk eO cW eK dV eO fm eD dS cI dT dd ef bV dO ea dH cA cr cQ eC cQ dX dH ge dQ er ei eP ec et fi dm bU dt dr fp fr cj dw cu ev fo fU dk eU ds ek cQ ee eG df dO ec cY dG eX ch dJ dy fo fX ed ea dF fY fe fA dE dt ec dK gR cL eZ dI gD dO ej eT el eQ dh fo fT gd dx fr bN bO cB ci cF el dm dX ej ek eZ cq cM eT fv bM dc en en dF ec fP cW dQ dL dO ep fP ea di dc dI 0 dX eQ ci eS da dD cZ dE ek gy fm gn dP X cD cw ex bX cp cG fv cP dd cI ff bu eB dO eI fJ dk eg ff eI ds fb fc dP eT co ct bR ej fn cW eS eA eU fL cD eo cS cV cT cD bQ dP dU cQ em fq fx fe dm dX fd db dR cD 0 fA dU fV eU ej fZ gB dd ek eZ ga dk es ep cY eD dD bK eU dT dL cS cD bC eE gb dq cA fi gc fL fw 0 db bL dY dq fg dt dP cu dx cU dl fD eF de eQ dU cw dk eS ek eG eg dY fh dS gd dt dn cN cu cK ep eT dV cn bI dD dP fP fa dA el eQ ep cT df gc gc ee eI fw eD cS cC bX bW ev dJ fg cW eZ eX et eu dQ cA eD eC eW fU dh dO dF dk dv fm eK dA eJ 0 ef cI cz gb cu ev fe eX ef eD fA ef fv dQ ds ge dN fU fl fk ex fd gY dX eh dd dH eG cs bU s dh cJ cv cT do dj dx dQ gb fD fm co fL dO dl F cd cC dU fi fD eO eL dn ea fq fM eP dA ep gf em db eJ fM di es dB dT bT cR cN cA ew cr cp cH cU fu eE et dF fi cK cH dc fq eS dT bG df cE en dx dA eu eR dn fh eF cx bJ dD du bU bA bL dD eU dw fb dl dW gf cT dr dc en dD dR ei dg dl dX cN dC cQ ec cS ep cC dj dp cu cK dD dK dc dd ek fC cT cA bx cy cH bf bJ bB fg cr cQ ee dh fg du dp eQ dO dc cT ct cC eO eY dz em bx eQ eK dr eN dX dH db dw dV eb cM cL cy eS ff fv cC bJ eT dx ex S eS dK fr eE eE cI eh s dt bX eA bU fm ev bh cq bo u cj M ca eu ex bR bQ dP dv dv dw dE gp dd bM eC bV dZ cy bF dK eG fI eK dX du cp ep ej eZ dC bx db cJ cm cr s dM eg eS fi bA cI cd cA dc fh fU fC gq ea cU dQ eI em eZ dn do dL cg ex cu cB fc ex bG cQ cV 1 dl bm fm cA cQ bV eV eQ eS gU gg dn ea fk fe cQ dX cI ev 0 ex dI bY em dX dT cj cM dl dt dX df cu ce 0 cE eR ch cA dq dS cx dX dn de gh br eU 1 et bN br bQ -1 cW cg eY fw eu bk cS dj dJ ex bG bq dn dg bB ci cv ca dB es eB cz ca ck cK dR dN fz fF er cC gc dr dV cH dr bV bL J fv cZ dq ee fw dc bS eo dB dg di eG fj cz cR fr fe dx bn bl cu bo ct cG U ew dy cj dV cJ cn ce fe er ee bI eW bG dz dl ex dV dT ef cT eX fs ew fp ek ct cM cT dC dd bU dV df dl er bM eQ ew gc fA dj en dn cS fe cn cR cz bP N bq bd y bP z bT bY Y bY bG bs cz ev eG ci bw cs by bC co cL cf bp et cI cP ex bW eC fI cH fj dm cJ cC G bG bJ bj bY dd fw bL dP dW bM eS dV dh dx bJ fj cG bT cP cY dn fE dR eU fd dX eg eD eN el ck bF bL bW eB ec bs dl ec ds fm eZ dp ci ea dx cz bh cw bE cO eu gj bV dQ fA du bh bx ee dD dz eZ bx bK dz ef dJ eA gi ct du cq dF cj db bk bT cP cy bT bn bF br cp dR cU cy ej eg dK cR cb bS bq cp bX dQ bq cD ev ea fU de dI eo gj eY cC dF ek fn dl eI ee ev cr df ei cz fv cI fx fv dQ dh dk eC 0 dO eU ew fJ dz dA bx bJ cO eS dk bG cl cg bT L cY cU cS bY eD dL cy cb N cP bK cr bJ bR cR ex eA eL da cO ej fp et ea eE dW cq dg U cd ef bW ck eq co bb cK cS eC ct bO cd eB bC bL cg do bk cs eG ej bo cG cE ce cH dd eG dr et cg bG cC dw dk eY dL eF fg eG fJ eJ cV eu fN ey ex fn en dH fD eG fq cu eA ge cW dV ea cM fh bK cA cY bz ca bf dt ce ed dq dg da cx cU bM K N cl cj bo dt du eE dn fr eZ ga bM cc eB cl di fU cw cT S bk ea fr dq bR cH cL dL cq eE cp bI cV cU fg dn cM cZ cK fm cD dg eF fk cO cr cE fr cN bO cW cH ci cv ct cJ cw eL cZ cq cf cr bJ cS bn er ch cQ ei dC -1 eN eD dp gk fA eQ cm ck bp dM do dR s bL fj 0 fv fi bX bF S cn dF cs bY cJ cD cy cg cv dp eD cI cW du ev cG dq fq de bq bI U fv ce eF bW eJ cG cy ce bh R cx dd cU dF cw en ew dr ec co by cw da bQ 0 dM eD dE cE eD dD ei da eG fi eZ bq de ek dC ee du ey de cH ec dh dh bu cV db dW dg eF cJ cp cM bQ bK dq eg do fg cJ bq cJ ef fC eK cQ dv fz fj cM bc fP dD cc dP cV cw cE fr fj cw df dA dP dt fP fb eX fL ek ev eZ eT bC dZ cf dg bp bu eE dm dv dB bD cb bk cn bR W cl cl cr br bi bT eK cc cL dl fE bT cY bh eX dj eO dh df da dA em eJ gr dO cV df ee bN bL bV cI df dc dx dD dD fb ep dv dS do fM dC cQ dz bT dt cV eB cQ cU cp dd dt dd eU fb cL dJ dg eW bq ct bU cI dn bV cB cA X ct ch cJ dL cM et dH de gd ew dk 0 eK dR dB cu bN dq bE dz fq cM cn bR ew dv fD dO ep ge dL gc gl eo gv fD gc eY dr fg cA bU cF bC cf di dl bQ fj fj eG eQ ek cV da bM dF eZ cF bF cO bH bL eW -1 cq fq dI dR fp eI dQ dD bR fe eu cv bl bq ct dz -1 dJ cQ eE bQ dh cM bL cG fb eE db dx fi fq cj fj cg cJ cs bs cy fk dQ gm dN dh cF dH cU eC gg ey dx cA cA dk eW fi dZ fo cS ej eC eU eb eC cz bC ev cs cZ cA cz bO cK cc cF cn bM bq dn es dd dk ey ek eU dD do eX bX dB dq fg fm ej dP gc es bh -1 dq gj dq cD dk cI bW cD dQ dr dx bD cl dd cz dM cH dv cC es cL gn eX gm eQ dV df cq eK fj cy ce cM ec dT el ep de dq eu dI cG dx dI cS dJ bx dw do dp cW bO cs dl gg fn fE fj dn co Z cU bK eG bx dT fs ep di dg dB bY dF cH dc cU cR dC eF ch cR cz dP x eZ cH bM cg dV dq fC eo de cJ dO dx cP dz cL bn co ct bQ cI ch ej ey dX eX fZ dt ex eS cp dP eO dN cz dx fw eO de cA do cS dc cf eA eT dU dO er fz dF dM cz eF bD S bL fk cm bR cv cd cU cG cu cG cW eN bI ds bU dt dt ep eI cM et fj bo dy db cQ bY dm bW du bz cl cx cH fF bp bO di by dJ eC cU dj dJ cR bv x dt ec ch eW cr dj cf cH ec ee fU cp cC dK ea bW fk dL dz eW cS ec dA en cu cm ck de fk bO eE cf cq dA cY bZ ct cE ck eo cZ cJ dv dp ce ch ch eF cj cF ct bx 0 cO cA dV fg di dE cI cJ cr cr bn cB bc Z bD bx dV dh cd cx ci cc ci cq di dp dp bQ di cw di dp eu dD eS cg cs ex co dg bG cp cV fv eg cG dL ci cT ds fh db cI ey bL du dM dw dZ fh ek cP de bh cS eo eT dI eZ eO bs bE dd cC dh cI dF ep fb dB ck fe dZ en ec dr ft dw dH cZ ce er dH dr dA ep fD dc dl eC eS cW fD dZ bF ed ei fm bL bR bQ bX gb bE cL bP ch cV fr dX ds eP eL ec dv cT fq de eS dr dB bp bP bI bf F bZ cI db dr fv dZ fj cY cg cV dc fg eD cF dS dM fP ei dc eX dn dB cY eF s cB dX fi fI do cL de cG cx bH ce bx dj fm cL cj eW cU ek dd de cI u bG 0 cd bI bO dy dq ej co cv cr ca bh by cz bQ bx bM by cM bA bC eC cO eo ex eF fr bS dc cp cN bQ eB fq de dd dR ef do bk eB bW cL cT cr co bL cU bc dl fk cu bL bY bd by bq -1 br bG bV eZ eT dV -1 cQ bX cg ce fE gn df ew co X bS bH cE cZ da bP by bA bZ X dh do bZ dx da eZ dz cN cb co ck ch bO ef fm X bK bT fr dZ ex fq bn eF dB dl bV cT cP s ck cL ex x ci bC di bK cN dV dc dm dg fH bS dB dk cO eC cO ew dl cj fk cB -1 cq fv cD G fk ey dg bw cK cE ev bL ee cd bY ee eL cJ fK cz dL bZ dd dW cm dk da db cx db dg fe cx ci co dm bW dg eN ev bM cH eu cp eO cl bO df dw dx fU cu bN bJ cg eE dg fm dr bT bW bZ cd bB dn s bh S fq ef ex cM dB by cd bt F cC bs fv bX cS fj cp bM dm bU em cZ cJ cB ey eC dM fe ei df df cZ dB bV du fe bP bZ cV bL z cV bE bC cS bl ct eF fj ew bQ eS dl cs bR cD dt bg cf cH s cm cj cD bo cs dG ff cY fg dJ dj bV bQ bg bs cf cg bE dD ee dh bF cv cr co bW ck fe fw di bU cV cJ dk ey bO ca bM cF fh cY ep bF cZ bh br cf dn bE bY cW cy bq J bU bQ cP de dl cA cs bV ce bQ cH bD ec eT do s cZ eG bx cp cN cZ dJ eO cV dB dm cm ch cg bR cf cS Q bC bi bw eE cP bY ct bq bo cG eZ di dW ex bX cm bi eT ct db dZ dY do dU de dl dj es ex dg do ci ch ck cm bN cZ cP ch cU eF cG ev cB cB bV dA cK cn di bp bQ bG cz fr cO cq dh cD dL ep ek ct bc cY cU eO fm fk en eQ de bp br bC eZ ee dP cZ do cK cf cK dZ bI cQ bN dc bB et fg fj dC cj ev dn eF fw cL dj dp du ep ex bX cf eZ cg cG bZ bL bX cN cv cV fC eE eP de bK cr ci bC cO bV X cZ cY dV cK cc eS by bV bC cx cF bx eF ci dD bm cN fv bh cH dq cR cL cx df cQ bT bx s fm dq fi db cK bJ J cZ fV bt bV bZ bL eO dJ bo bU fe dB eD cz cn ev da dY fe bp Y N cB dB dZ cC cy cI bx bP dn ek dA bQ bU dd cf cn cu eB dd cv dd cP dr dJ dA em ds bU dj de eu ea cA dq eS fK dJ ce bc ds cf cR dJ dt dH cw by eZ dV cQ cH ey fn fr fr bW dd fu dd bY bY co dL dx cY ca cc fP fv cQ ex cR dr di eB er cC dU bK fq cZ bG bA cw bP fj cG ct dc du dg bR bU cu cw cf er cH Z cN cl cw cz bX eE df dw fi de cL bF dr cy ct cu dw cd dn cg bV ci eS cW dn cf eS cS dh ex bh cZ bm bL dr cc cq du dA bG df bC ew db cO cA ed cA ek cw gc fs eT eB cD dB en dq es eF cJ dV cN bM dV bR cl Z cG fv cy bI fg bV bQ cB du eS bc df dF do cO ee cU df eS cH cC ck cC cS co bN ce dh cK fr dr dt dd bR dv fE ep dF dD bg du fk eR bB dz ex bX dn eW cM cI cv cU eu dA cM bL ee cS bW fb eF dp fu bO cZ cz P bk cD fe eW fj cf fD eC cK dr fj eC dW ds cq cG dj cM de bT di dv cN cw cz cL db cI du bZ bO X K cx cF cw fm eZ cZ fg cu db cC fk fk eF cZ bI ca bP db bX fk dy cL bL bo ce dt em cx dh dB cO bY cS dU dH ee cU dC cl eS eu cE Q bN bR dn ce bH bR 0 cF cr cf Z cS cI cr eW bJ cZ bC cO cS cI cM bN dg Z bX cg dX fg cr bq eE dS cD db bL bD bX cA fk fe eu cN cT cH bJ bV cr bL bW dO J Y dL bG cF cY ci dj bx cn cy en fE ck cB bT bs df bC eZ 0 bc bo dt db bk cH eS cS cT bT de dA ck X -1 ch bK ch ds dv cF bU cM bX bZ bj cx cO bV bP u eZ bf bw cn cu eE bT cZ dF fb bt db cM cE df bq cm cj bI db cI cJ bn J cL bK J cy Y cR cq eu ej cd ch du cc bN cd bK s cd ck bY cl bo cw eW cL bc bq bm cO cW cB cM cD cr bH bn cU V bu cP cG cr dZ ex dL ex da Y cM df eW fi dL dc cI bi cb dO eC bq dr cV cI fg ce bV dg dD dn cV cK cs cF bZ bJ cH eZ ck cQ bX dn cy ce I bz bV bE 0 bo db dD X da cR bJ cc dJ bn bQ by bG bn cQ bq x X cq db bv Q bp u cB h H J cn bD bU cq X bx cK bP bT cf et cE cD dj dn bL cE do bD bM bF cb cx bx S bw L cy bW eB bx P L bO bY cf cR Z bR cT bH bg bR bD V F bJ t bz bQ df bI bp y bz br bj bF be ci bu ba F K ci x bC bV bz ch cd bG cq bg E K bt bH bH cc ba x E cq cr cO bU cv bB dg bJ by bN bX cF co eC ci cD bN Z bU bH bh bb cu bn bt J cs bU bP bo dZ bF Q dV dP bW da cI cr cy cm cf bx cb cL cx bd ck bV S Z cl R bq bz cL cf cM bW R ca ds cB cv bN bU s Z bC bQ D u bB eF ci cE de bS B cd E U bE Z bi bl O G cZ bL bw bm cJ ev n cs S cL bk bA eS cN cM bs by cI co cf bH bS bX cN cK bQ cS bU bC eW ct ej cH dd eI bO co eW cf cx cA dF cT bR ck bS bd bY cq cd by bW cc cB z cA bz bF bw t bC cN bY cU bZ N bc ct cs bg bj bI R cv cJ ee bo eV cf cs dx cZ fr bX df cG eT bg ce bU dB bK cZ cw K bs bW by cD eB bn eF 0 H cu dv cz cP dd bf dC cO dF cH dv cD bm bG L cc de cj bG br db bl cf eT dq m bW bP ca Z cL cM ct bP cc bh ca s m w bZ s bF U A cm bK cI bY ca bA bv bz eE fm cM bf bF cG cL ck dn cM bP bn cH U cn cd co by bo bf bM bg bw K bK M V cv cJ cY bO T bu bn bZ bt bL x G Q bO bb be bg bo cR dF bM bj bp X dj A bW ej cx bI bn bX cE Y O ba bf N bP v bP p bj bT bk bg cP bg bO bD bQ u be K cg cw bi cY bm bm bZ bN cj bf bL cx co R bX ce J cK bY bt cy bw t bg bh db cW dZ bC dg fj dC dj cH cI eO cz dg bF cG dB eQ eS bU cp bQ cu J cH do dt dn ex cz dA cZ 0 cG cW cp bx ct dc dq cv by dJ s bI Y bz dJ cy ci bn bf cO cf L bE br 0 ch bS Q U cn da bf cg cI bP bO dl cT ca bU V dh cq bf cO bt cb ee 0 fw ex ck cQ cJ eu bU cH cK ca bP W bn cd cY bU bm cC bm cS bT ce bB co fm du fk cC cV dz dk F bX dZ ck bQ cl cT dl ct fL cu cp dq dD dd dm cw bt bZ cR bW cR cu dD bo da cQ cl dL N cN bT bs bc bW eS eS db bL ey eJ fP dV ex dD cP ca eF fq em dw dP bQ cT ek cI fk dk ex cF cE ce da dC cQ dK fi db dP go fg cN fE eu bK cz bs bZ dr em bF dC ek bX cN cM ep cK dj bE cC cD fm df fi cV bn cW fr fb bQ eR ex cp bq eE dt cS fc dz dn dl fv cP cf dO cU cD eT cI eB bk ev dm bt cu bP eO dP cL cy k br cN bM bw cB cC bB cS dV fz fw fq ds dJ dS eK fS go ev 1 ej ea ee cr ec eu bX cP dw cI ds eP eT eT eD cO de do cH bJ dw cw F bB dR eS dc cr bw cV cQ ct co cz fh et by eG fg dp gp dm gd bZ -1 K cR dh ew bH bG ck cJ do ej eF dk eJ ej dp cU dd eS ej bN dL dS dm eF da dM ej cT dH dg bc 0 cI da eE dC cP dD fn fE eA cj cy fk ef fi ev dF bB fU fo cr eq eT fv cp eT cz dh dz fq bv L cg bN cJ fi 0 df dD gq eg de dl fe dW fv ee cP cE fe Z ec bH cp ev dT fm ef en eg eC bC ew dt dK eW bX dq cE dB ci cz bs fR bx cb eW U fn dy fs dK gr et du 0 dx eG fv eD eP du cP bx dL dw eW eu cE bx bx fs dL eq ed fa gC eO eo do eU ej dQ dd dS gf fh fv cH eS dt dx dZ cI dw dD cZ dk eq et eF cE fr cn cL bM cE dl er eO gg cc fg em 1 ek fj fU dH dz ek da eu dz do dm fU ea fz dD fr cV ff bU cx Q fq di ex cW cs cY cE bL cQ cA fr by cc dA bL bB bI dH cH cg ep dR eo eW dv ej dp fD cu dk dW fj fb 1 ep fk eP cu gh gn ef gt fG eC bG cK dP dJ fo eT fI en fS fx dM dO eU fd dT eU dd bX eS eC fP dD fs dk do cA dV eo dr dV de fu fi dj fu dp fx dC 0 fh eW cp et cH dc dC dZ fr fv dM eV db cT bx eD ck fv dm cM ds fK eG gc gx dy dC fu dx eK eU dA en gg dE gs fc dy eI ex dx dd bb dg ct bY dQ bK dN fM fs cp dC eO bn eI dz fV eR dk bi bi bQ bO dM dz dn fo cz cd bs dl eu ct bg cg cU bR bq do dD eC bB bS bU 0 fw gc cI cL dC eJ ec dz eW dO eb dN fM gh fG es eY ea fD cE cC fp eL fU fd dT fD ep dO eT fn dS do dJ bQ fj cV dK fi fi eO cH eZ dS fk dZ db ei dJ ck cL ce cQ fi cI fw cP ee fo dj dl gg gt eq gm fI ft ge ge cV ct ch cd bp dk cS eQ bT cw eC gu fe eD dw eM ew ej dO bE dT di cS dG cJ cv du dt eE fo em eR dK ew cJ gq cW eu eO dq fO ck er ep fU dV dr fl es dW dT eG eY gw eU fn ei eh eo eu es ey eX ef fc ha dS fx ek eQ fI hj eR 0 bL bN dk gv dJ ep dM eI db cZ eH bM fi fn dr eo cG cC eF fK gF da dn cI cz Q cz dR fM Y ce dT fp dC cx cD da dE dk N v cy cL dq eC eP eo fC eH fj fS cz dM eN dj fh cU ea ey gc fM dS eV fD ec cY O cD cn da dU fH eY gv fk dH -1 fV dA fK gw dW ga fP eU bn dq bU cM bP dh dV dB dV cO 0 eU dz fu fE dK gz eT fH eC fC eN fA fA eU ei dC fb eg dy eA gx gf ec eu cs ek eB bM n cm fo cU bV eT gc fG fG el eh fC eN fk fB eu cx dX fH ed fv bL dy fQ cW cQ fH gN fm K ch dH eI eL fr dp ef fT dW cC fh eH fl gy dr em er eC bh cf fq da ev de bn do cW bp ea dn dM do bx ba da cY dh dC fj fi cy dG eD dr cF fg dc dS dC dK eH fl eU ff cO ce dV en es bJ et em eX da fg et dE ew ew ck dM 1 fa dd fi eF fz dD eA dG fc ga dT dy dj dM ch fU fm cM cP ce em cN m I ey hk fT cy eG cO eL ey en cP fa bg eD eY bV dq dU dU cF dF dx dt gx ez gl gv fO eV eN eK fz eY fA dL bm cx eP eT gz eO dH gA gB fP fG eF eJ dm bE x bL ei df eX el fp es fy gq fY 1 fA gv ds dZ bM dJ fz ev eW eq cy fs dl gt eO fb dC dM gC fx dr cr ec eq fA ge ga dY cU es fE bj dp de dV fD fb bq cW bQ eS dp cD gk cM cy fC bH h bd bc eX ee cq db bK dP dv ds dF dl cV eE fd ed eZ dC dA cD dp dL es gc fI eP fM dC fN fD gs go fr dr fI et eo dG dS fn gG dN fb da R bu eu ez fF fd eJ fd ce J cT dW eo fD eX cr cD co bo bL bw Q cr fr eQ fI el dg H bU dF 1 dl eR dJ eW bs fx gD et gg fu ds ee dT eX eX fr dy ei dw bT fg cP dP M J cY eB U cd bG fv fn fw fa eH fp fh ea da dF cN bc cx dm eG dd P w bA bK cj cW ce cr eN cp fv gk gk gE fy gE en cM fD gk 0 dO dh fl ft dK fv ef er eb dK eJ eA em de dg eW cy bK cd j dT cI fl eE bW bu bu bZ dM fR en ct bX cv U 0 eo eF dD cC bC dk ed fy fO fa fJ gF el eR bI fk dD fB dN bX fv ed dM fe gI eD gG fC dY he er eU fn fh gg gW cG cY C r bY fk ce dX eW et eS cM bG ct X bZ -1 U W dA ex cp em eN gH fi eI db eo ci ba ev eZ Y N bN ca bT u M K bO fU eG dM fG fU ea ek dm hb gg gH de bj br ch cb dC bX fm fq dv da do gk fB 2 gy eP fG en gI gF eH gw gJ fa gV eg eH eY dG gw ez gy dy gK hd eo ev bQ dg dQ dH eq el dy dq dA cP ft bP N eW dg ea dM dp bq bg bR en dR cA dO eO eT cE dk fJ gK dJ bW bV fd cV da fJ dX ci cz ft gk cV eW bF bp cP cd em bq cK eF cx fr fb eu cK bx A cH dc dK bG fg do cU B cC du bg bW bB y cG cC cf dM eU dA dj fg cY do dp cj bV eC df dl ho fG fj fl eU dG ew fw dI eO cx cQ O bW bP cH cd g I bu br dQ dO fe cV ee cm bQ gf dD cA dh fP eR dJ bN dk fj fg eu cb y u cC dQ ev cE bL cz ew do bo du dp cx L -1 cQ cm dD cI cD -1 fm dK dA bV cb K D co eZ dq ff fu cf fv fd eI dy fB eV cN S dL dh -1 bG N M I ch cq dB cC ea eP fp dk eJ gk ff eF gL eD gG cf cT eh fZ fp fx ga eK fx hx gr fP fp fR eD ey dd dl dl dj cD bz cl Z dN dw fs ct dv dk eX ep eW et ej bv bP cB bR bV cS da fm dF cw dG dl dO em de dg dD eu X cP bG bY dR ci dM ei gg dJ cQ bL bX db bn N b ca V k cZ dA dj fC du dh fA cG dd dU fv fj dN ff fv fm dg cE cU bR cT dc cT dF eg dM cI dG fi eD ck bZ dd ff fd dc dj dO es eV dA ea dq bR bI bF cQ ds bV cu cx bX eq dk fA dN dm cj er eY de bo bv bY cp eO ey dy dA do dz eO eG ex fg dO bQ F L cD bm cs cH bp -1 eK eX fM cR df cR eF dz el ej cG dJ ew gp ew dF dx cK cr da dV do eT bQ bB dn eZ cA ct fq dN fg cI eD eK gg ei eE ck bW Y fr fk bP bA bh bk bZ Y bA bL ch E K ck fg cH bx bA dh cL ex dQ dz eL ci fj cp eF bW cO dg fu el cB cn cg eZ cC ey cR dt em er dY gI ep eB cD cB cs dD dL ed hh fv fr et ef fJ bO cw dF t cw eL et eR eZ cE N bp da cP cn cp eQ fd fU eW fz dh cx cb o v l ba H j M L bX bk N G bd bq bh cx d q P N p bj bR dk ds cQ dM cA cO ct cR bS cY bW dC fi em eG eC di dM cf A Y C cC dt bN bz cB cg bU cl bF ci cJ dV ee ci cb bB db cq bU bg bB bh ct bQ cm cb cZ ct cP cy eU dx bk bu bF t cc 0 el cf dF dH eh fs ev bN dr dn eS cM bn bS Y bs cY et da bs bL bY cn dp ey eo dA dh bU bc z N dJ dl dG fh fL fv dk cV dU cP go fw dU ci U S dg bW cV ep dA eA fg cN fj fj dx dV ei eW bd cg bx bj bY bz da dt cU eS eu cK Z eE cI dv cz bO bK bp bw N F K dP cj dj fk fd eO eW da dt cu bu dW dz eY dL ct bK cs cg dA de dx by Q ev fv fA gg ep eC dg cj dq cZ dd cW cq bJ cs fk cp dB bD cj ea dL eL eV eQ dP gM ge eh eR fz fD eo fE cG cJ cL cm cN eZ bQ dh et eT dl ce cz bZ dc 0 eC fq db em cf bJ w bM eO fw dz fe cq bA cj cm cd fr bt fi bZ bX fk bC bp Y bg U cZ bT bZ L cb cJ fe fq fE bR cq cf E dp du dv eB cj cV cQ cA eW fw cE eD eW er fu es fq dp dP fm dd dX cf bX dD eD 0 ej cT cA dF cv by ce bf cs eB ew dB dj cw fg cp bX de eU eh dP da dZ bO dr ep eE cO cn eF cO dn bE dd cn cn fi dw dE dh dm dq dX ew fr dR dm gf fv el fd dd cz da bY ef fz cV cK df eO ev ev eC cL cs fq em eB gg fI dk bN em fb de bc by bs fr cN dO fK fM er fm dx cu cN eo ep dr fS dR dq gJ fh cO cy 0 cK eB dw cT cs dd eU ds eG fk eT dJ cy cA eZ dP eV ed dh dH dE 0 fO eN fu cY cI ec fE cQ da cA dQ dJ bR eO ev fw gl eb eL eu dR eE eF ew dn fM dS dN fK fA dH gc eD fR gy ep dK dS fi eA eT dT en eN eF dO ej cA ef fL fB dS er eJ gh fC fA fs eI fR gB fM et eU dF dI dP gs dI gB dE gr fT gI eL eq eK dT do cP ei fG dT fD gd dz er cI fU fx ew dI ec gn gc fZ go ew eC eH fD fa fK fG cV ep ep cW em ee dn eO cQ cd dK ev ec ge fP gz ef eP ej en eu fq fd eg dP ek fq dH 0 dM fj fY fU eO de cK eJ dC fD fE ei dq eQ fG fj fd gp fu gj eW dH fC fp hi ea cS dQ ds dR fE ek fe eR dS gP dQ eL cE dG eZ fv fm dg cA cq eq ee fD eD fR gs gQ gM es eP bh eS dq du fM eG cP fC fO fv ez hf gN fQ ff eY ec ee dc dQ cu eX eE dH fc fs dn fi cI fb fw du dj fm dq fb dk fu fh eD eO dg ci dE bU eR fz eT bX ea eD ff eN dU eo de ga eF dJ fe fs fi fZ dy bM fP fo eo gN ed gv eX go dw dN ee dA dn dC dc dl ex cT ex dt dE dV cG ey dL dX cP cD fv dt dr gm gL 0 cg eQ dh bL cj el fz gO ds dT ey gC cP dE en eO dO dU eD fg fj dy dC fG fw gk ex gj eE dr co eE cH ej cY fz eD eo fB eo dH dM fu dH fN fc eY cP fe fj dl cW dm eC bx dk dt cC dF do fK eY dQ gs dt ec dr dn eD di ej dI fy gb gP eP fv ck dy fk dO ec cW dE di eg dy dZ bE D cr cP dL ev dh du dB dE X bV eS fk eG gg fU bX dB cz da cW dr cz eu dH dg fo ff cm eH ft dy dG dO eT fm dQ ez gb dY fo fD dT dK dI dy fP eH dG dx fG cP fu fk dM dH bV eZ dv dA dA df dm eC eD dC fO fA dt fp cN dv ct dh cf ff ep fr dU ea ff ge dH fZ gQ eR eb ee eE fr dh dr cW db dE dC fn ea fg eo fu df dv db dF dl do eG dR fs fO fe dV fQ ew fB ev fx eP dO ec dc dM dF eS fA hg fy eh ft ew fy fP dN es 0 gk fM dN fA fv et gn fd cK dD dA eV dm df cV fV fb gn do fv dG fe eP dX ft ep ec cS cD cO eZ bx 0 dR ee dg fv eU eR ee dT ea fs fo dI fZ dQ cu ea cJ dF dC dp dx fk ea gb dU eL fv fj fY gk gR eR gL dJ eg ew eI ft eV fA fc fd dQ 0 bE fM em el dy fU hc fQ dy dt dy eq es ec fc fB fq dA er dO dO fq dj bn dZ dP cM eE dZ dn dI fc gJ eU eU dv dP cO fv ed ea eR ed dr fa fn fD dq fm fA gT gr ei dN dE fT fc fv dy df fm eE cN er df dM eq fn gg fq cQ ej bq dW ec dO es el dK eB cs bK dd cP fq bx ec cC bP dX de fi eP dI fo fL eG dr ek dP dc ew fY dw gc dp cT eX ea dL fN fn fw dW cT fB fJ dJ eP fH dQ dJ fR gl gc dj fb cW cW dl fv ek dk eK gS fc ef ef eX ff eZ eN fw fR gT eN dR fe eH fh dV gc eY ew eB db dw eX eL gb fV eg gG dg fI fB dQ 0 fg et eZ em ci cR fp fj dz eX dH dH dK eV en fP en eu dy dw gd eD fn fl ec fd eZ ft eI fV fZ ec eY dM fs gg ds eP dd ep dH eP et db cR dQ ff ee dI dD ek dH fg dB eN fG fm ea dx dv du cC dB bK cM cG ck dk dW df cV dq cp eT cP fp gp fP dz ea ea dM 1 fb fF ef fW gg ek eg dP fJ dG dU dk gn go eA do eh eO dT dS fe dE bV dE eq cp fd dH eL fk eQ eX ev fw fR dK ec eK el dp dC dA fE cA ec fI cI eg dx dy gq ck fE dw fJ dS eQ fk eZ dU dT ev go dl fy dK fs dm cG ep dO gl cN fb cO eD fk fb do dX 0 dz ga eg cM dW gk eV dx gC fH fo ei ej eP et dU ew eV eW fz gQ el cE dB dW fI dS eK dz gg dw gx gn dN fi dv da fw gn fj eJ ei ep dA dc dB dJ ef fn de dO dx eU dY fv gi gd dw fm cP gq dw dJ dV fg dU em eu gf fu gp fl fo dQ dT dv ex dS gp eg cI fE dg cA dc 1 fh ff bn cq en fG ex eg fc fg ex dl eF ex cK fg eg dq fx 1 dQ eA fC gc gf cJ dz dZ bE fk ct bn ck bT bm ex cB fd cC bn ef dV fk dO fg dA 0 dO gp cS ea cr by K ba db cu eC es fL fq eC em dz cG fi bS fm dp fh em cT dx dw ej fg ct dH fb cQ ew fj fE dm eg dW dK ev bK L cJ cC ci eq cu en fr cR cy dm cV cc eS cs cK cP cQ bn bK cH do bx eE eY do ef ef fw dO dw dB dj bO bR dj dx fV gP dK dI em bJ cH ex dq dK fg er dm cw cu dn db cj fq ed dl dt db eR dx dC gc go fi fI dV fk dP dV bV dL fm di cn bJ bK bR cV cC dj bN df ct eW da cs dp fv fm cE em cF eG dp cT eX dc eW cQ bP cx cG bh dV ch dB du ea eV dL dy dm bP ct cY cs 0 fk ek cu cs dC bn cO dP cE cI dc cY dX bI Y ci ci cN dg cZ ds bW ci dr dW dI fq dv cH bs cU di X bN cb cd cL cv cN dP eN eE bV cG bG eE cE bO dL bC cG cw eN fe eX dz fM fu dE eh eQ dd dY bN do cy 0 dI dC dh dT en eG dI fs fR ek dt eX dG fJ dS fm eI dV eD dB ey dr eI dq eC by fv ct eD dB cu eQ ck ec fk dx dW gJ eu fw fD em ew fz dQ fR eo cP dF dH bx eT eW eW fm dA fR cV fm eX eL fv eQ eK eH 0 fU eZ ef fi fv X ct dk dU gb ff fN ft eb dK dm eE bZ bw dD eB fg fb dg eU fu dT dA eu cZ eJ cu eg eg eK dX eD dD eg eC db ev cq bU dV ev fE ge gU cx eV fh gv fa eE bV cA dx gg eG dK dJ dg dL eD dx dN ga dy eb ew ej cQ dG gh dR gX dT bQ du db dg bO dB fg dy dQ cl di dg dk eX dB gi cS fy do fk df fi eo dR dL fg ea dw dJ dk 0 er dn fm eO eR fM dR fH et cW eY eu bc fU eQ et fn dY dJ fL cI ce fP cV dn dW fg dy cP ci dq ee cH bV eN eG eP ci dB cC dA eS fE ef dH dO dT es fk ce cS fB dm eS di fw fZ ea fF dN eb gn gR fO gm fD gf bJ cG fv cV ds gp eK eA dD cV bW eo eF dV dc bX cl fA eC dk fu co ex Y dl gV cB fU cq cf ea eg cV ed co ek fw dB eX ct cZ dD cw dQ es cO em fb df dd bV ch 0 dn eX fe fb dc dl dA fU eg fo dV fU dV dZ dl fj dc dg gd ej eI cI ee eW fu eN eX cf er eO cZ cY fz fU ek ff fW eo cG es cu dW cT bY dd fF fg eG dv cl dH fE eG cz es eA gf eO ey fL dC fu dq cg em fj by dV ff dZ ct ei gs gS ep ds ed dw by x cb bU dm cZ bR bX cx bQ cj cJ df fe dx bn ck eB dn df do fd eg dI fh fj dS fv ej cH fr dQ de gg eZ bY cv ce cz dU eB dt eR dp fh fr dv fC dy dj cJ di eU ea bM bV cw bU K ci dD ep dJ dT bN eF fv fL eX ev cd cy cz es eL ds cR eL eE ed gy cz fL di eU ec dv cc dH fx dQ fs dy gy fz fR dM dZ dQ dt do dp dB bY cu bf bH -1 bU O bA cd cL cF bc bK cM ee dJ ee fA dW eD 0 ev fq fs cI dH eQ el fE dN gx cy dC di cz dj dQ er fj dy cI cy df ex cG cd ex cj ew cu cO cD bn cL bf eB cv bE bD bo bw bg cI bH X bF do dn bL ef eC cy ca do dv cw dn Y cN cY eo dt ei df eu fr bW ce do ew bG by L cJ cO bo cp ea eO cj dq br J bs dH bu dw fm bU cP dy ew cN ek bO dm cJ df ew cL eE dX cL fA ef fk dF ea ey eK ey ce co ew do fw bS cj ei cV fm cM dj ej ek eG eN dE cp du eZ dq ee ck fm bL cI bM bY S cF bB dq cj ck ev cW ej ey dL bG ch cl cY bm bN cZ bm cc bc bB cY bk bk bs bn cb bV cK ck cc cy cF by bR cc bL -1 cf de ce s cx dl cC ck bW fq co bp cy cd ct cz dp fg ep bs cU eT cG cN bf cy ee eE cy di dg bZ cH eE dc ex di em dl cm ct bx cs fm dp eQ fg eB cW dP du dx ej dt dm dv eB dJ dq bO eS dd ds eo en ec eA fj cP dg fz cz eF dg bE ek cD cO bU cs eg ds eF ce dN fS ef eQ dT fz dA cS bD dh dn dm cK cV eZ gm fB fJ bU bV co bV cB cg cr fi ck cl bh ep fb de dF cU ce eu ee cG eB bg cN dF ee cP dy cW fv dK dP dc dA cM em ff ds eo do de dn dj dx ex dr eQ cp dO dW cE dO dC fQ fv cP di do dl cQ fK bQ eI dE fi fj cw dl do eY dq cu cd bW eC cn bO bk bR R -1 bs -1 br cw bo bd bQ cc bn A bk bJ bp dP bQ cs bN cD dm cU ev dp ek bQ eX cC dj dA cv dk de cK dw cG dk eF ff cR eE bQ X cT cA dM dL ee eg gi cP cI do dl dL ey ef dP eJ eE dB dH dm es eO fm cM ev eQ eJ gd gP cq cA bG cW cE cm ck cD dd ds dx dt es dq di eE cO co cv bM dA em dm cz eY dg dW fi es dP cw ej cH cl cD da cJ eu bQ cY bN bN fg fk cA dJ dv bM db cZ cG fm cN dD s bs df do cT eE dj cY bJ cr bY dd fe cG dn dj gW gk cW dF eY dS gx fm es eu cQ dW dk dO cP dD fA eS dz dn fU dd dC eO dA cB du dX dc fA et fI cy eK em ej bp ct cH dv dx cf eZ ck du eT dh ck cY da cp bq cM dg bL eS bh eE cR cm dL dZ cW cp eS bP dZ cR bT cn cK ci cs cP cz eS dB eG cG dV cy dx eU bD cQ cG cp cR cu cf ch cI du cE bX cT dt cz cB cK cZ bI cz cC bh dA cx cP ci ct cE cN bV cj cE ev cP ep -1 dn cG di cT dh bM cf ej fz co cK cK dm cI ee ex dq dW bW bq eF fA dR dR eC fi ew eo ev fj dC dt dn fM fE df eo cF ev dn dw ej cz fr cH cQ ch O bg cP Q bU cf bj cs co cf eC eE dL eo dq dn fd eW dC di dq eB bN ck eB bQ bC ed dB ff eZ cI cr bo cv bT cE bD cf bg bA bH B p bZ cs cr cr cg bR bh bf bj eF dd bP cP cY bW L cm cC bA cC Y bt C cw cw bj L dq bn dp bC fr bU cV dm cC cD dA cz dD cz dH cC dm fg cB -1 bx dn fr cU dp ci dX dp dj dc cT cF cS fU eF do eB cc bQ de bI cl bW cy ec da eQ dQ dl er ea bY eF dx fm bx cQ bL N bG cC dN dc fk cm dc cy cB X cG bL ff eF bZ dz cS eC et cB bY S dv cT cu cr bh bZ cI el bt fq bs cH cA cf bO dV da dG eB cn cB bf dj cT di dt eS di ck ca fe eQ dF dC cQ cB -1 bS bE eF dc bY cy cO cR cA ct da bW bx cT bx de eW dj eS cY dU dP bE bK bG cp cr cY bz dx cO cj bW bF dw dd cz cw bd cR ct cS eC cp ev fm dn dg cQ ep fe dV dq cM bR cm by cn cL cx cf bO ex bQ cB s I bB cz cW bE cC fq ee 0 cO bE de cq eB bs bU co eD dh dn cE cM cD cx cM cH cg eE eF eu ep bc ch cx cH Q J ch cj ck bt Y cD bf cn Z bD cc bi cm cg cr X bW eB cd cO bZ dh cE cF bI ch cQ fk ch bX cj db dJ bQ cq co ck bc ct be cw cq ch cu cF bM bQ cR cT cj cS cV da dU dR dE dP bQ cQ cM cI bE eE bu cz cT df dL bL cf eS K dh bo bi ci dA bg N cT cY ck bb bc ep eW dF ct cK bT dj X bi bw bg de cm cv bY cf cb cd by ck bw cD cq br bP E cw B T cv bY dw bq dn eB co bl du cs fi bW ck ea dB cN cI cB cE dw cg cu dq cR fb eF dL eo di dc dw cI fd dq dU ce eu cz du bh dB dx ct cb bf bV bm bL cs fv cC bI cF cK cf bY dd dZ cn eF cr ci cQ eS cO dk dv cN cI ci ex fK cQ eS dr cz di cS fd cj cy de fj cm br bp cb bA Q bp R bs bG bJ eB dq ca cA dP cv eN cD bX by cp br bZ cE cl bN dC dm bW dO ck ch eu dg dA cH ce cp cL cD da bX eC ce bX dD fP fb dQ eK eZ dg cZ cE dh -1 eG cF dh cI cy ce dj dq dc dg dd fk cg di fT fp dy fI eF ff cS cY dm dx ej di bN P bi co bt bD cd bY dd co cH cZ dD dR dp cu fi eE dH fv dJ bh ex dV dc dM fu em dp dh dB bO bT dn cC ep dj bO cY eB ee dt eg fj cT dJ dm dB cJ fm bp bT cC bq ds eW dc dV cg en fu fJ eB cf cG bL cR eD ej bM fg ea fu ga eI eQ fB eN 0 cZ dp bp cf cK dF de bx cM cz dC eO fg do bK cH cG cR cu dS fK fP ef cD bs eB du eu cZ bM du du ck co bM bX ct et ck cB eE ct ce dw dF cW ey em cR ew eO df dc bX dI dT ea fj bX cB bO eZ dz fg fq bX dZ cJ dk dK da cV er gb ds fH gg dc dg du dL dk dj dA bK cU cV X cP cu cz cY dg fk fe cG fb dg eJ fq dp cJ dZ cp fq cV eI dZ ex cu dq fk eR eD er fv fY er fU ft eo dB dq cB fg dW cz de dg eQ dc dp fd gq eX fe ec dR ef eO fv fE dW em fP eR eB dg ee df eE da cy cP eF dm dz dH cA dT ea eJ eJ dy dk dL fM fj cG cS eS ep dd cQ bx dO el eF fw dw db dP do eF do cO dZ cf 0 cI dX fo ej do dg el fb ch dv eD en dk ge fh ef eI eU fn fc fd dF eH dg eG eV dW eJ eN fr dj dg gi fM eh fC eR fi cQ ex es dI dj eS di cY eN gd dN dj fA eP dL dH dF dC cN eB ev fw fb cu -1 dV cp cz cY ew dI dP dc fz eY cV cL eZ dx ev fA fg ff et dc cP dC ev dE ga dw gg fg dM ep dy dS gp eK 1 eI dA ev bO ea fq dS es fg fo ey eg fH cz dM eH cP fx eO dC fV eZ dB cM ct fA eD eY et ef fe fw dS 0 do dL eE fK fi eJ dS fG dc 0 dS ds dR ey dC el es db ex eG dJ dG dT em eQ dN fo et fT dT fN fw ea gG es ek fU fk dj dF eH fP dO cV eK ei ei dJ du fr dn dt dj ej cD dB bI bn cd cE bD bO bS bL bN cC cz bG cY cu cw ct bo cE cD dv cy bb cZ cn bU cC dF bN cS dd ct bz bW cy dA du eB cy bQ cy cR dB fm eQ dx eI gf fN cG de fu eT dA dk cm F cr cH co cj ej cU ek fD fU dY eJ cI cR fj dE fM fC bQ ep dn fj eo dK eU gl fO gR eq dy fo gg fw dy eK fu eq dT dm fU eQ dd em ey eX fz el dG eA fw fo fE fo cK cU dk dO fN ev fP ds ec dN eP gX gs fI fJ ek dW eZ cm fm ep ch ei eb eR fu dW gg dN dq fH fm dy eI dD ds bT dN ey eQ 1 eA eJ eP ds cr ck cG cr bT ex dk fk er fx fd es cS cC dX 1 dJ eY eN fD fx dN dp dM dj do cA de cx bf bw cg bT cu cV dP eo dk cz cL ct dL dR cp fv dP dm cO ee eP go dH dM ev dg fv dY eX dY cY bM fJ fj bX cp cF de df dv ff 1 eB co bU cN bF bq bL F dq cp dM dH go gT ff fC gm ed dK 0 ga dR ee dS fc ds dP cB bR dx dO cG bG eB cj fj fx dk et dI ff eu by de dL dH dF cR eN bx dl dc fz es el fO ds ee gJ 1 el eT fC cz dL dJ dx ff fh ed dT fE dt dX fC ec ef eF dJ fq fO ea en gn dQ dL do ei dr fg es fJ dz eA dS eo dv cv eu cM de dL dg dg fe dc fg eK fj fK dG fw 0 dO fn dN ek eP fx dC fY 1 dG gk dm fu em fb dx dM dg fg dG eJ ef dT fA dS dh dg cj dV gg eI dp cS bP U ck du el eX fC dM eY dN fi dU eQ cV ea ea eJ ei fv eG gq ec fA cK fm eu eJ gS dy dI dw eU bY cI cr dC fi eU eK dD dQ gc fE eu fJ ed dY ed eG cW cz dt dF fs gg eh eg er dI fi dp dM fu gK fM eR fO eY gd go ei gY gB eN fk cS ei fW dS fh fU gx fP et eJ fV eG dn fg gg eI ed fs eX ge fS fW dY eb dI fd dQ fi el dg ec eh fe eW fj cj fr ef eE cD db er fP fu dw es dR fq dD fk dq dN dV fJ ds fQ gf dk eX dp cM fq ea fq fD fu eA dx cT ex eF 0 eJ eQ dI ey fA dz dF cG fA eg cR fz fj cG bR dI dS fG eT eo eQ 1 dA dw dr dJ fl dR eq dU fh eK eq eD dJ fu dB cW fP eL ea eJ fk ec dV er cY eI du eZ cJ cM cH bK eW fa dw dt fv dK fJ dz cK dp cf dN cG eS ew cx cW bg eF co cB ct eD eE dD cz dq eW eC dP cp ds cI dn dW dn dA fz cK eI dQ en fg de ek eQ ej fz eK dw dV cW gd dQ cV eQ ej du fN ej eS ds dC dC fb dp el fh fh dH dp cj ck bD cu dB dN ei fc fv eo et cz cj dq cM ds fb gn gc ea fi ce dr dY dJ gg eq fG gf et dH fL em dS gc ek dk dj fL dL dN eI eI bL cF cw dW cS cz bn ea dz eu dM eh cS fF et ev ea dQ eu dZ eE fq dR eQ dI eo dw cU du fn fk dH db cV dz eK eT dH fk du di eZ cV dx dc dN ej eB eO cA bp cj cm de fM dv fn fz cE dc fi ef eA fA eq dJ bW ex fj eI ds dO ei ds eJ dA bY cJ de eT dC bN cY bC eG eW ft fF dV ef fx fn dn dR fv cy cC cY di ev cw ck eQ ff dN et eQ cQ cS cj dg bQ fv cD dy da eN dF eW dA cV eO dW ej dV fp fu dJ eU ft fj fm fY dv em fd dl fn dc dS bM cF cT dW dW eF fm cV eG fP cP dc dY ea dC dE em fd fw cU cT cx bi cC bq eZ dl cG eB ci dw bf u X dd cx dZ ci eu dz dR es fv cz cm bu ew fd fP er dq gt ec dg dU fb eF eC eu dP ea er du dJ dW gi dV dt dx cP dJ cJ dF eQ cw bp cm cC bV eN bV du eG ef ef eS dp cY eW ej dN dq eY dW dy ff eg fj dU ds dR dj eW dV fi cD cS cf bT bW bK eQ ds ee cV ee dN by eN fw ec dY eK dn dW cY dj eS eW cb cm cS em gg dS eT bM cK dd dX ec eZ cJ fr fg dF cp cG cT eQ ed fe fI eX dy eu dj eF ew dp fs bq bX cP dM eF db ej ce dh dn cl Z bz bK cH cS fo ds dp dg et dL dj eo fw fg ee dd fv dW ey cI cu eO dQ fn dL dK fk ew fU dz dC eJ gk fU eL dW dE fq fb dp ct cv ev cU cR bM ep fD fP fi dq cM cf bO cO cA eZ dD cp bQ cg cL cO cv dD ca eZ cG dd bQ dj fC dJ cR cE dk fq dU cO dE eR fv fm cj bV do dE fR fb eq dT fq eR dH ff dF dk ew bT df dR eE cn cH dq eT bs eF fr db ej ff ep fj cT cf dg eo dn dd cW cS bO dV cQ ex dt dQ bK dh fq dR eu ep dZ eF cO cY bC bj bR ch bB ed dW eQ dS cu dh br T cF fu fn eW dW dz fj dp cv eO db dP fv dn ep cO bx bx cg eT dP fu cB fe cI ep by df fP fg dW fn fq cP cS gb fb dK fM fY ea fn fe fp ek dQ eW fg dX dS eu dS dU fj dz fh dO dm dd fk cV eS ek 0 cA dn ex cf cw bX cS ep em ff dg fi fg fe cP eF eQ eO do eI fC en dv eQ dS 0 dx ex eC dP gX dA ff dG dU fv eh dT eV fi cU ec dT fw dM fJ fm dC dH fI bX dD cB fw ep fe eI em eg em dq dH fu eV dT gc dK dI fz ev dS gm dN et gn eU fw dp cV bE ds gx dW ft dL bh cb ex ci eT fE dM eT fo fe ef ek dK dN dG ek dN eJ dc dm cQ cV fh fC ev dx fc dt cQ dJ eT cC dn db cG ee fG fz eD gL eb gZ eU cT dv dt df ea ea eV co cI dD bL ex ed dD dq ce fA bN db dP dy eW da fr dv dL bZ fb cO bp cE dg fw ef dy ei cV ef ej bx eJ fE eQ eU cG dv fm fr cS eV fj do fm fv fU ck eS ew ee bx cZ dQ eT el db dU fn dd dV dF dv bW cd R bW eu bC bu bP K cg bU bL fr ec dS cR ev ds cz cV dG cp ds dO eW eV dN ey dK eR el fY dW dO dr fQ eO eI fc er gb fm es fu fe ff fv en eD dY ge fx dl eY dL fq el ev eq ec dy gb gI cJ dP dp eb fz eI gu fe eu dR fI el fF fc ds dC fd cA fr dC dx eu cV ea eJ cV dB dc dq ei dT fv dN cP dg ey dS fi cS gc fE eT dk dr dJ ed eZ dh cV dF cp co fd dB eQ dr gL cv dF fn fq cC fv dn et fw df eU dI dK dR ct ep eP fq fB em dc fd dT eK fD dX bC eo es ef dI gZ eg fK fw dz ct eY fa ge cV fA dK el dO eG dO et ge ef eo ev fJ fk dL eU fq cj eN eq gr dY ep dw dO de cp fA eG gn ew ee ge fd es dw eC dl eG cW ei eo ei eF fU fz ek fw ei er dv el eJ fw fv dO dq cg dh de fa dX dl cT dG dL fv eH dA eK dG dT fI ea ew fr eF ep dy eF ea fv dj ev dh dP di et de dx dg fw eo eW ff eA fB eX fn gX dG fC fc dr dI fu dC fT eo fs dS eK ge cV ds eN de eJ gg dd dQ fo eJ dX fm eH fs fu dC ea dT fs gc gk fZ fl gh eH ef dE ff gQ ei ds fd eA dR ec fb eH eA dW eW ep ch ew dW cP cY eC ex dY fd fu fb dg ds dR et ef ci dv dx fo eX eo cP en dD eC eo ey eo dr cP dF eJ dA el fA dI dC fC eF bM cf cW cl eK er dr bU cT cp dw dz dI ev dl fs fn eX eI dz eE ey dp dV ff dN gc dG dJ cI fk dk dz dc eY cz dW eV ep ct cQ dB ff ge ga eA ev eP fH dC fr dB cS dP fj fv ei eG dk fu dc et dX el dE ge ed dY eT dx dz dj dz dn dU dV dm eV 1 dK eZ eS cF ea do dA fh eI fg eS cK fo fw fn fJ dr cS gp eD dZ 1 fv es dI cN em dR fC dw ey eg gl dT dD eE dD fu cS eT gr ga fx fJ ff dS cR cA eo cZ cS dp dv dq dQ ee dx fj eg dy fw dS dc cU fA ev ce dc eZ cI da eC fk eT eI gp ea fz dV eQ dD ei ds dr ff dW fv dt eu fg eR dU bX eX dk fa fp dC ff dM ec er eO ey ec dx eZ fC dS ep cj cO er ea fM ed fq ep gk fE dH dV gd dt eW ee ej dX dE dH ea 1 dk fI eG en dU eO dk eq dI dl cg cP dP fj eo fH cQ ds dD dO fb dd fV es fC ei fv dM dE fb es db fw eF cA fe dg dr eX gb ev es dw fm dg dp dY dV eW bC eC eG eO cW dA fx ei cH cx ev fd dc eS dy dA cS cW fJ fq fp dw dA dx eh fh er fZ dS dJ eD ei fq ey fu eR fm bQ fc dr cK di fv ef ew dZ fA eE df ey ey el dS fU fo fP ey fK fn dc eK bq en eI dp fh dr bN gb fz dS dC cU da dl fv eW bN cC dz dM fu ea ek eo fS ff en eO dO dV ec fv fq da cI cM fM cK fp ey fB ec dG dv gz fY fC dU er dK cS et cP ft dQ dN eL fo ei fM eg ea ea fJ gx dz eR dO fj fR cU fD dH eo ds dv dr dR eA eD dA dy dt eZ fr fj ey fQ fs eC do eT fF dO eg fg da dM dF cQ fC fQ eV fn eZ dC gb ei gp dG dD 1 eT fP dq cA dX ew dS dk fP cS dX es dR dP dU eo eq em ew er eI eI eV cA fu eu dk dX dv fh es eV do fu dr cV es eB ef dX dO et ds cW dA dq gx dX fR dy cU dM dV fJ fi fN eu fr bn cf cH dP cD dV eo dN ff eu dk eU dd ek eu eJ eR eW dr fz dW eR et cA eW cP eZ dY dE ek ey dn ds dW gb cY eX eU df fa eO dX eX ek es ep du ga gc fG gn fH es eq fP fv gq gs eX gx fA el dI dU eD eg eK eA gR fs eA fp gg dS gl dS fE ej eg ds eD dz eg eZ fd cC eg dR eJ dA ep fk ej eX cA cP cl bh cv fo gY fA em cV fb ei do dj gx ga fp dt fz el dM ch du du fp dU fe fc dA bp fw eR ff go fP dU gH eY ga eH gt fC eL dr eE el fu ff dC cS fu fu dS ee dH fk fE eV dQ fb dQ eq cV dQ fh eq dm dp cp cJ em fn et du dM eN gn fT cG ee cz dC fn eq fu dQ cW cQ dd eI fx dp dy cG fS dH el dw gI fL fx eQ eP fw gS fU et eD fn fe ff dw ew eD fJ fA ed gr gy ft dU gk eH dy dH dM db eW dA bE cP bU ck ct dW ff dT ei eY dN bM di dT dI ga ed fV fX fY fv dK dL eN fS dM 0 fq cw ci dA di 1 fV eb fK eK fP dF ff eB fj eC dE fi eJ do ej dT dX gc cA fO fn fJ gL eb gb ha fT es fU cV ei fj er fh fz fw em fK fJ fi dy ds fA fC dM dE en cO fc gC fq fX gJ fC eI gv fM ga gf ft ef dL fV dV eF fJ hb eR gn eR eL gb ep dA eo dN eo eg fU fF dI eD dC du eS do eo cP eK ej fv eY eP eT de eq dT fQ dW ft fd eY hc ez fz ei fw ds dO eG et eT eA dM fM fy fP dk dW es fY fn dP eD ev fi dj dF dj dp fd fb fZ fx dR ee fM dF ct 0 dM eh ed gp gM fy gO ej fd fk cV cU eU gs fD eJ gG eH gb fm fq cT fq fp fp gy gx dw gL fu 1 ff hd gW gJ er gh fp fP fA fj he gp fh fA fm gb fo dh dy dU 1 ha eF cz em er cJ dT du ev dU ek fu ex bL fm dN fU et gp fR dU fj fn eW es eK eB fM bq dP dX eD dN dZ eE dY dw fC fZ dl dy dY dV eY dV eo dV eT ff dr eD fp fZ dG cW dU cW dB dK dd ca cB bV eC eD fa dK 1 dl ft eY eK fc cH eW ea en cj cA fJ fx eG dJ dk eI eO et fC bX dU eE fq dZ ea gg fv dV gk dy gb eU gx eh eo gS gx fN fK eK fI eQ eq 1 fE gg fp fU eW fB eL fX fM fN dp ga eY gn ga gg fq et dH fE eA fu dR dQ dM fv eJ do ee eG eS fN fM dX fh eN go dT fs ef du dP cy dP fi eC gd dp eE bM dM dv dC cJ dq eW fI fm fs fo dk dr ec eO eU eJ fw eX cQ cE dd eu eW cj eQ ft hn fu fg hc df eU dT ef fL gf fc fs ej z dA dK dK dn ge eC dN ee fh fq dI dq gd ex eK fI gf dy dm 1 dw gl db bX eR cF fI dQ dX dp ex ej fm fb dG fu fE fE ej eL 1 eX eu fU dK gQ gq dl fE el em dQ fF dU en dl cG dH fn eu eO ek gc fC dk dm dJ eh fi du dm cp cA dO bT ew ei eW fC da eB dl fb df dL cW dD bN ch bZ bO db cD dX eI cL bV da eC dv fe eO ev dk do eQ bO bL cD da cJ eC dB fs eW ck A cF fi bY co ev bx db el dN eg eg fz dF ff eT dp fP dx cs fh cx fm bL dQ cm ex fw du et dW eD fz dD du eo fj cH dh bT da cO ci bM eS M I S fk eF ex dt ee ev fC dI dS cJ di 0 cW fM eG gb cC ds eH et 1 fn dP dY bK cS eT gK fY ff gp fT hp fn fP fV el dS eb cC dq eg fP eE gi gc fp go fC ew fq dZ eR gy fK ft gG fO gq fY dG fc dT dI eS bV ei bX el dv ei fg ew cR dP gk fd fU ea 0 fP gO dP ek fw fn fH eh ew fi ej fq eJ ft fz fq gG hf dI eh bQ fk dq fk ei fO dK eC fg fD eI dg ej cZ fs dH de dQ et dd eH eI cH ed fm dW fv dI dG es dw gi eh fs dX fg fP dp eL dg bw cO bR db bF dn cz eW dv dX fA eR ei fi fM fg cC cD ce cp dh dF dD ej dj cH bx bE eE fP dv fJ ek ej fL hv fs fN fu ef eO dx cN cL dJ cY dp en dP gx fm dn eN ej er dU dQ gv cC dT fF df cm bC dp cD eu cJ cw eY ep eG gv fb dH fx fy hg ef eZ dl eE bx gd ec gy fP dT fx fA dV dP dd do dO fj dv fE cM fU 0 dT dU eT eX ff dQ ec bT cA fj ds db dm dH dk bK dH dK fz eC ge do dM fu gI fn eU dA ed fA dE eF eu dC db dz eC cU dT dW hh fJ bM bC ex bM dr du dP fv de db ec ea fP dU dc fV eI dy fl dq ft es gW gL gg fL gc eI ds fk dA eF dK fF eQ dN eH fU eI eE ff eA eJ fT hg eq et dv bq dR 0 em dn eP fk fR fs ea dN fn gW gl dM eA eD dj dW bY ds eQ do eI ef dV ea eR de fC cQ eD ey cV dG fM eN ep fR eS dl ec dM ex dT dm eo dY dA et ep em gk du en dp dh ec cB cz eZ bc ef eF cO em cV 0 ej cF do cz dV ck gk dS dV ft fd gI eA fw dh eq dj dX eP eB bM cS bI dM em eD eB eY fc eH eV dh eW dC dv eK cI eg fw fi dm ew dj fw fK dX cx cV eu dl dH fM cA dt et ec dk eD dv bF cj cQ dN gd gf dp bQ dv bq dB fq gc dW fJ gR ek fP dV dV eQ fi bM dj eJ ed gy dQ dn em ga hi dV dn de dJ cD go dR eV gg eV dW dS eF dm da bV dN fi fE gb dA et do cW cU cC fe ek dB dr gd da eX fJ dy fw dq dp eF fe eg eX fl en dN ge fY fB fj cS eG dL fv cL dL eW eJ fM cW eJ gb eY fB gf dw ev en dg fr eI em dr dl dw fr dq eo ei dA eH dr 0 eI fQ eG eL dO fd eH dY eA ft eS cR cM dg co ci ej ep fE gk dj de ee ev fE cz ei do eb eX dy dL dH fa fE dp dE fD dO fH gd fs eV eR el eU cR ep eJ cr cZ dS di dR dl dY fa fB cz dE cC bS ct ch cJ ew db ew dS dH er cV bQ cD do ep cP di ef eJ ee ev fp fv fA ep dL fh fm dE fb db cO dD fj gf gp dg ct eU s cI cy dh cQ fk ew ep dH dJ fe eS eV dc dR dk eq fM eK dm fd dY ff cV dx dl dP cU ek dl dc dZ cS fM dN eD cJ dv eW eC dc cm cI cv cj fj fb fU dH eo fg cI bx eo ef eL gx gI fq eY 0 eo cS em eZ fs eu dV ds eH fd gn ff em ek eQ dR dS dM dj fm ff dA dl dZ fJ fK dG fo dR dB do dn gk gq fr eD dw eN eq gk fq dA cQ fb dw dC ep eT eS cI ha fO ed fR fQ ev eG cz cZ dP ex fk ej bX bE cm cS en eo gk ga eR ek dh ey eg gd eY eJ eN dw cI cA eB bV cW bG dO eG gd dN fB eN 1 bh ck bL ct co dS eS bn fr cV dX cS cO ex bZ ec eC cU cW cw cH cS du ds fd ew de eE bx dA Y bq ci da bB cB O P z v ct cF cp cf bN K bs bS co cG dX fm dv cW cD ev cS fc ck eS dh co cN cH cD eF dq dv eQ dX fg eh do cS bP bN bP bN bI bp ci G z br bd bk ck bT bZ cS eS eF ew es dr dT eJ gG dw eo df ep cL ca Y dZ eD dh dq dw dh dI cy dc dt fg cT eE cR bK bp cs bC bf eW cK bJ di eC bc bR ct bp Z bX bM eW fm cj bp eB dA fk cd cq db eZ cR dA dd eu fi fC fY ff eJ cU dA fj ec ek eQ fk fQ dU ds ee cQ cS cI cK dj en fw eb eK eO cJ ex cu cz bL dc cy bn di cQ eD eC dz fc bQ da bA cM F bu U bs u H by cd J x bT bB bv cb cO di bF cf br bF bB bS K bY cq bH T br br bB w ba bv co cH X A z u bF P w d M P K ba Y e P Q ce d B t bH bj be by K z V bi cl bC u O L R bh W bv bH bt cn bA bk bN cm bK bZ bt bO bg dv bg cr br bD R M bG I bP bs G R I n K br bN t X cY bB bF N bF cN cs bO cm cw J cl bh bg bg bY ca O bz bc bC bW bz bZ bP W ch ba ca cB bL ck bK bD S u bj u bF bA ci cP bP bG ei bW cY di bw C bh bC bn cC cw cN I C bI G bI bu Z Q Q bu U bv bs ba ba W bk bm E bI cq bg X cT dn bI bu da eB cF cw cF R bs U bt m bI z t Q br bt G bA P B bk R bG R y c R N J N bS F X bi cw w A bt V B bw z bY T br V bz bc Q bB q bg cN B bP bZ br s bh D G C bl bA ca A K bc L n bB x M N O bb y bs O bf cn S bk Y bT J T bd bQ R bj G bi I bu bl bk bn L cs bn bJ bW by D bv u bu bs Z A bA cN K B bk by bt F bf cn cc p N bk t V Z ba M M P bi u t K P by cv L bF cd br T bV bk V bw bS bZ cu cl K bT T T bI be bt co q q T bb E t bW bN bD bH V bb t bl e k y T z bi G D Z B u ba bt B X bz bH Y bP cC bZ M P i bc P bw bf J C t J bA bq bA ba P R Y p F br cl L R bg B ba bz bA ca cO bb bA bG cn Z bK F cd Z N F bf cC R bi bk bC t bj Y K bZ C cm cb bq D J bw cd bm bs bw ch cc bY bh bp df A bw bt by A D o W d x bq G m E V R bf by F bU bJ bP bU x F bc Z Q A bk U A -1 cl Q v z I z bz ba S bs V e cc o bA bz J Y E Z bv X N bG K m L K u cd s cI bY cb bn bz U bF R bL R J cO bs L B L bd bw D E y bv ba bj bb o Q P be bj bB N bH bi k d bk bI bS J U C w bb br bk L bi bj A bz O cf cd df bi D br bz i -1 bl bv by U dP bo cN bD bl C L cc D be W bm m bl x bm N cl u cl ba bE L bD cd bU bz X bY B W V -1 bA cD bd bs R bK bU K B bm cl bU cq bJ by cr bg T bK J dq dj cj S co bn bB bd bE cB bu Z cY ct bI cr bi bw ca bo bv K cD dm bE do cB cR cm bN cq bj bJ O bN cB bS Z bF bT bd cH cG bf bd s bL ck S bb bF cd bS bS bY du cm cx cv U cK bc bA cA cq G bJ bI cl cP ct dd ef cp bq bA ci cK bV bX ce bh cE -1 bo bT cu bX cx bq B bJ bf bW bq cW ca u bE cv ci cb cC bw bg bS bC cC cR bR bs O bw bE bj U by B Q b ca ca bY bw bj -1 bZ T C S L bJ bo R d R Q cd O m p bd bZ cR bd s z ci s bz bS bE P bI cc bC bG bw cn bO cd cm bU bi bF F bd bG bO E q M D bc X cR cg bL bQ F cr cg eS bZ -1 bV bA bs K bl W bs bM bk bB Z cM eZ bP bL fj dt ey bO cq cC bE cK bx bo q cr cH cD cg fm ck cF ch dh dh dk do dc bJ bD cr u bT cf cs bS F bZ bt co u cl N P t cO dZ bn x bw cR dn bE cn bG cY ct bx cq bf X bc bg bz cN bm cs bF bU cp s cL bR de bR cJ cl cm bN bX dA ej dp fk da fq eZ ep cT bO bT cj bN cB cp cD ea dA cU bW dB bn cr bq cK cr bW cJ eF cA bJ cn bL cF bU eN fr cG dF bX cx cE eT cU ck dJ ex D eB bX fB fP dg ec dh fi ej bn dv dx ec eW di dr cG er fc cY dB eW da ch cj bM dv dh ee bM dh fj cw dx eX ce co em dG es fz co dA db df eZ eG fe cf cT cx bo cE fq dR ek fn eF eB cj cY cI cO dw dj eZ dg gf eF dG ev fr dv K cK cG dw cM eT dJ du bI cg cf cz cu cD bK -1 dL dO eI er dN cW cK dP bJ de cJ de bH da ev bc bz cs ci s U Z bk cl bT Z u be s ex K bh cy ev ce fm do de bF dB dA eI eX eI co ea cL bp fv fq dl cu fw fn ep br bp dG cR dt bY fi eN fi dn eW dX ej dV du dx cG cx fh dg bx dt bM ck cO cb cK bq cH bL cJ eO eu ej by bC cK ch cf cY eS ew bZ fz dH dR fs dy dj bW cY dR dx co bY cZ bs cA cR fr dU dC bX dr dv 0 eU eQ di 0 et ey eu do fj el es eq cY dp eS cP cT dJ cu bL cj dx bG bS cL dI dO bc cn cR eZ cZ dF cB eS cM cP dP fg ds ed fn dh cK bP bJ G bE bI cx cq cM cu cT eX fw eQ fk df cF eY eQ eE bD df cg bQ bE de dR by cz cq do bR dq ct dJ fh fg co em dc cB cR fr bC cN dl cL cb cH dl dl df dJ dD dK fw bX fi dA cD cC dV t cw P bS G bG bP K u bj O bq cM cJ R bT ct bG bv bF X cL bW dh ce ep cz cM s cc bY bq cp bM eC du bR bN cB bx cf cm dJ cH bS bh cz eE bC cV cH cG da eB cf dh bs ee cM ck eQ cY bc dD cR fg bx J cw ds eC du gx ei cf cJ dB cU bK cf dm cP ch eB ee ej da ea bn bt cm cp bU dL cO ej de cf cp cu ct cJ cW dB bF dg cN 0 cu bM eu cR cf cf fz 0 fe eg fg fr ds cE bf eX cD cy bi bV dj do cJ bW cO di bu cZ cp cl bV cK cJ cL bJ D cs z -1 bN di bI bi cv cW cE bs bc cj bf bM cY db eX eF bX dL eF bC cJ cH cR cF O ex ci bZ cd cx eX ee do ci cU cy ct bq cK cL ee du dD dl ey dr cZ bM dz fe bh ce do da bs du dx Z u bM eD eB fr ee fv bN bM dd df bD F bg Y Z Z bm bT D bv M bk cI cG bh V bx J bT cu bh cH cR g cl L cd bU bJ be bF bD G cO bJ B cd ca bj bs cD bF bx br bV dd cY K bu T bq dh bF bN w by bl bD da Q cb bH cq L T bw bf bz bW P ce cN cD dr db bN cA bW bY cs G bJ X cF bN cx dO cI do cB bG cu br L bD cd bR cr cM cN bm cl dZ cY bG bC bW bk cS cM cQ cP cE cr cE ep dx cp cv cn be bD dn bX bv F P cw bR ce -1 cp cA bt bm bz bu ba ca bL cg ck I D bt ba bj cl di ca P cW bO K br bd bU bq u Z cb t X bT bN bv cY bc cL bB cq bj G ca bS bt bg Y ba bo bO eF cS cp bY ch da bW X bz bk G bb bk bW bD bS ca bc Z Q N br u ce bE cn K bO bA cZ cf bJ cA cy fq dq cA eS K ca bK bF bS bN -1 bn cl bH ba bJ bR bv bF J bn bH fA dR cG dq bh bo X G bK cl X P R bZ cq B H cl F cd cy bJ ci bn bB U L cn bz -1 cG cr cp dv N cs T bP cc cl h bk J C ch L cl P ci bm eB cC bh bc N bj bb by cy cC dp bG dc dt cY bZ cU cq bP bo bD bS bk P bj Z e bl D bT bz z bs K J bz N bI N D bs bU cg bW F bE cC Y db ck eB di bq cy bz ce bF bR dm bE bP cc cv F bw bT s cc ca bO F cO cP cg cI J V z bz H bZ cf cl bB bS A N bE cq cr bC bP Z bm bA D bG bq -1 eE cv cH db cO cO dN em dw dh bR cP cv dv bA ci bc fi cG X J bD bJ bX eS bx cS cB eF do ch cc bo cE bA bP cB di cq eB bz bN bJ bx bG cv ce by cZ cm cm bT dg bp Y bB Z cF cK cJ do cR bu bA bE bI cs dr dh dR dL eu di Q z cq bw U bt Y G cL bp Y ca bU bb X cH cD eC cN dc bO bR cq dB bJ bf by cO dc cT bB cO cw dZ bP bM da dg dh cD ce cr dd fr bS ce cu cJ du T bH bG bV da bR bK dz db cA cD bi da bC cL cF ce cT fr bf bc bP cl bF cd I u by K bo bb q B bq bS cu cx cF bc bd g M k bv bo bK bo cf bS bZ bn bK ca bi bK bn p P bx bO eS bp cZ cb g -1 bV cV cs bi cf ca -1 bo cn bx ca s bL bB ck cw bB bI bS dd bF cd bE cH en cU dp fe cs cR cY bR cE cb dd eF bB bR cR cR bq bM bC bS cr ce bt cI bN bR cd Y cB -1 X bS cx bd cq cW dd dh cR bd ca N bW cT bB cs cC cO bZ bj br cY bo bW eC bY fj dD bQ bT J bq S cs cj cD cb bN bb ca cl -1 bc bk bZ cx eE cC cB cS bG cq ch bL eu fi cJ bW db di cZ cC eO ci cw cc eF db cq ct bx dC cU cC cm bt bt dc dg cn cp L bv ba X bg cg I ba F E R bm bH -1 dT cB eE cL ch bX fm cP db dP bM cy dt cZ cY bp dz cQ eS bX eB eN dK di eu dr eW dd cK eO cI et eC fr cx ct cB bW bH ce bN cl cM cQ cD cy dO fi cO s bB cN N G bP cT dh cs bp bI bT bC cP ce du eX cD bk cg cO bw X d J O Y bE br cY cB cZ cx bW fr cb bn bh dZ bW cF cJ bo X C bS by eI dX bX bw Y cK bx cZ bn bP bk cp bT bo cT cz do dg cQ db db do ex dF cF bV cJ cJ cp cN cN bx by bO bP dH dn cE bh cO dg co bC cE bo cy cE ca A bB cF bh bx bM bf bc ct dd cT cY ce F cz cv dn dt bD bL bk bu ck dZ dX cV eX di fM fi cH bU cQ bO cQ bV eW dt dB fv ev cY ch bh cW cF cM cp ch cL ce cO cI ee dX cG cy cs ck cZ cI bC cD cT fq dk ee co cY en cW cg cI dv cm dA cE ct cr dA eE ci ev dC cI bV ci ce cM bn df dl du bX eu fq cQ bD bK fg 0 ea eO fu cv dX cn bQ eq gb dG fK dU dr bX dx dj cV dA da cV dd fr eZ ep eu cJ fw eV fF dy em dD eS cU dp dw fM ew dH cV dQ en et eZ cu cU ej cA eP fv cm dv dw dO fq dW dR bx bU cA eS em cW cU fm dt ef fS fL ey dB fn ei dN dT gs go fw ef es eC dq fr 0 fI cP cV bU fJ dr eT fY dU fI df fj eS dW ee dg dU ep dV fh fN ev fI dz gk eI fm eA fo gb fe fo dL dq em em eK dJ eI eI fE fb eU eU eG fz dy dO fx es er dG ea gr gs hi hg gr eV hc fC dN fU gt eU ga fT fz ei eJ ga gc fm dE fp ei fR fM dE fv fn en gg gC fC eP fz eD dW ec eO fC fM gk fG gj fL dN ey dc dl dS dU dr 1 gg fK ew fa fA fZ gk ff dn fe cI er eq ft eu et ey ec fW fX fz go dL el es fP fk eY dO dN dT dz ea fK fP gT fH eM eh fl ey fD et eP et dS fs fb fo fx gC fp gx dY dc dw eZ dk fd fM dm er es eB do eG fI ga eK dr eb eF eM fp dT dU fi cU fb eY em ds eU dn eW eG dH ec cC fZ gg gp gl fd fQ gv fs do fU dz da dR eJ ep dC eg eh dB fC fQ eh eq eh dS 1 ft gk eP eW fx du et dH cZ eK fG dQ fw fa eP fV gh fm dC eQ dY gR hf fD du fw eQ ep dH cy dx fa ft gw gv dN dE cU -1 dk cS fd dN dT eA eD fh fm eK dx eg fl eQ ec dU eV eh fA eU eW dW dl cY ci dF fd dv dM eI ct dB ee eX cA cV eO fn fa eQ eN dS fp ew gm eb fR er fn eC eg fh eu ea dw eO dk et eP fZ ee er eI fs dR dr bY em eJ fc fm dy gd ev gp fI eL dY fx eZ eN fF fR cV dV fi fA fV gk fI 0 dB cL fd fA dw fz es dC fk fe db dV gv fa dw eG dI gW gk el dK ga fG dN dA dK dp cu cJ dd ea fs dU dT eI dI el go dM fY ej eG fW fh gC fK en gy dU dX eD fl fb cR cT bQ dR eX dv cY ef fa dn gh gy gy ey fF eV dV cy fm dN ff gg ep eC cz dF fm dH fg eZ cE fq dG gi dP dp gC fO dU gk fD er fx gV es gO ei eX fs eM gK fV eR fY gf dn ge eW fZ ew eu dk dF dz dt eQ gt dO gv gv gn fa dv fP eD dh eE eO dk en dj cP dI fG fn fS en fI fb eg 1 fK dQ fo bG fe ds hf dW fE ey fM dV gg eP gb gb es eT bM em gS gV gw ec ei fW gN gv eV dO cV eA dE fR dO gY dj fv fz dU eX fA eC dw ek fh gm fP fQ 1 cp fR dC dl ge dW di eX eU cH dM ev bJ fw fq dt dk gs gm ez eg eh gl dR ed fB dV eV dU fP fd fM gl fo fy gq dN eN dK en cU el dT fl eY gv dS dK fy eW fJ fT eu eE fV dg fK dC eJ dE fP cT gT fY eW fh fD fV dR dw er fM eZ dO fk dD eP fj gL en eg eD ef eA fL ej dX eU eo ff fn dT cf dg ff eJ eP eg dI 1 eG eg fB gx er em ef eG dr eu cG dm fZ dI eK ff fM fi dL gf dj eA fB eh fe fb fV fc ev fN gG eD cf fY ed dB fN dU dW gb fK es eq et er eh el fd ge cG dd eW eM gg fT fA gq gx fn fR gq dk gS es ff eq gf gH gv fJ fU eG 1 cK bP dG eN dS fc gp fP fI dd cU et eN eN fa gk fc gx dm fo fV hm dI fw ft ft eX fm eE dO fD eP fD eD eq fG ec el cM eS eE df ei cP fi gs fP dy fb eE gp fh gc eA cj cf gS eO fN dt ej eZ ft eH hg fM fs dI fw fh fN gq fz ey da eq gy dM gK eP ej fk gk dW cR el fQ gg eK eL dI eQ dm fn ev gO fw gi ft fr dD dD dX eI dE em gK fv dw eK eI et eo gc eV fg ec dS el dU gf cA gv cV eC dL gW gO es eN eD dK ft eA dI fb fT eR fv eP gG go ds ft eq gr hh er go gg eJ dI eR ft eq fA dM gx fp dN dM gk gc eR fl fT gv fD gC eM gH fu eY dM fo eH fx fH eQ fZ fL fW ga gH fK fn fM gB dS dN bQ ei fe 0 fo fQ hj gh eM fR et eF dm eF dI eQ eE ef dk dK dr es fH eP fu cI dr dE en cE cK ep cE dc cj fP cU dR en gB ga fn fP dW fE en fW fH fZ fh gc dC gs hk ez hw eb dg dL ej fU eR eh eK eN dv cP dt fs fV fC gw hk hu fI gI gk hl gJ gj dt eG ek fn eZ gv dE dT el ha fK eV fV gm fH gl fy eA gF hc eh eL gx ha eH fY fh dE dj cf bp cE go he hg fS gc gW gq ha gP fW fM dI gB dE gt fY gk gx fS gD gH gb gU hs fL fL gI gp gu fa eg 0 fe ev em dz eR gL gw gW fZ eH eq gq fK hc ez fX ed gu eh fI fP dl bn dE ef dO ee fK hb fN gZ hf dV fu hf fz gD dy ha dQ cQ dN fe fv fp eH eL fp dV fC el gT eG eQ fG gy fX fJ gy el gx fo gn hi eK dy gT dM fL cF eQ gG hl hq fT fo dE gf fx eU dN fF fo gp fT gE hm fs gg gK eJ hf fB ez hn gg 2 gr fH gJ gp fE er 2 gw eM hl fy gC gf cM ft dY eV gS fa er dQ fs ho gL gJ gu gs fZ fF fS hp hn gh ey ge gx dE gr hb gO eh gr dx gf ge fl eA fT fT fR gR ez gH fl gJ ez gv eH ez hc ft gw 2 gO hm hq ht gc fZ gr fT gg fW ez gI gp eV fa dT gI ed hf dz gJ ga eH gO hl dl gz eH hi gw fQ fo gc fN ez fV gC gA gm hr hk gg gJ hd eP dX gl eQ fz eL gG ga hn gK fH gb dE gN 2 hh hr hs fO go fL ho gt ht gj gB fx gU dX gU fT hu fT ez fW hu gE fO eg eG gY hn eP dE gO hk eH ez ez gP gP eH gG gP fd fv dE fC dQ ez fU fH go dK gX gs gE fw ht gn gR gE eH dT eq gI ez gH 2 eH eH 2 ez fD 2 ge 1 gr eH fy fy fl fl gE fX 2 hj eN fu ft fd go ft fK eP eG fk eR eL dX eD el gU fG el gd gP fw fP dG ea dl cT fx dc dw ed hd gQ gd ef gS en dL cC eh eW eH en eH gV gA fa gh hv hj ez gW fV gr fC dy eq fo fI ey 1 gl fG gx fc fz eA fC eK fA fw fE gc dn dz gP gr gw el fE cS fb ec fd gq gR fG ds gx ft fo fl gt fB gZ ff fd ez gD hw eu gO ei dw fx gr ez gH eV gg hx hi fo en hk gv eP gV dE hj et gH ez gl eb ez gg 2 ho hn ha fF gP gi gp dF fW eV fG gR eK dH ex eK dz 1 fb eG dh dI dU fB 2 gS eq eL ds en fo 2 eH fH eL ga dl fy 2 eH hx fo gU ht dQ ed en fi dG eD gN eR gk fc gT gr 2 fO fx eP gg hz hl 2 ez hs gP go cU dE gy hh gD dQ fC ez fO fF gS fy hy gq 2 eH dY fJ hn gG gv eH ez eq ez eH gG gv fG ew fM ek dE fE gh fN ek eR dE du dS dj dP dA gn fI fN gL 0 eT fo fH gi eg er eM ez fe fh du eH gS fa eV hb gY gF gn gJ fo fm ea hg gO gd gJ fw fk fp dY ez hy ez 1 gc eH fQ fY fp fW gp hq gI fD gq fl gr gR gT hn fy gG dO hf fa gz fY gh dG gf fu hm eV fh fW eD fJ eO ez eK eI gO eV gd fS hc fa fC eY eY eJ eS ff eK fl fI fo hy dt gH eH dl ft ff hv gw gJ gO fD 2 dI gU fl ft fX fD fx fl gS dj gi fp fI gf dE fw fB gj fW gP gS gH gD eq hk hh hr gi gG eH eH fW hc er 2 gE ez en eH fY dM fE gt gO eV gp eI gx fF dK ha gk fn dM fc gg gr gu fd gd fU hc fL hk hc hw ez gS hu fI eY fL ez gh hr fa ez fC gJ eP ez 2 fB eN 0 dV fv fa fc fN dE gO ez fl hu fl gS hx ha gH gk eP fz fw eD gM fv fC hx en gI 2 fH hd hf eU eg gt ga eL fW 2 hm fF fp fn fA 1 fD fT fD ga gp gb gw eA fU gt gl fB hm ho fy gP fk fG hc gy fn fx dE fC et eY gn gj dv bX cQ cG df he fZ fG fU fA ev fQ eQ eJ gx fj gP dM fE dp bn bp dD ey ed dH fo fJ hf eP ef fd eQ dW hc gm fC dF fR eJ fq dM dQ bX bk bR eR fc eV dT fC fl ht gY gv eK fH fI gk gJ gL fW dG fd dJ eB eg dW ek dK fh dy ef dw eY fQ fQ gZ hx gm ec he fM dJ gm dX eu eE eS bQ ea en fG es eD fR gl gk ff dE dI gQ fk gb dc cL eT eV eQ fd fg dV dR gk gN fE gZ fW gG ez gt gt gp eH eR hb gJ hx gD gG gD gm eK ef eh dz hc fc gg ez fN gr gi hi fX gR fl fW hr hc eg fJ dy gh gX dQ fv eK fE eI fD fO fC gf eA fU fB 1 eM hf fJ fQ hb ez ez ez gH gw eH ez gZ hi fS hg fH gF ed gT gO fJ ga dC dW dD fn fS gf gG eQ fX fD gt eM gm gn fb gr fl eH hy gA dy fI fu gs fd hv gQ gx he fY gN hn fa gY el eb gx eo dw cY en fb cC cu bS cP fr eZ fr bS dj eh fw dA eZ eN cS dA dJ ew dD ed dF fM gp eU ft gI gt gR eO eb dK eo cS fs dS gw fy gk gF gO dK gk ez gy hi hy 2 gO gZ ez gI gq fO cV gb ft dT eL fc fA gk gm 2 gf fZ gI gm er ez hw fa ez go fI fZ gl gC fT dH ea ev eu dL eQ fo en cv eg eq ht hk gf gm fp fH fC gp gV fz cE ds dW dR dK ei dU fN fx fH fV fN ed dQ er dq fz fB eN cW cJ eK ev eu cY ca dF dV dO dm fM fP gx fl ft eq fg cD em dz dS gw gb eG hc en dI dG fO gB eM hy dR gP ga dM fo dT dJ fg do dG fz gt he hu fK fg gI fx fM fl fH 2 gP fF 2 hd hx gO gT eJ fa eM gb eR dF gP fF dX hc dk dP dP cQ dP ge dD cR bF eH ey gP gR gy fH hr gj fV hy 0 cA fQ gJ eV eJ dM fw fs fu gW fw fv gh ea ga eP ez ez gF ez fS eM fT gK fQ 2 fN fc dM gI dI cW dk fh 0 dW go gP gi eY gv 2 2 gp gH eR ez gG hz gf dI fH gc fI eW fE fN gt fo hc eY gI gV fy el ga fy ho gb gs fS dT ei dv ec eq gm gS fx fU ft fQ ey eO cg cr bM bV eB dS fe fB dx cG bM bq bo db dt cd bE bo cm eU dM eA eQ fx fc eU fI gv fZ eb ed hf ht gR dX fU gd gc gb dY eh dA fx ec ej bO ca bb cr cH bh bL gj eR gu fQ ei dz eq fJ fK gL fM da dX eT eJ de fB eL er dq bX fA en cI eK ga dD eI eV dE do fC gU ez gE gI fW go gH fX gD gs gF dU he es dN fd cP bt ck cG bL bi U J U eI dS em dj dx eB do ds dv eX ej dh fb P ce bn bJ bZ bP cg J bA B bc bE N G bv K h s dk cH fr bW ee cZ U K u bh V n y bB Y r bG cr cU eC dm eq es hx gv eb dE fv eo cQ eK cQ em cj cK dd dk ea eR fA dP cw cH W bk dm eD ei gg dr dp cy dm fc ee cu cU cM dt ci bA cb cs bX da eS cS cI bG de cY bN z l bw dr cP cC dc cY cH cI R cn bW bu ca bu ci dP dF dU dR dD dc bW ct ew gJ gN ha fb fp bP dB cr cD bV bI Z s w dJ cH by bB bw cY cp bZ x Y cg ct cN ce bO bC de fm dX ej bX eR es eJ fU gH fF es ej fQ ei fH fo cU bU cQ bP bT bE cg bk bJ cs bW dh fr fA fT ez 2 hw gA fS fT ha eG dY eF eF df dW eu fD eW eW eD dp eB fj bg bG cZ cj cN cI S bC dX fq dz gi eM ge eR ey fs gN ft fN dK en fM hc dK en gc gX fX fI fD fY eR fX fI 2 gN gx dE fj fd fW gu gb dN gJ ei gg fJ dD gL gl hg gq dM dI gX gG ge fV fc dN dN gx hf fs fD gP gf eM gJ hj fF fp dy gL dS cU ei fh gc fF es fI ed dz ed eK dK fI fs eP eY gd eL fN eV fF fP fn gd gc gv hb gD eN gi fK eU em fz fi eq gp eq ga dE gI gx gU fE dD do cD cI eo dQ fm fi ef fi dg eo cK do cK cu dn dM fA eb dy ea dy dM fL dS ej ea fc ga gO hf gH fC fW fo ge dK et 0 dX dC eU fh eT ed fD fD fa fF he hs hn gm ez hu hh fo ez gI hs gA eH gV gh gb gq fO gt gM ez eg hh eR eg eY fY gl fE go gW gq gW gs gs gk gJ es gT fH dY eY eb dM eX cF fm dv dD fu fD he gV gl gT gN fW hd gi gl fX hq fT fy gt ge fy fs gQ eL hr fF fQ 2 gk hs gp gP gb eU gy ff ft gO ff ed fK gd dE eb gc ff dz ed eP eY dM ef fU gx dt dN gb eO ew cK dq fj fj fg fr cR ee fJ eL dT fk dz eg gf gR fX fT gN gw gV gR gM eA fR eb eb eX dI fF 1 fc ek fB fM eV gr hr gG fC fP gM gQ hg eL fE fg fs fF fG fY gU fQ gS gP gX eY gH gH dE gn dg gW gi gX dU es fX fU fc fF hm hh fQ gt gB fA gQ fQ fE fw ev ei eq ec gi gx fV ez gr gn ge hb eX gx gN fw fg dy gN gN gi fN ez fH gC fx eS ek eK fT fZ fW gQ he fa ge gl gP gJ gq gq eK eH hv fS gt fH fY gT gp gM eo eW fO gB hx fY gI fh fS gf fH fv eO dk eV ed dW gk fw gJ gl dS fb gs fC dI gG gS ep fx gr gr hc gr dG fD ev ep fS fy gO ft eS gD fW gD eb hx gI gI hn hx gV gx gi eR fW gB eg eL dU dx eJ dg db cP br eF dy dy gm gD gF 1 fl eH hr gj he gk eA gB dO fy dy em dR fM ey gT es fC gp eM gw gQ eL es dY eH hk dQ dt fg bw cL dZ eR gk gk gc 2 fW hx gT gP fW gH dY ho eb fV fb eV fA gZ ha ha fE dp fR gd eY eM eP gr fB fK fm dl eW dW eh fI eR fA fz hv hn gX ha dS gh gK hr fW fK gq gq eM fJ hl dy gi gJ gX gl fb dN ff da eI dv fM fE ez gc fy fx eJ dI dM dP fx dE gS gB fK eE bH cZ bb bw x eZ ev fr ep fi gG eN fM gF gN gk fT fF dV fv eQ dw gq eY hu 2 gH dS hx hg hp ed fN fG fz gf eH ez gJ hk 2 2 2 ez gc gE dY gH eg gI gI eH ez 1 gm gw dN gk dX gc fF gi gE hx gV gD fA fT gv eH eH gO gm gI 2 ht dR cK eJ dE eH gE fW fL fD fF ha hs fJ eN eh fW 1 hc fa gy fl gn fa ht dO fZ fO fb eL hl ez gd gg gO gN gg dI eR gG fC gm fU gh fY gn hp dv fl fg eg em dY ge gT fM fS fl fH eM hf gs ef gU gq fK fD gt gw ff fb dr fb gp gc gn fI dI fX fX gy gi gg fU eo fi dt gC gi eP gw gJ gz fv eb gw eq en fo fv fD gy gm hi eq gJ gP dN ey hk hr hx ez fW gV gg eH gS fD fX 2 ht gl hw ez gl dY fs eq gt fK ge gy fw gJ ff ec ff fo fH gt fp ey gI eH ez eo ft gI gG ho ez en ez gP fM dS gH ec fn gy fy eg ek gn fQ gs eK hk hh gc ge fJ dx fH fF ed dw ge eV gg eH ha gt ez gO gy 2 gV dK eM dG 2 ez hn ht gX eM fH eN fD ga eO hd fl gi dx dN ft dq gs fG fv gU ek ei gL fG eG he eA fy ez gG gr ez eR dV fT fZ gV gP ez ez eG eH gv gS gE eM dN dz gY gJ dR fT en ez gh fA eT dp gm eN gO fI fQ gJ fa fy fB dE dP dQ gl fN 2 gn ez hr gI gP gm gm eF fA fs gi gv fx eQ eH fO gc ds gc hc ec eM gO hs gO gl fp fK gb eP eC fE fd gO dt ej fV dV eq eH gO fe dU ez gK fO gO eH ga fX eH ea fW gi gv cM ej dK hu ez ez ej fH dl hc dN fn hv dI fa eq fF dH fp hk gI ej gl 1 eL fW dY fD eV eM dG eP fz dG dQ gb fV dY hl eH fa gE gm eH gH gC fQ eb fQ dG dQ eD el gh fa fb eY gV fx hs fG fH ek fF eA eK gb gw gR gI hj fo fc em dP gb gj eG fp he gr gp fE fo fO hn gc eL fI eL dB em ff er gt gt gx gM fO fQ fu gd fJ dc ev cG df fU gs fY el hq eg dU hu hh fF fR dP eM gi ds fZ fH dQ eM hu dN fL ds fg eQ do fC dg er gc gz gv fo fW fv fD hj dU gr eH fS fs gl dP eG ez gc eV gJ gP fp gg hh hf dW eb hg dY fe dK gh ed fB er eO ek gG hd eW gq es fC fM fw fh dl fH dY fA eI gG gf di cE eV ek fE ek hd fO gy fx eZ fA eD eG ci dv dm fL eX eT ef eY gJ fn hl dn eR ht er en eq dm ee gO dK ga gs bV en dw dL ew ej eu dG dR fT ft eH fU ez gH gO hc gm fw dX eD fU ew fc fq du dE es dJ ed en eo dl ei do 0 ew fJ dS fv fe gJ eP hy fy hk gq dE eV hh fu fF ed gm gG gc fC fO fw gK dM fA fL dM dE dI eN fo fD em eG fl dM gg fo eN gc er dE gm fM dY ec go eP fD fS dH fJ go fH gq ht fE fz fQ ed gs fO fU fl fc gb gq fj fG eG dR fI gc dG gg fN eR gJ fH gp hk gv dJ dR dz dy hs fW gg ep hk fO fC dN fX fD eb eK hv gY fI fj fp eb dS dJ er gS eM gc fa el el gc eH dw dW dW ey eR fw dQ fl eI fY ho fy 1 eL fC eN gq fh fl ft dj fW dz dX ed dA fI ey dU es fH gj fX ht fK gx 0 gg gO gz dl eW gv dW gH fx gK fl gf fH eT eP eD fE gJ eq fM fl gP fa dM eK eg gx eV fC hj gt fC gw dw fX gX fu et er dG eo gR fj fI fv gV gg gi eb eD dY ff gg gN fB fF gs de gc 1 gZ fv eO eg dx gv hc dE gt eR fl dY eH en eQ fH fp db eU gf gn dG fs fn gq et fb gQ dI fV dG eY er fM dp gj eH gG go fX hs eG hx fU dU gq fU eA fI eQ fP 2 hq fT gh ha fQ eJ fB gJ fg eK fH hb fF gl fE fB fH ga dQ fo ck gc ez fH fK fj eX dX ek cO es ep eH 2 ei fX dN hs gJ fy fU gz dN dJ ey fI gg er eK fe fz fp do ge dJ ej bS dN fK gs fH eQ gm he eR dG 0 fU gx gk dU el fb eM dB em fE fE fF ew go fe fA gg eA gw gh eQ fz gf eX eL eR eH fX el fG dN gX ef eK dt fs fx dD fp gg eo eL fU cf dA gc hd et eM hn eJ gp hl fD gr fW eq fC gP dN ct gZ fE gd fb dw dd cp ei eC eg fb dZ ej dz ck bq dD fc gG gC cV fY dX er eD fE fu dm gd dv fS el go gX fC dy fw ee fz dG ei eO eV dA dp dl dO cN dl fM eX dx fg ei eN cJ cQ fU ep eu bZ cq cf bO dx bU da dA fy fw dV hc eT fp dO dr eC eT eg dR fZ fL cz dr ec dz dp es dN dD fO gf dz eD gg fA eZ es bO cC cU dL dp dt ei dC dc eL fE fx hc fV ff dG fs fP dQ dm dV bP dU gH gI dk dE eQ eX cp hn hs gi hp ee dO bG fj cu eT cP cM eY dp ey eQ db dM et fu dG dk dU he fq fN dw bx fC dK eJ hj fL gO go he cg bY eB dU gh fC gr gm fg gc em gh ge ed eg cW eI fG eq fp ed dz eG dY fC dy er bV fg cS ey eI eI eC gI fx fw et ew dv dZ gl dG fg dS ei dp fy fG gM gh dM fV dE fG ey eP eh eG eg dL gc eQ fc 0 fv bO fu ee es dU fe 0 ck el gl en fw 0 fB dL fG fI eH gm ee fu fK dQ fn dg ga dK ea fd fQ eK fE fv eN dm fL cp cd eX dc eJ dW fq dw gc dk gx fC gr gN gk fd ed gD ec dz dW fp fV fb dE fX fe eF dZ eE eR ea cl fE dE eR fW dy em dm en cJ gJ gc da en fX dM hi fU gl fn et dz fG dR fB fH gb er eG ds fK fq cZ dF ea eA ej cE eU cV fm cz dr N X ci cC ev eR dU bQ dX da cC eT cg by bP bP bV ev cG ey dX en fe ct dg cP dc dj fk bX ee eN fz dj fC dc dc eY eQ fe dv fq cz bQ ep fA dV fV dE dH fn dU en eV ei eY fn eb gr fL ei de dR cj cY dc cy bc bX bh A eE cz eE cP fI fL dj fn ga fS fb gl dg gs hc eR eb er dw fA eG ec fR ee dL ev gL dB ec fB gu fi dv dW eK fT -1 fU em ft dG dy eY gB gp eo dm em eC dT dR eg bX cT dq cx cV eZ bh ct cM dQ eC eZ dB ci cN eE dc dn cQ eo cy dP dK fe fg fw el fJ dK cz ev cI dD ds eX cH bH bD fk fC bO dd eB cQ eU eR ct df bV bJ dw eS ek fD cj cP cD fm eu db dN cQ bX ga dV dA cV fg dn cN dR eI fU eK ea eN 1 bx gC fM fn hl dR fn fh eR dK dy dr fi gg cR eV gs eL et fF fo ew fU fE gd eX gN eO hh gi gm gE fF fA eK ft dG fD fx eM fb fY dv gs fl eP fY fJ fh dg dC dL db dl dp fe dy ez cQ bp dR cE dS cV eM dq cM cr cJ cK cp bC dA cF eT eQ fE fd fO eP fE eO dL dK dV cz ef fn fA ec dQ ev dh fU eq ee dH eG dy fU eg dA eU dv du fb cg eZ cV dM cg cQ dP dd eo dW dY dP fB fA gg fl dr eO gf fl fT dc fn dP fb dv ei dm ea cP et eS dN eb fT gz go dI dH fB 1 eG hf bU dm dM fk em do bm dd du ew fP ek fi bn fT gd gd hc eq gU gS eR dK eN dZ eX dX ew dl cI fu dZ de fe df cG fu eI eo cL cP dU dZ bK dm fq dm cI eO du da bU fL 1 dg dW el eq cV eS eZ dC em fv eF es dN fx et ex eU ch dQ fz eG fG cP eW dO gs cS eR cY do eB eG dg bV dW cS eC ds dV hf fx el fi ea eJ dV fj fH eD eW fy dc eV eJ fQ fu fK fs ex dP ct cP cZ bB dp dS fp gS dP ea cz fb dp en eF eD fa fD dX eR dI dC eT fe cG dj do eJ ft ge fY eg eL gt dU dV ge fg dQ gO 0 dL fn eV fj gx eA fF ew ff dX eQ dG gh en gB gh gL eO gn dE dy ff gC fU dT fk ey fz ec eP fh fV dK ho gG eN dI fw eR eH eR eg dQ ds dO dp dH eW gO fo gg em eO cW gT eH eQ gl fR fd eg es er hc eg dw dJ dc eM et fo 1 hn gs fC eG dN ew fI eg ej fC eh eG fH eO gj ei ge ee eI fI dA cU gd dR eA gi fs dF fc fJ dO eI ec dS gj fV ei dl dg ey dE ey fi dw eX dP dk cS db ga dM eW fx fw eF ff cV eu fk fS eQ fQ gg el eQ dt en gj gb ef fx eb ee eh fJ dN fE dR eg fF fP et fs en dC dI gf dq fK eO ei em ek eq gv ez fy fp hm fK dE fc ff gv ge fu de df eF cF bh cy eS eX eo gm fC ga fn fR 1 fv cT eG dD fm dw X cD eX ey dU ga gy dx eK eU ef fw bx el fv eE dH fj eu eW dx gv gc fz gf eQ em et et dJ cT cW cY dq dy eT gf fF hx ha et fi dl fG eV dk eJ dD eq fO fH dk eR gL fI fR ew fh fM dQ dt eR eZ eJ dT fY eW ea eG di ee fN dN ff dS ed fT fV es gB es dm eT dP dS fC 0 dE fI gd hp fx ft eA gn eA dK eR fQ ge dI gp fk cz dE ee eL fU gB gP eA dJ eu cJ eS di cQ cF cB cy cS eO cJ db de dO eQ fE dj fl fc fs gd dB fA eC cU fP dx eV ec gR gv gM fF gr gr hc eO em dS eO dJ ef ek cP cC ci cF df cn bW bh fi eD dM dK ei fP fq fQ dm fB fw dM cY dj dR ed dQ db fw eG fp gi eg dC fx cF eW cS dP dH ea cA cC cW bK cI cW df bJ dt cb cu bI eE cR dh cr ei fe fI fT dy fR dN 1 gp fz dr fd dJ eQ fa 1 dG eV ef gx fD eq fb eU dX fr du dk dV 1 eb ew eR eO el dy eG ew dE dY eh gd hb ge gB fM fY gm eU gI en ft dO ds fm bE eZ eW cD fh eX gH hi fv eU dU fn gP fr dw eK fu fq cD dS fi dM 0 bG dZ dd eU eO dB cu cq db da dW ea eo eK fi dc dc cO eT dj dn cP dH gk ec fV fP ed hg ez eb gW gk fF fF eU fq ds et dE ed fy gP gx eh ed fn fw dO cO df ea eu gb fc dG 0 dG dF dN dc ee eT dM fM cR)));
(display 'Stability' ^(a:0.54 b:0.37 c:0.76 d:0.49 e:0.67 f:0.47 g:0.73 h:0.69 i:0.71 j:0.55 k:0.78 l:0.6 m:0.84 n:0.66 o:0.57 p:0.59 q:0.7 r:0.29 s:0.39 t:0.83 u:0.88 v:0.36 w:0.77 x:0.56 y:0.4 z:0.51 A:0.52 B:0.86 C:0.58 D:0.42 E:0.53 F:0.68 G:0.65 H:0.43 I:0.75 J:0.64 K:0.63 L:0.44 M:0.41 N:0.72 O:0.8 P:0.82 Q:0.79 R:0.48 S:0.46 T:0.35 U:0.61 V:0.5 W:0.62 X:0.45 Y:0.38 Z:0.74 ba:0.81 bb:0.85 bc:0.87 bd:0.92 be:0.3 bf:0.89 bg:0.93 bh:0.9 bi:0.91 bj:0.26 bk:0.96 bl:0.94 bm:0.33 bn:0.32 bo:0.23 bp:0.18 bq:0.95 br:0.97 bs:0.22 bt:0.28 bu:0.31 bv:0.98 bw:0.24 bx:0.34 by:0.25 bz:0.27 bA:0.2 bB:0.17 bC:0.21 bD:0.1 bE:0.99 bF:0.13 bG:0.19 bH:0.16 bI:0.15 (b a h a k b q B c u z y w r e c i O f p d Z m d ba l e o f j n g g s h f i j d k bd V t A l m i H n P e o I C p j q o r q F e g h s t d d v u Y f E c v a j W x be w p x y D i z A d c J l x c p s bb s s B C s D E w p L E G l F w G n Q h N h o X H p E l M s n I C z K j o J a k C T bc S R K L M o p G x N h h K f C k J O G bj o z d P Q x d R c j E s d K n S e E x g f G F T j e K U n S U e G F n i n o p F N O e q x K J F K V a e a U n p a a bn C S d a p f l N n A C j f W x I p A X Y K A n G p j T X z s C e N M G E C o a A U z a d w J L h e A z q h x G Y q j V E E J g j o j S G e U a o A e K s W E X S E C e l E H C E c W W n S V J e i E p A R l S U E X G x h V f z X F p R K U W J W o S j A A X h d w n j R S o a o d L U z W h i d x C U X R A R x p F z b n K l h z f U C o p z U g G C a K K X J A V e C z g d n d l o W x o x n a v l U L j l o L A y l o d g K n p h U J R d M X h z o o a A Y D W n A S V j h e o E K U q o a a p C i R q g q s a M p A A N j K K j W e K q q x z G p J e h K a h K d j D U V A E q X a C l V E c S j e e o M f f L M V d z x V a C L o d H A z e q F h E E G K C z E I K S j H A C p j C G I d W C z J X o f R E J R W A l l f X S V p W p v p f x g o p l g e l q J q R E E J E l q G p x n R o l Z a y f f b h p f o M J A l V p a z R h h e U h A F F p c c K N z e N C E H E c W a W G e G h x W E h J I A A J k h p p w D o N a L L f h p e S o l F q E C D U n G C h o C p J w C J w o n j h x i C j a l n c d n x i U G p w h n q q F c p o W a e n W g G w V T l x j x x E K z n j y W J g N U K C j W n p o Y W z R q Y n n k K o W q R U i l K G e J i x Z q H x q Z z F C N Z p E j J O W G U q H K e J O G Z o e h h I c k w G w V W E I a z o l G Q i l O P i x h C h X J n p J i o i E E n o V W G E o q G ba G J e x p g k n F U d N h q a g C J h k N c I E f ba W F j N V j c Q c g O Z e l I W Z Z w a h a q U N k U N w P n i G l n c l l c l n q l n n C G G n e I n k i i p P F a q J I g g N p I Z O O O N t u w g g F ba k Z ba q W a F J p m D h k P x Z I q k c g O e h n U e w Z Q m c k k i q e ba Q ba q n g bb O t P ba O G c F C Q I I t k u O w c Q g i Z h P Q I F C h bc C Z x k P i Z I O U U bb c ba N q G g G c e Z C O g i Q m B i Z I k w g Z U F C c c a k k Z d i O g ba G u e B n K i Q i g w g n P ba G m I l k g ba e P Q ba P bb z c J n i w e N C c Z B ba g c i bc B P bb Q m O K N g t k N C O J bb t u h bg Z P Q Z bc c I w q o F q Q O m P N ba u W c U q k q h c Q m Z h u h g t n u m t Z l i bd g g ba i O e P g I Q O i O bb U k c K I l F bi t e w ba J F P k bb u bb a a bb bf bb Q Q ba I m g bb m N g Q i O k l F O bb m u w q bc bb F bb k t ba ba N q g c bc P z P ba J k k e O c C k be R J bf Q K T i ba bf F k U m ba P j K Z g j m g x ba U k i e Q t Z I B k h g bb i O i t Q P F u Z ba g O J B I u P I g bc ba m Z w O O C B i bf a E bb R B O O k h m bf i m t z bg t m u U l Q N Z bf bb I o c bh w Q x q o i u c i bc p t p O t t bb I I t bc O B u bc e P F P B J i t K m l bf W x bb bk m p q k bb U Q N q h u bh B k e G B n t P p m ba Z t g m t C h Z c ba w Q o ba k k ba O bd C C w P bf p J bc bg q l bb c d l d P I N h u B D c Z k p ba U Q G bb F C be J I k bb i h P ba P bc g t X bh t f u u F P F m q P i I h n i bi u bd J bf k bj bp O p k N bh p e k Q i h w N m h P t m t Z G k R p g i h H e k n g Z bb n ba bb g N bb K q w O e u x P bu L i l e i L u I p Z u O J G p bf bh J bf a c k O bi w O bd Q J Z P bh B j O bb N P k m q i N U N bb g bd X bi bg C bh k w S x S bh Q q t N q X m i z t k C bd R g N q P P I m u O P w bb w e k bb m ba O g bf m m bc G bl B bk j B B o bo bg a q t m w J p E V F e bb N l F P c I N k g w w e E B z bb J h E e k g e c x K bb m G x E j o N P q i n t Z w K Z bb w t bh ba F q ba q m c p h X X i u k z bb I G G g Q E I q F F u O N i m P q Q g bb u bc c J O O bb bf m bh K c N V g Q bi V k N z bl bF o c bb C P q bk ba I e O L j q E bf m m a G J i q i l c bi Q u A bh i g u O J J n A ba t bh a x I P k n t bb I I bc bh z t n X Z O bh z j w bh N C n q w C P O O Z u l a br e G S V j p ba e e Z g g k U bb w h bb B m n m m I l C e k B i Q k n G c e a l A U k q O t n i O B Q g h h I q G I I R t bd bd bc n n bi P bi w e g t z J F k O g P O P u w n P N O Q e bi q c bi V G B c N g u c K Z k g O h k q I c l Z m h Z n g g q k Z z k bc h bb bi W k C l B a N bb H bc G o m m E a bl W k P q O Q I E bf bb w P Q B G g I n F m bb Z n h k I w h c P P Z u U W u t k u bc bm M m m q h B c Z u m U m p P c O l bb w m bh G bh x ba u w c t B m x Q bf ba w G l o n w c bb A Q c t K F h m d f x V Z u g G N m F I l q t Z u i Q U h bf e F bb k bk Q u A ba k F bc O q i W G m h q m e q P G bg w bi bm bn w bb i k P l i g O bb h O bf Z Z y I O P Z Z o i O m q Z g g J Q Q K g l k ba k c t P O F o t ba h k c k B bi bl h B e bg ba bg c J c bc q q w Q k Q Z W B u e P A l n bk bl I C y bd bo bh I W q g bb V q K bf n w bb O t bd B bd B q h k n I O U bb t I m bf z c h j bf c e U bd bl bg S x i ba S B q I h k t bf w bc J ba O I Z k m g bc k G w J A m C t w i q B bi bq v P I bf i bh h q k Z f u e I n u bh a x J n k q Q P bg bk y j P Q q Q g c G J bi G u a g n O t ba N Q bf O Z W k C Q Z I ba m Z m B B g W bf t C bf k G I w I m k g e h P bd G x N O l bl bl bi q bf bd P O ba E Q N U B bc c k w P k l m I G Q c bg q q O P q W s m Z Z q t J k Z L I E a l w q Z h bb bh bb bb h n Z bc n G g q c Z P bd bp e P Q G bb k c U P Q C C p bc i u N F O Q e m ba h m f k B B Q bh k u c F W P Z t g w O I e bb g bq bk bl br h J A be bl F r h j N W G bb L h m bf ba bc M B O bq F ba h i W N Z I K B bh br w t k ba bc e ba F j bf w q l Q k t t O k h bc e z Z Q G k Z q I Z i bb J bi Q c B I m l e m B i N bh B bh bb f g Z N h a bf i bc w bb i bf P g P bf c U bs t bo Q bI c L bs o bg Q g G I J S J bl bt x bm C bn d bc P h h i O w i m J O k q bh l k K w bi c bh P h u Z a P P c ba c i n a bc Q J Z Q G c u bd O B bi Z q Q U g N n J g B U J g u bi g bj L z bc e t ba n t w N G O g d c G bi C Q bq K k j i P w k K u bb P w k f d V F B J bh bf c bb N u u u c G u Q x Z P J n k I c N ba I O bi l e c bf u bf g Q q Q n w P O bg h R F J K G k k k F t Z Z P g bb c Q n e o h i j O n bt bc bz v u i W q i Z Z I bc g P bb S br e e B f bd k Q t g d ba O i p W S t ba u O t J c n h c bc m l q B o bb g m C I bb k Q bh t bf bh bl f bl K k c bh c P h u F P bg bd n C B bb q O k i N m B O O m c m u k w bf O e P w g t O Z bh S w g bc G p k i t k k P bg o N S i bj bo r i bk h Q P h g Q D Z ba bf c D bl c z Z bf P bf t C G B bf O l N M d J i X Q q h n k e bc m bd j u q O q o N l u O ba X l h J h q B k Q F N q q c F C P u ba U O c U P p c bh e O O Q w h I Q O w n Z J m q j p U G bd N w J e I E C t m ba bh I w k K g W k x P bd I bi bg w bk bj bc u K i q O O q G m V c A m bc O w k c k N k I n ba p Q q e O m N k m bh I P bi i g B p c w k h B q bc I B O B h F bc N bc a l ba Q i h bf g u bf t T Z bd bq bb bB bq bH bq M bf ba i i w l Q E p O I p Z p h U x M q B x r bu bm bc t w p G K e g O K O q i Z ba O g k Z k e x d C O m F J m bb h a J bh k be X e h P g F P w i w bb e I w u bb V bi bd X e I bc j W n J p j bh h m F t h n bc P ba c O N m g U x p n c q B p bf J U u p J n c bb Q P h N O k O w m bi Q m O G p e m I Q c bc u g u P w P C O q F u C S bq bw U m bu g bv ba bn e g h bc bi I p x c x N bm bv bv bq q g J g c I e m Q I u J k m u c c bh bh c n bb q ba t N O G e bc bb g u l P Q K z J t J w K bf W bd Z V ba bw I bc m S l z j w Z a x bc bf e U I ba a N ba i n P i bh u a bi G bb J bf ba W bh e c k t w L O P S bi bl bA bl br f T L J J e A O P C w n k q A Q k bg e bf bh n bd G k bc k Q o m q O C E x Y bx O a B C Q j w K bb N c g O k K g w R d j g c ba t G bi Z bb bb q O B j U m T bv Q I bq s bg L Z Z k q ba I m B c Q I S bh I f A O T bi J bh Q n c Z G bc z t bb I m bb Z t p P I P u Z B O N I e Q k ba e N h G P n w Q F bh g P i bb bb w K z k bg bn bg bk s bi t bc N F f bh bg h D t bi O bh P c p x B bc i J U N O bb bb br a bc bh bg a h B bf E bc A E Q P Z F O P x K N F bh bd ba B Q w ba h P t g bb ba u O w x h J k O k c Q m m w c e t bf bd g l t q bb l c bh o E J bi L i a u u Q K k n q k L J k t k bf N c bc P F Q W G Q P Q t Q w t Q Q bf m W Y bf n n i I f g h c J g bb I P J O B U N W h N o Z x e m u m Q q ba G P bf bc bb q h B o I O bi bh t P k Z B ba m O U bb bh B bf F bi ba u O c G c O i bf f bg ba bx i by by bk g u bb m F F h G N j bf bf N J G bk o W L L t I ba m m u w bh M v bc N P B ba k g F G H bi bd br bx O bc E i Z bc f k U o a X N bi Q X Y w i ba G l ba Q h bh h k E g c w i i q Z bb bc t Q Q N bl Q t w q c G bb bb t t g u q q Q Q bi Q a bi u t N m bh t g P c bi c w I n bd bc B bf g i bg W bh br bf bg bc m N bd K m bq bf bl bk G br T Q n P I Q q e Q c Z N P t E u G h J l Q m bq q i w p ba P bq u t bc bi bh bg t u J e A l a a ba bc g x bi bl J d bh bC P d X bl V bm y bp t bc 0.11 N C bf S P a Z O E bz a D C bd n h bc Z K P bl G R l t t O Q I bb I bg ba J Q U k u bb bh bi l bf Z t I w N w I I bb U V P j I O Z B bb Q O u m Q B bi bq O M o F bE bq bv bg bg bl bl O m m P Q Z bc n i m k O bb G Z q P a bq bi g ba J B bi k I m bg B K K bq bb N bf bi bt bc bD k bg bm o T I W n W K c f C bc o G bi e f bb c B P O N h h Q ba Q Q Q m P e bf m i c m ba n B bq I t x p m c Q bb ba k Z bb m bb m bh k bk B bd n z Y E I bq N K u O c n c W t x bi Y m B bf z l bh F bb t g c w bb h Q t bh K h n L Q c Q ba a V u O Q x bi O Q I l u o Z k N B o P bc t g P A I b w x bA bk bB bk a S R j Q h E bd m G G ba bg j bb bl bu bl h bf q t ba N b B H e l q i bb bi I U M U bl X O t I k F bi l w m N B bc Z w Q ba a n w p K k k B t w P i t u ba B O bb bd bl bd bl bd g B L C bq bb bc B N t Z U A K G bf e D bb d K bq k bb n q O Z H j u bf w bi o O bc F Q g u bh h Q m k V bh Q Q P l m bc X F P f N h e t x h i bg n U x q ba bh bq t z C k bf c P Q O u J I u e O bk m h B C I bb bh t U F B bb Z a G g O t k c bc u bb e Q A bq n Q O Z B O m O k j Z J bf i n t bb B u bd q F I ba j w ba e a l W g bn bl bk bv bl bf l bl m i a bh bb w P Z Q Q F n T bi bi bh K m I ba h ba ba q k a j bg U N k bf q bg bd c bb g d bc bg bh I be B I bh h k J ba q h P bl I N N O N O Z t w ba m B Q u O q g d N bd N g B n c bb q h G u K t bq ba u d ba bq q br E s bb bl bq u G q e A g k w ba bb bc h i O Q F l e j s E bc t z B e g I P bb bb Q B l Z t bq F N bc h I E j bB e bC bs bl R be T bD L bg F bd bk P O y N Z k C I I L j P y h q bb br ba f r w bd J c n bq k bi Z w F bi K bd P x u m e I I P F t bc K W M u bb W bk O e n bq e n i u N K bc c ba q Q G w bf bf ba n bk bi bc I bh bc bl O bh c B bq Z t ba N bq P e m q bv t o bq u O K bc k N m e F m bf k i u bf t u N bc bg p bh f P z u bf bd bc bf t B S bb B ba c i t c Y bd bi m p bd F N bc bb bi c Q i P bi Q Q bb K Q P I c Q ba bq t bk bq l h E l bd bi c bb J a I Q G e e w Q bb G h P N G P ba bc bb q t O F B t Y K bo bB bE bk e p O i c w Z p Q W c P u m P h g t B bb h O m ba Q h bb n ba O bf I t m t O g i bl t Z bg K O z bk u Z G x z bo T k bh bd o bq B g U Q E d V Q bi P B bq C bf n bq u i B g k w g H bh R u G bi bf bc F q g Z B bd d bk A E q bk N R O J p ba Q n c h o c u q z w V bm u br bq A I G y l R k Q B n B n c w n m h bf p P e Q G w Z K e U k bh e e bg u bh l k Z Z i B O u k G l p u bl bl t bf c m h bb bd w G J U O ba I F c n a bq G q U h bc bh N h h e bb i t e N l q ba bb g t Q i t t Z o y bv bk b bB k m bb bg X bk bf h U bc B U B R Z q bf J l F W ba N u I G F g l Z K g w g B F bb bh P t i t I i N m W V n c y bb bi g W bf t P w Z J O bh q j P O t bc Q O bb F I N I c F K bb a K l q w K k D t I l bk u c N t B H J c bb g bc N i t q C p w W Z R J o O P j bd c k B q h i e i I Z m q F N P Z N bf e h N bb F c c K Z Q O B n D d l n R bc A c r f K bq bl n h P w bb w P l F S U d by bt bl t N bg d q g I W E K e e N V q J bg c k c bq bg E bC A bd B U bl F t bG t B K bf e bb E bf t w O s g bc bm ba K W R bs b bF bi bG a f bv a Y c o bf m G u l i Q h o N e G I k ba Z ba U e bl Z j H bk bi i bf c bd w k ba bh B Z c i F i h I B i I c N ba f I bh e h bh w Q N bb k m k n k Z k P k Q B p Z P F bb bb B h bb bd O g I c h c t e h h u bb t i J W j N p bi bd U I bl Y ba Z L bq bq Z K O bf Q bf w O t g bb J bb bh h u m bb B bl w f d G o i t I N N q Q c O h h i n t G G C bc W F W P B k t m k t w N n u bb N c P q B bb w Z bf m O P t t Z B u Z bl G Q bg ba bf P I N bf n c N bc w h t t Z bb O i t x P h bb P c P I u G h bh Q g K k ba F h O u B bf p e i C d h t bh B V z B N Q h n g P ba J bb P P g bc g e m k c w k F P m P u p O m bb I m c w ba k Q k Q bb I m bc ba u N F bb B bb N u m N bb u k N q bc q t bb c t c P u Q P u O t w N O t t Z O B ba t m c P t m k bc bc bc u k O c B Q ba bf g u Q bd N t bf ba i i B k g P O O N w Q c w Q w bb P t ba O I bb I g c P bi g I C e bb I ba bh P h k F J i u m t g B q P B Q Q O c Z ba i ba K ba I P P t P bb u c t Q F bf bh u g t m c B B bh O P t B k k w bf t bb u u P Z B Z P B Z bd Q bb t i c k k t c g w P B N P O ba P bc k Q i N Q P t m Q c Z i ba N Q t O ba B bb Z P q bg bc ba F B bc bf O q P B bb P O I c O bb O c bc t c ba bb B k N bb m k q m c c P Z ba u bb bh m t bc t c m P bb t ba u bh B u c t P O Q P u bc ba Q m bc bc i m bb bi u bf m bb h I k ba Q B O bf Q c ba bl bf w q k I J Z I bb I N ba B bh B bb t t m bd ba w bc bc h B bi Z bd t O N w bd i bb k m u bb Q h Z t ba t k B bg Q P bb bd m k m bi bb P bb t m bf B bc w g Q ba bb u bi m m bf u bb B m bd bf Z u bf i bd m Z m bb bb bh g O B O N P bi h P c bf i e q c O O m O bc O P P bf k bc bi ba m ba g P P u bc t w bb B c t Q P Q O m u c u c B P P m bd bc m c O B ba m bb bh B w bc u w k bi m u t bh bf Q ba bd O P bc c q P h m bh c O B w O bb c bf ba bc bi u bi bh O u m bc bg bc Q Z q u bi bd I O bh m u q bb P I ba m w h O N O k O P O J ba bf m Q t q i bf B m P B O q Q B bf G ba Z bd O P u F w k N Z O q P N c k g P h I O O bc Z e P c c c bb g g Q B q O Q t Q P O k q I w bc O B ba Z bh O c c P m bf O ba I t k w k bb Z q u G F k O q Z g k bb c O q u i B t c Z I P k w e k bb P N bc I c k Z i w I Q t u g w i w I bb g Z q Z w w n u a I P k g Q u n N e g n m O Q I w P k N k F ba G k B c m O bd q u K i I P k m l Z Z Q ba Z N F ba n O t h Q bb bb U P q I u O O q B J h F bb t W P m I w k O k q bb B B w bc ba ba P B k ba o J bf bc i g q i bb h m F c bb bc e I g Z l ba w C O bb F bb O A O g J bb G c k K c u h I Q t h i G h q i O u m w bb O Z F g q ba O i k W I t w N w B l Z n P G Z n bb Q k m I p m C Z Q n i f H bc h C K Z W o Z m bb a I Q e N W p e Q h P I l K h i N B e Q q c B w k h J w m i q B s n c U K C B W ba I i g O O g i F bc q k c P t c u k j O K w w q e g U bc Q G I a e U c J P k N I k w h bf N E k h U W k f z K O bh be t ba t f O K a B U bb P R O J m e l m I bc h c t J K l q Q P t O F J G B t bf K Q bc Q ba q I J p m m Z B Z O bb p I Q J w g I P e U ba i c m B q N p w q W O e g q Q Z q q p F m A ba u i E d O bc B G bd bf c W J B k m g J h m U l k g p c t J m o B n G Q P N G e q e M e I P e bb q bb x I O bc i c O bc bh q ba B c O e I e O P K l I o J g k Q o g w t m i bb h g B m P g i g bi F e G bf z z t N ba O p Q e W t U Z bb ba B e ba q k O bh F k bh q m t bc ba U u k bg q n t e P Z w F k C c u bk c e t I Q I o bi j c t h w I O c I k B w P Z g J k O m O O bf bb g n K Z ba Q O O W Z O w o h bb e p B O R B E J I bb F A U Z bc P B Z O G N F q t N t z Q g g B ba ba e N ba t w bb m m bb ba bb V J E bc O n U bg k h Z t ba O m t k I F bb I bb bh O N j O O bc bb O p B bf B c Q t I x t h J e n w u i k G p P O bh O k bf B t Q F e c o w O q P n I e ba O e J i ba B bi V A bi bl L Q i z bf m c K t O e u bi c P bf m B O F O w g C bf P m q w C c ba C e B Q Q W ba P N ba w B F P t B F E B bd t K m O bc w u u ba m B bh F c c w bb bb bc B bb i bc Q t Z Q Z bb O P g q P m c w q bb I O J bf c u I m g N w bh bd I l u I Q bf f Q i J t O bc J z i bc N bb i bb B F K E P bb K m N j C B bb bc P I l I N bh e q i g bb Q k Z O c i I J n Q q Z I u h Q K bc P z c m I w B c i C g Z O O g G Q P bb x q m e Z O Z C g k Z G J N m Z J N Q P t bi g O u k bc k k N Z m i i g q O P c q k h k j bf bc W L N J m u S bh I Z A g z O j o ba I n P z Q G q I I w w n U P I w O I k h l m g p o P Q ba t O m q g q i I e Q Q K O h K N ba B B m Z P N N l G w g I w i l ba C m W l x N k e c o k N Q w j bb A w t ba G bb G g g ba e N t J c B bb q w i o n O Z m i w q u O bf I Q g e O k bi W w U P Q I g i Z ba U g q e c x h q I m c e Z a F m O O n e B bf h n n n w o bb P Z c bd M t Q w i B u Z bf W g t i t q h g w c q t q c h Q k bc t k h w c k m q B w m P ba Z ba K h g Z c k I c N f B c bc bb g ba h q Q u bf K m U U B c m w t n k Q Q c J J O g u bh e t bc e N Z n h o g k G w J P q I c h m Z Z F bf e bb k i B K q Z t c I Z I h N w m N F bc U P O k F x o bb c bh O c t F B h P P o Z ba bc G bi N I h n w k l c ba m Z c g Q bb w l l i I w Z w J Q U w P Z I q w h F B Z bf J g l o I k m Q q P bb g c bi t ba P q k G G h e n u t g h bc N U w u bb i bi h t bf F I i P N Z P m w G g q u t P a g k O k Z U Z W w g bh w Q N e bb g Q g k bb O h I P k h bb O F l Q t G n Z h h K P t c k Z G K Q c w O I q m Q m t P U K bc bf bb Z k k P N K n h K g N g bb Z g g B i P Q o F bh F n k Q g Z N Q k P c G J Z Q W w bb N J bd bi G G u bc e e O O N N e c p G I bc t N U bc bb p bh u k q t h B h w m n i Z J g K m P n a P U I N bf ba l q k i q g ba t h h A g W F g k O N h Q bb Q l ba N p c i Q bh k ba g I q i U k O U R Z O K K w ba bf bb G q bb q N e n m g w u t ba g I p O w m t K p bb m bf Q bf bh g G P O Q h P ba ba u g bf t j m bh k bh c m c u Z bd P t bb bf O i B t g Q ba c I I B B i m c G bd m t g m i P c t n B g c c P P k N w t P k c Q B P c bc bd o j P bf ba X m P Z Q m N bb B G bg O bg k h F bi L bl bq s bf B bf m c t B n i bc w Z x p k bc g l t F I g e w i W ba I Z w l B P w t n B i i h u Z q P bi t Q w P Q bc bb B w h F n i k P i Z t bf bq R u t d bf Q J n bc w e i J Z N P g B m Q n G F C K bg I w B I i w G i h Q w N Z bh z P bc B A n B z h c x P e O N bf I O n bh E bc bc bf bb bh i G C f N bb o a P bf Z t P Z q n i bf u B bn G bd g Q Z bd bh a j bi k ba e w c P J j W m B bm p X F K V w I a q g W g Z c n c ba I w e Z O Q w G e O o bb Q N m k u o z t U i G I k bh l ba ba Q V C bc Q W C bb bd u S o p N N m Q bc Q K e P O I Q w Q q N Z N Q bb bb N g w bc g N F P F q bh w O n c B e h u W w O k bb t t F W J g bf K k K t t g bb P I ba G w i bb Z P K O c Z J l t g bf P Z q G d k Q w j t O Q Q c t j n u n N o U m w C V K Q c bb w Q q G J Q P u h w bl Q K B U B e F e e g p B k P i w g bc c m g u bc bh N F i O N N bc k i g U K N g w bc J h K l S h bb W g N ba c w h g e h O W k A u C c W x bb g j O O Z c K ba u R c bb w c U bi u N J g c bb w bf bi h Z u t G bd t h g N Q F i bb I Q G c bb G w Q I U c i bb t m l ba Z ba J k I c bc k I B B I k I K Z I g e u c N c C h c ba Z g c bf bb Z bc u u bh B P bi bh P U t bk d bg z I ba bf B w k h m B t x q bb I ba bb Q q q ba Z K bi bc N O K P bi bb w L m G e V bh bb K P w W l bh w Q k ba c bc bb n B g bc bf N Q C g h bd bf h N i B t B N w c B I Q m k i e m m ba Z u i I bb h bc n ba k Z u Q F Q bf bi bf G O q bb t I Q c bb bf o k t I bh bc h ba N Q I I c x Q J o J bc j D Q bi bb j bc q P h k G N bb k Q F N h bh N e w K k G n u bb F Q G Q U W c p N w F B ba K m e h O N bl P bi bq bx q j p P bf bh bf G g i k j h q h N P Z t B k Z k Q G m q q l A k B i e i p O k w K t P g q bb a l K t k e I Q i B G e l C p t bb e N t q o O ba m G Q O t e F N e bc c ba I i k Q P bb O c n ba w e G n w g P O G u c Q n j bc O l w i o u bf t B P O J n c u P P t o P g B q w P bh F t K F E c F c t Q m m U P ba q i w C E c K i t l n t Q N e Q O F h w P q W n N N P k bb h W w z u O B W k U ba P J l P ba ba l i P F W I Z ba Q s d m k N B w O bf bb F P g I G J c q J N n q i n e Z h n c m Q J g I k c N O N bb i I g k Q X bb Z J B V I Z h m k J O Q Q w c t N q ba ba N J q bb w c c B p i t ba k Z O i m t O g Z t I F h Z bc B k O c t V k j N F Q I I O t c w h N Q k t g W x bc z i J K bb u bc n G q k g w t W U F k w Q t k B q J N e c W w i k k g O ba i bb e P t bb w k N F N c B O N k Q E i t k c g N O c n Z q N Z g I Z c t e bf n c J t g c k c bb ba m a t ba F g I c bc m Z G I N K c bb C ba Q i P Q N N ba g P Z m I O I L p bl ba u u bq Q c N q bx L I t bc O E u k Z q k B K w G w q U t O I I O c k i k h w bc G ba N Z e H n k J C n l ba J c J B t g w t I c bb bc l I m W I W q t g ba K a j Q i P l k c w t n d m z R i A F t k n q k N h w h O h I c O B U P h w m z h B g K Z Z I q I w t c t K i o q ba W N P n w bc u o ba m g B J N I N Q N u bb m ba Z J F q m bf bb Q n bb G N p B w Q p P q t c B n e bb g k w m F q q N l K Q I C n ba ba k e O R E Z w c N bb h m c bb I s n f u A j P a o Q F Q i Q l g P u B F G a F P bb F Q i P ba c k m G q c O ba g k c h O h E Q m F g bd m W B k D B A B g ba O u w I bb k w u Q t bf m bc t p i X F g z v bn be bc O bc C w n q i Q bh s K o p I o u w k J bf Q k p q q w g Q h t P Z g O bc C K bb w m O I c N Z Z c G Z k B m O J ba q W w l F h Z c w N bf m ba k h N U G B m Z n i z q l u i u P N n bf bf i bc P I ba m B Z P bb k m bf bc W B u Z P w u n ba q t k Q m Q n Z m bb q J N I B bh Q q m B R p t p m bh k q i P u E k J k t O Q g t P c g c h Q Q G k m O k i k m k Q c c O i c G h Q k I Q q n q t c i I bh k Z ba c O O g bc W N t h l P w p F o Q g F I I k I Z Q Z j h x c u K f ba E p m ba m Z w P w O i i P bh n g t Y E m w G u B g u b P V W B t K A h c a q i bc m P K G Z V w g ba ba bb bb B ba C h c h q Z bd t Z bi c Z g R n P P B i J bb J O e t O i bc bb bi P k k P R bc P bc W bb g Z O C I bh g k t bh u t K i u O bi Q bi Z Z U N c p P q w Q q K g bb k bb bc bb u bf n P h p bc n F k Q O w w B Q bc c m O Q bc N u ba J O bh bb q u c d h bf bl B P bf w B t ba q O g F G C Q u bb q K L bi t F N g ba N bc w w g g N Q m m P J ba N w i W q t Q P h k N h B k bf w Q w bi I t ba ba u Q bb bf m m w l C d bc n t bf bb w W x bf bi N bd l z V bb I c I I h q w bc t U w ba Z e P m q P P n k t i N J O U N N e bc g k u q P Q h g B P O bh m B bd Q bc u U I t q Q n bh K m G t m O t u U e G B l bc ba k bq bl Q N u bc Z B t q m bf bb t bb u q O c bb g u q bd B A J bh M O u m m F g ba h I Q w U B q bf I w t n J bh ba O G j P w I C Q w p N J q bc ba G q bb W B I e c P P e I c Z q u Q P W q G k bh ba m h F bb c q ba O J t ba w l ba m O N u q bi bf D N K q Q I G ba Q ba k n ba c c w P N i Q Q O i w O m G h Q w O w m N Q P K Q h O P bh N l K t ba i J G k U E x z P I q F Q Z I t t h t P n bc q l x I ba bc w c Q m ba Q e K bb W Q w z N i Y c J l bb u c p g q F c F w B P w n O i N bb I t g N c Q c Z O P P m t bf bb Z O O k J bb k O bb c F n w Z ba w bi I i g e i B U g k I i w w Z ba n ba l m I w R a I bb bb m i J k e t Z m ba U Z K k bc V bf bh d O i bc e P bh k q t Q t bb B Z u k bb l P O N F t bh w C Q k w ba O bc G ba Z I bc P h B g w h bb Q ba O P t u w h bh bb B i K w W F Q F h O c B i m t Z K k f O j bg bc w e i n G B Z h Z I I I N q x g U k g n p O bc bc n P J bc N O bi x q I k C t Q n m e g Z i bb F w h P B F t w k Z w Q q i m x C h w w k c n k g bc k t c Q bb N bb O x a bc Q P A G h I f k g ba K I J c t H ba P G e O B t Q t O O Q O N m e m l U a H B Z bh w bq bg A k br C w X W bd bf bi ba bd w t bc K m bf u bb n m O B Z w P ba Q q B e C m w Q Q l N J c I k ba w Z G w B bc P bl S k bc bf e o g Q bc m G Q g I t f e t C J q i k m bd q h B Z w Q Z N I U O K k P t I P Q bb Q I O I O w bb Q Z N q O bb k g J ba O P o P ba bb ba O W ba n w m Q Q e Q B i w N U k t I h c Q P B F i w O O B c A F g Z c n bf w m c c ba m F ba bf c bf h bh bf f bd q j X e F bf bk t n o u bi t bf k g i J O w bc N g bh O bg ba O h d G z bb bp K k i c E N w q Z e R bc C bx k K x W S D bl g g bc h n O i q p e N B i g Z I k Z N g g P e w t k u t h B I Z P C bb Z c n B V e a p bb Z q G g q Z Q Z w bf k m bf c m bb c Q N O A m l q ba w w bc U P W bb q Q g C P t N k t h O bc bf P n J k c t t I F G Q t F bb bb i m P m Q I bh P K t O Q k c Q bb O u Z ba p e m Q O J c I u k w K P F J I Z Z u q I K G i O w l u n x I E ba P S O m bd Y U bg t bl m k X a bf n U i q e g w bc w N P Z q bb O g h m e Q c N U i t k h I g w e c G l q I h O m P m B m f i h Z m P Q ba Z w h I Z ba C I O B e e P O h bb i G Z i B G n m E c ba e P U q x bi i N n P h I G e u k bf Q k ba G bc P w g h k N B Q l B ba G k g q F l I k F bc bc B m I t h ba k c Z ba k q w bc U bh w e Z bb G h u q k x K bb bc G bi Z E m i n O g q Q t w c G g I Q ba B N m Q I ba c w u w N q h c Q n N k w k bb F ba Z q i B bc g m P t U Q P Q ba O bc Q B e e bb n c K p bc bh ba u bc J l A bc q d N m i t m p p bf w E K P ba O Z U n ba w J Q bf R bd bi bf S m bg z B bd bi bh j J bm k c F bb i Q l bc P o bd bi q P E G G a F bb u O I F J z bi g E u F bb ba U p U t Z E bc bz e G bg J F w bi bi N c i Z ba t B ba bi W O K bg bi bg z o J p h O Q F G e j p Q w g H D bl a O bq bb f W bd bc z ba c I t Z n q m P e m Q P F V B K J O O O ba w P p J I g N c c t t c c n a n W Q w i j N l J i G ba Q g N k P i I P h I Q w u h q i a bb G f k A h U O ba o P a k i w e m C p n x k bf C K Z P a bd bb A A P q o g W e l N z e K o a w bh q bg c V u j w o a m a bi bh Z c g c O bc k E c K m ba t bh P O h N bc G m w bi K P G bc N c k w t bb t B B C F bd P i I J o g l P m bf bh l c m O G k C t n m q l g bb c c c K w O e c P Q g g c O c k ba P O F h O m B i bm u y Z P R z G ba Q P n c w Q n O Z K g bl w V Q O bd p bf l X h G G P P w K n bh w F bb n x bb U a F Y p e L Q e Y h t m bc t k W Z t B Q t Q o g bf g u g i w e k C K I U j L s ba O bd H P t c c K u N g Q g g K e j bi bc P B bg u c o O i i o u c ba U bf q E O p N g Z F g q n i h F g P K I bc q N q k t k h G w g n I i N G Q k bc V m x C I t bb Z O Z I F U u V m U bb h Z j c i i O Z J P p I x P U bm c bl bj Q bb bl w x Z Y W K R f q e F G G Z K Z C bc k G c P u O K Q c q A q F P m J bb n W bh m P l s p bf U q m Z q Z e c bh bf m O e P Z bb k Q Q k i l bf p bf bb w k N ba q bb B bc n D B h J I A bq x l t c O U W N E i w K N e k c F Z J k h h I m ba N m C bb P w bf G e u N i g k O g G C w bc q bh w Q n c B F ba B e w bc c m n Z ba P i bb m I h q c P c m J V g k I t w w t u I V E C A t o J E q q c m Z O m g n k W n w W G h G F m w W bc t U w g bf c bb K C bf R bd n z q D bb bf a z h ba t W w q c e t N g c c I J K i O n N i k Z Z h ba ba bc I K e g F w bb c U J bc u Z U w B O O h n B k q bc ba i i Z bh bc W g O n e ba Z m c w J t W O Q c q w B bb q c F w G q Q B m c O e m q c o g Q F E P m m w bc Q bc P m e t k w i n m N Q bb bi Z bi x I z U Q Q bc R J m u n t J d O d B s U bh z Q e V F G K t O i I m e k w k W O p h q B P bb t B G I Q B p I e m K t O bd K o bh B o A O Q N I a h N B F k l bb N bf bi O A c n P k B g Z i N bb O i bb F C E O C m W O e v X U O u o z k F K c N J G p Q I bf P O bd I g bd C bf U t J u c B p bc I w L K K G P H N m m B Z ba l bi ba q R bh bh f f k bq bp bc u bq bx bh w f o Q bn B o c q Z G z ba Q D k h K m Q N k G O t L K bh e N F g G C I k l t O r i t V bi l w k t Q W g t w u k c k R C l bg bh I c u Y b n X k p bf bb B I t bi w O a O w I P bf L E O I u N p N Z P x X n R Z bf bf M c e I h B P L W q X J bh u bd r c bd N t K B F K G N I Z bc C Q bd q B c m m O m E N S N B F t G N C g i l e I o Q p G bf i z w h E R E bh R O t G bc h q N J bb c u B Q k t J p U Q bb K I k H M bi m bc R bf G R L A i c p bc K x q bf J bx i P bl M bm Z i I E g bb Q C I c G g bf l u Q bc ba Q F ba O J d l G J n c P P w bh k bh F bc bc e h u i Q c a K P Q k n bf n F f B R G l Z bf J Z N x I ba c U p w J w E W B q F q I n B F t J p w q I O bg B c bh m k J g F e bi i e W m h U w e p w U n l J B ba bc F F ba c Q n N W Z L O t I ba ba F e Q w a c g Z h w a n k P h K m z O bc h x w c k B h Q bf w k q n N e g bb I c E j o bc P G T g J t h K U O j bi D bb bb bg i W n T B bc bf B O j w Z k p C W Q m n A K p e K i G I N P g i J B c K U R l bd k O m bd bb i n n w N G P i t G E O p Q w J w g c c Q c K q G q P G N N U U W k E x h F O E e Y F bf bb i bc t S f O k bc B g U bb P O n Z i k ba u O c bh w O J bc B h bb q q P m c m z x I P B bb i F o P O h g e B u P m M bi B j ba k o w N bf bc L B o F O E G N R n v J q ba O t I f q n G e g t P e J Z t F l k O bb u J G bh w C J c n P B P P C c I f n a ba k f I e C m N W N I n c e e A Z P bh bh g bz bb g bl M bl j bk a i G Q I o y G k d S q T k r N j B Z z c k n n G c bf Q Q t i P Z q q q u l I J bd O M bl bg w B k Q Q w F ba j m g m n B u P Q bh K Q Q A O i B P bc bd O F m O n P bb G t bi bi U bc bh W bf g bi x p c h q F H t d N Z j a c W n N P P F I i N J m k ba bb O O e I Q G n bi i Q A O h h k I A j a P c H Z N n G N w ba bb u Q t G m m I i bb u g bg ba N C o H Z n E P bh bi n s d F bg K d w L bd Q w t w i K h E I G e k Q k g h j q k c O U G c q N P i g t i bb Z t k q t Q d S bc P bl C Z Z bd bg W bi F x i ba w N n n C k P Q I bc c bh k Q c c a K P e F K g Z bc C F N g bd q a n N bi T o ba S bm L t k n K P F p bb Z g B t q m w bc Q n E ba Q bi m bc B I bc p bb z e bh l h bc K O O h g n u W N m k P G l m a A ba P bb u C u P c F F t w e u k B P k t g e bi p Q bf m U z i Z w G ba c h c k i l ba V L z g Q i P bi A W r bq bx bq bH w t j s h bq ba T R N a G F Q n F n C W t P N J k o L B g w bb q W c u m i J k I P c w h ba bb Q w P O G I u Q w k N Z O w Q w Q u m O bb Z B bg C Q bb U bb bb i B n A Q H f O g bf C G g bi Q w i I Q w u n K g O w i t c F bb k N B t c bi c bd bg i I B z e B k N bf bc F q B P m g P bb m bc Z bc P Q P O t O Z ba F B t B bd ba ba B t bc J bf ba bb k bq m bb e t I I ba i g N c I q t k h bd c Q k B P u O n B g J e bf W bg B bf bh P i E bq P m Z w u Z F I i bb Q k e m bf bf bh m m bi bf I Z u t t h c u P G C bd P bl Z t u n O g B m n g bh c G bb Q P t w h k ba k Q Z ba I k ba bc P bb I V p w bc Z bd ba N G bf c ba g bb k B bb c e k N q o N d bb G g n bi bd g o bh F k bg Q bh bb t bh N w bc m n t k bb Q t ba u g bb B q P C G P bc bb c t P Z B N O g B bg w c f g D i k c u bd C P O P bc B h bb bh ba u ba i c m t P m C ba w ba P bb Z I Q bh bf N ba O i bi bc o bq bf Z G i P O t bb O Q t k bh O Z q t k bf g i m m i c F ba k F k N i w O c I bh c w w B bb w k B P C B O N w t u bh U O bf P O bh i I bi B F F B bc I bc I ba t j bl bd bg Z bh c w bi ba w w I C u C q U J bq bi N g bf bc I G bb k O u bf bb u bi u bb e bi bq bc br Q F t bq I P ba bh e N bc c bf Q O bf P P Q t bb w bh bd Q Q t bh ba N B j Q bd bc I u I m g q t c g O B t B t u P i B B bi m B m P Q i Q m ba bf B t bh bi O c bc u B bh F t bf e B U O bi k F m m g ba bh bf ba bg ba ba w i N N Z O K m bh u t O t bf B w c O Q O ba B ba t B bc bc B bi bc h bd i bi O ba t c q ba bc m I F Z m F bb u N u bf bb g u Z B bi bc O I P k c U z e ba O o k B bf O m N Q w P c i t bc bb t bh w m Q w i g bc q bf m bd O m B G bd ba m B B t t O bf bf c e t m bd u bb bc u Q F bl m u n bd t N bb i bb O m bc m c bh bh bi O u Q ba bd g bf bh m Q i w Q ba q m k B B ba i Q e O B bb i u c bi t bf g h ba i i P bc bi bi P O R ba ba x J l m m B w q n bc w J bh bi g N bb t bh O U Q bb t u bi P ba O ba F bh N m bc u u O e n bc ba P bf m c e N m bk ba t t g bc N w ba O u ba O bf bi bb I bc bd B g I m F B Q c B c bc bh bc Q k g bb B bb bl k bg h t c Q i e G p bc Q Z U n G q P w N m O bf P P Q c bc bc q bf k bd p Z m k Z Q w F m i m ba c B m bf m m w bc Q O m bq bd bd t bl R l Z I i bb t t ba t g B Q m w m m B ba bc k u c O ba q Q t ba w t k t Q k P i Q e P g u w m O g bb B t bi bb B u bc bf P Z bh B Z bc P ba k B P m bb bh I u bf N c P t u P Z k c m bh bh bh bb bi bl u bh bi w bi u bg bc w B bh k g k e c W bg bf bi t A j u bh bh K bg bd I N w P B ba bf t w bf u bc q bh u bb I ba g N Q g Z k bc bb bg bi bh bh bh i w bb ba k c Z B u t k i m Z W k I m Z t bc ba g F c Z G I t bb k P u w B bi bl Z k t bb P g I B bf Z bh m w bf B w c c bf bh B bf t N Z Q g ba u c P Q P ba k B t h O Q m bh P u Q q B B g g t B B bc m Q g B Z bc Q i u Q bd O O t Q O Q bf u w m t q m N bi c Z n q bc i t B bf bc w bc c bb h q w P O P O c c O c B bb B t U W Q h g bi ba bf bc ba g t K k bc I F W bd bc h bd B t Z I bi q ba g bd m k c bf m u F B bf bh u P Z ba m P bi O c bc Z Q O Z Z k bd w bh t B m k P N bb P O m bf l bf t m m t c u B Q bb bb bc bc bh P u P C J L ba v i b l bk j bi o R B bf ba F t n q bc B P n m Q u S c bc bd P i J bd G ba Z Z O U B t P P ba m G G q h w k bb O N k ba m g G bf g Z J k u Z bl bb bg g bi bb bf P k d Z w N O t Z c bg bi bc P t Q bi m B c q g O k P O w w w O t m g ba I k k bd w u P t bd I bf t t w c Q bb c Z O Z t n Z bh O u q bc bc bg a A N w bh bd o bb B bl bq m a O bi t bd g k g c m P O g m bc u I bc bi O w bi t bi bh m c e Q k bf m bf t bl t bb u P B Q B u O bg bh bi n bh V m N h Q m Y bl s j l c l Q i bl bf Q bh m ba m d O bc m k O m g O m t C bg q I P bb t P P bh O W bb u O P h k B q bf bc k P q bc bh K u B bh B m I t bc t q bb P P bf bf q Q h bc i u P q q g P I ba Z bh w ba u i bf u c bf bf bh B bi Q bd m k N P g i m O t c e w q Z bb m bb k u Z Q i Q P t q n u J bf B Q B P F B q i W bc t bf m bc l B i K O q O Z Q B K ba K k P m n Z bb B bb Q e P bc I u m Z P I bb O bh t P k N bf w P m Q bh P P P bb B bc P B bd O U A bd G H W bd C bi by Q Z bl e bb w a bd u bl q t bb bb ba Z m O c N u m q Z w I Q bf O c t bb O bl bi c bh Z Q bc s H bx bl bb bf bk p y bm b A S bf i x A l i h c h U t e N bf z B m Q h N P bh bb ba m F o bd l E B i ba a bf N e u bc bl bd ba B K Q n bf e Z i w bc G F Z h I bf h bg q e t bb bc k ba H bd o bd n K N i G I ba c q bb u B g N bb bh bh bc e F O c t m bc Z B Z bh k I u u bb m g i q t I w w B i P n P B g ba O t W u G O bc e h Z u N bb K P N z bc p c N g G Q P q m Q I u m Z q t F Z bh Q q F w Q J I bb F F t k ba h w F c t ba bi I Q G k n G N I Q g Q P h g P h w O q q Z bb t n h u E bb bb g w p bc g bg m e p w N k B ba Z q t O I bh t t P u e J P bf k C h g Q e P bb e bc x bc k P t e N bc A c k g x n u K bb m ba t Z l g S i q t J j n p W ba w Q w J B w bi h G ba O K F i I t bb P w k g m W n h I B J B ba bh h m bd m D K ba W O s v u N h k j i x Z p B J o B n u I O Q O k ba i bf P C i t t h h F C c w g ba Z W t i N Z q o j h I bh m h P N w B t Q N t w bb R bk j A O q F h t I t ba k c Z w z bl bg Z bq u L bm B bf bk o u bC n bk bj bm bb L D n U bb G c J i e p P bb Z j G bh U e P bf W Q j t i q c q E bc Q bb X c J G B bi f N J bb c bb t h e h t Q o bb a Z b N L bz k p O m P C y bb bb h Y j P g w P c i a q O o K n t q G m n w h e O G m C J e Q U K ba P c N P ba e B g bm bc N C B e p u O C s w U t p o A g o h i Q F N bb N bb m k P N e U k ba g P W bb I g c m Q k J g a K k J bc ba G bc I U K F k m e Q I e k x P P l q J K o W G Z I B Z s u l I t O O B O bd e x bb bf R J F I J I bd m q h N J c E r w bc A T O f br n p t t m Q E R t E t G u bc u M x Z E F K m W Q G I m P i q k Z t h G q q K i m t B m w h I e O Z q bb o K Q bb g e be D bf bc h V K v f d bn w ba G B y G bb u w O g I x h c Z i bb C C ba q Z e bg g F c e h c bb n N t N c ba l g c bb c bi bh u B bq bq f y bf bc S A N T bs bg bw z T d V b t Z c B t K p F h a ba O K C I I I I C N k P bl h bz A N R bi E t u B s z t S B x F w e bb O bb ba I C Q p w bc ba bi ba N ba J U e o a l l bc bb B x k n m u K Q c N N g B i G k n k n bc t w e i I g k P W P P bf E w O I Q w w w w N Z B U h c j n J N B F h n o g ba t Q q O c G q P w e m B K p w C j E a p bk P V s i y t i d q C k Z Z q q N n C I Q I bb n i u i G I O c Z o ba N w e w u n ba N I x K bb G B B bf N m ba w p Z g bc t ba t n e bb Z bc o bb J q x G p t bf U q bc n ba i u c J q I F ba u N P Q N ba bb N e g m P j B n h h m i T bh j K bb q C l O t Q x h z I c h O A l O w Q U N c g U i h e Q I t O t bf ba V I c t w l F B t k B O Q W B C Q u N I W Q O bh q P ba t k h o n U bb i K Z q E m bb N W t bc g J O Q t k q g c q q B bc B n o I c F w B B F n J O g Z w Q Q O m O Q bf bb F i bb c k i g ba n u Z t c k Q P bb bc Q l P m g Z N O bh K e n F m bc Q t G Q Q m bi t G C c u p I m Q O Z u t c m N P E ba d Q O C k e q w c G F k h O p q P t G N ba z A H E G f S t bc bh P ba ba O J Q m I g w c B N h P O c I P h O K I N e bc n P c P Z W F k P A h j c ba k i m h bc ba I J c P bc bi A j N ba E g U w B D ba m I p Q n c c w w k m J J Q k u k bb Q I a n N m O P m l J Z bc l bb o bb bg bi P ba c o bc bh bh l g h t O g B bc bb w B ba J bb e N I bh J m bc P ba k B e ba c t bb B bc g e k c g l Q B h o G Z c ba Z Q bc N P B t O t E k F t k w e Z m bf k I u bf O B Q ba bf Z w bb B u N i l Q i e bh N n n ba w t w P t k c w h ba bi n u h e e K i C c e g c w k i I q I w K i ba O g m Z bb h P m I Q N p J e Q N bb c N K n c t c w q B E t u H l bc s q O e n g bb K bc n F w k u F ba o m P l W c Z I q I G q e Z O w K U e h bb bf bc I w P i w P O N a i g q bb h n e N g Z k F e t k g g P q bf O O bh n Q Z n t c ba m w l i c C G G bb w c ba t O n ba P B bb I J n g O g n N bb q k bb l A B g N w h u m G N ba c Z a z j n N w G U W N K F h U Z n h bb o e i Z Q h F i t u k F k c W e bc k g I w I bf Z G e c c W h Q bb O k l w e N g g w W Z q h Q c bf c h u j p P g O t i u W Z i G U Z K ba k O h N bh m bb Q W h p i G m bf N ba bb w O e u P c bb k m w k J ba B n n t Z i w U k B u c g g Z c e h N P m i e B N I i Q I Q w u q ba g O bf ba I N ba c n w n w g O n P bf O K O w N m bb w B Q c n Q w w Z Z o F m N D R bi J g c j N l q ba e E P w F O P P i F k bb Q k m k bc e t u k t m m Q i J ba e bb W ba s K u i x K I bb Y be bd f g E O F K w u q I i e q A h i J e U q G g i e j n h a n i e h z g F P Z z ba J g g N i e h ba g d J t m bb e c ba n ba ba l G d c ba G h x N P w t u q l m A l bb J g I bb w bc q P J e N O c Z B ba Z O O L bb P bb f ba w i k k bc bb bc p k w bb c ba P Z i i I I bi c w t w p q F m m m c bc u W n m P bh n j j h I Z n I H bi f E G Z G Q O Q c O Q W q I C F i O bi h F k i g B g I l p I J bf k f m Q bi bi U a Q bf P H u ba P E i bi U ba i w ba g B J g ba K O j c h q t m Z w bb o w u g w W n P n q N bh bf P i O bb m q P P Q Q t a n N P h bh E m w ba c k w h Q i l e Z K Q I O l G h I I C w i U g N Q bc u Z o n Q O ba J O G G h p c e W O bb e O p ba p G i B U N g B t d bc A E G q Z c Z k c t bf Z j n t c bh N bc e l q Z i u c a e q P bl t c bq G p i p bb l bb o Q P V g e G J R A l g m t E F D i w T w j Z J j F q M F w bb m B C N p e ba t P l l E F N G g U k J z Q g g p E W W m ba J w c q bf e A n Z G Q ba u ba A g F w bf c bh U G t A t w g h J K Q v l p h n z h bc bc W bb P c o w Z J x O W N N g i Z U W ba J F h W u O bc I e e Q c bb c p P p N bx X E q bb p C J l Z m F q G J C U l Z J ba c G m m E t l t R e B J l i E e B e W x c Q k l V g h Z c G o h n n i g U k Q P q Q p e I J n o N h c h U O x I U i O bc J O Z h N x bc i N n g B w ba m l bb C Q B O P e bh o g g l N I G f g bb e m bd j A w bc O q h k P h q U P l n e w e w Z e bf t Z q t K t F g O ba n i N m q K t w g t d B N Q e W u t t m C k k u ba ba C K Z F e bb n C N O K bh N I l h B z Z I P p N o q W c N n n c I o V D w E c g k d I I F W P bb Z x O p J y z h h o a U U I J C i G I p bb n bb l ba i Q A a y n x O Z c w P W i q n I c O N Q K n k Q O x t g n N c t c n a Q h n m K O i G bf l O k x w A t w I G Q F O bl F G O p i I U Z t bc i i c I N W N ba ba i O k q m F m bb N J t I k Z G n G C N Q e N l c g W i P c J t Q G S N G h q w l L Q Q u D K j S q G bb z t x F L m P m z Q q Z h c I W j l bh Q e G bi w J Q N p W t e J j K G w i t bh i j k w W q h B W G U K G Z C W q Q o a P bc z h Q F bd F I S B k C t Z O N c K g U i c z g q B I n U l Z Q U m P N t t I C a D p G C O Y c c o e O k g G h O P Z W O e Q Q q B Z t c ba q g I U w u O U S ba P k F bh G I O Z h q i w q J F G O e h C Q l W ba n i n p E O g k bb q u a a E Q z k J j m o W K G l bc bf l J q W m bm N bc X ba h ba J c bb Q f c g bh Q K u g u q N m S bi Z P ba w h bh Z X q J bc m N J J V W k F w d Z e O l bb Q bh K I K g Z P C G N O o f q h J Q P Q Q J g ba S c i c w t O n G z l bb ba c bd n u e C x Q w i k h e bb t o T V T D C t U U a x l D h c K O e Q bb l c ba B O O p B e C Q g m C x U k o B x B O h J c q C z N t bb p E W i A ba Z bb F B Z bc N g Z i p N B i P t i g Z c N h K a p n e F F bc g Q q U S bf N p k n V W m X bb o i C q Q Q N I I f i X F K bb P k I I Z j F w W V a I W U Q c e a F g g F G Z F e Z R c w Z O bc t a C h ba K N k A G N t bb o h Z P F d u u U bh q m K P bf bb i e q bb N Q I a O P Q I C h x m c o bb B Z ba M y q ba Z f k i w l e C m I h P k g i w B B c bb U u u bb bc bf B n C m i I O Z s p t d z G K Q m q k i W G i bb g w q e p Z j N n Q bi p P d R h o n ba Z x W W a N a N o H h J Q o p U G h Z k h l E l e l V m l w P q N U A C A W K E Z w J I Z S e k bb Q p Q h G Z J bb k h q h h N n N g h C l bi P P o K J P h bi P e c Q g O e G t w bf i g k e q G h N I l g Z q h ba A g Z h F q N O J g G h W j I i w J O N O i q J k n k K g bi w l Q n bd h Z k A h Q h t g c c p P q W k B i P G g J w c n bh F bb K k G l w l K k d q k p a Y p g m X I Q i x h P ba Q k g t s Q U n u C k t s O g P z n Q z t C O j x i u G m q I j c O I K i l h n q ba j h h h i K Q E g z E F l h U g K m q B N K E Z Q i C J Z bb K w bb bt I r l h v Z S k q e e X Z G G K J U F l n q q U Q p h P h K O e g J Q C bb m P z U l K N E E z e O g k c k bc z D f c e J N g t R m F i q bl bb O n u I o x F e P n q G m c J t O p Z A B c Q K O F N n O w h Z c m I e k e e G k i B bb N o bc O p ba B B w Q K x g w g n I m X B t J G t P K W G J E e Q i q O e i bi bi G B N w O C O e W Q x q bc ba N K P g g w h I i F k bc l U Z Z m N I bf bf U I e t J n J h bc k c w Z Q N Q m J I Q Z S c bh g x t bf Q O k w u u t h Q w Z w bb ba I j q h bc A Q E f q ba a C N w h J J m I i J k bf Z h O e P Q E C m g m g m S m F l Z ba Q B Z Q K m m P J q w F Z n I c N c bb c Q h k l t Z c i N w n n B bd Z N Q Z g c P Q J q u N bc N g bh U bb m Z h B k Z P p p K K e G O bc g O g i P z bb H O D a bf V k u K h d N q m c G i N k i ba c m k h J J bf V bb I P X S F bb U S v u E O k Q E P Q e i w e Q m bf k bb ba x w i t m n z bf k bb B c J n bc bf bb w n bc Z n N t q bi Q bf F k t bb bb bb k bb i A c ba m O w ba bf G g g Q bb i P O bb l J g k O N Q N N W i k B w G I Q bc P e bb n t G m B bb m k w ba J B k O P P ba t bb ba w I ba k Q bh P g P i Z t m Q q m F Q bh Q t t bd u Q P bc bh U m u bh O g m Z k q W ba Q i n I l w Z ba bb Z k q Q c Z Z B k Q k B n B c O G Q B Q n h G K bh K W p Q bd bf I n t J P bf bd h k B bc bb t Q k bf m p n Z Q F C G bf i e I ba u X N Q I O t ba bc N P c P bb j q i h Q J bf k o k W I P B x L bd P bh B m bi bc bi B O n O l bl G B bi bd bb bb u Q W N h k k w m q J bf Z J m h e k F bh W w bc G O bb bb n O h g k N w O g B u P k V B U bc k P E bb j k bh P B I o ba bi m h ba bf Q A bl bd m f Z bh k a g I O bf q m i P O q m c B u Z ba ba B i I m B u m P u j bi P N p j I q bi C i bc g g B bf ba W bf q bb q m w bc P c P N bc i i O bi m bd m t P k w m Q W m w m u k K u I u g i B bc G i P B Q N P ba F q N Q ba i bb bb N q bf ba J w N w Q bf t U q E l P i B P F bh Z bf Z bc bh g c bb Z N I h O h Q N n n t ba O t Z P ba o u U P w i bd q B m bf bb P I bl Q c P bg bi ba B I bg B k bh c u bc q O ba B m u Z bb h bb u W u n J w e bh k bb g O w c P w u u B ba u u k w bd e w u O t t t bb k P B k c bf O I B m ba G Z bf u Z c bb B m O bb F I g w Q O Q i E w F J bc e k bc g ba u c bb x F u n c Q q bb I m Z c ba i K Q Q i J N O k ba Z bc ba bc c N P F Z W Z m B u m Z q B m ba G k bb q bb u n m G u bb w Q t bf U bd O bi g w P x k C J G n m p h Z w I Q P k P w q ba t F N w P B t O e c P K G m i g bc P h n bb bc bf m bb W n q c bh bf bg P ba w I B bb I Q Q Q P I u K B K u c bc bh Q m w B m bl Q G B l bh J F P h U bb bc C B I U bb bi e g t g C bc bi C g u bb bi F Q ba bb K bh e c t h O t u Z K g B t Q P m bb q P w k g t N Z bf bf k O Q I I q Z k bh G m bf e p bf e k I l m P m O U t q B u ba u G bc P O I B U e G g u u Q k N B g O Q h bb i w n B ba k ba F bb Z O x k O m w g e Z Q k g W t Q P i I C j N p O t B c Q Z ba w g w P Q w k m bc Z O k Q P Z bc t Q P k I F i k bc Q I q Q i Q h m i C N B e P c K K P U F c F bh Z O N bb i U N G w bh P k bi h F bb x N bc k E a O u B i bb C p m n F P w t i B m i I Z Q p N G q O I ba i m g ba ba bi q u O bh bh c Q g N bh B P bb o k h w B k K m J a Z bc P bb F J m I l n O U t bf G bh bf N G i E X J e p P F Q w Q h n q U Z p I k w K bh bc w J I Q Q h q g w B N e G bb J i w h w x G e e U k Q Z bb c k g bh g bh bi u J I i q W U k I P G bc q P m I bc G x k m u O B ba w q B c P i w P m C k i h c g ba c bd i O G k t t bb c c bb bf Q bc K i t g I Z q O B c I c u P I P bc n o a w Z W P q G F F J x F c G k Z i bc k O g bb F m k g c m F U I F ba i B Q bc ba W g g m G G h g Z F bh I k Z bb U k J bb bc bb h bf C B bc c P h m l o g x N N Z N G Q t g I C t k k Z k I w k n m k e bf B K P i Z q g p c G Q c n P Z G e h q O w e J m c O bf E w P Q Z F bh g t t P O Z O q n P m K B P bf O w i w m n m c bb h h O bh h K e bf Q Q N P F t k Z e B I k g m h G J g g c w o ba J h I e bc N B Z e q bc ba c c F n J bi I N K bb N u ba bc e bb I bc m c bf c O P bc u m k u J P c bh W N w P B Q O G h P t P bb w u bf u bb F O bf q F l O P c O h P Z g B w k u q e G W V q P K k W ba N F m O K o j i e q U g w e e bb N C bc bi e Z B K e W bb Q n m h O c e P h k h t bc ba u q I t P i Q B O C k Q g bf bh u u U i bg bf D I O i ba Z w j i K bb bf I Q ba u u t u g bh bb P O Q I w B bf I i bb bi O g ba bh P i bb bi B c O ba Z k C V A m F B F w w q q i t t K ba ba n e h W m I ba B g P O Q bh m t k P ba ba I U w q q w W h bi g k w t Q c bd g e u J bb bb F bf k F bc ba P O Z k ba N Q Q l u bf i m c Z bf g O u t B w bh bi O Z B Z u e e bc bh P g N u I h ba t P Q bi bc ba bc O Q u B k J U w w t k m B t g m bb Q Q Z n G l n c I P t bh Q bf bc P I m J w k I I I h bh Z I g k g N bc k bc i N e bh m m h ba bd m bh Q O w bf bf bh O N g R p n B Z ba i Q K m N k I G g B Z O Z t O J q Z t k c B u k c h m O U bg g P bf O Z U bh q P e g bl h u q e p h m K t i k k Q u O bh U Q h P E i h B n h O B w k i bb q B m O O t J N N U P bb e P h O bb C i I F O g Z p c A G q B P K k x ba G O k c g q Z R B P m Z Z m bb ba o G q a l O K w w g h I J Z bc h u ba e K w O g N k N I Q O o g Q I C B ba w t w w m k bh N h Q k Z J u A c O E e I c Z Q i J Q p w k t u w bh U B e t w t m x i k Z u Z F Q h P W ba n k q bc Q P g I O u k B k I m Z W g c n N P O bc w bc c i I P O bf B w l bf g k J c x P ba P I U P B U k w J K ba O n C i e g N G P bb i Z i k N Q P Z k e j e B O h w B J q Q I Z k ba c G N bh m Q O h N P h B u Z i m c N q d C n t e c h c G C n g p Z o l bd t h m ba J P V N O h w c n C N Q p N c c e c I W O J w Z w A q N q l c c h Q i W ba t Q g n i l m ba bf ba P bc E k w B h J g bb bd Z O e m p i q q N Q g K O I N N O I e bh B bh p w t N P U c Q bc i F I Z N Q c bb u q i k u e G p G G t t e w w j l Z K G J ba bb O k J a N G n n l G t n q w m i O bh I g z e F u q N k q O bb h e w k J F P i O Z J bb Q B G w w e ba p F N w G bf ba K P i N k c ba J q k g Q C n q x c N m P c x c k ba Z g ba t m t bf h k I P N i w N Q I P c bc Z G q bb t w bc P t C P c t i bh B q B k P Q c I bf O h Z i B P c N q Q t h Q c bh bb n q bb G g N i e bf B N bb ba O ba n F N w t Q c w l bc N P bc q Q bf O m N i q Z q m k P bd U n n Q N m Q e bc h u c bf t i P O e u I q u E w P B O I bc m bb O I B O Z B O x O bc l h w B h g e c n bf G g e w bd k Z Z m l m Z W Q t m g w u i m c j t u g bc t Q P k e I Q q bc I m P bi F K J Q q h bh w O P O w Q w k u k N ba P e bb u u k g bc U i C ba bc B m k R u m k t bc bg c w e Z U c A c w B c c k bb q n Q F w t t Z U ba B q w P c ba O Q bh W W Q N m bb bb Q E P bi n bf B bb u c e I m bd B z V O ba o G bl Q i t w bb w Q e F N G Z i n G i c o B w h O i P w F u k N bc u bg B l g t bd q i bi O P i bi w k bd I g Q u w B Q N l q c B B m O bf B o o m P bi Z k bc c ba R W w x W J i bh d W q B B bb h Q bi m n I g m B q t i O O ba Q h i N c bf K bb K Q N u F m bb m P I u B k bc g Z e n bh i I P t bb h i bi bb B q u P o bf e k O bh m K p m p i t w Q o t c l Q Q ba bg N bf u I w q bb k bb O k k bh F k e I ba t P bb u bc bf i Q n w W k J B i P e m P q n G J P c m c bb bb bh bc bl O N g ba ba O g Q m I c c O Q c P u w B m c h j q I e o m w n i t ba R N i P K bf k bb t B w i Z O O w c Z e O w bh k h bc G u bf x c P c ba Z i h I B w bb Z N ba bh u bh i g P O m g Q N P U K bc q P P m u p Q l bg I k x I Q c bb u m O P t c Q ba I t u n O w bb bi n W g u g P t bc i B O t P m K t w h bb q u K c t m i e bh bh bf q e k N I ba w N P q m w u Q P c c h bc e bl bi Z I q u k ba k Q w P p l k g n O c bd c q P g ba l bc bf c bb B bi bc bi c C P q g Z c w I g c bc P bf I q Z bb h O g h w P m m I bc w i K l m n V J g N A O J t B n c F Q B t B c i O P F ba ba m ba O u w Q J x J h t t Q w c t w i w c e B O o k z e t u N I k G k m Z O p c O e u c ba P P Q bf q m q U k c bf P bc I J t j B bh c i k P Q p u e x n t Z m W i w B P G I u O I O g f I bh W G ba x bb N c Z J bh bb F k p h w t i ba q k j I U q q P I O ba bf bd j F ba e i bi U k bi N bi bl W bc m bf C m bi P P bf ba N bc I l bd N e ba bb q g N bb u k bb Z Q w C G V X j w bc Z k l m bi bh a O ba K i q I n q bb g P N I o N P j B m z q F F O J Z F e n bb g t P B e Z t O q Z k Z ba ba k k l x Q E bi ba bb j i bg l bh O bf P q F u bi H f g Z t P c g I w g Z O g Z U ba k bb g m c t q N l k N Z w Q k m B O W G g bc G O n p Z t u e P J k q c O ba bg bx bc m Q h k F bq g bb P l w t bh bl p U Q c bc q I e bb e j bf F t e g J m ba F P I q i w F N q K G bc N w Z O i Z P O q bb Q Q bh g k G c bc g B t k g w P B P O N O bf J bf E bq x bb w t o ba n W F N bf U O P W bb t m bc c k k G W A bb k O z q bf k e N ba P q O O J bf U c g P I q i q bf ba Z k h h w U J O t z O j h bb t J y bh u bc bd P bc L J I bi o P U m G ba W N bf c m k O B U I E P ba O E u W H i c R bf bf m e a a ba k w g u B n R N k e i O F g n g e w q ba bc c h N w u U J F A e X W I c F ba h P i ba Z bh K O w w g n ba W g N x m P k bf o O Z w t I O I c k U h g Q Z i Z O O w g Q z bb g B Q bi m F g bb U j m k t bd P I B g n N h N O q P k F bf U k Z I ba C N B O bc U I K N Q g J w w J F w l t q W J W m W ba U bb o G q N G k O p k Z k N bb e c x ba z B P m g c w W I N bh n L N S m p f bb bb H F bc I l k G ba e h z k i P m q G V e e Q W bb j w u m B f I bc G bb Q l ba bg V Q I q P t z Q bd Q t c a t Z i d l W I Z h B n z q E T R e Z a H t V k S F X U bm D k l P a J o bb E k bf h bl h f u B U S d bf B Z bt z J W P m A n c l U bb G S s e Z w c X p c W I bb Y u j G f P g o U u A K bh w Q g U P F O S m g o u x O f Q bj bn g u C s u w p c B W a n X u k Q t b e bc O t B P H D bc h f Z u U m I Z G K n X a K A v D N x q z g z V bc k F O A K K f O bc q F z D w t n w y p B a J S t j I m a p l y f K q w bc k n T h j q bx G ba m h g N F o k K b Q I Q d R ba p m bx W n n U p x i i O G Q d a F i Q bc i I w U bb G C j n U x s F l x E f z q Z j A I U C g x C p e q t C w h w F C Z Z k Z I z e Q U F R q h j i S R n O w W f w A c Q n Z bn i Q p I K n d Z m e q B bc o p J bb G Z P N Q s M E Z d w bg G G J e bb c l O p G l G U J q z u Y g R i W x g E j A K W w A q G f E i V R U q bf c c m ba h d bi bn J e M g y y V bf t V j K R q c G bc n K g E C O O F H I Q h g e q U n O m ba O Q I Q q x m U x o g R bx Z bf v y W b J bb O e c ba P A G V U V S w S J a m O C j q F I o f Q z J h E e F X J R Q J E t bb t n W g G m E n W ba W e O h U a c t L G Z I T t O o P Z a c t P w y S l J R b bn E Z R J t z l ba K O A z z w g C w J e Z y J g d N bc h O j p c G I k m q F e Q q E p N N f O p e J i A q bc C Z K g J I C C C J K J f u p a Q s i K F bl x C k Q g S L t s g u V d M J e G C Q d K K X G y S a K J q n y J S e o X q A W l s i B E q F O N q A z M d U J i l F d j h f j a j K p z h o A Z Z n P e m x f J w z C m m ba m t k j I l o bh bf bi bd bb bm Q k d d c bb Z o X A g p J X S W U k O A e C P m U J q D G q w J N q a p G V A C R m N i o C w l t k R P n p Q O A K E U n bm I g p Q N K O P U T H j c v d z J C J o R o o a U d Z M bf h h J U w k a G R R K k J bb g x U j W p m j J M F x S P x e O o K L R I N K J f l z I Q p R Z q ba G k h J l y r G a M i l t C N H j w bf V G q g u A A t U I e q C F S w B a l o h a F O g g ba i E h a J x W d n x U N q i U z a X q z h s e G W l Z d bc i p bb i T Z P L N g e t u q f Q t t p g G o q e O i h U G A h B z l j i Q h j K z W q g l I N N C I K V C j i E g Y i l R H O X t B e E Y R O g p O G h C J U Q P q n p N q W Y F t w U p h p Z f J P E e C t s P k J g t C K o R o g k S I c v B G I A s X d F m N N p E Q bf q R L bn S j V Q p q o c Z O k z D e N bb c f k e bc B bc p N i a ba k C P h A q w Z U g bh O I Q B t q c N N U g O ba g A e k q g F Q s bh t g k g a g n N P o B K E B c c N c N D c bc f bc Z U Q bh t j h t Q U B q P q h O Z G x e i q F K n m n W C y bc p l g z P I h m q g g P E N O G Q N l i I Z z W k I R N e ba c e f j C h i o B w p d w W C l ba S p B ba P J l i S P f k V J o F A l w n i F c bb j c l l D s f u N B y h k O z l e h L Q w N G q l P i l g e u m g N Z n C E R e K F Q w d A w p i bi q k U n F c W w i i g Z h bf F N x G D Q h G K u a k w B h h X p V W t O G q f i p p p F c K C j F ba o g ba w y B i D q J u S N Z I K p G V N z M l d O a P o P y x f d G w N F j K V a Q J t m K Z bb P g G q u q P N o F m bf bi h I l bf I K m B bc G z w U G c J N W a c Z W A e u g N o z q N U o U j W G j x J j L bh u bq N z q K Q N u x P Q o bf M e a B h O c l c I i F x q t z w N j t w I J z O Z j w K I e E k L S K Q z E I e w n o q B f I G j Q t D U I K l bc o h G l l f w Y s E e C p c m l s w F n H Y A B E e w W n V h e Z N O q m m A U j c P m F t W Y j q J O j P bh P c d ba D p a c i e l q Z Q K i z i m L p k K q ba h Z z l N g E j p i n C w u K h Z S h i j q P bb w N N W Q f bm o Z C l f n w j k p h bh B I g N f Q o Q s P N B C K L a z n F e j k N G C u C Z w Z U bb q V l O bd q ba J J J e E c N I i V N bb u Z ba x N I t Q P W P E E Z ba J i m V N C G K o w F g F x C ba Z k g bh c P I j P J B Z bf B n J bb N n G c h a L S I h P bb O A i bg bf H K I L K U p K J V bc p y f Q w q U n P N Z N J Z bc Z I a w q bb z P T l c h B P m H bi C S S F P a k N c J K a bb j x z B S J A t H U F z C f F w k R ba J K h v Q A w E D Q w g g I H Z N l e O g n e e C R c W y E O Z V C O R Z P n m I J F E h n F w c l g l k V g a F h I L m g j i P J N p k i w I c z G N c B P d j h bc w i X O k y O U O d c g A P h e q Q n K m V a w I O i C z x w P J Z bh N i B O o W N g J y o n p g N Z Q P I W bf F I t F c g m P U w d o A Q Z O B Q q bh I l F e G n j g B N bg E a q x g l m ba N I l n N W h D N U o F k i I t E V i c I q o q h t bf I A c c x o D R K O p M O W ba i Z i J K Z Z P I c i f U q e N a u j I q t e ba m i i d ba U ba R m n ba L m K ba h V v w F G bb g e Z G q U O H ba l p e bc W K K W J o k N t q g m bb C Q j c P bc z q C e J A q U p S k C K H F G u C bx R c t M J I h g i t h x R u bd G P d G P j l a h z R L k c X Z i L t e Q x t G Q g l L j Z p i l E h A N g N Z q W j e x Q V B q bc I D X J E x d n i F a V n X l m c B R k o U N bn P e u W h P l n u z y w d D G X F t g x bd o n T A Y t Y q N a i n g v q u a k c a A j Z P e V o W e U B F F U H ba ba p Q bc B n bh G Z t n bf h y A X x h g T C B k R n n I a K p c W w Z u U i m w n ba n q O f G bd b P bh t O u W c w T i h X U l U w N bb V Z n J Q G k a bl N p t F F q m P h U bb q z a h V k h f w W c f N E p i Q u l Q e Z I M f p F t u G e k I U K I bb m k l g N I t U Z G B e ba bh J o N h p g n i Q k J bi n I Z K L K bq E b y t I P a l E z ba O m L a V b Q u l G A p j k i N u c t u l z bb c N U l C f W c n i ba Z w C G l N I l u g n i Q N g Q t m bq W w N Q w G g Q K p P P I g bc K k B m bi E F R ba k C Q F F N K A w ba J I U q bb N W O bf q O i i q p k Q a c W bf bh p C ba q g t V Z n F Q a G q S I Q I W w a I q H I K I N q e j w F A h t bc n q bi bb B Z z h Q F h w i g u G Q q c w F F J g B q ba J g p B E j w t U k Q O g a Z l j e m l B E C B ba G I c c Q t O z bh z w Z K bd Q O p i W e c ba g j F B G c o p B bb P k bf ba p bi m B q J Q N N c G Z m f q F p bb P O F h I k J G c u P L d bh B t l G m f ba B bf u V k o K e E N i bf L G d U B t R W P j o p l J a d w J i n ba Z Q P c ba D X w C g P A q L E w J W e R R c c N E Z N A x g k j O W t q Z E w C C g t q W J k J k C C h w x x N q bf R A w i c h O B k O l bb Q bl e k g J p q B J w O l c c j g C j bb O ba l j I F F ba bc bc P w j bb bf p J j w u n I P p p h E m I k ba g q n Z bb P A Q t g x F e t bc w P u Q h F h K g w c N bd g U n ba w O O B ba bd u i W q j t z t h q n O g c Q i u bc j U L P E q P l q e Z k c c i U Q c bi k J c D B bh ba I E x m k d B C Q w F Q Z W t bf R f bb u g R R bm k bb U R P v bb q bd g E J h t N bf J m Z Z q g O K k U K bb i C bt bh bt H q t Z z R bc i bc t bb N Q B k x P Q G o A j D bn A Q P i bb U i i Z f ba i e Q u bb D f c S P G i Q bi O E Q O G bc t u N Q D L k q Q bh m m bf ba N m a J o f R f e w w bq f E k bb k O c bb h u ba O k w i t V I Z y e o c C o N h g a P bx e a V h X ba Y d c P J bf b c i bc U J bb s S bh M y ba ba J S q be g L E C w q i d J V P d j l w e a d P h O c V N c O I V o e Z W o r e ba C w N G N H K Q N bc h P A N P t Q x m k Q K B K J w x K B Q t P bd W h t bb j N E bb N bi bc q W P i A t e t e c bi c bd F N S f U bb h Z j c d bc l N g g q U q t g Q O k K B B E e k k u w H N W bi Q o p o n O h u U E N Q Z d m bh V x O bd D j g B K g x x F Z bf P w Z t h P c q q n G e h p d p o Q J N e Z ba C g u n O I Q Q u n N h e i R O c O p e i G X d j O h K K m Z C c B S bb B m i O o P h N h q ba bc q I P B q h c h Q P i O B S Z K q o w T A K N Z x w G p G h i w G c g t N Z L q g i i z k l i A k M w i g C N G V C e n e J U l u V K w a D Z p o p g n g Z j w F K Y J w j t g R J X g F g bf V c w bb c h k V P P B B N g m J O h K J X Z F m i Z m q t q bh G o E Q P L t Z p F Q F f bf c F bc P U t m bb k n I a i W W u w m Q J K w i g W J O t c u h X i t q q w U J F Z q bb e q n g U P h i a e n g bh G L P h w j I w k k N k t A q N Q E m j g c J J bh bc S c ba B m bh l S V y x C w u c z n ba q t e e bb P m p O I Q Q K m u q o i k Q bi N F g bb l c q J E l q bb O l N c k bb bc h Z S u k x bc B c B u bf j O P k x o C B bh P q N bg bi J g B G G P U A a E P Z bf bh Z bi B P n A J J O h A A bf C t C V q u p bb m bh i i N m u t m O h o w bf B Q Q h bf bc Z k J l t g m h g e h Z t W bf e g g c J N ba bc g t bb bd ba bb J m n g k n Z I e F i i g bc w E Q bi e I I m F P i N U K m C ba E o O Q G bh q P J ba n e ba k U Z w ba k Z bb B h E B e e bf bh bc ba k u u Q h K G J p bb K e j t bb m O bc O B bd U bh O Q k bf k P q ba ba J n B P g O c bb u Q Q B h g Z N C P N Q P B O t ba g bi Q c h I t k Q e w O q F h c i w g Q bf bb q bc bh t O S U a c W u d bl bg n bf bc t n bd P B l bc x Z e h bb k n P bf bc bb u ba m k k B c B N u S t u bc B P J O Z bh P e k bf h t K c bh t ba k F g Z Q m m P g ba l bc g O i bf G J q t Q k X i w g bb Q t o k bl B C t m bk z G J bf Z h h h bd o l u bb ba Q I P q m bh O c O bf u Q bc bl ba bh bh p bd bd S Z j n bh E bd bf L u N O bf u h k B i ba c bb B w O u bd i n I c P bh P I Z O ba N Z p i G bc J e O I q h k R L t c I P c I U m P e ba bd N t m bb ba bc O g k g B t m I bf u h g bh e Q P i i bc P P Q bb I u t G t ba bb ba P m g Q c P O Z N N P O bf w ba w u g t g t u u t O ba k e bc i t U O t bb B w Z e I t h K m h C i J h bc g Z t bi N i I I m i t I I g m m Z B u bb B m bc g I I i k w bc t q O P G C g O O O O bb P F i ba bb m n w m ba I t bb bb c t F w k c t q F N bb W I e q P O I l O J Z bc bb c G bc u bh m t Q t m g z O P O m t i P bf u I t g u Z k t w g u bc k i Z a h bi N G k bc O bd G h bb bd t h m t F bf t w c O P g bc P I ba F ba ba Z J P w g P w c g i bc k O P F g h P P k bb k o O c bh w B bd I bh C g bb B m h ba m t bb K Q w u o bf F bh n t bf t k c F bi Q m N u e c bb p g bc c bh l c c bl bf bf B n t k u e c O i t bh q G Z P bf h O O m I bf ba O t bf t bi I Q P t bb k I bi h m O P c p u g O bh U bb bf F n w l bf t B I S bb bf A bf t Z t w q m O bd O i c i k t k O P I c bh Z h U x j m Q ba m t Z t i q t bf F I g ba ba O q o P B ba bc B u bi bb ba t u e q bf B bc O Q bb w I bf g P c w k m O m i u m m Z bh bc c g i bd bd Q K c k k h w bd c B t bc t Q k W J m Q bc w I w t Z q ba Q I bh D bb bb H F t g bf bc bc V O m t c P N k O B n m u m t K q Z i bh w l n W B h t u bh bb P P u P t U ba c bb bh k br L z f A u k B bb e c Z I bb N c k O O N g bb ba I J F t bb J bb i P B m ba h e ba bb u F F P ba t K ba c Z t J c P Z c t q bq K C e bk bf t O u Z O m ba m B g m bf bf P m t l bf u P m n N B P Q bc Z I I w P k P c w bf bf P bl O u bf bh O O bb U J c ba i B ba t Q bg bd Z bg J bh w P ba O c t bb k c Q Q h bh h Q Z bc t u N l B B t J N g N bd bi B m bi l c c w bb N c a w m i bb bb K g ba bl F t Z bb i P u B I bf bc bi O bc bi m w F bb m t k c Q c F bc i bb P N c O m N k P Q t o B Z U N t k t P i u Q bf bi k c c m h B t P u F P u B bc P k t O w Q i w ba g O G k F Q q n K i u Q w w B Z F n i k w t N m k h N R w W bh Z bq bi bq bc u V bg m I V Q G n f bd w bq bk J i bl bk J K O G bb Q Q Q Z m bf u I bc bh bg P m bc B P h t w k x A O o c i J Z N o w J I i C m w g N O k bc G P bd e Q ba W bq N bk bc bl w bx h I U bu br t bi bx br q T g bc x bc S k q bd n bk C K br bq d a e X N bq bg R F H C O P bi bf O m J ba u c p u B bc bd bl bb bb bk bh Q X j bl k ba br bf bq u g j m bk l d br l l w w G n G c i P ba w g h bi Z u c Q F bb bc P N bf N c B w J c m o a g c K m y i bu u o bu S f bn w bi bm e j bh m R N w c O bi Q I w k A u h u bg m w h bb Q Z k i Q bh m e Z bb Q t O bb bh bc bc Q bi bc u m N u i ba F n C bb bb bi k bb bf a u bc w l bc B bl bg t J m O B Q I I h K O q ba bc k I Q B e Q u P m Z Z Q P h m Q O c e w e P e G bh U G n c I bi O bi bb V B a G A U m W bb l o W bl X h O B ba A h e d D Z Z bd bd F A c Z Q Z t m U B bi B bu Z Q W s Q p bC X h u z Q bl q X W z Z i G O O P P P m w B J h P g B t e J ba k N w m O c c h q u Z P bf i h t F c bf O E u bg u ba O ba N Z m Q K O t ba bh bf t I B F B bd i Q u F c h P i I t e J d F h h q G q G h j c k J P k V bc bb Q n Z h W l C U A N o K Z bh f m V K q e x Z bf y ba t W N O P Z U Z Z m J O B h N u l t k N F q t q Z P Z bc U Q p i B Z p P bc F o m O I J O x G w C h u Z g Z t bc h N F O g h k Q t w bf k K bb n V Z P bi C br bk ba k bd G g bq f bi k bd Z q m bi g e U q u bc bh ba i u P bf bb I k P F k B F g ba h B h A U bh e P N l P P i J U o O N bq a n G bl G I i I W g bb w c O X p n bf I e bb bh G Q bb h bc k n m w P Q P Z P t n Z w q bd h bi bm t h l bd bk bi c Z w I ba W p bi bh U bh k w h h G t e K bc n e e u g J I n m bb k I q w q P e t q q B e e u g i bb u I p i bf Q bd l x k bd bi K y C U bl h K bh O I k m D G bh bl O e P I bb F c Q bh c C m O N U ba h X U f E n n x K D h bb R q bh j q l c Q E Q t e F Q Q t X c s bb c ba k c N c bf i Q I g ba q i N J w P ba Q q Q p g F i C B j G D h a k O B g Z O w I u Z l g e k k k bh i h t F i A K o O F N G k m w bc m B B k g m B Q P K P O k ba m d m bn t M i P O u N h by B n bh g V U Q W P O t k F bb I O n bd J m e J bf F O o g e F Q J P e G J O bh q ba i I e p a m k c Q q c bi C g Z L bc N h P q G bq bx c K s O bc N i x L m g p ba F P q P O m bh G C K I bc ba G t U i i P F bb w m t g O q P n e E K O I k e g Q V q W g e P w i bb t bi t t h B u bi O F t w d bi E bf bl bl bf n bh bi bh u t p e F q i U h m Z i n t bb w w n i Z N t I N O w K g U m q g bf W bA bl q br O p q bb bd bb j q bb a L S Z q J Q l d m q bb V I J Q bb h c bf k Z G n O i q c p t m c m B Q bc B bb l k q m N p h h C B i x B l N e I g w O i Q Q C c P i m ba B g i w bd Q P u B bh bg P bh Q E Z u j m c c l I ba F h c g P Q P B i w t C f t bc ba bg w O C B Z Q i N Q m P bb Z G k ba bb d k P t E bb P u Q F B U u h Q f t k bb F w i i c q h F bb k t u t w G u Q bb t h bc B B k bh g V Q bl u bq O bl q H f k t k O p a bf h c c z V F K S bi p G t p i Z c u bf S U d h w bh t S G bd bu h t Q w m V M bh A bg m t t g E j bf a ba B w c N B bd i k bc D bc l u bi c bf C P m O Q Q bb i Q N h bc E m Z w w q J J bb g h c R bb P i bi c N g g e bf q P I B k N bb m C O bc h bd H bd bk z bg X u H G ba l bi br Q br w J u c P G bc bl j g B q t g u w bh N g U bf f u N q P I c q B N n I m Z q e g h F t bh K P bf Q u O m K u N I e N bb Z w k Q w Z h Q ba bc O I u P m bb m t i n n V i bc P h U g q k e C F B u F ba N i ba J w I c e m bb J h q K c bf c G O Q bb l G C I n n Q u c bc B bi e bb k k J l x g w ba h u bc W D y ba w bf B E O Q j J Q bb i c n A U U m t I F bc e m k k c u Z g B w F g O q P B i u bf m J m Q t Q P F c m i N O bc B P m bi ba m G ba Q C K g F I I J Z O k k u i bc c e ba k B O E q bb N A bh ba W B bd t p bd t t d bf I K g c G h N K h w t bb c m bc bb k U I c O g l B m I k w w q h w k h o n O i i g ba Q m bf Z Q P w t bf q bh t bc K K u F bf h ba O t bg c t P bg z x G u u O m P u J Q Z e P U c F O G P Z c Z O g E k e g C i t Q Q K S bd g o Z k g Q N g W m Z C g i I p P g n e Z Z g bd o O g I O O c g Z k h P U bi F D bd F O bf q t R l m i q bb w ba q u h G n G e o I N bf a bb i e bf w n bb l I x c I bb t N P I e m U t Z I f P bb F P N bd k m w ba ba e w w p k K w g w t c w h g ba O h bf P o b bk f G C r b bi bc bl o E i bb q o K c x i O bl bg A k g bv bi i L k k bi A Q X bk M Z I bf bf u a X bb w bb h H F R bq P A bf m ba ba bc bf P t p O k c G g P m i bf d F u p P N k j e B i g N O t B P N bh h Q ba O bh bb P bf P N g t G j e C Z P O q e k f v g w O w u P B u bc L G w e Y u A P W e J c O Q Q O ba l c N ba q g bf O bq e g o w bd T K bc w Q l C j B i s c z m n U q Q m bb c m F k m O N m O Z I Q F g B O u O m I E e u w u t Q n q h F w bd B X P G bb A l u B O e B h B m i bf t i Z i P bc A bb R P G c P g n o G c O ba N Q A w w t U l W k c k bc m w w Q h n bf u e t bh e B m t o O p O O bh U bb h k k K w Z t m bc g bh Q t q ba i g I bb c bb o Z f p t bc F bc l Z m bc h e e t N N C q V w G h Z t I W c Q w q Q w w t g U bi P Z e K Q G i w w G l k n w I bf J i m c j Q h I W m U g N C bd bi bc k c s bc bf g bz bI C bF bv bH q u bG bt p H Z w D w E z m f l f F p l ba C B c y P o w n O N E G B Z U m P k p P c g w Z bb u bh bh I ba a h bz A g J F d P bq bb p bw ba V q B B U b bc f P t I R B o c B q X x bt bu q bb o bC R d g M P Q n g m bf bb Q bh i P bl bd P C a bc U bf U bb Q N W G P G w N g h N bc I Q bf e I K ba g Q bi k ba i q X c p t N bb I J m Q H k j S E g u h O i Q p q U P C J Q U N m F F g O k W c Q t ba g Q O bf E J W h G t j Q d k Q g N J g m J o bb p g j G V ba bz m j bf P C K E A d D z w X S g bi ba L F Y bg br F o bk u i t B M bd a t m bb bi o bm f bh bh g bw g T y k g i k Z W w F A k n bc F P bb ba J W U f m R e h w q ba O N W k h m w q F bb P P C Q g m q n F u h l y ba c H x k bb u O k ba q w ba Q bc B bb bc B I V E Y bk P B H Q Q bd Z J M bh I d w k K i c q D bf P q o O P O k c l I P O Z bb X m I U F J V h B A F P F bb i F o B ba c O Z h m P f a k u y M bl D bb A 0.14 bj 0.09 bz K D x t b i N R F N k l g X u n r w bh q K O G E w w g Q Z j ba Q U t c ba P bd k Z o bd bh g N bi t W c q h N e X a u G g P t E h m u c w z n e N q n Q m O bd t ba O N z b p S l G O n c F g p n O Z m X g g w V k Z m q F Z I c p m q U Z a e l j U P e k w g n e G t l B B G e t k O w bf c g C bc I Q C d C bh N Q bf P W i G B m m m I m e ba u O bh w Q bh F m bd ba W Q j bh e n d D u bf R bf bh k bb j m m h g B G c G bb E U q c q u u h g d c bl V u G bq P U Y q f n i C J D B bh f U bf J A P N n W O bb w bk Y K R K q Z O bc c t B j h j g N w I F n k Q B g h N D e N O U j p G ba g X A n G I N g C O e J N l K c Z j k o g w o F W C l D q U ba N P Q w c C q U bh bh B B Q N h F B Q p P X g O L bx Q t i ba h S J bb q I q k Z q j I L c I bb w o Z O z K O K z t I N i g w u U W Q I E m U y q bf h p o I L J B u Z C P l V I l n s U F c J I P G e a S N i U g q i h i C p bh p l m I I q c N n C J J P t B K c S q x F h G G q B O w t Z U q n N m G Q bc C i I l X H C k I v B B bh J C F Z Q u k q I w Z u F C e F e G Z F I i g n g bb h ba g n bb Z A t u bq P bb B j bb bb n Y N Q o t L bb c j J p I k B Z e bi g F U O bc bb k g N bf bb bi m W P I bc Q bf t K e C i n bq bh P v m bt w e bn R U h q Q c e F h i U z B A s n N G e B B L bi m j b o bi t bj I N d Y o bu I u bj bh t Z q C)));
(display 'Loss' ^(a:2.01 b:1.517 c:1.198 d:1.512 e:1.149 f:1.081 g:1.238 h:1.118 i:1.096 j:0.622 k:0.621 l:0.499 m:0.868 n:0.617 o:0.45 p:0.667 q:0.448 r:0.513 s:0.399 t:0.465 u:0.423 v:0.561 w:0.452 x:0.489 y:0.398 z:0.367 A:0.466 B:0.391 C:0.468 D:0.362 E:0.303 F:0.294 G:0.387 H:0.307 I:0.375 J:0.311 K:0.313 L:0.334 M:0.321 N:0.275 O:0.293 P:0.296 Q:0.295 R:0.246 S:0.333 T:0.292 U:0.259 V:0.255 W:0.316 X:0.301 Y:0.299 Z:0.297 ba:0.218 bb:0.306 bc:0.236 bd:0.261 be:0.263 bf:0.23 bg:0.178 bh:0.212 bi:0.195 bj:0.225 bk:0.201 bl:0.215 bm:0.153 bn:0.223 bo:0.196 bp:0.203 bq:0.185 br:0.157 bs:0.154 bt:0.198 bu:0.188 bv:0.186 bw:0.148 bx:0.17 by:0.179 bz:0.174 bA:0.146 bB:0.166 bC:0.171 bD:0.163 bE:0.127 bF:0.139 bG:0.137 bH:0.129 bI:0.141 bJ:0.176 bK:0.12 bL:0.189 bM:0.152 bN:0.14 bO:0.135 bP:0.114 bQ:0.117 bR:0.11 bS:0.093 bT:0.116 bU:0.088 bV:0.111 bW:0.123 bX:0.112 bY:0.099 bZ:0.109 ca:0.105 cb:0.087 cc:0.102 cd:0.094 ce:0.136 cf:0.128 cg:0.133 ch:0.097 ci:0.119 cj:0.103 ck:0.071 cl:0.106 cm:0.089 cn:0.079 co:0.092 cp:0.083 cq:0.096 cr:0.058 cs:0.061 ct:0.074 cu:0.057 cv:0.095 cw:0.07 cx:0.08 cy:0.066 cz:0.054 cA:0.064 cB:0.068 cC:0.069 cD:0.059 cE:0.065 cF:0.082 cG:0.056 cH:0.06 cI:0.052 cJ:0.043 cK:0.051 cL:0.045 cM:0.039 cN:0.041 cO:0.046 cP:0.075 cQ:0.032 cR:0.037 cS:0.042 cT:0.044 cU:0.048 cV:0.034 cW:0.053 cX:0.04 cY:0.033 cZ:0.049 da:0.047 db:0.027 dc:0.036 dd:0.029 de:0.021 df:0.031 dg:0.026 dh:0.028 di:0.023 dj:0.022 dk:0.024 dl:0.025 dm:0.02 dn:0.019 do:0.016 dp:0.018 dq:0.017 dr:0.014 ds:0.015 dt:0.013 du:0.038 dv:0.012 dw:0.01 dx:0.011 dy:0.008 dz:0.009 dA:0.007 dB:0.006 dC:0.005 dD:0.004 dE:0.003 dF:0.002 dG:0.05 dH:0.062 dI:0.03 dJ:0.035 dK:0.072 dL:0.055 dM:0.1 dN:0.09 dO:0.076 dP:0.063 dQ:0.086 dR:0.073 dS:0.101 dT:0.067 dU:0.081 dV:0.104 dW:0.078 dX:0.084 dY:0.098 dZ:0.077 ea:0.085 eb:0.091 ec:0.107 ed:0.115 (cz 0.633 e 1.603 3.344 3.805 2.073 3.205 2.582 2.086 3.305 2.286 3.761 2.72 2.716 3.527 1.712 1.87 2.043 2.064 1.394 a 2.391 2.103 2.461 2.549 1.761 2.724 1.497 2.761 2.375 a 1.458 1.5 2.002 2.773 1.478 1.774 2.123 1.292 2.156 2.09 1.614 1.685 1.217 1.434 1.031 b 2.118 2.764 c 1.566 1.058 1.513 d 2.317 1.583 1.247 1.215 1.637 1.653 1.76 1.414 1.102 b c 1.67 1.495 1.665 2.393 1.152 1.823 1.525 g 1.532 1.017 0.992 1.443 0.92 1.02 0.902 1.577 1.529 0.903 1.651 d 0.991 f 1.205 1.313 1.009 1.352 1.262 2.193 1.043 1.12 e 1.239 0.975 1.26 f 1.219 0.873 g 0.875 0.977 1.056 0.941 1.291 0.915 0.874 0.775 h 0.935 1.018 1.321 0.778 1.082 i 0.803 0.91 0.727 0.958 1.109 0.865 0.711 0.733 0.791 1.002 0.672 1.511 1.097 0.654 1.047 0.859 0.882 m 0.893 0.822 0.682 0.598 0.77 0.987 0.708 0.652 h i 0.896 0.553 0.678 0.629 0.665 0.71 p 0.909 0.625 0.663 0.741 0.81 0.772 0.695 n 0.639 j 0.783 0.64 0.838 0.717 0.547 l 0.604 0.51 0.963 j 0.79 0.595 0.705 0.537 0.752 0.756 0.5 0.7 0.662 0.477 0.538 0.687 w 0.641 0.61 t 0.571 0.396 0.395 k 0.549 0.555 0.576 k v 0.445 0.833 0.557 C 0.505 0.802 l q 0.53 0.592 0.528 0.531 m o 0.669 0.709 0.566 0.515 0.584 0.648 0.433 n 0.464 0.518 o 0.457 0.503 r p 0.483 0.586 0.459 s 0.441 0.542 o q 0.41 0.438 0.525 I 0.439 0.488 0.57 A u 0.405 r x 0.497 s y 0.339 0.517 bb 0.354 0.522 0.447 0.435 G t 0.458 0.346 0.401 0.492 u v B 0.34 0.431 D 0.449 w x z 0.349 0.498 y 0.407 z J 0.309 A 0.471 0.43 0.444 0.454 F 0.304 y B 0.417 0.422 0.337 0.332 K 0.442 L x H 0.397 0.386 0.421 0.356 C E 0.427 0.331 0.282 D 0.351 Q 0.265 0.25 Y 0.271 D 0.35 0.325 E 0.285 Z F G M 0.327 0.317 H 0.341 z S N B 0.28 I 0.264 0.373 0.36 0.361 U 0.276 V 0.252 0.322 J 0.355 K 0.328 L 0.269 0.262 O M 0.323 P J N O R P Q 0.33 W T K 0.344 P 0.253 R S 0.257 0.243 X 0.274 0.238 T bd 0.287 bf bh U 0.226 I F 0.27 0.245 bl 0.266 V 0.278 W 0.247 bj D 0.216 bc 0.281 X 0.286 Y 0.256 U Z U ba bt bg ba 0.268 0.231 0.208 bb bc bk 0.233 0.209 bL bv be 0.199 U bz bd 0.244 bd be bc bf 0.251 bd 0.169 br bg 0.241 0.222 bm 0.165 bh 0.162 0.214 bi 0.181 0.232 bs bi bj bk by bo bu bl 0.19 0.21 bm bn 0.173 bn bo 0.229 bp 0.194 bJ 0.192 ce bq bw bp bq bB br bI 0.159 0.193 bA 0.235 bs bt bx 0.138 0.149 bN 0.204 bu bv bq 0.158 bK bw bt bx by bG 0.134 bz by bA 0.221 bC bD bA 0.168 bB bM bF cg bE bH bB bO bv bg bY bm bC bW bs bD bx bE bF bG ch bU 0.143 bP bH cf bI bJ 0.177 bK ed 0.142 bL 0.122 bQ bM ci bT bu bH cc bX bs bN bO bR bP bQ bS br bR bH bS bo bT cp ec bV bU cl bV cb bG ea bW cj bX cv bX bK cn cx bN dM bO bR 0.151 ca bZ bY bZ bX ca cd cr cb bH cc cd bV ce ck bP cf cg cm ch ci cj bK cs dN bS co dY dS ct ck bU cl cm cn 0.108 cP cE cn co cF cp bZ dX bS cu cq cq cK cB cr cD cs cA dO dR ct cu cv ch cw dQ cw dH ck bS cx cy cy cz cw cH cJ cC cA dL cB cI cn cC cL cA cw cA dK cD cE cD cU cF cO dG cG cD cG cH cy cM cG cA cI cz cJ cN cz cK cL cL cR cS cM cr ck cL cG dP cJ cN cN cO cN cO cW cH cM cz cP cH da cN cY cZ cQ cQ cO cR cT ck cX cS dc cT cV cQ cN cU cV cJ dd cW cN cU cX cK cT cJ cS cI dJ dI db cY cR cT cZ cL da cV cT da dk cT cZ cW cN dh cQ db dg cM cM du df dc cT di dd cQ de cQ de df df cY dg dh cX dp dj di dd db di dh cO dj dn dd de dl dg db dd db dm di dh db dj di dk dg dl dl de dm dj do dl dg cV dk dn dl dn db dj dl dn dj di dq de do do dj dt de dp do de de dp di dm de de dg dq dn dn dr dk dj dq de dl ds dr dq de dn dn dn dp ds dp do ds dw dp de dt dq dq dp du dv do dt dr dt dq dv do dn dy ds ds dt dr dr dw dv ds dx dw dr do dx dw dr dt dr ds dp dv dx dq dq dv dl dw dv dr dv do dp dr dw dt dt dv dw do dq dx dv dx ds dt dv dj dw do dt dr dr dw dy do dv dy dt dr dt dx dz dx dr dt dz dA dw dz dv dw dw dr dy dz dx dr dw dw dv dA dw dw dz dy ds dv dz dy dx dv dp dA dz dr dt dy dr dy dv dv dr dz dx dv dy dy dw dz dy do dt dr dv dx dB dA dA dx dw dy dy dx dz dy dy dw dz dz dy dw dt dw dB dv dv dw dz dB dx dt dz dy dv dw dz dw dz dy dB dy dy dy dA dw dr dy dz dA dt dA dx dz dA dz dy dy dr dx dC dB dA dA dr dB dA dv dy dA dy dx dw dy dB dz dC dv dz dA dA dB dB dy dy dC dA dB dB dD dB dy dA dB dC dw dB dA dB dA dA dA dA dB dB dx dB dD dA dx dA dB dB dy dy dz dC dy dz dv dC dB dC dB dA dz dz dB dC dC dy dy dz dz dy dy dB dC dz dB dB dC dA dB dA dB dD dB dD dC dC dC dB dz dC dA dD dy dB dy dD dx dA dy dC dC dA dB dA dB dC dy dy dB dC dz dB dw dz dB dB dB dB dB dA dv dC dB dy dy dz dD dB dA dB dy dB dA dx dA dE dv dD dC dB dA dw dC dB dk dC dA dz dD dC dB dC dB dC dA dA dz dy dz dy dB dC dA dA dz dy dC dC dy dA dy dC dD dC dy dC dD dC dC dw dw dB dB dv dA dB dD dy dD dC dt dD dy dC dB dt dC dA dz dC dB dB dB dD dz dB dA dD dE dB dC dy dB dC dC dD dC dz dC dB dD dz dD dC dC dC dt dB dE dA dD dB dC dC dB dy dC dD dz dA dD dy dy dD dB dE dC dD dA dB dy dC dC dA dA dC dw dC dC dD dC dy dx dC dD dD dC dC dE dB dC dz ds dB dB dA dD dC dD dB dB dy dB dz dD dC dC dB dA dA dC dz dD dB dD dA dC dB dB dC dB dB dy dC dy dB dz dB dy dE dC dB dD dC dB dB dD dw dD dD dy dD dC dA dy dB dD dC dA dx dC dC dw dE dA dy dA dA dB dB dC dD dA dD dD dD dC dD dB dz dD dD dC dE dA dD dB dB dD dy dC dB dD dA dA dD dz dB dw dw dC dB dz dC dE dC dD dC dz dD dz dD dB dz dD dB dC dy dC dB dD dD dB dB dB dz dC dB dE dB dx dA dy dA dC dD dz dC dD dD dD dD dB dC dC dB dB dw dC dx dy dD dy dC dB dx dv dx dA dB dA dA dD dC dv dD dD dz dC dy dC do dy dC dq dB dA dy dB dB dE dw dC dD dx dB dD dE dB dC dE dC dB dD dy dE dD dD dC dC dD dA dA dB dz dD dC dD dC dB dD dA dC dD dz dC dC dA dE dC dB dC dD dB dC dD dB dA dB dA dz dB dD dB dE dC dy dD dD dz dA dA dC dA dB dD dB dC dA dz dE dC dB dA dC dE dz dD dD dC dE dD dC dD dD dz dC dC dD dE dA dC dB dy dE dy dE dC dD dD dy dC dD dC dB dC dD dE dA dz dA dy dC dC dA dD dy dA dD dB dD dD dD dB dC dC dE dB dv dA dD dB dB dD dD dB dD dC dz dA dD dA dy dE dC dB dB dC dC dz dE dB dC dA dD dy dr dD dw dy dB dC dC dD dB dD dE dE dw dA dA dD dB dC dE dD dB dB dz dC dz dE dE dA dD dy dy dE dy dD dz dD dD dC dD dC dB dA dA dz dD dD dA dD dD dB dC dC dz dB dw dE dD dC dA dD dC dD dA dD dC dy dD dC dD dy dE dC dA dE dD dD dw dB dC dz dB dE dD dA dv dB dw dA dB dC dC dC dy dy dA dB dD dD dz dD dC dA dB dy dB dw dD dC dw dC dA dA dA dA dB dw dC dD dy dC dD dE dC dA dC dC dD dE dD dC dC dE dE dC dB dC dD dD dB dy dB dE dz dA dD dC dv dB dy dy dD dE dC dB dA dC dz dC dC dz dC dC dD dA dC dA dz dD dC dz dD dE dC dB dw dB dF dE dC dC dB dz dC dE dB dA dD dC dA dE dC dC dE dD dB dE dD dw dC dC dE dB dB dD dC dz dB dt dC dC dB dD dC dC dE dA dy dC dy dB dD dC dC dE dC dA dC dD dC dB dC dB dB dC dD dw dv dy dD dC dD dB dC dE dC dD dD dD dD dC dC dE dA dD dA dD dB dB dD dB dC dw dC dD dC dA dD dw dy dC dE dC dB dC dD dC dE dD dD dz dA dD dE dC dB dB dB dw dD dD dB dE dC dC dA dE dy dv dB dC dF dC dE dB dA dD dC dD dC dD dE dA dC dC dD dB dA dB dC ds dC dy dC dz dB dC dD dC dA dC dA dC dB dz dC dC dC dA dC dA dA dD dC dD dD dC dC dE dB dA dB dF dz dD dD dC dC dD dE dA dz dx dC dC dA dz dz dD dE dD dE dD dE dE dC dE dD dB dD dB dD dC dA dD dy dE dE dE dB dC dD dC dD dy dC dC dE dC dD dB dC dx dD dD dB dD dC dE dC dt dC dE dD dB dB dD dy dC dD dB dA dC dC dA dC dD dE dr dD dC dB dA dD dE dC dC dA dB dy dE dC dE dE dC dE dD dw dC dD dw dy dD dB dE dC dD dC dC dD dC dD dE dA dy dD dD dB dA dC dD dD dD dy dz dC dD dA dE dC dF dB dC dD dC dD dE dC dD dB dB dC dD dr dx dC dD dC dD dD dy dy dD dz dw dy dB dD dC dD dD dt dC dD dC dB dD dB dw dD dz dB dC dA dD dB dC dy dB dD dD dD dD dD dA dE dC dD dy dD dC dE dA dB dB dB dC dy dD dD dD dD dE dC dy dC dD dC dC dD dB dz dE dy dC dC dD dF dC dA dB dB dA dC dD dB dD dB dC dF dE dC dw dD dC dD dC dC dE dD dC dx dA dD dD dC dy dB dA dA dC dE dB dE dA dy dB dB dA dA dD dy dD dD dC dD dD dC dE dD dC dC dE dE dD dD dD dC dB dB dC dB dz dE dD dC dD dE dD dD dE dC dA dC dC dD dy dC dA dB dB dB dD dw dB dD dA dy dC dE dB dy dD dA dC dD dB dC dC dC dD dB dC dB dA dB dE dC dw dD dD ds dD dA dC dD dD dB dC dC dC dB dE dC dB dA dD dC dE dC dD dB dB dy dD dC dC dF dB dC dC dC dC dy dD dD dE dD dD dC dC dC dB dB dx dD dz dE dD dE dD dB dA dB dC dD dE dA dC dC dz dw dD dB dA dC dB dE dD dB dA dD dD dD dD dC dD dB dC dE dB dD dC dy dD dz dw dC dC dD dD dE dE dy dy dE dD dD dC dw dB dA dv dD dE dC dz dD dD dD dC dF dC dB dA dB dC dD dD dD dD dD dC dA dC dw dC dC dA dB dA dA dE dD dB dD dA dA dC dz dD dC dE dE dy dD dy dx dD dD dD dz dB dC dy dD dw dC dB dD dA dC dC dD dB dA dE dz dy dB dE dD dE dC dB dD dE dE dD dE dy dA dC dB dA dC dE dD dD dB dD dE dA dD dF dB dB dE dC dB dC dt dE dC dB dx dy dt dC dB dB dy dy dD dD dC dz dC dw dB dB dD dC dD dB dC dE dE dC ds dD dC dE dC dC dD dA dB dD dC dB dy dB dE dy dE dC dA dC dD dD dD dA dC dD dA dA dB dD dC dx dD dC dC dy dz dA dC dD dD dD dD dC dB dE dB dE dA dE dC dE dC dA dD dD dD dy dD dF dD dD dD dE dD dC dD dE dD dE dB dC dD dC dD dD dD dD dA dz dz dy dB dw dC dC dB dB dA dB dC dD dD dA dD dD dw dB dA dD dB dD dD dD dz dA dC dE dD dB dD dA dC dB dD dC dA dD dD dC dB dC dB dB dB dD dD dC dD dB dB dD do dD dw dB dC dC dC dB dy dC dC dC dB dC dD dA dA dB dC dC dB dA dD dB dE dy dD dA dB dD dy dC dD dy dC dC dE dD dD dy dB dD dB dD dC dD dB dE dA dE dD dz dC dD dA dA dC dC dC dA dD dD dA dD dD dA dB dC dE dE dA dD dA dA dD dC dy dA dD dD dw dB dD dB dD dB dB dB dE dD dD dD dD dA dD dC dC dE dD dD dC dF dC dA dD dE dx dD dD dy dA dD dD dA dB dB dC dB dD dD dC dB dD dC dD dD dB dB dx dt dE dD dz dD dz dE dC dB dB dA dC dD dA dC dB dw dC dD dB dB dw dC dE dy dD dC dA dC dy dC dE dC dC dy dE dB dB dA dC dD dC dC dC dw dB dD dB dD dC dB dA dB dy dD dA dD dB dA dD dB dB dB dB dD dB dE dz dE dC dA dD dx dB dD dB dD dD dB dD dD dB dB dw dE dC dC dA dD dD dD dF dC dC dD dA dA dB dE dE dy dE dD dB dB dC dC dD dE dD dE dE dC dB dE dw dE dD dE dE dC dD dA dy dC dE dy dE dC dB dD dE dE dD dE dy dA dD dD dB dA dt dC dD dE dC dC dE dF dy dE dE dD dC dB dy dB dB dC dD dD dC dB dw dC dz dB dB dC dB dB dw dD dD dA dA dC dC dy dE dC dC dC dB dD dD dD ds dE dA dB dC dy dx dD dD dC dA dC dA dE dC dC dB dC dB dD dB dE dA dD dy dD dA dC dC dD dC dA dC dD dD dD dy dA dE dD dz dB dz dz dz dD dA dD dC dD dB dC dC dE dD dB dD dC dA dA dC dy dD dB dD dD dB dy dD dt dz dD dC dC dC dD dD dB dD dB dD dC dD dy dB dD dC dD dC dt dB dz dC dC dB dA dC dD dC dE dB dD dC dA dC dA dC dD dz dB dy dE dz dw dB dD dE dC dx dD dD dC dC dC dA dC dA dB dA dB dE dB dC dB dA dA dC dE dy dD dw dD dA dD dC dy dD dC dC dB dE dA dA dA dy dB dy dz dD dB dB dD dD dB dD dB dy dy dB dC dC dA dB dD dB dC dC dz dC dB dC dE dA dA dE dC dA dB dC dC dy dB dB dA dA dE dB dD dA dA dC dD dA dD dD dC dC dD dD dy dw dE dB dB dC dC dD dy dB ds dB dB dB dw dD dC dA dD dC dC dC dy dB dA dD dD dC dA dy dD dD dE dA dD dC dA dy dC dD dB dB dA dz dz dD dA dC dy dC dC dC dD dC dE dB dE dB dv dD dC dE dC dD dA dz dA dC dD dz dD dE dB dB dB dD dC dC dD dC dD dC dE dD dB dB dB dD dA dA dD dB dD dC dE dC dA dD dD dC dB dA dE dC dB dC dA dA dC dr dA dB dC dC dA dD dD dE dC dA dE dA dw dB dC dD dE dC dD dA dB dz dC dE dr dC dC dA dB dC dD dD dB dB dD dB dy dD dC dD dE dC dt dD dD dC dB dE dB dq dB dD dD dB dC dD dE dE dE dz dC dD dC dC dC dC dE dC dC dB dD dC dB dy dD dD dE dD dC dw dD dC dA dC dE dC dC dy dB dB dB dA dD dA dD dA dC dD dB dD dC dD dC dC dy dD dB dC dC dx dD dA dw dD dB dC dD dy dD dD dB dC dD dD dE dD dE dC dD dB dB dD dA dD dA dA dC dB dy dC dD dD dA dD dA dE dE dA dy dD dC dB dC dC dD dB dD dw dC dB dA dC dC dC dC dC dy dC dB dA dB dB dB dA dB dB dA dD dE dD dA dB dE dC dC dC dA dC dB dB dB dy dz dA dD dE dz dC dC dB dD dB dB dE dC dE dz dy dE dD dB dD dC dE dB dC dE dD dB dC dC dA dB dA dC dD dC dD dA dD dB dA dF dB dD dC dt dE dB dE dB dD dD dC dC dE dz dA dB dD dE dB dD dE dy dE dC dC dD dv dB dr dC dD dC dy dB dD dD dA dD dA dC dt dx dA dw dC dE dA dC dA dA dB dz dz dB dB dD dA dA dD dy dD dB dC dA dB dC dB dC dD dC dA dB dB dC dD dB dD dC dD dE dC dE dD dB dA dr dp dB dE dD dD dB dD dB dA dz dD dD dC dz dA dC dC dD dD dw dE dC dD dB dA dA dC dC dC dA dr dE dz dD dD dw dB dC dB dB dD dB dz dC dD dC dC dE dB dB dz dB dA dE dD dE dE dA dC dD dw dy dA dD dB dz dD dx dw dB dC dD dz dB dE dC dA dB dB dw dB dD dB dB dB dy dC dy dC dz dC dB dD dD dD dz dz dy dB dC dC dv dB dy dt dy dy dy dx dC dC dB dy dB dC dD dE dq dB dE dB dC dz dy dB dB dA dD dB dD dy dA dD dE dr dC dE dy dC dC dC dB dC dA dy dD dA dw dA dE dD dD dB dD dC dD dy dy dE dD dv dD dD dA dB dC dD dB dE dB dC dE dC dv dz dB dB dC dD dA dC dB dB dD dB dC dD dC dC dD dz dC dx dB dE dD dD dC dD dD dD dC dx dw dy dA dw dy dA dB dw dE dB dC dB dF dx dC dC dA dC dD dE dC dB dB dD dy dB dy dC dD dy dB dD dv dz dC dA dC dv dB dy dD dB dr dA dA dy dB dD dw dA dA dB dC dC dC dC dB dC dy dz dD dC dz dD dD dz dr dC dD dA dC dz dB dC dx dD dD dC dB dy dz dD dw dA dC dB dw dC dA dv dE dC dB dA dC dE dC dx dB dD dB dB dw dB dy dt dC dA dD dE dE dE dt dD dA dA dB dy dC dz dy dE dw dC dC dD dC dB dE dA dz dC dA dD dD dC dC dD dB dy dD dC dB dy dr dA dB dC dB dA dC dE dB dC dB dB dD dD dA dC dy dD dx dy do dw dA dA dB dA dB dA dB dw dD dC dB dy dB dD dy dC dy dB dD dC dB dB dr dD dD dC dB dD dB dB dB dA dD dC dE dC dz dB dC dA dx dD dx dC dC dA dC dB dB dB dE dA dz dC dC dE dC dB dB dx dD dB dy dB dC dw do dA dA dE dD dB dC dE dA dy dz dC dv dC dB dD dz dB dB dC dD dB dB dy dD dC dy dC dA dD dB dy dB dD dC dy dE dw dC dC dy dB dA dA dC dC dD dE dB dy dC dz dA dz dz dx dy dB dB dA dC dD dA dw dD dy dx dC dz dz dA dB dA dB dy dB dA dB dE dA dw dC dy dD dC dB dy dx dC dE dC dB dC dC dy dB dB dB dp dB dB dA dC dw dD dC dy dC dA dD dy dC dC dE dC dy dy dy dB dt dC dA dy dy dD dC dD dC dD dx dt dy dC dx dx dy dB dD dA dB dy dx dB dA dC dA dA ds dA dA dB dD dz dA dC dy dB dx dD dA dC dy dB dz dA dx dA dB dA dB dB dA dC dA dA dA dC dA dC dC dy dC dA dw dy dz dy dD dy dv dD dC dx dA dB dy dB dC dy dC dy dz dB dB dB dC dC dD dy dD dC dC dr dA dE dv dC dC dx dC dB dC dy dA dw dB dC dz dC dE dz dy dy dC dA dA dB dB dA dz dD dC dB dy dr dB dC dE dB dA dC dz dC dw dC dB dy dy dB dy dC dC dE dB dD dE dx dw dv dy dz dB dB dC dD dB dE dE dC dq dA dw dD dC dz dw dw dy dD dD dB dD dA dz dA dB dy dz dC dy dp dB dB dD dw dy dC dA dD dB dB dC dA dz dB dz dp dy dz dA dw dr dz dC dt dC dy dA dD dB dw dC dC dx dC dy dC dy dy dx dE dB dA dC dD dD dC dB dw dA dC dw dz dB dz dC dB dE dD dv dB dE dA dy dA dA dB dB dr dx dv dA dC dC dD dA dy dy dA dA dw dA dA dB dB dC dB dw dt dB dy dx dw dD dB dD dA dA dC dy dC dx dB dA dA dy dC dD dv dB dC dB dy dy dD dt dA dz dD dw dz dC dB dz dB dC dD dw dB dy dC dA dC dy dA dE dA dA dC dB dC dr dB dy dD dC dC dB dA dB dy dD dt dB dy dD dy dC dA dy dB dA dC dA dA dD dA dC dE dE dy dC dC dt dB dA dv dD dx dD dt dz dC dA dD dD dC dy dw dC dz dw dt dC dB dC dD dD dz dx dC dy dz dA dt dC dA dB dB dD dy dB dB dw dA dx dA dB dw dB dy dC dC dx dC dz dB dD dy dy do dB dC dy dw dA dC dy do dD dx dA dz dC dB dw dz dC dC dA dz dC dy dz dz dA dC dC dx dr dE dr dz dz dB dC dt dC dA dy dz dD dw dy dC dC dA dB dB dy dC dv dB dv dv dC dB dy dw dw dA dB dy dA dA dB dB dB dt dp dx dx dw dB dB dD dr dB dz dC dx dx dC dz dC dz dB dC dB dw dz dw dA dz dC dC dx dA dz dr dB dC dy dx dB dA dB dD dz dA dy dD dB dz dw dz dD dx dz dD dD dB dD dC dC dD dx dA dr dD dB dC dC dC dC dC ds dy dC dB dx dC dB dC dy dD dz dC dC dw dz do dA dA dn dA dB do dz dy dA dy dw dw dA dB dB dy dC dv dw dB dy dB dz dz dA dw dC dw dt dE dA dA dy dA dx dD dz dz dw dA dv dA dB dy dC dA dD dB dz dx dz dB dA dE dw dC dC dB dA dv dy dy dv dr dv dw dw dB dz dB dB dy dr dA dC dB dy dz dy dC dy dx dv dC dz dA dy dv dB dv dw dC dB dA dw dC dA dy dA dw dz dA dz dD dz dC dv dr dz dA dy dD dA dC dr dw dB dA dD dC dA ds ds dD dv dz dB dB dw dC dA dz dy dx dA dA dA dv dx dA dy dC dy dy dy dz dz dx dC dB dB dB dC dy dx dr dy dx dx dC dv dw dy dt dt dz dz dy dy dz dB dB dw dz dD dC dA dy dB dB dA dy dy dz dy dA dx dy dz do dv dA dC dn dr dy dC dy dx dz dC dx dD dA dD dD dA dv dy dy dy dz dt dB dA dx dw dr dq dA dA dy dz dz dA dz dB dz dq dB dx dA dA dy dy dA dB dv dz dv dz dA dq dx dz dw dx do dB dr dy dA dw dr dx dB dx dy dz dy dy dz dA dA dz dA dy do dB dC dn dC dB dy dx dz dw dz dy dC dB de dB dp dx dA dx dz dz dy dy dB dB dy dA ds dw dq dB dz dz dA dB dy dt dy dC dD dz dA dA dB dt dz dA dB dz dB dx dw dy dD dv dw dt dr dq dn dC dB dA dy dw dz dz dw dB dx dA dy dy dB dz dz dA dD dA dz dz dA dt dq dB dC dC dw dz dA dy dt dw dB dB dB dt dA dC db dB dA dB dC dv dr dA dy dx dC dA dz dv dC dw dw dw dy dB dw dA dB dC dz dy dx dD dB dv dA dr dA dz dt dz dy dz dy dB dy dA dv dr dx dq dn dx dr dw dA dx dA dw ds ds dB dx dy dy dy dy dw dw dx dz dw dy dx ds dA dv dy dw ds dB dB dj dy dy dy dz dq dv dj ds dz dz dA dz dv dC dy dt dr dC dy dz dw dw dt dw dA dz dy dz dA dh dq dB dD dB dp df dB dz dp dA dy dz dq dt dC dy dz dw dA dB ds dw dx df dz dA dy dx ds dz cQ dz dw dB dw dt dy dy dz dx dG cY dy dm dH cI dA ds dA do dI dy dn dx dz dp dk dx dx dp dv dB dI ds dl de cI cT dy dw dA dw dx dx dn dd dw dc dt db dz ds dv dt dr dy dz do dx dl dr do dt dy dq dm dn dz dy dA dq do dA dv dA dA dC dy dz dz ds do dA dx dy dv dw dx cr cS dt dy dy dw dp dm dB dC dx dt cV dw dy dt dA dq dA dv dr dz dl dw dx dp dB dc dz do dy dJ dj dI cM dx dk dl dz dI dg cM do dv dv dt dm dt dA ds db do dw dw dp dz di dx dw dz dl dw dz dA dw dx dy dd ds cT dw dw dw dA dn dv cT dK dn dc dJ dA dz dt db dJ dA dy dt dr dp cV cC cS dt cs dv dw dv dp dz dI ds dv cU cJ dL dq cS cW dq do dr dt dk dq cM ds dt di du dt dI dt du dp dt dx di dx dm dw dr ds cY dh de de dx cO dI cX dp dl dy dt do dt dt di dm ds cR cs dv dv dt dp dw ds cZ dv df dv cQ cS dg dI dv dw dI ds dp dr df do di dr dx dw cG dr dv cN cR ds dx dx ds dv dr dJ cR cL dx dm dz dh dn dz dg dx dj dl cS dr dv cO cK cU dr dn cR ds cJ cJ df dq ds df dj dn dq dh ds dg dr dk dc dl dr dJ dz dx cV dt cp cq dJ cY dg cX dc do dr dq cR cR cJ cU dr cZ cV dr dq dh do da dp dr do dt dn dI cz dq dk cS dm du dq dI di ds cU do dj cA cC cI dv cU dv ds cp cB cI dm cB dq dq dH cR bR dM dm cD da do dn di cH dk ds dN dq cV dJ de cV dp cO dj cz ds df dd df cZ de dO cA ct dP do cy cN dI dk dl dh dm dc dh cs dk dp cW dc dp dp dr dj df ds dj dq dJ dZ dq dh cs dm dt du cP dU df dk dJ dd dh du dg dl cA dq cc dK db cN di dd dt cX dq dr dT dn db ds dm dr dp cK dr cY cQ cJ dq dV dp cG dQ cz dv dp ds dl cx di dp dR db cG dI cu dm dv cR ds dh cD dt cN cJ dm cN cH cF cN cs dr dk dk cR cG dr dI cl dd cL dn dG cy cK cP dn dS do ck cU dk dk dj dN cM de dp cw dW cZ dO da dl dm dT de dn dg dU cW db dk dj cN cK cW cw cZ dJ dn dL dU dJ cL dp cV dc da di dJ cW ck dt cD cs dr dh dV cm dp dq cY dS cs du cO cF cI ch da cs dm cJ dI dh cT cW cY dc dp cC cT ca cM cJ cT ds dT cF cR dJ cQ dl dp cT dj cd dP dn cC dp dr dg dr cp dJ ds cb do cM db db cM cJ dj bH dH df cO cc dt dG dj cM cu dc dL cM cs da dG cQ df dG bU do cY cJ dh ct cy cA di cu dm cV df dn cU cV cm dh cJ dQ cG cJ dd cW cV cI ct cU cM cW cs ct du cX cI cc cm dp cG cX ck dj de cp dj cX dc cC dd df do dW cY cO cN cz dg cD cz cY cS dT dm cW dp cu ck du ck dG cA cQ cL cb dd cs dT dX cI cA dd cr dn dg dT dk dV cy cX cu dj cu dI dJ cJ dP dc cX dP dk cV dU dQ dl cU cX di dk cX cU dY cy do cu cJ dq bU cQ de cM da cB cN cM dL cz dJ cE dX cr dT cd df cB dm dY cD cr dH dm cR ct dn cG dQ dt 0.124 cG cC cY dZ cL cN cr cA cu cP cW dT dq cR cE cZ dm cU dU dp cK dl dP cd cL cu dg dt bO df ea cE cY cz cR db dQ cK cH cY cn dK co cY dG cJ dP da cE cR cX cY ck cQ da dT dX cV cn dp dM da di cU ck di cn cx de cL dR db cW dN da cJ cA da dG cZ cz dq dj cZ dN co dP dG di cX ck cy dI cN cN du dG cP cT cM cW du cz cD dL cu cU di cO cS cU dJ cw cw cY cQ dm dr cw cL cN cL cu cQ dc dP dc dp cD dI cS cx cL cG cM de cO cd cO cM cZ cX df df cB cI cN cU du cz cE dL cW cV dj dL dp dn da eb cu cs cO ch cz cX cX cO cA do du cZ dr dL df cB dg cC dT dT cQ ds di dk cC di cY cd dk cY cO cG dR cW df dH cX dc cI cX dL cJ cF cR df cV dT cR ck dG cU dd cF dL cG dJ cu cX dh dT cH cT dW dd cM cW dd de de du cJ cU cT dJ cJ dO cX dT dk cX cU cZ cV cY cL cJ df cs dP dJ cT cW dP cs dH cT dp cx cA ct di cK dJ cY di cO bY cI cT cW dc cT cH cJ cU cX cz cx de de cR dJ da dm cJ cO cu df dJ bR cN dm cm dn cU dl dH df cZ df bU dI cW dp dt cO cO dJ cC cW cG dr cY df cu cC cK cN cQ cI db cO df cG dR dJ ck dg cV cH cT cN dH cR cN cN cO cw di cI cy cV cm ck cE da cE cM cQ cY dR dL eb cN cW cH dT cu dP cO dj cZ du dK cT dk cN dI dm dh cO cE cr cT cr cS cQ cS cW cO bU cB cD cK dR dU da cS cs dk ck cL cG dm dG cy cS dH dL dl cT dG cY dl dd dL ck cC cO dP cI dc cW dG dP cK cQ cr cJ dT dR cG cT cs cZ dq dh cZ cz cm cG dh ec dI cu cH dR cO cN dX cQ cM cH cI cP du cW dk dH dL dc cS cI cO dh dP da cF dj de cV dZ dK cr cX dQ dO cR dW dL cw df cS cR cQ cw ct cS da cJ dP do dl dX dG cz du dJ dL cz cN cO cD cz cV dN cu dJ cA cK dK dd cA cV ea dG dd cM cY ct cT dL cI cJ cS dW dg cU dO cE cs df dh dI cU cH cB cX cy cL cS cH cV cM cU cr ck cG db dH cV ck cc dL dG dh cS da cL cS cz dJ dG dc dU ea cK cG cY cY cm cU df cN dL cX cB df cL cr cs cE dT cZ cC cL ck dG dJ cw dH cn cK cz cy cO cJ cA cM dN dP du dU cz cV dZ cH cr dk dP cG cX dd cL cZ cD cJ cI cX cO cI cJ dG cb cU dI dR cy cY dW cy cz cI cR cZ cp cy dO cr cZ dJ dZ da cs cx cz cG du da ck cK cK cU cK cO da da dd dI da dR dH dL dc dO cA cW cr cU dT cE cZ cT cT cA cU cX cM dc du cs cR cH cz cE cR dL cS dc cJ cs cL dh cy cO cQ cA dL cO cr cJ cR cV cG cK cJ cC cw cN cD cX cU cW dc ck cU dT cB dW di du dH cB cH cW da dG cZ cU cT cK cz cR da cT dG dn cJ cC dd cV cy cJ cD dH cD cZ cY cK dc dT cJ dG cD cp cE cH da du cN cn cD dK cX cS cs cM dc cT dP cA cK cw da ck cN cZ cn cK cJ cM cT cD cz cH cG cu cC cC dc dc cO cC cG cJ cw cV da cU cX da cu da cT dH cN cJ cn dG cY dd cT cI df cG du dH da cE cM cU cD dc dJ cD cR cY dk cW cT cU cD cs df cy da cJ cz cs ck cP cL cV dc ct dG cZ dL cW cz dk cG cr cD dG dL df ct cs cX cA cs cS cL cD cX cA cu dZ cO cQ cM cL cG cA dK cL cJ dJ dK dd cy cX ct cN cA dJ cN cV cV cT cp dg cW cG cM dU dW da dL cz cs cG cO cD cT cZ cG cB cs cT ct cr cM cG dK cC dI cQ cM cD dh cW cK cT cV cu cZ cu cz ck cr cz cG cG cs cD cO dT cW cJ cI dc ck cP cz cS cO cM dL cL cB du cU cI dd cD dT cJ da cC dP cC cG cX cO cO cG cG cR cx ck cu dd cI cG dl cW cu cJ cT cD dc cs cK cF dH cU cZ da cC cT cz cd cK cR du dG cI cD df dk cA dK cy cN cr cS dJ cG cU cw cM cD cQ cI cZ cr cG cC dJ cV dG cJ cI cI cr cz cQ du cx cy cX cK cO dP cL cL da cS dh cO df dG cW cs cs cu dP cJ cu cT cO dL cJ cO dR dL cJ cH dT cY cM cs cJ dG cO dc cI cM cJ cD cQ cW cT cu cX cN cT cO cP cW cN cu dH cV dG cC cu cr dG cN cS da cs dG cT cI cT dH cS dc dJ cS dL cJ cY dJ cE cL cs cE dK cr cZ dJ cs cS cI cX cG cH cK cz cW cN cQ dG cs cZ dL cL cO du cX cO cr cS cr cu cK cZ cW cD cO cJ cD dT cu cR cK dH cH df dJ cW cJ dP cO cA cN cs cN cI du dL du dH cu cI cK cy cQ dZ dK cJ cK dG cy cU cG cB cV cZ cW dL cZ dL cT cK cW cu cM cK dG dH cH cO cr cI cO cz cT du cI cI ck cJ dc cT dP dL cU cJ dP cU ck cW cG cK cI cu cK dH cT cZ cs cJ dI cL cD dG cR dc cX dL df cH cL cC cG cM cs dc cX cX cI dG dI da cr cA cN cJ da du dT dG cS dh dL cN da cL cN cT cT cS cr du cL cX cN cG dP cU cZ cJ cO dH dG cQ dL cS cY cN cS cM cU cN cO cI cN cO cX cX cS cW cJ dK cz cJ cZ cD dI du cX da cG dT ct cX cI cK cZ du cU cM cJ cR cT cJ dP cJ cT dW cQ cT cy cz cQ cL cu cE du cQ dT cJ cz cL cI cO cP cH cI cr cI cN dG dG cG cy dJ cS cU cu cr cK cB cT cS cI da cU dG cI cR cL cw cr dG cU dG cN cs cD dP cK cI dT dH cL cs cZ cI cG cX cV da dJ cr cU cA cN cL cI cM cZ dH cs dL cN cX cY cu cM dc cY cJ cu cN dd cE cL dc cZ cZ cy cN da cw cL cQ cD cN cV da cK cU cT cr cB cs cS dd db cO cW cW cX cI cA cC cU cC cN dL du cS cZ cM cL cD cN da dG cO cu cM dG cu cW cX cw cL cY cY df cn cT cO da cW da cU dG cO cT cR cO cE cG dL dL cQ cr da cZ cH dG cZ cu cZ cI cR cN dL cX cH cO dG dL cw cJ dL cN cJ dL dG cK cK dG cS cY dd cJ cI cS dL cD cT da cH cW dL cH cT dL cX cX dG cW cJ cL cG cJ dd cM cI cz da dI cU cT cU cO dL cJ cw cU cY cr cU cJ cJ cU da cZ cQ cT da dH cG cK cJ dL cu cM cM cJ cL cW cJ cR cC dK dJ cS du cR du cE da cZ cr cr cE cX cS dc cX dJ cG cB da dc cu cG cr cR cy cz cs df da du dJ cH dL cG dT du cJ cO da dG da dc db cT cZ cK dL cT dL cK cu cr cz cU da cK cu cB cL cL cG cI dL df dU da dH du cy cU cs dG cN da cS dG cQ cD cz ck cU dG cr cL dG cL cD cX cO cI cX cX dL cX dG cz cY cK dP cX cz dL cY cr cU cJ cN cG cL cI cX cu cV cJ cB cO cY cJ cJ dT cZ cS cL cR cs cD cr cO cL cK cW cS cV dL cZ cy cL cT cI cL dL da dL dL cX cR cT cL dG cL cK cK cB cN dG dH cG cR da cW cU cU cA cN cL cO cT cW cR cL cX dP cD cz cM dc cZ cu cz cV cS cI cO cX cX dL cM cU da dG cI cL cT cS cJ cS cO cE cM cS cL dL cR cN cs cO dL cL cu dG cR cO dT cN cN cB da cN cN cu du cz cK cX cS cJ cM cS cT cJ cZ cG cT dG cM cO da cr cU cH da dG cJ da cM cW cu cD cL dH cD df cN cS cG cO cA cX cK cS dL cu cG cR cs cU da cU cS cJ cJ cO dR cy cJ cV cI cN cD du cI cw cE cT cR cN dL cG cU cP dL dG cZ cJ cs cX cz dL dH cu cI cS dG cs cT cM cJ cU cG cJ cR dc cO cH cN cV dR dP dL cK cy da du cZ cJ cW cR cW cu cS dJ dL cX cL cJ cV dc cZ cO cV cZ cu cZ cJ dG cL cX cU du cG cY cK dJ cJ cW cJ cu cL dG cr dc cM cG cH cL cO cI cN cX cJ cL cS cJ cT cI cR dK dG cI cT cu da cI cK cX du cK dG cG cE cN cT dL cZ cr cT dP cS cY cz cG cD cI cS cS cD cu cG cw cL cO cM cN cZ cT cS cM cH cU cZ cD dG cJ du cz cN dL cI cU cA dH dH cz cJ cN cT cG cU cI cT cV cJ cO cM da cY cO cJ cK cO cR cT cO cT cs cG cV cA da cW cK cG cN cJ dd cJ cW cK cI cW cX cu dP cr df cS ck da cT cY cU cu dL cO cK cz da cT cV cO cU cW cC cS cD cQ cL dL cT dL cN dJ cW cY cH cz dL cH cr cN dL cX cU cw cZ cG cN cu cS cJ dc cL cX cQ cz cI cA cU cQ cz dg da cs cz dH dd cD cN cK cI cJ cL cS da cG cZ cM cX cZ cI cS cM cT cM dL dL cQ cT dO du cN cR cJ df cS cG df da dZ cI dc cs cZ cJ dJ cT cW cH dH du cu cU cT cK dL dd cU db cS cI cX cO cK dG cD cI cZ da cD df du dd dJ cO cK dg cI dL da cV dL ck cQ cT cZ cZ cJ dG cN dg du dG cZ cG cK cK cX cL cR dJ cM dc dL cM du cT cO du cJ cI dL cM cZ cK du cM cZ du cL dd cL cX cO cU cO da cO cT cS df cV cJ cU cX df cW dh cO du cK cT dg cX dd da df cI cs cS cV cJ du cM cN dI cN cJ da cS cL cM cK dP cT cK dd dH du cZ dc cR cR cL du dc cL cX da cU cM cQ dJ cJ cU cJ dT cQ cX cU cM cJ cV cQ cQ cQ di cX cS dG cM dJ cL cX dd cU cM cX cZ da cU cJ cM cS dk cM cN cS cH cz cD cL da cJ dg cS du cJ cQ cU cK cO cS dG cQ du dJ dc dJ cS dd cD du df cJ cY cO cI cM dJ cQ cG dc cK da df df cS cN dJ dc cX cL dI cS dJ cN dJ cX cK dc cX cX cS cD cN du cU cT df cZ df dc cS cN cz cI cN cH cY cS cL dc cU cW cU cS cN cz df cD cz du cJ dl cS dd dc cX dH cZ du dJ cN cV cD cY cV dG cM dg ck cX cQ cR cU du da cQ cJ cM cX du cQ df db cQ dJ du cV df cY cS df cY cT dI dc cN cV dJ cX cL df dJ cM cY cQ cQ cH cI dJ dk cN cV cS dJ cW cs dG cV cT cr cL cU dc df dG cY cS cR cN cQ cV cL dc cz dI dJ dW cT cM cZ cX cN cN cO cT cS cN cD cX du df cX cQ dm cL db cT cV cR cR dd cW da cU dl dI cZ da cJ cL cW cW cY dJ dI cM cN cX dL da cG cW cN dI dc cV dc cN dk du dG cO dG dc cX cQ du dc cS cV du cz da cY cK cX cV cS cM cT du di dO cK cT cG du cK cS cI df cK cQ du cO cV dg dG cO cZ cI cK cT cO cO cL cV cJ cX cN db db df cU dL cL cN du cO dh cQ du cM cA cV cM df cZ da cX cX cY dJ cM cY cU df da cQ cR cS dj cR cT cU cI cQ cL dL cR cS cY cY dj dJ da cY dL du cN cz df cS cO dL dG dk dd dc cV cV cV dh df cT cV du cZ cK dc df dh cX du dl cI cJ dc dJ cS dL cZ cO da cY dh cE cJ cY cV cS cN cL cL cT cO cO cZ du dc cJ cT df cz dK cM dc cS cZ cJ dh cz cM du cM cL dh cZ cS cL dc cS dh cS dh cY dc cJ cR cN df dd du dJ cT dG cR dJ dJ dh cJ cH cL cN cN dc cQ dI cO cN df cY cJ cL cY dh dI cS dd cL df dg cO dG dh dT dc cN cT cU cT da cL dI dh df cI cY cY cN dG dJ cX cZ cY cR dm da cO cu ck cU cL dd cO cM cV dL cS cY df cT dg cS cN du dl cK dh cu cK cM cN cK dg cM cY cX dc cJ cV cQ cM cJ dJ dc cz dh du dJ cR cQ cJ da cS cJ cN cs cV cR cR cM dn db df dh cM dd dk dI cU cJ cQ cU dk cT df cG cX cV cM cJ dJ dJ du di cQ cR cN dd dI dd di cL db cX cM du cN cT cK dJ cS cM cR dc cN cz cr dI dI dJ df dJ cL cZ du du cY dd cX dk cV cV cR cQ cQ cO cJ dl cT cY dG cW cS df dd dd dJ dj cK cU db cR dI cK cJ dd cT cV cQ dh cL cR cX dJ dj dc cM df dg cU cJ dI cY cY cN cY dJ dc dJ cX dk dh dc dc cX cN cM cO cK dI cY cJ cY cX cQ cQ cM cW cU cR dh cV cR cQ dJ cL dc cQ cK cX cK cM df db cR du cS cY db dI cS cT di cS cN dh cO dc da dj dd cN cW df cY du dJ dl cQ dc cR cQ dc dd cO dh cW dl du df dg dc dc db cI dJ cY dJ df du cU cV db dd cY dh cT cS dH dG cM cR dJ cX du cM cQ cW cK cO dJ cK db df cJ dJ cN cY cK cN cN cK dh dI cS cM dd db dI cY dc cN cz df cO cV df dI cS da dJ df dI cI cV cS cR cS dJ du dK cY cS cQ dG cV cX cU dc dj cV dJ dJ cT cY cX cN dJ cS dI dJ cS cV cG cM dJ cT dd cY cK cX cY du cX cT cV dI cS cU cX dh cQ dJ cV cs cM dd cM cM cR cR cM cK dc cz cR cX cz cR dI cW cV df cT cr cD du cM dJ dl cJ cR cU cY cS cT df cX dc cV cw du cK cB dJ cX cR cD cQ cX dd da da cX cQ cX cs cO dG dc cT cS cV cN cU cM dc cX db dh df cQ dg dG cU cT cz cO cQ du df dl cU du cG cz cQ cE cU cS cJ dd cM dd cE dd dJ cI da cJ cS du cN cD da db dI cM df cS df dd cr cR dj cr da cS dI cW cu cX cW cY cR cX cN df cQ cI dh dc dG cL du cJ dl cV dc cR du cL cY cN cM cU cS dh cS cO dc cM cN df cQ cQ cs dI cN cU cR cR cU cU cY cR dk cV dJ cW dc cR cZ cM df dJ cY cR cL cY cX cY cS cY cX cM cL cG da cO dg dJ cz df cU du du cK cY dG cM cz cV cM da dJ df cJ cZ cS cX df cO cY cT dc cB cQ dk du cR cY dJ dL dJ cX dH cG dd dL df dG cO dc cZ dh di df cQ cE dm cQ cZ cX cJ dI cN cL dI dl cK cS cz dI db cy dd cQ da du cQ df cX da df dc da cY db du cX dJ df cM cY cT cY cW cT dH cQ cH cM cZ cz dP cI cU dG cG cL dH cW dL dP dc du cJ dJ cR cO cX cX cS cU cD cU cX cL cZ cX cV dc cX cX cs cY du cL cU du cU dG dJ cQ cY dH cL df cI df cL cI cu cZ cR dG cM cR cA cH dG cH df cM cU du cI dJ cV dJ dI cU cH cT cX cC cQ dG cT cU df cN cR du df cR cM dG cW cT cU cM cO cL da cR da cX du da cK cu cY dh cU cK cW df cT cY dd cV cM cz cY cX cX du cO df cL cM du da cQ cU cG dG cG cu dG dJ cO dL cD cu cK cU dG cU cV da cS dG dg cs dL cZ da cZ cD cT da cI cU cZ cR du cT cZ cW cZ cV cX cr dc cO cN cS da da cL cW df dg cX df cN dc cJ cT cJ cQ cU cM cE dc df cO dh cU cY cT cz cX dh cs cN dP cK cS cU cJ cZ cY du cL dd cL da cA cz cz cI dG da cL cX ct dk cL cN cY cW cV cA cJ cN cJ cT dJ cV cN da cU cL cA cZ cL cU cM cT dI cS cJ cV cJ cG cT dd dT da cW cL cR cR cZ cK cV cV dI cz cu cz cV du df cU cN cM cR cY cT cV cM cV cz cL cN cX cY cI cJ cV dL cX da cG cL cQ cU cW cL dT cM cV cN cJ cu cV df cJ cQ dd cQ cT du da dd du cI cY dc cJ cW db cT cL cX cL dc cN df cS cR cX cO cO cY cJ cS dI dc cZ cR db cN cM cO cV cM cz cR dG cJ df cV cY cY dJ dI du cz dJ cX cN cK cO cS dJ dJ du dG cQ cZ cR di cS cr cR cQ dI dG cK dc cQ cL cR cK cM cJ dJ cu cE cK cV cI dG cJ cS cN dJ cK cS cJ cO dc cQ cT dJ cU cI cR dc cG cU dL cM cM cW cX cV cZ cS cJ cZ dH cH dZ cN cX cX dc cV cG cH dc cO dL dd cU da da cu cK cJ cZ du dI du cA cM cQ cP da cW cu cV dL cL cS cw dL cS cS cN cX cQ cG cT da cT ck cT cQ cz da dc du cJ cR dI cO dP cC cT cz cN cY cJ dK cW cG cI cS cH cR du dG da cL cU du cT cM cL cM da cX dJ cT cZ cZ cZ cN du cK cS cV dI cD dL cM dJ cV cI cO cI dd cL cH cO cY cO dW cU cK dI cI dc cz cT cR cU cO dH cJ dG cJ cI cJ cL cM du cV cI cV cU cG cY de dk da cI dH cX dd cN cG ct cT dJ cH dI dd du cI cR cN cL cM cG cJ cO dI cN du dG cN cr cW dc cN cK cU cI cM cN da cA dJ cX ct du cZ cy cN dc cX cZ cJ cM cS cN dc cM cy cz cM cN cr dI cR cW cN cL cJ du cH cW dI cG cA cT cR dc cI cX cu cY cS cY cI cT cR cN cM dG cD cY dL da cB du cZ cL cL cD cG cK cL cS cL cG cM dG cT di cY cS du dO dk cT cJ cI cX cM cL cL cU cG cY cX cN cV dc df cK cI cM dH cQ cI dc cI cK cG cL dJ dc cN cR cI cS cR cR cS cO cz cU cX cT cY dd dc cD cK dJ cu cY du dI cI cR cI cQ cG cH da cm da dc cG cr cV cz cW cI cC cL ct cO cR cN cw cV cM dH cG cG cZ dG cI cY cN cZ cS cu da dH cN dP cu dc ck cG cL dl cO du cQ cR cZ cZ cN cV cM dT cz cQ cO cJ dc cK cu cJ cX cR cV dI dl dG dJ cR cD dI cy cV cy cQ cu cz cL cY cN cU cO cr cA dc cr cL cR ck dJ cN cM cN cM dI da cr dJ cZ cQ cU cJ cs dG cr du cM dL cN cR dG cO dc cU da cQ cz cJ cK cW cu cH cL dL cJ cQ cZ du cE cT cS cJ cG cu cZ cW cT cT cR cs cY cz cT cZ dh du cM cT dG cJ cL cJ dc cM cR dG cG cX cJ cU cJ cT cZ cO da du cM cT cI du du cJ cL da dc cw cN cO cu cD cr cM dJ cV cJ cD dH cD cN da cO cT cJ dI cL cN cX cu du cT cK cz cz cr cZ cS cz cK cN cJ cR de cz cR cJ cS cK dI cI cX cT cO dd dL cM cL dJ cJ dJ cX dG da da da da cs dG cT cC cW cJ cN cO cS dI cr dg du cz cJ cN du cS cV cY cI dG cW cZ cI dl dL cG cV cN cJ cM dK cI du cJ du dG cT cz cu cK cZ cW cT cS cN cW cL cR cX cS cL cT cO cI dG cu di cJ cX cr cG du dc cU cZ dP cK cX cO cJ cK du dL cZ cr cX du dI cz da cZ cC cR dG cJ cY cX cG dJ cU cS cM cL cz du cJ cW cL cH du cX cU cV cT du du cT cu cs cN cT cI cN cM cG cM cR cT cZ cL dK cT da cI cU cN dG cE cU cT cT cT cI cM cJ dc dP cD cZ dT cH cL cZ cR cM ck cQ cN dc cz cT cN cT dG cz cK cT db cO cL cV cX cR cM cN du cZ du cJ cS cI cY cO cU da cL cD cY cJ cZ cZ cX cX cz cZ cJ cZ cD cY cT cS dJ cG cN cZ cL cG cR cS cZ cM cN cG du cM dJ cL cW cR cI cR cY cY df cJ cM cs cK cK cK dL cE cU cu cU cR cN cO cD cT cz cZ cG cY cJ cG cN cQ cL cL cN cx dT cO cY cB cD cS da du dG du cZ cX cH cJ cT cM cS da du cG cJ dJ dP cI cD cZ cK cW du cu cA cM dJ dG cH cX cT cJ cX cO cT cr dL da cr cM cE cO dP dG cw cR cz cz cW dg dG cM cH dh dL cT cK dL cR cW dL cI cN cM dg cz cM cZ dG cz cJ dH dJ cz ct cS cT cN cD cX cK cz cU cR cr cI cL cD cU dG cN cH cG df cG cX cJ cU cJ cV dG cO cL cI dc cL cJ cS cM cr cO dG cK cL cK cQ cW da cV cR cU cs cz cV cX cu dP dJ dI cH cZ cz cr dL cI dG cM cU cE cY dL cL cu cK dG cU cS du cB dG cX cR dL cO cO dG cU cI cK cT cM cL dL cz cO dK cw dc cH cK cM cR dL cX dJ cH dP cA cu dH cT cU cG dG da cT cS cJ cY cz dI da cW cO cK cz cQ cX cY cL cV dd cK cM cO dI cU da cL da cI cN cG cM cM dd dG cO cS cN cO cM dG cK cZ dc cX cN dJ cY cT dJ da cS cO db cN cK cT dG cX dI cR cK cu cD cK cQ cT cL dL du du cR cS cZ cJ cH cH cZ cK cS dL cW cs cO dc cD cD cA dG cR cz cu cI dG cM cT dT du cB cu cS dG cW cX cU cX cQ cU cJ cy cJ cC cT dL cH cN cz cJ cR cI cJ dG dJ dL cI cr da da cK cV cO cr cZ cL cs cO dh cG cT dL cC du cz cZ dL cW dG dc cZ da cW dI cW cX cI dL cT cO cA cG cS cW cM cO dL cW cI du cI cN cJ cz cT cL cJ cN cK dG cK cT cN cU da da cG dc cI cS dc cy cC cN cQ cN dJ cD cX cw cV du cQ cO cX cZ cO cU cG cS cr dT cX cL cX cW cu cr cL dG cD cT dL cN cU cG cT cK cH cX cL cy dG cS dJ da cL df cI cA da dc cU cO cN cT dJ dc cR dL cr cZ cT cU db cy cK du cT cN cN dc du cN cS cW cX cZ cD cJ cV cN cX cS cu cJ cU cZ cV cN cZ dJ cu cJ cZ cZ cJ cX cZ dJ dG du cz cV cR cR cV dc cX cL cS cu cU cz cM cK dL cR cR du dh cO cO cA cW cN cI cu cS cN cX dd cU dI cJ cZ da dc cR cz cQ dJ cY cJ dJ cN cY cW cL cS cz dg cL cI cz cz cQ cO cS cL cV dJ dG cX da cY cS da dJ cX cO cO cU cM cI cz cM df cT dc cY dG cM cM cM cG cT cI cR du cE dc du dG cR cN cN cD df cM cK cT cQ cO cW cZ cS cS du dJ da cU cW da cU da cS cU cW dc cN cX cR cs cM dP cS cO dG cZ cD cG cU cR db cR cL cu cM cM du dc cS cJ cS cX cJ cT cK cZ cO dG du cI cU cB cE cU cN cJ cS da cL cM cS da cH da cO cT dc cG cT cJ cS cX dJ cZ cU cA cK cU cJ cX cR cr dJ cS dc cQ cL cV cM cS cS cK dc dc cT cI cU cQ dc cN cZ cz cT cT da cU cD cU cT cM cr cL da cz cL cS cN cz cU dc cN dJ cW cr cR cO dG dc cU cJ cO df cO cN cZ cN dJ cU cT cZ cT cy cT du df cQ dP dL cO cI cO cX da cM cs cX da cS du cZ cO cS du dJ cR cI cT da cN cH cK cU cT cH cX cW cJ cV da cZ cW cQ cU cM dJ cT cT cT cJ cI cJ cT dI cR dG cW da cG cX dG cU cV dL cN cV cN cT da cz cM dc du cJ da cJ cS dT cZ cG cM cO cX cU cM dc cW cJ cZ da cJ cU cR cK cU cY dL cK cJ cS da cT dc cO dG cU cM cK dI cU du cS cI cN cG cI cD cz cT cU cz cS dL cT cU cX cV cN cA cM cR cJ cX cW cJ cD cR cS cS cZ cy cW cZ cL cZ dd dc du cL cR cJ cu cH cK cL cS cz ck cV cT cK cT cV cr cR cU cu dL cT dG dT cs da cA cY cW dd dH cL cS cN cQ cR cS cH cX da da cU cT cU cR cX cT dP dJ cU cW cE cL cr cO cJ cJ cU cX cL cK cW cX cO cU cG cT cN cT cM cr cT cL cN cz cV da du dc da cM cQ cV cs cN cz cW cS cO cS cs cI cD dL cT cJ cS dJ cR dT cU dL cU dc dh du cE cJ cJ cW cO cJ cS dG cX dG cZ dh dd cU du dL cK da cN cZ cz cU du cy df cR cS cU cL cS cJ cJ cU cM cL dc cG cQ cM cH dP cZ dc da cM du df dh cN cD cJ cV cS cO da cT dG cN dG cL da cK cL dL cW cO cL da cA dG cM du du cN cX cK dJ df cS du cN da cT du df cR cM cK cM du cV cH cX cL cS cZ dg cK da cY cL cQ cr cE cY du dJ cX dd du dc da dJ cO cT cy dP da dJ cY cJ cL cR cU du cN cN dc cQ dh cU da cN cS cY cZ cO cT cM cL cX cV df df da dI da cR dc dI cT cR cL dT dc cZ cM dJ cr cO cM cT da cY dh cL dJ dL cr cW cT da da dJ dg cM cM dI cR cJ dG dG cI du dL cT cA cM dL cJ du df cD cR cT cV dg cS cJ cY dG cX cN cT cQ cG cI cQ cZ cX cO cY dI cV cT db cS cX cQ dg dJ dc df cT dc dI cS cN cQ db cJ cX dJ cI cX df cH cQ cL du dG cY dc cS cY cN cK cQ cT dJ cM cT cX cQ dG du dc cR cJ cZ dh dG cT cR cT cI cJ cM cX dl cM cN du cL cU cY cS dc cL dH cM df cM cX cu cU cY cH cN cL cO cR cS cO cU cX dc da du cL cO dJ cL cR dc df cT cL cQ cZ dc cS cM cT du cJ dJ du cO dG cM cR dL dL cX cQ cO cL cJ cQ cR cK cS cu cT dG cV cS dc cN dc dJ cN cZ cX cQ cY dg cN cO cS cT cM cM dc da dc df cS cL dJ cN dd df cN cV cV cO cK cN dc cY dI cK cL cL dl cY du dc cY cN dd cS cR dc df da cO cS cV cY cQ cM cS cR cL cz cY cR da dd dc cK cV cQ cW cX cX dJ cS cN dG cS df cY cN cU df dg cJ dd dk cN cX dc cV dI du cY cY dc cY dh cM df dJ cV cT cM db cS dh cZ cR du du cX dJ dc cU du cY cR cN dh cT dh cR cX cJ dg dI cR du cV cY dk dJ cM cY df cJ cT cJ du cZ cN dI dI cS dJ cL dc cQ du cX cM cV df dJ cS du cT dI du cQ du cR cM dc cV dl cK cQ df df cN cL cJ cO cS cQ du cX cQ cT cS cR dc cS cR dd cJ cV du cR df dd cL dJ cI cX cQ cY cY df cN cK du dI cr cO cQ cY cK dI cX df cL dI cM cY du cQ du cM cQ cQ cR cM cY cK dc dc da cY df cJ dh dd du cI cZ cX cY df cR dd df cQ dJ df df cX cX cV da cV cQ cV dJ cY db du cL df cJ cN cR df cQ cO dh db dc cT cS du du dJ dJ db cY dg cL cW dd dg cN cJ cR df cX cY du cu cN cR cR dg dc cN dJ cY cY cV cG cM cO dg dI cQ dh dc cX cY dh dJ cY cV cN df cB dh dl dc dI dk dh cN dP cK cM du dc cM dd cN df cS du dI cH cS dJ da cY dl cV dd dc dh cV dd cO cM dc cN dJ du du dI di cR cM cN dk cR dJ cR cR dh cZ cN cJ dI cQ df du cV cQ cR cN dg df cJ cR dc da cR cM cX cQ dJ cX dg cX dg cV cM dc cR dL cM cT cR cV dc dJ df dI dI dc cO du cQ dJ cQ dc cV cY cV dc cR cV cN cS cN cM cV cR dc dI di cY cT du db cS cZ cL cN cS cM cT dc dJ cR dJ cX cW cY cX cR cQ dk dl cQ cX dl df dJ db dg dc cR df dI dh du cN dJ dI cM db cL df cT cS cV cV cY cJ dc df dc dd dd dJ cR di dc cR dh cV cQ cQ dd dJ cQ cM cO cS cN df dg du cJ cQ cM cL db db du dI dd dJ cR dk dI dh cO cQ cM dJ dI cN dL dI dI dc dJ dh dI df df cO cY dk cM du dI dc dJ dh cS cO dh dh cV dd dk cJ dJ cV cN cQ cR dI dl cY cV cN cJ cL cU cY df de db dc db dd cQ cQ di cI cR cR dI de cS dd cR cU dI dh dd dJ cX dd cZ du dg cN cV cS cQ dh dh cV du cM cY db da cY dk dc cR du de cT du dk cY dk cR dH db dd dp dI cM db dg cN dI df cN cQ dd cY db cR cX df dI dJ cQ cV dI cV cR db cV dJ du dJ dI dg cM cN cS cW cO cR cY dJ du dI cV dl cV dd cR dc dJ cL dg dk dh dc cR dg cR dc df dc dj cR cQ dl di cY dl dd de du cS cR dl cV du df cJ dd dd cV dJ dc cN du cV cR cY dd dk dg cS dk dl db dk db cV dc cL dc df dh db dc di dd df dk cT dk dd cR dJ cL dl dJ dk du cY cQ dc dI dI cM cV dc dk cY dJ dl cR dk dI dd du cM dh dg dl dk cQ dk dc dh cJ dj cR dI cV dj df dl de df dJ dg db du dI dd dc dl dJ cV dl dk cS dJ db dh cQ cM dc dh dc cN cQ dg di dI db dd dg cQ dd cM db di cM dg dg cX de dI cR cQ dI db dk dd cR cQ cM cQ cM de di dl db dI cN cR di cS dl dh cT df db dh db cM da dj cX cX dg db dc cX cQ cJ cY db cY df dp cR df cQ df dd dg dh cZ cY cV cR dl dk di df dc cN dl dI df df dh dh cX dh cR di cM dJ dI dh dl dj dp dg cM dh dJ cV df dd dh dl dh dg df db df di di cM db df dk db db dh cX dJ cV cV db cY dk cQ dh cX cY cV dj cI dd db dg dl dh dl cR cV cQ dc cR db cS dk dd dk dk cY cQ dc cR dd dJ cR di du cV dc dc cJ df dI dc cM dI dc cZ dd dk cM cV dI cY db dj cT cT dd cY dJ cT dk dJ cM cY dh df cN dl dd dj di dd dI dc dk dg cQ cR cJ dJ cM cT dI cQ dI db db cQ cY dJ du di dg cQ cQ di cR cY dg dd db di cV cQ dj cV dg dh dI dk dh dg cV cY dI de cV dg dn dg cY cO cV cY db db dd dI dk df dd dJ dc di db dd cY cN dg dd dI dk dh dc dh db db da cR cX dd dg dd dm dd df de cM dg dd cM cV dI dc du dk db di du cV cQ cY cS cQ dl df dh cQ db db cR dc dd db dI dJ cJ dm cY di de cV dd db cV db dj dh cQ de dI de dl dn cR cQ dd dg dd cY dc cY du cV dd dI dd cV dg dc cW dh dl dl cY df cY cY di dh cQ dh dI dJ cM cX dn cQ cJ dl cV cU di di cM dh dI db cV db dJ df dc dk dh dI dn df dd dh dh di cO cS cQ dk du dd df cV dI cM db cN dg cY df df dh cY cN dJ cY dI cY cQ dl cM cQ dl cY cK dl db dk dg cX dI cM dJ dj dl dh df dI dl dh dc dJ cX cM db db dI cY cU dc dI dJ dg dl cY cY cY dd cY cT cQ cL cQ db du dI cY dg cV dc cS dd dk dd cJ de dc dk cX di dI dJ dg cR dh cQ cY cQ dj dl cQ dl cV dI df cK di cN dJ cW cQ dJ di db di di cJ dI dh dc cV cR dd db cQ dc dh dj dd dk cX db dh dd dI dd cS cX dd dc cY cS dj cQ dk dm cM cT dc dl dh dJ df da du du dc du dg cI cR cR cV dJ di dd cQ dc df dd cR dI cS dc cR dq dh dl dd cR dh dc cY dp du dk cY dm dh de db dd dh dI dl dc dl di dg cR cV db dl cV dI dm cZ dm du dg df dd dg df dJ dc dg dl dj cY dc di cN cQ dd dk df dc cW cJ dl df dc cY di db cV dk dI cR cN cN cY cR cY cS dG cV dc dh df dc dJ dh dJ de cR cL dI db cQ cS dg cR dh cN dl dj dl cY cY dh dg du cY cR cV cz du dd cR di du du dh di dJ cX cN dg cQ cM cR db dJ df dh cQ dI dn dI dg dj dI cM cQ cR dh cY dk cI cz dh cV dd cX dj df df dI cS dk cR df cQ cV cU cV da cY dJ cV dk dk db cX cQ dk cO cT dl cQ dk dk dI dl du df db dn dc dh dI dI cR dh cG dg cJ cS cV cM di dc cV di dl dk cV cO df di cT db dI cK dl dI dl dk dh dk di cN cN cY dg dd cQ dl cL cR dI dl de db cQ cS dc dc dk dl cV dJ dJ dl df cV di dI dg dj du du di dJ dk cZ dg dj cY dI dl dn cT dJ cV du dI cS dd dJ dJ di dg dJ db cS cV cR dd db cT cY dI dI dh dh cJ cT dc cY dJ dg dd cQ dd cQ cQ cI cZ cV dd dg df cK dI cR cY dJ dk df dI cJ dh cO cX dc cV cQ dd dg cS dh cS dd cV cX cN dj cT dd cX dg dJ cY cY cQ cJ cR db cN df db dG cV dg cT cV cY cQ cY cQ cN df cY di dI dc db du dh dc dg cS dg cJ dI cQ cL db db df cR da dl du dh dk dj du dk dJ cB cX cX cX dh dI dg dc dk dk dl cY dm db dk du dl cS cQ cY dI dI cT cK cQ db cN dc cY dI cX dg du db du cN dc df dd dI dd cY dg cI dJ cX cY cV cV dI dk cM cQ dj cX dc dd dh dc cT cQ cY dd cM df db du cM dJ db cR dI dl dJ df cV cJ db df cO dG dd di dI dl du dh cN dg dd cR dk cN dd cV cY db cV df cY cL cT cX dd dG dJ cX cY cQ du cY cQ dl dJ dJ dh cJ dl dh dl dI cR cV cV df cY dJ dc cM dh de df db cR cV dg cJ cS du cN da dd cV dh du cV cM cX db cG df cS cQ cJ du dh dh du dd dc cM cQ cS cO du cR dJ cN cR cN cu df dL cM dn dc cR dh du cQ cO dL cV cL da dm cK db cV dg df cG cX cK dL de cN cT cV cR cY df cN dI cQ dL dh cJ cQ dh dc dd dJ dc cY dk cJ df dh cT cT df cY dg cT dc cR dJ dc cZ cY cL dg dJ cJ dI de cY cY cZ cY dl cL cW cQ cQ cY dg dJ cN dg cJ cS cR dI cV cY de cJ cT dJ cY cT cV cZ cO dc cM cJ dc dJ cL cL cV du dd cG cQ dk dI cJ cQ dg cL dh cN dj cR cV db dl cV cX cK cM cQ cS dc dG cT cS cV df dd cQ da cM cV cL cY cN cN cX cM cX dd cJ dJ cJ db du dk df cR cJ cL dg cM cV cU cr cS cV cS cT dJ cY cX cQ dh cR cX cY dc du cY cM di db cX cS cR dc cz cX cR du dd db du db cQ dl cL df dL dc dc di dJ df dI di df cV cV cS df dh dI da dc df dg dJ cO cQ dc df cV du cR dI db dl df cO dh cJ dn cT cJ cO df cU dl dI cR dl dc cV dh dg dg dg dd cX cZ cL dh dI dg cL df du cV dI cV df dH cU dI cT da cL dd cN dh du cO dJ df df cY dI cM cN cU dc cN dg cU cU dI dh df dI cR cI df dI cS cV cY dI cQ cV cM cY cQ cT dJ cQ cY dJ cS cV cX dh du cU cR dc db cM cY cY dc cY cS cX cO dh dI du cU dc cX dd db dG cO cU cX cL cM cU cT dc dL cT cX cM cO cM du cX cJ cQ cY df cY cO dI dc cJ dc cQ di cX cU dJ cN cU dc cS cM cS dh cQ dc db cL cT cM cJ du dG di cG cO da cV cQ cL du cV cQ du cY cW cY cT cX cQ dc cY dg cQ dc dh cO dd cQ cR cY dh cZ dL dl dc cK dk di dG cU df dl cR dl de cO cY df dI dk cV dJ df cR cY dm dJ cS cM cL cS cS cE cL du dd cT cL cX cN cL cV dc cN cL cR dI du cW di dI cM dc cO cQ dJ dh db cN cD df du dh cQ du cW cO cO dJ dl cX cO dj cX dg dc dh cL cO cY cN cY cV cT cN cV cM cE dg dJ cM dh cU dh dJ cM cS dG cR cN cO db du du cQ cX dd cQ cL dj cV dI cZ dc cS dg cS cS cZ cV cM cN dJ cJ cU df cV cT cZ cR cV cz df cQ cK du db cV cY du cM dd cQ cQ dl cO cN da dJ cM cA dl cD db dI di dh dh cL dg cu dJ cX cJ dn dh cV dk di cV dc dI dJ cV dI cu du cI cJ dI cR dg cY ct cX du df dd dR cU dP cY cr dJ cS dI cS dJ cR cK db du cs cV de cY cJ dJ cG du cW cY df dg du cR dj df cr cS dG cO cY cb cO cM cP dl cX cK cR cY cK dI da cQ dh cI dh cN cJ cS cr cI cD cO cX cN dG dc cX cQ dd dh dg da cQ cM du cK cB cZ cS cY cG cQ cX dd cK dl cT cu da cR dd dd dc cV cS dk cW cN da cX dI dI dc cM cT dI du cI db cO cM cQ cz cZ dc du du dL dm cD cV cU cS dG cG dL dG cE cQ di dJ cE cV cV cN cs cN cU cZ dG cU cT cu cS dc cO dL cR cN cM cD cD cS cw cT cR du du cT cX cR cA cL dG dl dI cV dL db cJ cO cJ cX dJ dJ cX cN cZ dh da cY cV du cQ cX cG cN dc df cD cX dJ cZ da du cQ cX di df dJ cI cT cT dI cR cW dJ df cL cr cL cS cJ cO cK cL cY cV cX cT dq de cu cJ cR cJ dJ cZ cK cO cM cz du cZ cU cs dJ dG dL cX cT cU cI dc cQ df dH cD dJ cz cV da cX cX cU df db df du df cQ du cU cD dk dh cT cJ dg cQ cM cK dc cJ dJ cM cN cO cK dl cG cR dJ dp cG dg dl cV dJ cX dJ du cZ cV cO cZ cO cD dd cM cT da du dc dL du da dk cK cV du dG cY di cM cT cK cA cS cN cV cM cS dd dj cS cL dJ cS cQ dh cN cQ dI cO dl cS cW cZ cX cX cV cR cU dI dJ dc cJ cU cT cV df cR cT cT dc cO dk cJ dJ du dI du du cR cz da cN cZ cD dT dd cR cJ da dJ cX cU dh dc dc dc cO cM cD cO dJ cV cJ cO cM cZ cY cJ cI dl cS df cJ cQ cV dh cN cM cM cJ cz cA cI df dd di cI cT da dk cT dJ cT cS df du cV cr da da df df cM cZ cN da dJ dG cO cL cN cX db dG da cL cS dI dh cM cY cT du cV cQ cM db cJ dJ cS du dH dg cO df du cV cr cM cM cQ cS dI cN da cW cQ di cU dI cK cR da de du dJ dJ dc dI dd dO dh cS cE cD cK du cM dJ dJ cO cD dI cK dL cL dI cQ cK cJ cA cW cM cS cR cT cN dJ cM dP cJ dG cu cN cV dP cU cW cZ dH cV dI cB cS cs df cu cI da dI df cN cJ cz df cH cO dL cR cV cS dG dI cO cV dJ cM cZ cX cU cU cG du da cL cM dK cO cY cT dJ cN cU cT cQ dg db cV cQ dc cH cZ cQ cE cD cT dc cB cM dG cU da cN dc cM cO cR cZ cK cU cT cZ cL cN dc cD cL cS cJ dG cD cM db cK cU dG cY cN cX cJ dL cr cO cD cJ cS cz cS cD dI du cR cM cZ cJ cT cV du cS df cX cY cZ du cR dL cT cN cS cM dG cG cR cL cT cM cY dJ cr cR cX cT cJ da cR cJ cL cX dT cz dH df db dG cZ cG dg cT dI cX cX cM cJ cD dG cQ cR dH du cV cO cT cM cO cQ dG cU cT dG cG cZ da cT cW du cD cL cs da cO cR cU cM cW cK du cr cU da cX cO cN cM cQ dG cN cT dJ dL cs cW cO dh cY dc dL cu cz cX df cZ cS cW cM cL cu da cr cZ df da dc dG cY du da cW dR dJ cY cL cK cW cK da df cR cV cX cQ df dI cY du cL cQ du cO cH cL cX dL db cN df cJ cG cX cK cT cX cY df cO cZ cC cI cK cS cQ cY cT df cM cM da cS da dh cS cu cV cr cT cW cM dG du cM cO cu du cU cN cM cY cZ cR cu dc dd da cX cI cD da dP dZ cY cH da cI da cV cD cX cU dI cO cT cO cK cY cS du cU dJ cX cN cS cZ cR cI cU dZ dL da dc cL cI cL cV dc cO cN cJ cT dJ cL cS cG da cR cY dc cM cM dG cW cY dL cM cX cX cS cT cX dc cR cu dL cH dL cG dL cI cI cS cX cU cS du cS dP cI cJ dc dI cr dG cX cR cL cy cK cN cD cZ cO cN dJ cC cL cK cX cU cr dI cz cD cT cO cQ dJ cW cA cX cH dG cS df cM cz cS cR du cA cL dk cT cL cr cO dd cW cW cH cT cL cT cD cG dL cL cN dd cO cZ cJ cJ cT cL cO cE cX cL cJ cu cJ du dG cZ dG cR cX cD dc cW cM da cz cL cI cN dJ du cS dJ cR cN cV cQ cX dH dG da cU dG cV cM cr cV dL dJ da dc cH cL cz du da cM cL cH df cZ da cO cu du cG cS cZ dh cN dJ cM dJ cU cW cY cR df cI cN dJ cD cX cT cX cM cy dL cD cJ dJ dc cI dG cL cL cK dc cU cu cJ cK cQ cL cY cW dL cJ cU cI cR cL cJ cR cR cG dL cX cS du cG dL cz cS cM cK cY cJ cS cM cG da df cT cU cW cO cL cR cN cS cZ dc di cJ cM dH cT df cs dI cM dc cL cy cR dR cK cX cE cL cM cI cR cM cX cM cM dL cA cJ cN dG cZ cr cr cT da cJ cJ dJ dH cZ dL cU dL cS dL cN cM cJ cM cG da cZ da cG cS dc cM dL cU cV cS cX dc cS du cM dJ cL dH cZ cu cT cU da cZ cU dG cM dJ du cO cS da dH cO cS cV cY cK cT dc cV cO cQ cY df cT dc cO cJ cN cZ cX cT dT dT cJ cO dc cK cO dl cZ cH cJ dc cS dJ dk cK cN cS dc cW db cQ cR cY cW cL da cH cX cR cJ cQ cQ dH dc cZ du df da dc cS cT cI cO cu cX da dc cO cX cT cZ cT cz cX cY cU cX cQ cS dg cu cT dX dL cS cX cJ cG dJ cV dH cX cT dJ cX cJ cY cT cS cV cR cU dL cJ cu cN cZ cN cS dh dG du dX dI cT cV dI dg cD dI cT cI cJ cz da df cO dJ dI cS cU cQ cS cY cM dG cG cZ cN dh cN cs cG cT dc cX cY cz dP cW dd cH dJ cL cQ da dl cL cS dI cJ dk cQ cU cN cN du dT db cV cX cM cz cG cB dJ cO cu cP cJ cQ cK dJ cO da cS cO cW cM cO df cs cO cY cQ cX cQ cU cD cR cW cX cS dG cO cJ cO du dJ cZ cZ cR cO cM cO cM dG cR dc cT cI dL da cG cT cT da cL cQ cT dJ ck cK dG du cR cS cR da cR cV df dG cs cT du du cX cr df cZ cw dJ cL cZ da cT du cI cG cV ck dd cJ cR cT df da cz cX cV cL dl cR cs dc cL cZ cW df du dI du dJ cZ cH cU cV cJ dc cT da cM du cO dI cX cz cS cR cT cs cQ cZ cR cN cG cI cK db cN da cN cV cM cX cL cN cL cY cJ cR dc cL du cT cN cO da cR cT dd cT dd cJ cO cT cZ dI cM cX cV cT cX cN cO dd cX cV cy cZ cR du cV dL dJ cL cr cQ cN dJ cX cX cX df cQ df da cL cM du cZ cX cX cS da cY cR cu dL cK df dJ cS cW dJ cM cX cO cM cX da cD cX cM cO dG cR cR cD cV cr cS cJ cT dK cX cU dc cZ cS cV cU cs dc cV cZ cN dL da cN cY cK cM cY cM dJ dJ cJ cN dL cY cz cY cS cX dJ cM cT cJ cH cJ dc cK cL cU cs du cK cX cJ cM dH cM cu dG cU cH cO cK cM cB da dH cX cR cW cI cN cJ cS cG cu ck cM da cI cR cW dc cY cO cz cU cY cM dI cZ df cO cK da dG cO cY cL dG cT cI cU cU cX cD cS cY cS cS cJ cI du cu cJ cW cT cX cZ cK cS cL cG dL dc cE du cL dc cz dc cS cM cu dJ dP cL cU cR du cY cW cI cL cI cX cQ cO cD cT dG cX cS cL dc cr cN da dJ dJ cJ cW cD cR cJ cU cM cQ cT cX df cD dg cT cZ cT cU cO cL cI cV cN cH cH cJ cT cO cV du dc cS cI cQ cJ dc cV cH cT cT df dT cV cO cK cJ cQ cN cC cR cI cX cN cZ cU cX cU cw cS cL cN cZ du du cX cJ df cV dc cV cR cT cN cS cX cM cR cT cV cT cY cL dd cZ cZ dG dJ cJ dJ da cM cO cG dG cu cQ cX cM cN cR cY cZ cX cJ cS cV cL df cH df cU cN dG cS cO cX du cN cr dI cL cz cD da cI dI dL cN dc cI cX dT cZ cM cJ cL dG cM cS cR cN cT cU cY cX df cY cO dc cR cZ cS da du dJ cT cN cD cK cS cT cu cN da cO dG cX da ck cG cS cX cT cV cJ cs cG da cO cW cD cX cT dc cO cX cX cZ cV dP cW cr cZ cu cX cK cR dk cN cL cy cN cz dG cu cJ dG da cT cL dJ cK cS cS dH cO cN cZ cV dG da dG du cS cU df cM cr da cI cW cV cW cU cI cL cU dL cR cZ cL cU cJ cM cZ cz cK du cX cy cY cU cG cu cL cL dG dG cK cU cz cN da cL cL cX cN cJ dP cz cI cT cG cK cT cT cz du dJ cO cO cS cz cU du dJ da dG cN da cW cZ cZ cW cw cS cO cQ cU cN cX cr cN cS cN dG cz cR cO cw dG cN cN cW du du cR cA cU dJ dc cL db dG cU cL cW df cL dG cr cS dL cz cU du dG dG dG cz cT cO du cL cu cU cG cs cI cW cy cD dG dL cK cW cS cN cN cA cJ cI cM cD da cN cG cG cU cT cU cM cU du cQ cL cR df cK dG cJ cs cJ cQ cL cN cT dG dG dJ dR cK cJ dG cM cN cI cN du dk cU cU cS dJ cM da cT cW df cN cN cQ cZ dJ cR cU cR dG cZ cT cZ da cG cW cO cX cz cS cQ cV cQ cy cU df cS cX cN dd dc cD cJ du cX dL cz dg cV cO dL cJ dJ dJ cJ cN cL cX df cN cN dh cN dl dc du cU cL cA cN cC db cJ cM dL cL cT cX cR dT cY cT cK dc cM cN cL cS dJ du cX cW du cI cX cZ du dJ dJ cS cR cZ dc dL cL da db cY cT cz cS dk cM cR cX cX dc cX cL cX cQ dI cS cZ cL cI dc cV cU cU cT du cz cX cX cL cR dc cN cR cX cO cS cR cY cL cZ dJ cJ cT cS cX cW cR dG cX cY df cM da dG cM cL dJ cL cR cU dc cS cG cU cU cN dc dc cW cu cG cR cL cO cK dL cN da cQ cJ cR cX cR cX dL da cT dc cO cR dL cS cO cZ cM cM cM cL dJ cY cZ cJ cD da cJ cG cT cT cO cI cY cG dJ du cI cQ cM dJ cW dd cI dJ df cX cr dT cM cD cO cL dG cK cW cV dI dL dJ da cI cO du cU cI cR cH cK cU cs cT da df dT cU cR da cU dc df du cr cU cL cK cT cz cS cJ cI cM cz cD cM cS dG cW cT cK cS cT dL df cD cA cJ cO cK dP cE cL dc cV cT dL dc cO cJ cr dG cz cK dc cH cI cr cW dc dG cJ cX cN cS dJ dd cS dh cN cr dH cL cX dh dI cQ dd cW cJ cz cO cI cX cN cY cQ cL cY cS du dJ cR cW cG cN cS cI df cS cK cL cW dd cS da cX cW cK cK cM cM cK cI cO du cu cU cD cR du cS cV cS cI cM cQ cR du cI cU cT cT dc dG cT dG cM du cR du dJ cJ dK cR cS cG dG dI cs cT cL cS cL dc df da cR cO cS du cW cV cL cG cL cN cS dI dH cR cO cO cJ dJ dG cS cW cL cz cs cG cO cN da cS cV cW cS cR cM dc cN cN dJ cX da du dc cJ dG cM cS cM du cX cM cJ cT dG cJ cX cO dc cZ dh cQ cL dH dJ cM dP da cz cU cU cJ dG dI cR cX cT cV dc cO dG cO cX cU cM cI cD cV cT cR cJ cX du cO cJ cZ cK cI du cO cJ cM cV cK dI cU cK du dL dG cU dJ cz cS dJ cM cT cU cT cU cZ dI cD cK cM dh cr da da cM dL cK da cS cR cI cG cS cJ cJ cX cJ cV cV cN cR cJ cM dg cM dG cN dL cY cN cM dG cM cO cE cD cJ cU cs dd dG cR cV cM cX cX cW cS cT cI cI cX cN cU cL cT dG da dJ cV dc dT dI cZ cK dh da cY cO cU ck cM cN cE cR cM cX da ck cL cL cZ da dJ cR cY cR cJ dI cI cO cz cY cu cs dJ cY du cX cG cK dG cZ cK cX cz dc dL cW cM dG du cX cZ cZ cr cU da cE cY da du cS cT dG cT cr cY du cK cT cI cT dG cD cI dG du cI cJ cU cX cK cr dd cS dc cW cW cJ cz cM cJ cJ cr du cu cZ dG cJ cR da cW cz du cI cS cN cN dI cS cD cX da cs cV cS cN cX cr cS cW dL cX cX cO da cG dL cG cK cz da cU cT cz cN df du cT dG cZ cT cX cX cM cU cL cz cz dJ cN cO cR cT cH cX cZ cr cJ dL cN dG cU cM du dG cL cH cZ da cO cK cD cT cO cW cS cT du cR du cT cr cM cJ cJ cT cu cU cL dL db cY cK cI cN cL cV cR cX cA cX dI cQ cJ dJ cT cL cR cK cR dJ cA cR cU cz cX cQ da cJ cH cJ cR dI dc cU dL cZ cJ cz du cW cL cJ cI cL cS dd cL cM cK cH cY dJ cU cX cR dJ cI cK cZ cJ cu cA cz cM da cs cJ du cY cW cJ cQ cM cY cK du cO cD cM cK dc cN cQ cS cG cO dc cM cN cO cu cV cN cX cY dl cM cW cQ cK dJ cO cN cV cM dJ dJ cW cR cW cR cU cS cQ dI cN cr cJ dJ cI cJ cM cX cT cX cM cX cY cO cR dI cL da cR cS dc cM cV dG cT cT dJ cM cX cU du db cO dc dG cS cQ cM cN cI cY cS dJ cY dc cQ cW dh da dg cU cM da cT df da da cY cV df dG df cJ cV cI cX cL cU du cL cM cM cT db dJ cR dd dJ cT cL cJ cM da cL dh cX cN cM dI cT cM cK dJ cJ cV cW df cR dI cW cO cW dh cV cT du cT cR df cK cS dP cR cz cS dd cO cT df cN cZ du cU du cN cM cQ cX cO cS cQ cX dd cK dI dh cM cQ cX cZ dI cN cV cO cN cN du cL cX cK cD cM df cQ da cI cR cU dH du dc dI cR cS df cN cS cM cO cT da cX cL cQ cz dL cJ cM dL dG db cS cU cV cV df cS dL cJ cR cW cR cY dd cN cX dh da cS cX du cV cM cT du cO cV cz cR cU dI df cR du cS du cX cQ dc cR cz cO du du dJ cJ cX dJ df cO cQ dG cZ cr du dl cL cY cL cV cO cZ cQ cU cS cK cI cL du cO cI cW dh cS cX cZ cT cR cQ du cM dI da cN cN da cR dd du cJ cV cJ cJ cN cz cQ cX cT cS da cH cR df du cM cK du cM cH cN cJ cJ cM df dP cW cR cS cQ cV cR cV dG dG cJ cV dc da cu da cK df cY du cO dc cI dJ df cU cS dg cR du df dc du cS dH cN dc cJ cS dc dc cO dc cY db cJ cS cN dl cM cY cO cV cY du cu dJ cX cR cX dc cZ cW cu cK cL dc du cL db du cJ cO cJ du cS cJ cL df dg cX cU cX cW cV cD cN cY cR cS cS dc dc cS cU dh cX cU cT da df cU cT cN cU cN du cS cX cN cL cV cR du cK cX cS di df cX cM du cQ dI cX cX cL cX dh cT dI cR cJ cX dG dh cZ dJ cM df cT du dJ du cT cV dJ dJ cS cT dc cI cY cX du dd cH cJ cs cU cT cT cQ cR cN dc cV du cQ du dc da cM cz cW cX cX cS dc cJ cM dd dG df cS cY cJ cY dh cV cM cX cZ df dJ cI cI cX cQ cN cz cJ cM cY dc da cN cQ cE cZ cZ cS dc dJ cK dh cN cK cX cR da cT cX cR db cR dG cX cS cS dI cZ dI cN cu cz cL cK cT cY cX cY cM cN dc cS du cN dJ cJ cS df cQ du dc cY du cY dI cY cM dc cQ cX cR db dc dJ cO cK cL cV dc cZ dl dI dh cH cR cM dJ cM cU cN cR cR cM cX dJ cT cO cV cJ du cV dd cO dc cN dI cD cO dd dh db dh cX cN cS cN cJ cX cR cN cJ cJ cL du cY cL cQ cR dj cR cM cX cX dJ cJ dJ df cM cN cQ cL cR cW dc dc cM cX dI cR cQ cO cD cS cN cR du dJ cY cT dc cO dG cS cU cN cZ cL df cV cR cY cW cW cQ cV cK dc cR cI cN cY cS cQ cJ cS cM cR df cQ cR cY cM dh cU cI dj cM cS dI dJ cU dd cX du cN cO cV dI cJ dg dl cS df cN cR dJ cN cX dl dc dc cM db dJ cM cS cU cO cS dc dJ dJ cM dJ cM dd cS cZ dc cS dJ cX cK cV cQ df cK cR dg cN du dJ cQ dc du cX df cW du cT cz cR cX cR dJ dc da cZ dc cO du dc db cN cM dJ dJ cS cX dd cQ cV dl dg cY cM du cX da cV du cU dI cR dI dd cV cY dc du cS dI dd cV cT cz dI dG du dJ cJ dc cY cY cM dk cY dl dL cY da cT dI cR cQ dd cQ dh cR cY dI cR cX cS dl cU dc cV cT cM da df dc cY cN df dd cY cJ cV dI dc dc cQ df cR df cO dg du dJ db cQ dJ dc cX cV cN du df cR dh cQ cX dI dI cX cQ cU cT dj dI cU dg cL dG cN db db df du cR dh dd dl du dk db dm cX dd df dc dh dh cN cR dc cL dj db dJ cZ cQ dI du cR cY cV cr dJ dl df dJ df dg cR df dk dI cK dh dg db dd cQ cM cN dk df cQ de cQ du dJ cM cR cN dh cN cJ cM dJ cR dc cS dh cG cL dd cQ cJ cR dk cN df cN cT dJ cX dI cL dg dI cL cR df cQ db cJ cV cV dJ cV cV cW cQ du cM cT cN cR dk cY dl dg dh db du cQ dp cJ cT cT di dl cQ dI cV db db dd dd dJ dJ db cV dd cZ cX dc cR dg cM cY dk cU cR db dJ dl df db dd cO da cV dd cO dd dc cV dl cY cY du cS dJ do dk dd cX da dI cR cT cN dc dd dl da dl df dd dJ dc cV df di cM dh cV dl db cJ dI df du cJ cX cL dg du cT dd dI da dj dG cY cY cU dg dn cX cR dh cM dl cT dg df dg cZ dI dh cQ cN cR df du dI cQ dh cV dk dJ dj dk dG dh cQ cR cQ dJ cM du cV dj cX dh dg cV dj dd dk cL cV dJ dd cY cT dI dd dI dh cT cV dp cX du cM cY dI dc db cM cY dd de du cV db dg db du cY df dh da cV du cY dG dg dc df dc cX dh dI cX du dk dI cZ cV dc cN cQ cQ cT dc db cL dJ df dl dk cM dh cV cR cJ dd df dg du cL cN cR cV cV cQ dd dm dJ cR cR dl df dJ dh cS cM cM cR df cS db cO dl cS cO db dh cS dc dI cQ dd dj cM cR cV cV dc dl cQ dJ cO cO df du dc df cY dI cV df cL cQ cN dd df cN dh dc df cS dJ cM du dJ dh dh db cV dJ da dd dd cY db df dI di de cM dg dc dd dd cS dI dJ cX cM db cQ dl cL dJ cY cX cL cQ df cS dh cM cL cZ cV du dd cV cQ cJ de dh dl dI dh df dd cY cZ dg cV dI dd cN dc db di dk cL dj cN du cY cR dk dJ cV dI dI cR db dJ dl dc df dk dj cM cz dm cY du di dd da cS dh cQ cY cN cN cV dl cS cM dg cV dc cQ di dl cN cQ cY cQ cV dJ du db cN cT dl dc cR dI dc cQ cQ cR db dI cL df df dI cX cN dl cQ dd cJ cR cY cL dg dc cR dg dh cU cQ db cQ dc dd db dg cQ dc dc dg cY dJ cQ dk cY cV dI cS dk dl db db dI dd cY dk df dc cQ cY db dI df cX cX dI dc dJ cO cM cV de cO dh dg dh cT dh dk dh cR cQ du cQ df dI dc cY di cR dd cY db cT de dl cN cY cX cV df dI df dg di dk de df cI cO df cR cu cY cM da dJ cO cY dI dg cN du df cX dg dc dI dd cM dd dd df cY dd cY du cV dl du dI df cV dd cR dh df cV dI cQ cV dJ dc dl du cQ dc dG cS cL dI du db dJ dd dI df cX cR dm dc dh cV cY dg dI cX dh dh dn cX cR cQ cM cV cX dk du dm cX cS dc db dg dc cQ cQ dc cJ dd db dJ dh dj cX df db dl cS dI cS cR cI dl di df cY cR dI dc dI cM cN dg cQ cR cX cN df du db dh cY dh dd cS dI cS cR dh dJ dk cY cS db dI du cV dg cM cR cQ cN cY dg cL df cQ dm dh dg dj cO cR dh dg dc cM cL dj df cT dJ cR db dg dj dk dJ dg cY dh di df cN cY dh dI df cU dg dc dJ du dc cQ dd cY da dd dc dh dl cR dJ cV db cM dJ dd dJ cV du cS df cX cY cQ cN cJ cY dh dI df df cZ cG du dh cU dc df dg cJ db dc dl dI cY cS cV du dh cY dc dh cQ cX dd du dh df cV cR dd dc cQ cY cN dd dh dl cL cR cV du cX db dI dc cX cR dc cL du cV db cN cK cM dm cO cY du dn df cY du dg cM dI du cX db cJ cS cJ dc cS cV cM du cS cI dd dI cJ du cX dd cZ db dJ cO dJ cR cX cz cR dI du di cX dh dL du df cS cM cS dd cV cY di cR cY cV df de dI dh dg cY dh dh dd db dd dd dG cQ cX cM cT cY cQ cV cQ db dj cQ db cR dh dJ dr du cN cM du du cQ dJ du cJ cN cQ cX du de dI cS dJ df dc cQ cY dI cJ dd dh df dJ cU dn cY da cO cV dI cM dg cR cY dI dc cZ dc cQ dI dg cR dI dl dg dL dI dl cX cV dI cM cR dd dd cs cQ cT dJ dg du db cX cL cM dJ dh dk cM di df cV dk cQ cM cX cV cQ dc cY dI dJ cY cL di cS da cX di cM dJ da df dJ dJ cL dI cY da dI df db cQ dJ db dh df dd cM dg dJ db dk dI dI cX dh cJ db cV cY cV du di dc dh dd du cQ du dh dr cT cQ dg df cN dI cM dj db dh dJ df dg dJ cJ cX cY cN cY cR dm cT db cJ cM df cY df cQ cY dc dd cV da cQ cX dj db cY db cQ cN dh db cV cR di dl df db db cZ db cR dh cY cV cY dh df cV cV db dm dj dg cY cY cQ cL cZ dc cZ cV dl dI dn cM du df dI dh dI dn dd cQ cV df cV dp cV cQ dc dh cX cR dk du df cY cV cQ du du cN cY dI cQ dc dh db cQ dc cR du cG dI cV du cL dl cS cS dl cJ dJ dJ dc db cM dk dI df dd dk dJ dg dc du cN cS cZ cD dd cV dg de cN dg dJ dk cN dI dc dj cQ cS cJ du cQ db cM dd cJ cO cR cN dc dI dn dd cV cU dn cM dg cQ cG dJ dJ dc dd cR du da dc ct cQ dc dI dI dh cX cQ cM da df db cJ dd dg cY dh cM cS dl cY dI du db cV df da cM cK db cN dJ di dl cR db du dJ dd dh cO dd cS cQ dh cR dd dc dk cV cN cQ dl dh cR dj dl dJ cJ db dI dd cV du dj dm cS du dJ dk cQ dl df cV dk de dh du cX cQ dI dI df dg dJ df cX dc dc dJ dd dg dm cU cV db dc cX dk df dJ db dj df dI df cY dg cL cN dJ cX cS cN dl dq dI cX dg du cQ cQ cT dI cY dg dk cQ dn cQ dd dl dd dI cR df dh dj dJ cQ de dg dq db dJ cQ cR cV cR dk di cU dc dd dJ dH dI dg dJ dc di df cS dh cS dI cX cT dc dk dm di cJ du dh dc cQ dd cV dd dc dc dI dI de cR df cR cQ cQ di dI cM dk cY dh cR dc dh dm cX dd dg dk dJ df cL dg cU dI dg df dh dJ db cL dl dh dh cV dd dJ cY dh dg dk cX dJ cO dJ dg dJ cL du df dg dJ dh cR cJ cL dg cQ de dJ db cY cS df cQ cQ dJ di cR di cR du du dg di cR cQ dg dk df dJ cX dJ df cX cV df dh cN cS dJ cR cY dh dJ cQ dd cO di cR cJ cV cW df du cR db dI cS cR cQ dc dk cN de cQ du dJ cT dd dI dl dc dm dJ cz cM dJ cR dg dk cM cL cY cY dc cJ cu dI du dj df cY dJ dI cJ cY cY cR df cM cQ dl db di dJ cV dc cV db dj dh cN dI dc dd du cX cS cX dh cX di cQ df cI db de cN dl da dJ cQ dh cS cM cQ dG cY de cT dJ cV cz dc cT cN dk df cV cX dd cS cT dJ dd du dd cX cV cz dd dp du cX cX de dI cY du cY dk dJ dI df dl dc dh dj dk dd cX dI dd cJ cV cQ df dm dd dI cS db dd cZ cV cJ dh db dg dl dJ dc dI cK dh cL cO db df dd dc cQ dl cX cQ dc dc cQ dq cN df cO db dd dd du df cY dh cS dI cS dd dg cY cQ cN dc cN cR dI di cQ dJ cN dJ dj da dd dg cM dl cJ dI dd dI cS di cN cT cT dl df dg dc df dh cX dI du dc dJ dl cQ dc dh dl cN dJ dh dJ cr dj dJ di cY dc dc cN dJ db db dk cS cR db dk cS cY da cV cQ dg cU db dp du dj cY cV dg dh cU dd cR dd dI cS cV dh cY dc dl de dl cL db cS cQ cV dI cM cV cY dq da cL dg cQ df cX cV cJ db cN db df db cR dI du cY cM dI dl dL dk dc cS cN cS cM dk df dI dg cY dd cQ dI dJ dl cM cR df dG du cJ cN dc cU cQ cM cX dG cM di dH cM dk dJ cR di cV cY cY cL cT cL cV da dh dm cY du cY cT cY dI cU dI du df cY dk cM dl dh de df dh df cR cM di cR dd cT dg cQ dk dh dk dg cQ dh cX db de df df df di du cO dd dk cQ df cQ cY dh de dI du du cV dg dI cQ dk cJ dg df dj dJ cJ db cM dl cr dl cY cV dd dh dI dd cK dd cV dn cH dg cS cV dl cV cO cV de dJ cZ db cL dc dc cN dk dk cM cM db dg db dI cV cQ da dJ df cU cW du dj dg cu dh cY dd cY df cT cY dq df dg cM cX dI cX cR cM df du cQ dc dh cN dh cT cM dl dJ cR dc dj cV dJ cX dk dJ dI cY dh du cM cX cV du dI dJ df du dd cS db cQ dh cW dc cY df dG dc cR cM dd dd cR dd dd cL cM cX dc dd cO dP cN dd cY dI cI cX df db cL db cK cT dh du cY cO dl cY cR dh db dd dP dk dJ dl cT dl df dl cM da dg dc di dg cV dI de dJ cU dl cM dk dk cY dd cV di dg dl cQ dm du db dj cM db cT dd dI cQ dd cY cL dk cT dk dI cL dJ cZ dc cL dc dj cR di dc cV db cQ cJ db cQ dI df db cY dl cQ cR dk de dh dl dH db db df df cQ dm cY dc dh db cN db cS dg df cQ cY dp cM db di cN dk cY cQ db dd dc dh cQ db db dg dJ dg cM cJ dc cT cS dj dJ df dl dp cN cU cX dI dn cY dj cW dc dl dj cI cJ cJ dk dI cQ dg dI cV cX cV di dk da dh cL cQ dc cR dI dG di df dm dg dl dl dc dl cQ dh dk dJ cN dJ dd du cL cV de dd di di di df cQ df cS cY cQ dn dd dl dk db cN db dd cR dc di dm cX cz cQ de dj dk db dg cY dg cR dk cQ df df dd cT cY cY cQ db cQ db db dc dk dk dp di du cT cQ di dd cX dI dm cQ dm cV dd dl di dl dl dj cQ dk db dh df dg cY cR cT di dj dd dJ dh dm cQ dd do dI dh cV dc cS cQ cQ df dj dh dg dk dJ cQ dd dk cM dp cV dd de dI dl dg dJ db db cN cS dq dI dk ds dl cV dJ dj di cM cY dl dl df df cY di df cV cS dh dg cR cT dn di de cQ cO de cY dc dI df dk cX dh cM cM dc df dj cQ dc da de dh du di dg dk du cQ di dI di dk cR df dj cR df cV cM dj dm cV du cT dd de cV cY cQ dI cQ dh dh dc dd cM cO cr dg dh dd dI cN cX df dd cQ de cL db dg cS db dJ dh db dp cT di cM dc df dd df di dh de dd dh cV cV cQ db dh dc dd cQ dl cN dq cN dk de dk du dl du dm dJ dn dJ cN dl dp dj dc cZ dJ di dd de dl dl cz df db du dq dg dl de du dj cV cM dd cY di cY df do dh cR df dI dI dJ cM dd cR dJ dm cQ do dd dl cV dI dk dI du dg dk dg dg dh df dh cY dk dI dm di cM do dh dd dl dk dd dk cQ cV dm cT cM cY dg du df di cM dd cM cV cZ cL dg cQ cA cR dL cO dc df cV cM cJ dn dj cY cQ dj db cV cV cQ dk dj cR dd cZ du de cS di dq de db db cu dc cQ cR dp dl dh dk df dl dJ du cT dh cX dh db di cY dl ds dI dI cY cQ cQ cS cV dI du dm cT db dk dI df cS dg dl dk cS db dh cJ dJ dJ cS db db db cY cQ dJ cV db de cM dh dJ dc dm cN df cS de cM db dc dI de cL de db cY cY dk cY dg di dn dI dm dn cQ cO dg dh dh dd cJ cX dl cJ dh di do cL cZ dp db cV dJ dh cX dj dm dd cY dl dJ di dh du dk dh dn df cV cJ dg dg dg dI cY cR dg df dk cL dI dd di dk cJ di dI cS dJ dI df dg du dh dg cR df dp db dl dh dg cY dJ de cR dh dd dn du cL cQ dh dc dg cQ cM de dg cY cV dk db db cR di dI db dk dh dg dg dj dJ cY du dJ cV di dJ db db dd df dI dl da cQ de dg cR du dc cN cR df dp cS cY cX df cV cX cY dJ df dg dl dj dc dp dd db dl cR dg df cR cX dI dh dh dl cQ cV cO df di df cQ df do dj dJ db dh cU db cQ cQ cQ dl cY di dg de dI cQ db dh cL cM cM dh dh dk dh dI dd cY dj df dl cR cM cT dk cY di di dk dc dg dg cS db dh dJ cY dl cY dj cT dg do dd dd dl dI cQ da dh dk cQ cY do dh di dg dh df dI cQ dj dh dJ cY df dh dc dl dp cU cQ de dJ db dd dI cJ cQ dd dh cX di de dj df dI dI db dk dj cN dI df cQ dm cV cL dd cM cY dp cY dh dh df cV dm cX da dc db de db dp dI dm dp dg dm df cQ dl dm dl du cQ di cQ df dk dk dl dI dg du dJ dg dd du dn di cX dj di db de dJ dd di cu dh dI di da df cI dh de dk db df dg dg dg db cQ de dJ cV dG cQ dl dl cR dj dl cN dI db cT db dc db cU dj db cQ dh dJ cP df dI df cR db dI dh df cV dn dc cV dd dp cN dp cV dl dg cY dj dk dg dm dI dk df di dI dk du dc do du dd dg cV do dk cV dc dI cL dk cT cY cN cV dk db df do cO cS df dk cY dJ du cV dh cO dl dh dl dp cQ cV dd cY de cY dG cV dg dd dI cQ dn cQ cY dl dg cY dI dn ds dh dk cR dg cQ db dc dh dq dc dh cQ dn dj db dl df cY cV dI dq dl dk dI cM db dj dI di cY dl cQ dd dk dd dh dl db dj cJ cS cY dq dk dj dl dd cV cM du dr dd dd dI cQ dk du cU dj cY dm cQ dj dg dI cY cY dI de cQ db de cQ dI dh dj dJ de cQ cV dj cM cQ db du cK cQ du cY dk dg di dl df df cR da di dh dI dc dc cQ dI dg cQ cQ cQ dd cQ df cU du dd cV di du cT dl cN dc cR cJ du cV cM dh cV di dg df dh dj cV dd dI db cV dI dJ dd dJ cR dg df cZ dj dI dh dd ds dj cQ dI dJ dg cR di dn cV cX dc db dJ di dq cV dh dk dJ dc dJ dc cS cL dc cQ dJ dc dd dj dg dq df cT dj dI db df dl dc cY dm db cY di dq dI dk cX dc du cI dI dI dI dc di dI dg cM dI cW df cV db dl dl cX dh di dI dh cN cY cY dc cM dp dg cY cN cQ cJ de dh dP dI dJ cQ cL cM dj dJ cT cV dk de cX cJ cR dm dk cR du cY dd dk dI dk cX cY cY di df dc dp cM cQ df dh cJ cV df dl dl dI dk dI dI dd dh dh dg dn de du df dJ du cY cY dg dl cV dd cY dd dh dj dg di cQ db cQ dI cQ dd cM dh cV dl dg cQ dc df df di dl dh cI df df df cN dh cX cV cM cY do dl di db dk dj cR dJ dd cS db dk dm dh cT dm cQ cV dI cN cL dI de cY cX dg dc de cM cW dJ dc cX cY cQ di di cJ dh db dJ dk cT cN dl dJ cW dk dk du dd cV cR cO cR cY cX cS du cQ dI cX dl cS cT dd dh dI cN dp dh cQ cR cY dG cX cR dl dc cL cW cM df da cQ cS df dg cY dg dj cS cM cR dI cY cQ df cX cV dl cM dg dc dc cY cV df cV cY dI cJ cM dJ db du dd dh cV cR dh cN dk dI cY dc dh cV dc db dk cV dJ dI dh dI cG cQ cM cM du cR dc dl cY dd cV df dl dd cY cN dd df du dg dc cQ cU df cV de dJ di dl cV cU dd cL dl cO dd dd cK db dI dl cO cX dd dc dl cS dd cY dg dJ df cQ dg db dl dI cJ cJ dl dh df dd dI cY dg cL cz da dI cR df dh dJ cR dl dg dc dI cS dd dj dl dd dh cQ dd dI di dh cL cY dl de dI cM cM cO db cS dl cT dj cQ cN df cG cY df dk cY dl cR de cQ db cY dg cM cV cY cV df dm dd cY da cY cR dJ cN dj dc di dn cO dh cY cO dk dl cY cR dc di du cS cR cQ dd dd di db cX dj dk dL cT du cN df cQ cY cR da cV cN df dJ di db dg dd db cM cY cS cV cM cM df cR cR dh dJ da dd cS dI dd dg cM db cS dJ du df cX cT dg da cV dI df dd cQ cX dd cJ cQ cY cJ dd dJ cR cQ dd cX cV de dI db du cQ dc dI cN dk dj dI cG dc dh dG cQ dh df dh dI cQ dp cE dl cQ de df cS dh dg dc cX dJ cY cL cZ cQ dJ cL cQ cV cK cX cM dh db dc cU cS cR cQ dh df dh dd cQ da dJ cz dl cS cO dh cR cY cR dI de cS cZ db dd cR dI dg cZ db db cV dk cL dm dJ dJ dI cV di cN du dI cR cR db cT dd dg cX dJ cM dc cX cX dk cS di cV df dd cT df cR di dh dc dk cQ dd cR dJ cK cV du cQ dI cR cX df dd cM dq cQ df dI cM cS cL cQ df da cL dm cR dc cY cR cM cQ cO cV dd dl dk du cX cU dJ du dJ cR dj cV cY dl dm dJ cK cX dI dJ du db cM cQ dk cN db du dd dg dc df di df cT cM dd cV cY cO du cR df dJ cR cQ dj da db dI df cQ cL dh dc dk dd di dc dd dj cY cY du cQ cR dI db dh dJ cN cI cR cV cX dd cS cR cK cQ dg cR cR cY cT dJ cY dg df dJ du du db cQ cs cJ dc cQ db cz df db dg dJ cN df dd cV dm db da db du cV dk dc dc cM dc db cY df df cN cQ cJ cQ cY cX dk cI cQ cS dk dd cR cN dI cY cJ cL di cV dc cQ cY dc dI dc cG dk cS cY cV cX cO dI du cX dJ dg cJ dc cS cR cX cS dk dh cM da cN dG cR cS dI cs cZ cO cI dI dG dI du db df cN cQ du cM cT dc db db cT cN du dh cM cU cO cJ cR cK cV dJ dP dI dJ db cR dJ cO cR cL cY da db cV dg cM cZ cJ cN cN cN cr dc cY cM cU cY dI cH du cQ cT dl cR cM cV du cY dd dc cV cN cz cY cU di dJ cX cN dJ dh du dL da cS cX dG cM cZ du dG cX cS cM cQ cE cI cV da df dl df du dL df cG dH cQ cV cZ cY cX cT df df cJ dh dJ da dc dG du cY cS cY cO dk db cV cV cY cU cN df cu cu dg cK du cR cT cI df dG dh cL cY cT dd dd cV cS dJ cT cJ dJ cM cZ dd dI cR cY dk cU dI dL cX cZ dh cJ cK cT cR cS cM du dn cL dI cG cT df dI cY da cJ cD dI df cY dd cY cB cz dJ dH cJ dc dJ cS cN cQ cT dc dc da cy dI cr cD cP cZ cz cQ cz cV cT cT cC df df cN du cV dI dJ du cS cN cK du cS dc cV dJ cQ cL cQ cR cT cO cJ cG dK cw du cR cu dc cX cL cU cX dG dc cS dh cz cV du cM cW cO cS cN cU cQ cT cx cO cr cS cG da cr cI db du cJ dP cR cT dd dJ cY cY da cJ dc cZ cV cT dc cL cT cN cX dh cJ cX dd cS cw cY cG cM cy cT dG dI cM dc cJ df cM cz cG dL dG cO cz cr dL cK cZ cN da cM dc cY dl cD cV cS cO cw cT cQ cS dH cN cS cL cT cX cW cZ cX cD dJ cK da dd cI cZ cM cr cI cL dL df cU cG cG cS cz du cG cO da cQ cI dd df cQ dG cZ dJ du cO dl cK cR dJ dc dh cz dj cT cL dc cZ cY cS cZ cV cG cM cS dc cV cV dg cT cC cS cJ cL cI dI cS cL df cy dI cZ dG cD cW da cL cZ cO cY du db dP da cX cN cU dj cT cY du cS cY du cM dl cz cN cL cQ co dG cS dc dH dc cD cV cZ cZ dl cu cN cK cs cZ du dk dL cE cX dg cK cY cT cr dP cW di cI dJ cX cW cY cX cU cX dJ cK cO da dJ cX cr cT ct cL dJ dR da cN cT cX cB cR dG dg dL db cM dI cM da cZ du cY da cL cz cT cI dJ cN cI cN cS cu cI cK cV dJ cV dG dT cA cO dc dc cH cO cL ck db cQ cT cS cH dc dI dJ cU cK cU cR cV dG cR dH dc cK cM cY cU cY dG dI cN di dh dP cT dI cD dg dk cM dd dL cU cW cO cs dd cK cS dG cy cY dh cN dH cy dh dk dh cQ cN cX cU cQ cQ cW cE dk cQ cM dH da dI cr cX cU cN dc df cQ cJ cT cW du dI dh cK cQ cJ de cJ dJ cY dk cV dg cD cW cU dk dd dJ cZ dl cU dJ cI cS df cR cJ dI dh cN du db dg cZ cX cz cX cD du cX cN cT cY du dc cV dk cS da dp dm cS dJ da cR cY cI dk dc cX cJ db cO cZ cX cU dG dc cY cR dI cM du df cr cQ dJ dJ cZ dl dL cX cO cQ cZ du df cs cT cO dT cS dc cY cV cR cM cX dd cV cT cU cR cR dJ cO cQ dI cS cL cV cR dT dc cO cO cZ dh de di cM dg cR dc dl cI dH dg da cT cT cM dc db cN cW cO da dh cU dI cM cQ cV dc cA cr dl cJ cO cN cS cT cQ cV cV dG cW dx di dd dG dJ cI cJ dd cL do cX cN cT cy cQ cY dJ dk dd dj du cU dd cB cW dI cS cK dg cS dO cM dl cX cV dP cs cR cM cU dI dG dI cI dG cJ cJ cZ cu du dl cX dd da cZ df da dl dc dL cU cr cU cY cJ da cZ cS cM cG cR cX cX cN dg cY cK dJ cS cM dj dL cX du dd cL cJ dp cY cz da cU cN dg df cL dI dL cZ cS du cw cN dP cW cQ cX dg dd cM df cQ dG cR cJ dd cz ds dg cY cJ di cO cr dJ dI cV cN dh cT cW de cU cz dl cR cM cN dk dd cO cX dK cS df dI dg db cL dk dk da cZ cQ ck cJ dt dj cZ df cV db cO di dl cQ dh dJ cJ cK dc cR cS dh dI cI cS cZ dL dj db cO do cJ df dc cR cV dk cA cG dh di da db cz cX cY dd dH dc cz cD cJ cW cS cC cz cV dI di dJ cN cY cT dh cy cJ cz cM cQ cO cZ dc cu dg dI dh cV cZ dJ dn cK da cU cM dI cM dg cR cL dc du dh cI cY dI cY cJ cX dh cK dh dk du dd dk cK dd cX dd cL cK cZ cM cZ cV du df dk cS cQ dL cV cW dG dI du df dh cL cZ da cQ cD dh cR dI dk dg cW cT cV db cY dR dd db cE dm dk dl cT cR cZ cR cQ cL dk dc dj dn dc cV cS dc cL dp cT cL du cN dL dj cV da cU cZ dg cT cQ cR du dG db cV do dI cr cL cJ cT cL dl cK cY cN cV dt cZ cY dL dJ du cO cZ cK da dJ dJ da cQ cr dq dn dd dJ dl cK cT cL cI cR dG cT dJ cY dJ cK dd dj cM cQ cN cS dl dh dI cR do cL cM dh dc du cZ di cR ck dk cD dh cJ dk cZ dn cY dg cr dn dm cZ cV cY dJ cr da dt cU dL cQ cJ dJ cM dH cN dI cV dc cN dd cM cV cX dm dI dg cO dh cz du cJ cJ dL dd db dJ db dl dI du db cY dL cV dm df du cY cT dk de cT cK cN cX dh cI dh cR du di cV dJ da du da dt do df cV cU cJ cR df cZ cU dp cV cV dL dp cY cU df cQ dk cY da df cU dc cR dd di cL cW dd cC dk du cJ cR cI cV du cS dc cL dm cV cT di de cR cJ cS dg cO cs cS dd dL cY db cR dm di dJ dI cY cY da dl dd do dl df de dx cX cr cR cY dI dh cS cX cK cA dG du dI cW cN dh da cN cA dg cX dd cY dc cK cO cR cM db cL du df cB dd cQ cs db dd cR cR dk cR dg dh cJ cV dg dI cU dg cM dg dl cX db cJ di dt cG db cV cu cX dh db dc cX dJ dl cU cL cO cR dq cV dJ cN dg df db cT db df cS cO cS dI cN dH cN db cM di cY cT cO dd di dh dJ cz cT cW dc cM db di cU dJ cV dG db df cW cQ cX cT dc dh dh dg df cV cV ds dL cO dI cY dd dJ dJ cJ da dn cJ cJ cQ dh db cw cS cQ cX du cX dn dm ds cS cM da cz du dJ dg dk cS cQ di dI dj de dn cK cQ cR dc cs dq dI cL cO db da dh dJ dk cR dc dd dh dd cT dk cT dk dI cQ cO db dn db cV dc cZ db dh cM da dJ dI cH di cN cT dg du cT dL dm do du df cS cL do cR dc cO db cH df cL da cO dj dl cX cQ cM dm dI dp cY cN cR dh cZ cJ dd cO du cI cZ dI dp dJ de du dI cG dh du dd df cQ dn cQ di dc cI cI dG cQ dh db cQ cO cr cR dG dI db dl df di cJ du di dl cT dj dg cV cM di dm dn cJ dd cU cO df dh du cY df du dn dJ cU dg dk du dI dJ df dd dh cV cQ du dI cN cZ cL cL cL dt du dI dc ds dc dI cL cU dg cQ dI dc cQ dn cT cV dh dj cW dd cR di cZ dI dc dI cM dc dk cI db da dm dm cL cY dl du dh db dJ df dh cQ dJ cM dd dg db cU cJ cO cM cC da cY di cJ cJ cI cV du de du cD dq dd cQ dI dd dd dm dc cM dn cW cW dd cX db cU cV dL cL db cR cU dd do dG dI dx de cJ dJ de dn cY dh dJ dk db dg cZ dk cJ db dI cT dg dk dh dI cN dd dJ cr cQ cL cM dp cA dr dg cT dz cY cz cM cR cY cG du cM cY do cM cY df cR dh di dJ du dm cW dd cW dn dl dc cX di cT du dh dv dh di dl cT cZ cJ df dj dh du dk cV dq ds dg db do cL dd dg da dk de cQ du dI dh dr dk dI cS cX cu cT cV cQ cQ dG cJ cY de da dg cN ds cJ cM cQ dk dl dI cS cD du dn ds dm de dp dJ ds dg df cO di cM dJ di cJ cY cV dl du ds cH cV cT de dg dc cT cS dg dl cN cW dl cY df di dg dg dq cu dp di cN dh dI cX dp df dd dk cM cM dL cN cU dh cU cX dl dc dg cV dc cy de cS cL dJ dh cM dh dI du cY cR di dl db cY dg cU cY dn df db dJ cR db dc df cQ dq dn cY dc db de dh cV dd di df dp dd cU du dc cT cN cO dc dy dJ dn ds cO dn cX de cI dh df dk dg cR dh df dk cY df ds du dJ du dG cU df cM do cL db dJ dd db dg dg dn cT du dg di de de di dl dd cQ dd cX ds de cR cV dm cX cV dr cO dI dn dl dg da cY dj cK de da dJ di dd cQ dc dd db dt dl cM df cN db dk de cR db cR dI dd dc di du cJ dn df dG dI dx dh cS cQ dn dg dr df du cR cI cO dJ dc dq dg dk di dn dp cS cV dn dg dd cM cQ cS di cQ dm dl dh dh dI du dn dt di dd dg dh dh db da cR cQ dh cR cZ dh dl cY dJ dj dj ds cQ dl dj cR cJ dl de de ds cZ cR cS dg dg do dd dl do dc dg dd cQ cQ dk dh cV cV da db db dl cV dk dj cO cQ dq dh do dn db di dn dI dd cV cS dg dk dg dk cJ cA dg dl dn dh dg dJ dI dj dj dh df di df cQ cM df dg dz dm dm cJ df dg du cV dk db cV df dp dh dq dt de df cM ds dk dg du di cQ cS dn cQ cX dk dg cJ cV dg dG db df du de dk dg dq dm dq df cQ dJ dl dl cO dh db dm cQ cM cY dg dg dd di dd dj db dJ dp dl du cM db dI dg dl df dd dn dj di dj do cJ dh dI ds cQ dn cX dn dn dq dd cM cQ dg cY dc di df dj dj dh di dp dn db dj cX cM dp cY cN dd dn di dw dm dm dI db dl cK di db dl dd df df dk cQ dJ dm cV dl ds cY dp dn dn di dm dl dy dg dd db cY dg df dx de dk dl dk dj dG dk dk de dq dq cY do dh di dq dI dg cY cM cY dq di db dd dk do dk dd cQ dI db ds db cL ds dh dd di dl dp dh dk dl dI di dp dd cS dp dh dk dh db db ds di dk cQ dd cM do dk de dd dk dj dm dk dk db dx dr dt cY dk dl dp do db dc cY dh di cY db dc ds cO db de dn cY dn dl de df di dl dr cM dj dg cS dm df dm dj cV dd cM dl dd dp cV db dk df db ds de dt cV cY dI de dp dn di dj cV dh dc dp ds dq dh dl db dj dk dn cL di db dj di dd ds cQ di dp dj dj dm cQ dq dr dr cJ dp de dj ds dl dn dl dm dg dm dq dn cN di dl dg dl df do do di dr dI dq dd dg dk de ds db dj dj dp cV dw db dc dr dJ dg dl dn di di do de di dg dw dk de dg de di dq dt cV cQ ds dJ df db cN cV cT dl de df dJ dk di dr dJ cQ di cR dq dp dj ds dj dd du dJ dp dr dj dn dm dl dm cM dl dk de dg dh du dJ db dk db do dg dd dl db cJ dd dq dc dj dd di dk dr dq dj dd dJ dc do dt dy dj dI dk cG do cQ dg dp de dn dm dq dm dq dg dl dk di dI dq dj cL cM cQ dh de db cU dx dJ dm df du dh dq dm cJ dj dI db db db dd cQ dd dl db cR dg cV cV dj di di de dh do di dn de dg df cQ df de dd dh cN dp cR cY cs dk db cT de dp dh dl dl cJ cV dc cS cR dg dk cJ dq df dn dg dg cX cR dd dg dj dg dj di dj cO dl dI dd dI dd dm df cV do dk dd dk dq du dj cS dk dg df du dv de de di de df cQ cY dm dh dc dl db dx du dd ds cY dd dj dc cW dJ ds dj dk dd dd cN di dm dh di db cN dn df du dh di cR cN dn cY cQ da dj cQ dg dg cO dI dj dl dk dc cS dJ dg dI cY cJ db dc du de cM cO cQ cV cY cN dp dk cJ dJ db ds cV cS dJ di cM cJ dd cV cK dl db cW dg dg dH cY cY dJ dg cD cO de du df dI df di df dg dc df cO db dd dn cY du cX dg dm di dj dl df cO cV di du cG cQ dl dd df dg cX cM cY dd cY dl dg cR do da dc dd de cM dj dd cN cX dd dm dg dd cR cY dd dH cV dh di cV dd cJ du cV cV du cR cM cR dJ du cL db dg cL du dI dd du dm dl do cR cU du db cT dc du cY dn cJ cS di cN dc dI cK cQ cY cM di cY dk cN cS db de dg db cS dl dJ cT de cY dc cQ dj dT cQ db cY dm dI cN df do cM dI dk di cL cn dd cN db db dd dj cW dl cY dk cS dh cX dI dp cY cJ cR cX df cR du dk dh cM cY dj cS dl cM dc cL cT dd dl cM cN dc cY da dJ dh du cV dl dg cS dg cX cU dn cR cK dl dI df dJ df cT dc cV dd cX cQ cV cT du cz dg cR cN dG dJ du da da df dI cS cR dn du cV cS cR df cV cQ cT cS cM cK cZ dd dJ cY dd dI cG cS du dq cY dJ dh da cM dk cY dJ cV cX cX cS dh cN di cM db dc da cN dJ dd cY di dg dg cV da cY dh db cY dd cM cI dl cR ds cL db cZ cU cQ dI cR db di cO cS dd dn dT dc cM cJ dI do cD de cM cY cM db dh cU cM cV cY cU cV cX dc df da cO dc cG df du cM dm cL dd dJ cQ cS dk dl du cV cY dG dL du dJ du cN di dd dh cY db cQ dJ cZ cS du dd cV df db cR cX cO cY cX cz du cY du da df cM dj dj dG dJ df cM df cQ cJ cN dg di cL cX cZ dc dk cZ dI cQ dj cz cQ cT di dj dp du cY dd cQ cQ cK cY cM cR da dc cR dh dj dk cM di db cT db dg dg cO dg cQ dJ cX dh cQ dd dh cQ dI dI dd db db cZ dd dc de dk cX dc dL cV dn cR cY di cJ cZ du cV dc db db dn dj cY cQ dJ cM dL cN cY dh dh dh dh cX dh cY cU dJ cW cz cR du dd dh dj cN dI df df cJ cW df dh cV dc cG dh cO dh cV du cS cW dk dn dg cR cs dj cV dh di df cS da cZ dI cV dg cO db cY cZ dh de cV cY cO cO dd cS cY cM dG cX dJ du du cr cI dj da dg dc dc da cX du dJ dk du dj cS cN cY cK dJ dd dg cQ dJ cX cQ cO dm cX cY cM dJ cV cS dh cJ cN du cO cY cY du cY dh cU cV dc cO dJ dI dJ du du dG cV dj dq dg dl dh de dk dh cI cV dk cS dd dc du cy cL cS dj da dc cY dl cL dk cM dl di cM dL cR du dh dJ dd de dI dk dj dn cM cS dJ dh de cY dg dk dJ dm dc cN cS dc cY de dJ da cY dc df dI cS cQ cX cN db cO cR df dJ dI cN cY dj dk cY cI cV dI dp db dd cL cV dI cQ cR cO cX cV cN dI db cM dk cR cT cQ dJ cM cM dh cQ dg db dh cS cT dJ cY da dJ dg cV da cY dg cQ db ds dJ cL dl di cI db cT cN cT cQ du cK da cV cV cR du cQ dI dI db da du db df cL cZ dc cX da dn dp cV cL cY cR db cT db cR dc dl dJ cS dd cU dd cQ di cV df db du dJ dd db dg dh dI db db dq cX du dd du db du db dp cY cV cQ df di cu db cY dJ dd dJ cV cV dJ cY cK dI cZ cI cV cK dc dl dI dk di dc di cL du dk cJ df cQ cV cJ df cJ cX cU dG dd db db dp cG cM cZ dd dJ dI dk dI cQ dm df cV cY dJ cX cV dp cX cN dp dd dI df dd dh cM cN cX cJ cX cQ dg db dl da cM cM dI cZ cY cT cY cV cT di dk dd cY db dc cX cV dl cB cL cV dk cM dn dJ cM cQ cZ df cN cZ db cQ cU db de cz cJ dI cN dI cY cV db du cQ du cY du dI cY dg cV dc dk cJ cM dI df dI df cS dI dd dk cL cQ db dg di dd dm dg dI cR dc dk du dj cS dn cO dj cN cV db cN cX cV dk cS dc dg dd dJ cY cN di dc dm dJ dc dk dI dd dh cV cQ cL dg cK dJ dl cR cR dG dj di cU de cR df cM dj cM cR cQ db cY dl dI dg cQ cu cV cM dG df dk dd db dd du cM cV du cN dg cX dn dc cO dd cY db du du cR df cV dk cS db de dJ dg cG cK dc dh dj dl dl cV cV cQ cL cN cQ cV dl du df dg dh dk de cV cQ cO dd dg cY dd cY db dJ dd db dj du dd cY dh di cK cX dk dg cR dh dl dI df de df di cR dk df da dd dg dl cR dn cN df dI dg dJ dI dc dm cV dJ cY df di cX db dp dg dh cQ cQ cL cZ cO cY dj dJ dI cs da dc cS cQ cN dl cS cI dI da cN dd db db cS cM dg cY cK cN cY dI dj cU dc cM cJ dc dc cM dg da cU dh db cV dG cN cR dk dc cS db cZ cJ cS dd df dk cQ db du cL dg da da cJ dg dh cM dl dl dd db cY dg dg cS dJ dI dh dd cW dh cR dg dI dk cM db dh cX dI dh cS dk db dc cu dl dd dJ cJ cQ cS dI cY dI dg di cV dg db dh cS cM cS cT cR cK da du cQ df db cQ dI cX cY cZ cO dn dg dj dg cN da cJ cR dI dc cY dd db cR cJ cQ cL db cK cR cQ du cV df dc dc cL di dd dh dh df dI df cJ dI cR cY dk cN cO cV cY cS dI cZ cY db cJ cY dn cJ dg df cQ dI dg cY cZ cO dd dk cN du dI dh dc cQ dk cQ cV cK dh cM dg de dd cT dg dG df cV dk df dc cN cX cK cV cT db dk dc dm cT dc cY cQ di dh df cV df dc dI df dc cR cR cR cY cJ di df dg cL cX df dc dd dI db dh dq cS cL dc dh cV de dm cN dI dG cZ cS dp cW cu cQ cG dk cX cM cQ cJ cV cM df cX cQ dh db de di dc cQ dI du dI df df dl dn df dh dk dl dd cQ dq dI cX dh dn dg cz cW cJ df cY cz dc cX dg cI cR cQ dg dk du dl dI dc dc cQ cR cX cR dI cM cR dg dL cR cV cX cU dh cS cM cG db dI dh db dI df du dc dd dg dl cY df cY dh cE du cX cY cN df cN dd cK cX db cX cS cJ cR df cX cG cM dc cY cN dJ cR dd dl dh cR cL dI df cR dc cN cY dj cX df du cN cT cQ dd cX cS cW dg cR dI cY cV cX df du cz cS cU cM cO dc dh cV cR cU cQ cM cY cJ dg dg dj dd da dd dd du da du cJ dl cJ cR cU cR dl dg dI df cX dI cT cL dc cQ cJ dj cX cS cJ dl cV du dl cS cL dI cJ dg dk du cO cZ cN dm cX db dJ cM cV df da di cQ cR cT cL cV cS cM df dd cI df dI cO dh dJ df cQ cN dJ cQ du cT du cN dl dd df dl da cN dJ dG cX dk cU dG cQ de du cJ cV cZ cB cM di cJ cX da cT cN cM cT dh cU dG dc dc cJ cX cV cX cR dh cO cS dh cJ dh cS dg da db dJ cJ cO db dl dP df cM cJ cX de cD cS cT dc cO du cO dI cZ cX cV dJ da dk dc dJ dh cQ du dI cJ di cS cV cT cQ du cO cM dG di dd cr dc df cM db cN cN cJ cY df cX cY cR df cK dI cM dJ dJ dJ db dg cL cV cV cY dJ cK cY cT cN dk di df cS cU dh dG du cS cO cJ da cG cN dJ cZ dJ dh dP cS du cN du cY cY dJ cO cQ cR cN cM cZ cQ cM dJ cV dI cK df cT du cR dI cM cV dd dJ cV cV dJ da cM dl cV dh dd cV cV dI cY cV cO df dJ cQ dd dI dI dg dI cu dI da dh cM dJ cS cV dI dI dd cO cV du cX cQ cO cV dJ dd cL dg cQ dI cR cM cY cV cG da cw cL cM cO dh cY dI dI cN cN cV da cQ df cO dI cY dk dc cX cV cQ cX cO dl cU cM cX dJ cV cX cO cT cQ de cr dj cQ dU cN dJ cQ dk cL dI du cS cT dc dJ cS cz cN cO cX cQ cI cM dk dd cM cY cM da cT cV df cN cQ dd du cW cU cI dh dJ dI cM du du cM cT dJ du cE cY dJ du di cM cN cI du dc dj cT cR du cV cT cN cY dg cT cV cV dG cB dc dI dJ dJ df cz df cZ cV dc dh cY du cT cL du cY cT cU cK cY dk du dh dg dP dI cG cX cQ cU cX cJ cN cN cL cT cV db cY cS cW dc cN cX du dG cL du cQ cN cK cu cX cN cJ di cO cL cS dc cL da cL cY cU dh dd dJ cM cV cN dI cM cR cJ cS cS dh cY cz cM dG cN dd dI cM di dd cY cR cR cL du cZ cX db dc dg cO de cT cJ cV cQ cJ cR dI cM cR cL cV cM df cY dd cQ cS cO df de cJ dH dJ dd cN du dd cR cR dh cS dk df cG dc dI cO db cN cS du cY cM du cV da dc cU cQ db cL cN da dh cU dc cV dc cR cX cU cH di cI dc cX cN cL dg cV cV cX dg cS dh du cZ cT cR dh cQ dh df df cQ cu cQ cX dd dI dJ dJ du cJ cX dh dc da du dL df dL cN cN dl dJ cX cM dj dd cY cS dd dc dh da dc cA cO dH du cr cM cV cU cV cC cN dJ cS cQ cM cR dh dL dJ cX cr da dL cS du cI cQ cz cY cH dJ cz du du dI cS dc dG cU cR cQ cO dG cO cR cZ cJ cN df df du cS cM cN cY da dJ cK cB cX cO dP cU cQ cX cR cW dI cI dc dI dc cM dG cS cI cT cT cM cV du cV cM cG cZ cO cV cI cU cU cL cQ cR cM dk cN cN cX cS dG cX cJ cS dl dI cL du dJ du df cV da dJ dH df cQ cR dc cT da cV dJ cL dg cQ cO cS dJ dJ df dd dc cM cz cI dR cX cX dJ cX df dG dG dc du cN cY dJ cQ cR cV cT dc cT du di du cS du df dJ cQ cO cO cM cM cs dl cO dc cU cT dg cW cR cR df dj cQ dG dc cW dJ cX du cT cu cS da dJ cV du dd cW cM dh df dJ cr du cU cO cQ dJ cZ da df cT cs cr cV cS dP cU cT dc cW cs cQ dJ cK cN dJ cS cM dJ cN df dc da dG cr cV dJ cJ cX cJ dH dO cV cI cG dG cS da cJ cS cH dK cM cI cH cM cU cV cK du dG cI cH cr dG cN da dc du cO cX cU cM du cK cY da cJ cR cw cN cK cT cM cJ dI cS cX cZ cK dP du cO cW cE cw dc cu cI db cR cH cr dc cK cS cB cN cX cZ cW du cR cN cB cK cT cn dS dd cO cX cY cs dc cZ cN dc cU cX cN cm dG cL cS cG cs du dJ db cO dd cR cJ cO cZ cR cM df cR cV dH dT cS da dG cM cQ cK cD cZ ck dP cL cR cX dH dR ck da cS cz cP dl du dH cV cV cS dc cK dJ cN du cA cH dd cN cZ dh cC cX cJ cJ cV cS cT da dc dR dk cS cS cJ cL cB cW cM dH cF du cz cK cz cY cS cQ dK cS dT cO cs cJ cQ cR cz cD cQ cT dc du cw cR cU dG cZ cH cT da dc cL cB dd cM cG dc cT cT dd cM ck cI cL cL cT cX cZ cJ cI du da cS cI cM cY cd bY dG dG cT cS dc dX dS cu dL cz cY ch cs cH dG cT dG cX cZ dh cX df cM dG cp cX cx cV bS cL dP cM cD cA cZ cZ cz df du dG cJ cu cb cW cO cI cT cL cw cX dW cM eb cX dG cR cG cX da dT cK cw cJ cz cX cS cD cL cB dG ck cU cr dO cW cu cs dP cZ ea dG dh cZ cD cS dP cL cS cu cI ea dG cB cD dK cx dU cd cI du dG cS cU cU dJ cR cW cJ cL cX du cy du cL cH dJ cB cy cI cK dP du du cU cz cD cD dP dc cO cM cL cA cU cU cR dJ cK cG cO cH cS cM dG dT dX cM cX cO cU cL dG cE dW cO cS cQ da cA cQ cU cT cV cI cI cZ dH cz cn cT du cN cI dH cp cT cI cZ cV dc cY cT cT dI cD cL cY cJ cT cW cX cu cQ dc dG du cZ cA cR cT dG cK cS cN cN cV cL cM dX ck cJ cU cU cN df dd cR dL dL cT dJ cS dT cN cP cI cU cT cL cX da dT cU cL cM cV cR da cX dK df cR cW cN cN cT dc cK df cA cN cK dI cN cM cS cX cK ck cJ dc cV cH df cZ cP db dd cX dG cB cQ dd dI cn cr cJ cM cj cT dg cK cW dY cV cY dG cI cw cO cz ck dI du cx cI cO cK cV dX cL cR cK dJ cM cT dI cL cJ cV cM dG dc cK cz cR dI cY dd cQ cM cN dI cU cU cM dJ cT cD cB dL cu cW cZ dR cG cX cU df dJ cR cr cD dL cO cS db dJ dg cX dg cM cz da cL cq cJ cN cG dG db dK cM dG cA cm cN cJ dd cE cT cV cK cS cQ cV dL da dg cE cK cG cD di df cX cK cV dG dZ cE co da cX cG cU dh ck cM cV cQ dc cO cX cT cA cw cm cL dc dL de cR cK cz cs cT cU cH cM cM dI cX cT dL dj df cS cM ch cV cN dh dI dg cR cn df cs dJ cX dh cz dG bU df cy dI cr cX dT cH da cV cV cT df cS cS dh dL cI ea cR dc cJ dc cN cO cG cH cM cL cL cY cx cY cQ cN dX cs cN dG cK da cr cK dT cs cs dJ dg cM dl cR cQ cD cL cU cY cL cY dJ dI du cz dI cV cL cT cT dk cB dP cV df cY dW cM dk da cR cJ cM dh dI cY cH cT cu cY cL cO cO dJ cu dd cR cu dl cH cN dd cS da cN cn cY cL dh dQ cA cY da cO dl cr dk df cJ dI dP cX cS dd cK cM cE da du dP cr cR cE cH cT cZ ck dg cW cH dG cR cK da cV dP da cX cR dl dh cO cQ cs dc df cR du cs cT cL cE cY du da cM cZ dI ct cQ dc cJ cX cG dG df cN cU cJ cH cZ cW du dc cI ck cN dd dK cD df cC cu cr dh cK du cL cX cO df du cN cR cO cN cY dP cN cW cL cV cT ea cj dl cJ cM dh cJ bV dG dc cA cV cW cK dH dH cS dd cS cU cX cK cG cK cy cG cN cT da cO cG df cZ dJ cx dG cN dg cI cD dJ cR df ct cA dk dT cS cL cT dL cT cX cB dR dg cL dN cs cD cS cG dG cT cY cQ dT cL cz dG cQ cB dG dd dJ cL cG cR cz dg cM dG cz dJ dh cz cM cJ cK cQ cJ cS cD cD cX dG cU cw dP dc cR cJ cS cE cO du cN du cJ cU cR dK cu cH dd du cY dP dd ct cR cI cU ct cu cH cS dJ da cH du cG dl cM cH cP cQ dR du cM dG cK dg cN dG cz cG cL df dR cz dW cN cL cX cO cS cU cD cJ cS dI cD cR cW df cL cz cU dJ cN cT cz cW cX cz dI cS cY cY cz dK cX cz cK dO cO dL cX dI dd df dG da dR cM cu dc du cX dG cG cy dc cD cZ du dc cR cY cr cM cm cM cN dT cJ cL cJ cM cL cA cy cX cV dK cN cV cT du cM cT dK cr cS cN cz dc cR dT dI cV cx cs cr cz eb cB cz cR cO dc cN df cM dT dc cQ ct cU cG cw cx cS cN dL dc cQ du cD cX cO cJ dL cV 0.125 cz cy cH dJ cV cC dI cR cz dZ bY dc cI cu cF cW cX dJ cL dJ cT cU da cj cC cs cX cJ cR cZ cK cr cG cR cR cM cz cG du du du da cS cU cQ cJ cy cU cK cL ct cN du cC cN cV du cL cZ cT cJ dR cV dU cA cu df cN cv cT cD cA cX cZ cR cY cU cA cu cH du cK df cd cM dL cX cM cL cG cI cV dk cy dG dJ cI cX dG cQ da dG cz cV cR cA cJ cE cA cr cT cz du cH dl cD da cT cS dH da da dG cU cp dJ cX dN da dG cG cJ cX cL cs dG cU cC cH cs cR cO db dP cW cL du cX dO dT cX cZ cG dc dc dJ cQ cH cV cu dR dG cJ cJ du cs du dh dG cR cJ dc cS dJ cW cL cO cX dI cY cM cy cY cM cD cT cN dL cR df cN cN cZ ec cO cN cC cY cK cx dG dH cZ cZ df cJ dX cH cX dR dX dP da dP cU cN cZ cy cs cu cQ cR cI dh cu cd du dc cI cI dI cP dX cZ cM dN cY cW cV cR cJ cR cV cQ ck dO cx cZ cM cY dG cL du cG cL dQ cZ cM dd cX dl da cr cy cW da cU cs cN dh cM cX cV da dc cu cz cV da cQ dc cM dd cu cX bU cS du cR cB cW cU cM dJ cI cH dI cR cS cX dc dd cM da cz cW cD cU ec cK cB cd cO dL cV cN cK cu cZ cS cM cI cS cI cL cO dJ cy cu cM cF cR cL cZ cQ cX cp ea cH cE cZ cM cM cO cG dR dQ dc dG cX dI dQ cy dZ dL cs du ea cM df cU cu cJ cO cw bS dc dJ cV cR ed cI cG cG cy cS cD cV cT cT da cr dL cZ cO cu cF cD dN cH dG cW cI cH cX dP cz cD dK dR cM dH cB cM cR cr cO cT cF cV dO cM da cH cz ck bS ea cR cu cA dL cu cE ck cX cZ cr cn cK dT cZ cs cL cO cC cW cT cG cr cr cW cu cz cN cH cM cK cX cp cW cL cZ cG cr cR cm cz cL cT dO cH cr cS dG dK ct cL cZ cC cT dO cz cO dL dJ du cZ dT cI cY dI cK cJ cN cY dL dG cD da dL dW cI cW cR dZ cK dH cU cI bU dL cU dQ ea cU cE dL cZ cJ cS cU cS dT cz cR da dP cL dT cW cr cu cU dV cu dJ du dc cQ ck cM df dG cT dL cK cZ dG dJ cK cG du dG cV dg cQ db dJ cz cG dL cN cV dX dd cL dX cr cS cS cU cX dH cX cs cL cG cO dP cK cB cB cJ cJ cE du dJ cz cX dJ dI cJ dc cI cH cN dG cS cu dR dL da cU ck cO cL cR cT dG du dP cX cu cL cT cR da cI cs cU cT cT cZ cY cR dL cU cR cL cW cs cI dH cV cY cY da dK cy df cO cD cG cN cU cL cO cH cU dG cI dk cW cN dL cu cM cT cn cu cu cD cG cL dJ cT cU cD cV dI cJ cT dc cI cS cJ cr dP cU dG cT cU cG cM cH dH cS dc cX cK cG cE dh cJ cL cz cY cX cT cw cZ cu dd cJ cG cW cV cI cu cw cN cO cO cQ cr cV dG cL cO dG dc dc dI dH dL cR cX cJ cT cG cD cJ dH ct cE da cK cJ dc cK dR cL cK da cJ cR cL cM cU cB dX cQ cS cy dd cE cH dd cT dJ cL cU cT cu dI cR cU dG cG cs cz cR cK cD cQ cL cI cu cK cr dG cK cR cr cN dL cR cW cZ dZ cs cB cM cT dc cM cU cR dY cS cI cZ dJ cZ dg cG cI cN du dc cH dL cV cS cK dO cU dJ dW co cz cM cD cS cE cO cF cR cs cF cL cM cD dH cX cA cz du cI cO cO cU dK cN cr cX dP dL cG cX cN ea cE cX cQ cH cA cW cS cV dJ cS cM cL cW cK cI da cO cR da cV cW cA du cI dK cG cL cz cz cZ cx cM cB dg cU cN cP cS cQ cN cJ cI cM dP cz da cI cI cE cr du cr cM cN cX dO cL cU da cC da dL cJ cU ck cS cR cT da cG cL cK cH dH cr cX cA cT dU dd cQ cS cx dG cG cM cE cU cM dI dL du cK dL cR dJ dL dc cO cD cW du cU cS cT cX dR cL cT cJ cR cW cP cK dU cS cK dK cN cs da cZ dL cy du cO cO cI cz dJ cZ cI cC da cS cw cK dI cY cI cT cH dG cJ du cT dP du cJ cL cD cR cM cu cK cX cM db cG cD cs da cA cS cJ cW dc dG db cs cK dL cS cR cM da cT cW cW cG cy cG cL cN cW cM cT dT dL cU dG cO cH cA cW cK da cN cH cI cU da dc cD bV cL cr cO cE cM cP dL cS cS cN dZ cT cT da cz dJ cI dL cO cT cd dL cs cZ dP dK cU cU cK cL cH cN cI cz cW ch cX cZ cz cM dT cJ cN dI dW dK cA cN cA cZ dG cM dP cz cW db cJ cX da cA dL cZ cS cI dR dO cA dH cO cZ dH da cO dH cN cR cO cs cG cN cI cW cH cz du cM cJ cd dK cO dP cx cu cy cz cX da cJ cD cZ du cR dG cI cR cM cy cX df cs dL cN cM cQ da cW cI cu cO cO cR da dH cU cU dJ cW cS dL cX cO cQ dP cS cW cS cO cZ da dR ct cV cS dc cY cF cN cs cT cG cN cL cH cE cL cI cZ cK dL cK cr dJ cV cr cG cr cI du cI dJ dT dG dd cT cM cO cK cK dL cI cD dc cz cM cY cM cO cU cV dc cR cN cz cS cN cZ da cJ cO cH dh du cu dJ cT da dW cM dK cW cG cL cM cJ cN cy cJ cX cZ cC cW cU cU dG da cZ cW cI cB dc du cW cs cO dO cI cN dG cU cz cN da cL cO cK cR cH cD cJ cz du cY dJ cw cW cU dG cK cr dc cK da cZ da cV du cE cX dG cZ da cT cX dI cG cI cO dL cT cD cI dK dc dI cw cT cz cB dT cr dd cJ cE da df cX cr da cS cS cN cJ cU cz cJ dl cS cS cZ cU dL cL du cT cW cU cG cG da cL cJ cL dR cK dU cZ cU cJ cx du cu cT dH cA cq cS cX cH cG dH dh cu cu dL cS dc cN cJ ck du cI cT da cH dG da dP cL cT dK da cM df df cK cQ cT cW cZ cz cE cL cJ cK cS cs cD cD cL cM cJ cI du cJ cJ cW dH cQ cO dG cs cK cZ cI dP cD cK cu cX cZ cR cG cZ cZ cw cL cS ck da cr cN cK dH du da dc cD cA cY dP cL cL cI cO cN cV dg cr cD du cU df cZ cN du cu cr cX dh cX dG dI cW cN cS cS cU cT dc dc cL cG db cR dJ cy du cX cy cX da cr cY cH cS cM cJ du cT cY cW cS cO cS da cn cE da cW cL dJ cT cR cZ cW cU cS cM dI cK dJ cK dc cr dP df cC cS cr da cz dG cV du cT cI cr du dG df cG dj da cM cE cX cI cy dO da cO cU cr dG cZ cM cN da cS cR cI cR cG cX cN cT dL cM cV cS cL du cJ da cL cN cu cG cL dJ cN da cT cW da cN da cR cO dL cJ dL cX cQ dc dU cX cO dG cr da di cU cL cL cU dJ cJ dG cO du cu dh cU cK cU cU cU cO cJ cw cJ cy cT dd da dJ dJ cN cL cZ cT cR cU cT cD cY cu cJ cS cZ cU cY cM cQ cZ df cK da cS cI cT cz dd cM cL du dc cT du cS cK cR cQ cN cU cO cR cJ cI cS cM dc dP cR cN dK dG cV cQ cM cN cr dL cT cD dJ dG da dP cU cs dc cD cZ du cO cT cu dP cT cD cY cr cS dZ cJ cz cJ dg cH dH cT cO cU cR cS cO dL df cX cM dJ cK cO cX cH dL cL cK cR cL cM cs cH cQ dc cU du cJ cT cK cH cL cY cQ cM du cO cB dc cX cW cS cU cL cM cM dc cJ dc dH cG dL cT cN cV cD cY cI da cS dT dG dP cI dc dW cT cO dc cY cN cI cT du cW cL cS cT dJ cM cR dG dI cn cT cY cI cU cQ cT cT cU cV du cG cL cJ cM du cL dL cP cW dZ cs df dJ da cT cN cY dJ cT cE cK cM dH cZ dc dd cz cO cR cN cX cJ du cM cL cA cJ cU cX cJ cz cJ da dP dJ dG cN cX bS dc du dH cM df cW dJ cR dJ cS cX cI cI cQ cJ cX dc cR dc cT cU cu cM dO cS cI cZ dJ du cI cV cV dJ cU dh cD cT cT cs cJ cU cG cO cr dj dc dG dl cS cI dL cI df cN cZ cV du dh cO cN cZ cU cT dc cS dg dL cN cL cG cT cu cO cQ cM cJ df cZ cV du)));
elem('text','')
\`\`
            // TODO: Re-compute plots, because it crashed, and 30k epochs is quite low. (Also, probably put plots into a separate global; as a bonus, we'll be able to see their size.)

    - Without an \`Sz\`-returning function exposed:

        - Stochastic-ensembling \`stddev\`=\`0\`:
            // TODO: Plots.

        - Stochastic-ensembling \`stddev\`=\`.25\`:
            // TODO: Plots.

        - Stochastic-ensembling \`stddev\`=\`.5\`:
            // TODO: Plots.

        - No \`SequenceState\`:

            - Stochastic-ensembling \`stddev\`=\`0\`:
                // TODO: Plots.

            - Stochastic-ensembling \`stddev\`=\`.5\`:
                // TODO: Plots.

        - Individual \`Predict\`ion NNs:

            - Stochastic-ensembling \`stddev\`=\`0\`:
                // TODO: Plots.

            - Stochastic-ensembling \`stddev\`=\`.5\`:
                // TODO: Plots.

\`\`elem 'hr'\`\`

For once, reward goes up. Much better. Though, probably needs millions of epochs to arrive at anything remotely useful.

See? The prior examples just did not have enough reward diversity to be trained. In struggle we are stronger.
    (Probably. I cannot run these forever, partially because of some strange memory leak. This is to encourage you to implement your own, preferably as a shader: so portable that even I can run it, so parallel that it easily scales to 1000000× the current size.)

Ultimately, I've never seen any algorithm quite like this, so I cannot predict what it will do.
But it's just another tool in the toolbox, a tool that can do anything with enough compute, and is a toolbox.
It also lacks a use-case, that is, an interesting environment (with cons-world inputs and outputs being properly-sized matrices).

But.
Poetically complete.

To recap.

We summoned programming languages to fight for us.
We summoned learning to fight for us.
We summoned types to fight for us.
We laid types to rest.
We laid learning to rest.
We laid programming languages to rest.
Everything we thought of got subverted into learnable generality.
    With good libraries and hardware, this is how AGI (artificial general intelligence: do anything to satisfy anything) gets made. Here, we used it for learning.

            Ah, the disturbance that called you here: timelines jumping left and right, stopping and starting… Nowhere to be found now.   \`\`elemCollapse elemValue(elem 'text' stringToDoc('A good heuristic for how any thing develops in life is from "something" to "nothing" to "everything" (embrace, extend, extinguish): from blissful ignorance of an unexamined answer, to mostly-ugly big hypotheses, to an elegant small solution. This "first you build your confidence, then you get trapped, then they move in so they can murder you" path was followed by these tutorials, and you along with them. Now it becomes memories. I don''t have the strength to continue.'),'You overfed fuck. You have everything, and yet you do nothing.')\`\`

So.

In these tutorials, we have outlined the Transcendence% speedrun route. A machine learning algorithm that efficiently learns a problem that is so general that a learning compiler is the only solution is called a \`\`elem 'i' (elem 'text' 'transcendent galaxy brain algorithm')\`\` (or a TGBA for short): requirements are learnable meta-circularity (so that stopping training by unchecking \`\`settings ^_consReplayImmediately\`\` does not change behavior, as if it keeps learning in the same way), generality (so that any world can be directly represented), and neural networks (for efficient composable tensor-target learning), and obviously, being an algorithm (no one should care otherwise). \`\`elemCollapse elemValue(elem 'text' "Truly, the best way to make a programming language more convenient to use, and so it's the only way.","I'll head this off right now: TGBA is not AGI, and bears only superficial resemblance to it. VirGIn (virtual general intelligence) / AGI: mind is constructed from what is learned from natural language; can be plugged into any system of human existence; its own Turing-complete bases are too murky to internally use or even come to; little better than a human in silicon with 1000× more processing power; too hard for humanity's current level of computing science; is hope and fear of AI researchers; is the crowning jewel of human progress but is its own individual. ChAd (challenge adaptation) / TGBA: the language of thought is a precise programming language; always makes its own system of existence; transcendence is as easy as fully understanding another; is the never-seen-on-Irth lifeform of all lifeforms; could be done at any time since computing existed (or before); cannot be done non-deliberately; is the natural attractor-point of all possible worlds and is another world.")\`\`

This is the end.

May you find happiness on the road ahead. \`\`elemCollapse stringToDoc("We should all strive toward a brighter future, together.   Which future?   Heeey, you wanna get turned into someone's brain tissue? When sand runs out, you can't really build computer chips out of organic matter, but special kinds of organic tissue should be possible. Long-term, if the capability to turn stuff into general-purpose things exists, then general intelligence will converge to them no matter what: you may not like it, but this is what peak performance looks like. When all dreams are realized, all is melted in generality. So. Become big-brain. (This is so horrifying that it doesn't even trigger my feeble conception of what horror is, and seems funny instead.)")\`\`
`,
  ],

  stateCell:{
    use:0,
    docs:`For \`accessState\`.
\`stateCell()\`: the smallest separate mutable piece of memory, initialized to \`undefined\`.
Most numeric operations can also take these directly, without going through \`accessState\`.

Compared to arrays or other linear memory, these are much more directly representable in neural memory (in your mind), but are also much more static.`,
    readAt:{
      accessState:_(`accessState`),
    },
    construct(x, obj) {
      if (obj === undefined) {
        obj = Object.create(null)
        obj[defines.key] = Object.create(null)
        return Object.freeze(obj)
      } else {
        const d = obj[defines.key]
        if (isArray(d)) _rememberArrayItems(d, true), _disposeEachAndDealloc(d)
        _rememberToDispose(d[_id(deconstruct)] = [stateCell, keep(x[1])])
      }
    },
  },

  accessState:{
    use:2,
    docs:`\`accessState(StateCell)\` or \`accessState(StateCell,NewValue)\`
Reads or writes a state cell.`,
    dispose:true,
    interrupt:false,
    call(sc, v) {
      const d = defines(sc, deconstruct)
      if (isArray(sc) || !isArray(d) || d[0] !== stateCell) error("Not a", stateCell, ":", sc)
      if (v === undefined) return keep(d[1])
      _changeArrayItem(d, 1, v)
    },
  },

  interpreter:{
    docs:`\`interpreter callAdjust Expr\`→\`Result\`
This one is not for casual user use (though \`repeat\` uses this).
Runs a function-that-can-do-anything in its own execution environment, where \`consWorld\` regeneration is finalized, loss is plotted (if not \`\`settings ^_noLossDisplay\`\`), numeric variables are \`commit\`ed (\`commit(false)\` should cancel this), and tensor-count integrity is checked so that everything that is not the \`Result\` or associated with objects is \`dispose\`d of (and tensors are auto-disposed if \`\`settings ^_autoDispose\`\`).

Shields execution from arbitrariness of JS code.

(Here, execution happens in 3 stages, each within the previous: first, the global interpreter loop \`_jobs\`/\`_doJob\` (controllable via \`_schedule\`/\`_cancel\`); then, an \`interpreter\` iteration; then, expression execution \`callAdjust\`.)`,
    readAt:{
      repeat:_(`repeat`),
      call:_(`call`),
      apply:_(`apply`),
      callAdjust:_(`callAdjust`),
      _forgiveMistakes:_(`_forgiveMistakes`),
    },
    philosophy:`This kind of separation always happens with general things inside general things: they set up a membrane that transforms rules of the wider world into their own rules (and back). Biological cells, human viewpoints, and programming languages are similar in this regard.`,
    dispose:true,
    impure:true,
    argCount:2,
    call(fn = callAdjust, expr) {
      // Set and finally reset some global variables for us to communicate with the evaluated expression through.
      //   Perfectly readable, what are you talking about. By skipping over it.
      //     Besides, what are the alternatives?
      //       Forcing every expression in all user code to take and return an array with their values?
      //         By my calculations, that's approximately a million point two times less readable. Much less usable too.
      let [mark1 = 'interpreterStart', s = 0, n = 0, futures = _allocMap(), usingState, all = _allocMap(), consWorldRegen, errors = 0, consSources = _allocMap(), result, arrayCount = 0, mark2 = 'interpreterEnd'] = interrupt(12)
      if (mark1 !== 'interpreterStart' || mark2 !== 'interpreterEnd' && mark2 !== 'interpreterEnded') error('Interrupt stack corruption:', mark1, s, n, futures, usingState, all, consWorldRegen, errors, consSources, result, arrayCount, mark2)
      const ps = _knowLoss.s, pn = _knowLoss.n;  _knowLoss.s = s, _knowLoss.n = n
      const prevFutures = future.f;  future.f = futures
      const prevState = using.state;  using.state = usingState
      if (all === undefined) all = _allocMap(), call.env && call.env[_id(_tf)].push(all)
      const prevAll = _tf.all;  _tf.all = all

      if (consWorldRegen === undefined) {
        consWorldRegen = new Map
        const env = call.env, cw = _id(consWorld);  !env[cw] && (env[cw] = _allocMap());  env[cw].set(consWorldRegen, (env[cw].get(consWorldRegen) || 0) + 1)
      }
      const prevConsWorldRegen = consWorld.regen;  consWorld.regen = consWorldRegen;  let errorDuringRegen = false
      const prevErrors = error.count;  error.count = errors
      const prevConsSources = consWorld.sources;  consWorld.sources = consSources
      const prevArrayCount = array.count;  array.count = arrayCount

      let interrupted = false
      try {
        // Call the main execution engine.
        if (result === undefined)
          result = fn(expr),
          result === undefined && (result = _onlyUndefined)

        // Finish `consWorld` object regeneration.
        if (mark2 === 'interpreterEnd') errorDuringRegen = true, _finishRegenCons(), mark2 = 'interpreterEnded'

        // Wait for promises to be fulfilled.
        result = await(result)

        // Display average loss, if there is any. (Also dispose the tensor used for carrying that info.)
        if (_knowLoss.n) {
          if (!_noLossDisplay[1]) {
            const s = _knowLoss.s, n = _knowLoss.n
            const L = !n ? 0 : typeof s == 'number' ? s / n : s.array().then(s => s / n)
            if (!_isPromise(L))
              display(label('Loss'), _knowLoss.lastLoss = L)
            else {
              const env = call.env
              display(label('Loss'), null), _knowLoss.lastLoss = L.then(L => {
                const penv = call.env;  call.env = env
                try { return display(label('Loss'), L), L }
                finally { call.env = penv }
              })
            }
          }
          dispose(_knowLoss.s), _knowLoss.s = _knowLoss.n = 0
        }

        // Commit changes (gradients) to numeric variables.
        commit()

        // `_autoDispose`, and/or check memory integrity (whether we have disposed all that we created and did not give to JS objects to dispose).
        const preserveResult = _isDisposable(result), prevCheck = _tf.justCheck
        preserveResult && _disposeNot(result), _tf.justCheck = !_autoDispose[1]
        try { defines(_tf, _cancel)(all), all = _tf.all = undefined }
        finally { _tf.justCheck = prevCheck, preserveResult && _unDisposeNot(result) }

        // Make our caller responsible for our result, then return the result.
        if (_isDisposable(result) && prevAll) prevAll.set(result, (prevAll.get(result) || 0) + 1)
        return result !== _onlyUndefined ? result : undefined
      } catch (err) {
        if (err === interrupt) interrupt.stack.push(mark1, _knowLoss.s, _knowLoss.n, futures, using.state, all, consWorldRegen, error.count, consSources, result, array.count, mark2), interrupted = true
        else {
          const prevDoubleDispose = dispose.safeDouble;  dispose.safeDouble = true
          try {
            commit(false)
            dispose(result)
          } finally { dispose.safeDouble = prevDoubleDispose }
        }
        throw err
      } finally {
        // Outer `interpreter`s need to know about what inner ones created.
        if (_setting(_debugCreation) || _setting(_debugMemory))
          all && prevAll && all.forEach((v,k) => !k.isDisposedInternal && !prevAll.has(k) && prevAll.set(k,v))

        s = _knowLoss.s, _knowLoss.s = ps, _knowLoss.n = pn
        future.f = prevFutures
        using.state = prevState
        consWorld.regen = prevConsWorldRegen
        error.count = prevErrors
        consWorld.sources = prevConsSources
        array.count = prevArrayCount
        if (!interrupted) { // An error, or normal return.
          if (!_autoDispose[1]) dispose(_knowLoss.s)
          futures.forEach(dispose)
          const env = call.env, cw = _id(consWorld);  env && env[cw].set(consWorldRegen, env[cw].get(consWorldRegen) - 1);  env && env[cw].get(consWorldRegen) <= 0 && env[cw].delete(consWorldRegen)
          consWorldRegen.forEach((R,cw,Rs) => !_rememberToDispose.seen.has(R) && _disposeEachAndDealloc(R))
          _allocMap(consSources)
          if (_autoDispose[1]) defines(_tf, _cancel)(all)
          call.env && call.env[_id(_tf)].pop()
        }
      }
      // .callCache, .adjustCache
    },
  },





















})
})()
